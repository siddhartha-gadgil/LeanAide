[{"type": "Injective f",
  "tactic-prompt":
  "example (X Y Z : Type)  (f : X â†’ Y)  (g : Y â†’ Z)  (H : Injective $ g âˆ˜ f) : Injective f := by intros x x' h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros x x' h",
  "core-prompt":
  "(X Y Z : Type)  (f : X â†’ Y)  (g : Y â†’ Z)  (H : Injective $ g âˆ˜ f) : Injective f",
  "args": "(X Y Z : Type)  (f : X â†’ Y)  (g : Y â†’ Z)  (H : Injective $ g âˆ˜ f)"},
 {"type": "1 = 1",
  "tactic-prompt":
  "example (x : Int)  (h : x = 1) : 1 = 1 := by apply_fun (fun p => p) at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun (fun p => p) at h",
  "core-prompt": "(x : Int)  (h : x = 1) : 1 = 1",
  "args": "(x : Int)  (h : x = 1)"},
 {"type": "a + 1 = b + 1",
  "tactic-prompt":
  "example (a b : Int)  (h : a = b) : a + 1 = b + 1 := by apply_fun (fun n => n+1) at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun (fun n => n+1) at h",
  "core-prompt": "(a b : Int)  (h : a = b) : a + 1 = b + 1",
  "args": "(a b : Int)  (h : a = b)"},
 {"type": "True",
  "tactic-prompt":
  "example (P : Nat â†’ Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b) : True := by fail_if_success apply_fun Q at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success apply_fun Q at h",
  "core-prompt":
  "(P : Nat â†’ Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b) : True",
  "args": "(P : Nat â†’ Type)  (Q : (n : Nat) -> P n)  (a b : Nat)  (h : a = b)"},
 {"type": "f a â‰¤ f b",
  "tactic-prompt":
  "example (f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b) : f a â‰¤ f b := by apply_fun f at h using monof; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f at h using monof",
  "core-prompt":
  "(f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b) : f a â‰¤ f b",
  "args": "(f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b)"},
 {"type": "f a â‰¤ f b",
  "tactic-prompt":
  "example (f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b) : f a â‰¤ f b := by apply_fun f at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f at h",
  "core-prompt":
  "(f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b) : f a â‰¤ f b",
  "args": "(f : â„• â†’ â„•)  (a b : â„•)  (monof : Monotone f)  (h : a â‰¤ b)"},
 {"type": "n â‰  m",
  "tactic-prompt":
  "example (n m : â„•)  (f : â„• â†’ â„•)  (h : f n â‰  f m) : n â‰  m := by apply_fun f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f",
  "core-prompt": "(n m : â„•)  (f : â„• â†’ â„•)  (h : f n â‰  f m) : n â‰  m",
  "args": "(n m : â„•)  (f : â„• â†’ â„•)  (h : f n â‰  f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m) : n = m := by apply_fun f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f",
  "core-prompt":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m) : n = m",
  "args":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m) : n = m := by apply_fun f using w; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f using w",
  "core-prompt":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m) : n = m",
  "args":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f)  (h : f n = f m)"},
 {"type": "n = m",
  "tactic-prompt":
  "example (n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f âˆ§ true)  (h : f n = f m) : n = m := by apply_fun f using w.1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_fun f using w.1",
  "core-prompt":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f âˆ§ true)  (h : f n = f m) : n = m",
  "args":
  "(n m : â„•)  (f : â„• â†’ â„•)  (w : Function.Injective f âˆ§ true)  (h : f n = f m)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by have h1 := forward; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h1 := forward",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by fconstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fconstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by econstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "econstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (foo : False) : a < b := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": "(a b : â„•)  (foo : False) : a < b",
  "args": "(a b : â„•)  (foo : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (h : False) : a < b := by by_contra' foo; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo",
  "core-prompt": "(a b : â„•)  (h : False) : a < b",
  "args": "(a b : â„•)  (h : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (h : False) : a < b := by by_contra' foo : Â¬ a < b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : Â¬ a < b",
  "core-prompt": "(a b : â„•)  (h : False) : a < b",
  "args": "(a b : â„•)  (h : False)"},
 {"type": "1 < 2",
  "tactic-prompt": "example  : 1 < 2 := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": " : 1 < 2",
  "args": ""},
 {"type": "Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P := by by_contra' foo : Â¬ Â¬ Â¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : Â¬ Â¬ Â¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type": "Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P := by by_contra' : Â¬ Â¬ Â¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' : Â¬ Â¬ Â¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type":
  "(e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source)",
  "tactic-prompt":
  "example (e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³) : (e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source) := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³) : (e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source)",
  "args": "(e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³)"},
 {"type": "(e.trans e.symm).source = e.source",
  "tactic-prompt":
  "example (e : LocalEquiv Î± Î²) : (e.trans e.symm).source = e.source := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt": "(e : LocalEquiv Î± Î²) : (e.trans e.symm).source = e.source",
  "args": "(e : LocalEquiv Î± Î²)"},
 {"type":
  "f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s",
  "tactic-prompt":
  "example (s : Set Î±)  (f : LocalHomeomorph Î± Î²) : f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(s : Set Î±)  (f : LocalHomeomorph Î± Î²) : f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s",
  "args": "(s : Set Î±)  (f : LocalHomeomorph Î± Î²)"},
 {"type":
  "(Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "tactic-prompt":
  "example {I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''} : (Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y} := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "{I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''} : (Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "args":
  "{I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''}"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h) : True := by choose! i j _x _y using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j _x _y using h",
  "core-prompt":
  "{Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h) : True",
  "args":
  "{Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt": "(h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i) : True := by choose! f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h h' using h",
  "core-prompt": "(h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i) : True",
  "args": "(h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose! i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j h using h",
  "core-prompt":
  "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "(âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True",
  "tactic-prompt":
  "example  : (âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True := by choose i j h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h",
  "core-prompt":
  " : (âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n)"},
 {"type": "âˆ€ _ : Nat, 1 = 1",
  "tactic-prompt":
  "example (h : âˆ€ n, âˆƒ k â‰¥ 0, n = k) : âˆ€ _ : Nat, 1 = 1 := by choose u hu using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose u hu using h",
  "core-prompt": "(h : âˆ€ n, âˆƒ k â‰¥ 0, n = k) : âˆ€ _ : Nat, 1 = 1",
  "args": "(h : âˆ€ n, âˆƒ k â‰¥ 0, n = k)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i) : True := by choose f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose f h h' using h",
  "core-prompt": "(h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i) : True",
  "args": "(h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1) : True := by choose! f h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h using h",
  "core-prompt":
  "{Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1) : True",
  "args":
  "{Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1)"},
 {"type": "(Â¬p âˆ§ Â¬q) â†’ Â¬(p âˆ¨ q)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬p âˆ§ Â¬q) â†’ Â¬(p âˆ¨ q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬p âˆ§ Â¬q) â†’ Â¬(p âˆ¨ q)",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "Â¬(p âˆ§ q) â†’ (p â†’ Â¬q)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬(p âˆ§ q) â†’ (p â†’ Â¬q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬(p âˆ§ q) â†’ (p â†’ Â¬q)",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "(âˆ€(x : Î±), Â¬ p' x) â†’ Â¬ âˆƒ(x : Î±), p' x",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (âˆ€(x : Î±), Â¬ p' x) â†’ Â¬ âˆƒ(x : Î±), p' x := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (âˆ€(x : Î±), Â¬ p' x) â†’ Â¬ âˆƒ(x : Î±), p' x",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "(Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x)",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "decide (Â¬ Â¬ p) = p",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (p : Bool) : decide (Â¬ Â¬ p) = p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (p : Bool) : decide (Â¬ Â¬ p) = p",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (p : Bool)"},
 {"type": "((fun x => x+x) 1) = 2",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : ((fun x => x+x) 1) = 2 := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : ((fun x => x+x) 1) = 2",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "Â¬ Â¬ p = p",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬ Â¬ p = p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬ Â¬ p = p",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "Â¬(x â‰¤ y)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x) : Â¬(x â‰¤ y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x) : Â¬(x â‰¤ y)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x)"},
 {"type": "Â¬ (x â‰  y)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î±)  (h : x = y) : Â¬ (x â‰  y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î±)  (h : x = y) : Â¬ (x â‰  y)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î±)  (h : x = y)"},
 {"type": "Â¬âˆƒ (y : Unit), (y â‰  ())",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬âˆƒ (y : Unit), (y â‰  ()) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬âˆƒ (y : Unit), (y â‰  ())",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "Â¬âˆ€ (y : Nat), (y = 1)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : âˆƒ y : Nat, Â¬(y=1)) : Â¬âˆ€ (y : Nat), (y = 1) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : âˆƒ y : Nat, Â¬(y=1)) : Â¬âˆ€ (y : Nat), (y = 1)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : âˆƒ y : Nat, Â¬(y=1))"},
 {"type": "Â¬Â¬Â¬ (x â‰¤ y)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x) : Â¬Â¬Â¬ (x â‰¤ y) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x) : Â¬Â¬Â¬ (x â‰¤ y)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (h : y < x)"},
 {"type": "Â¬ âˆ€(x y : Nat), x = y",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y) : Â¬ âˆ€(x y : Nat), x = y := by push_neg at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg at *",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y) : Â¬ âˆ€(x y : Nat), x = y",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y)"},
 {"type": "Â¬ âˆ€(x y : Nat), x = y",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y) : Â¬ âˆ€(x y : Nat), x = y := by push_neg at hâ‚ hâ‚‚ âŠ¢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg at hâ‚ hâ‚‚ âŠ¢",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y) : Â¬ âˆ€(x y : Nat), x = y",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (x y : Î²)  (hâ‚ : Â¬Â¬Â¬(x < y))  (hâ‚‚ : Â¬âˆƒ (x y : Nat), x = y)"},
 {"type": "Â¬ (p âˆ§ q)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : p â†’ Â¬ q) : Â¬ (p âˆ§ q) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : p â†’ Â¬ q) : Â¬ (p âˆ§ q)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : p â†’ Â¬ q)"},
 {"type": "Â¬ âˆ€ x : Î², x < a â†’ âˆƒ y : Î², (y < a) âˆ§ âˆ€ z : Î², x = z",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (a : Î²) : Â¬ âˆ€ x : Î², x < a â†’ âˆƒ y : Î², (y < a) âˆ§ âˆ€ z : Î², x = z := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (a : Î²) : Â¬ âˆ€ x : Î², x < a â†’ âˆƒ y : Î², (y < a) âˆ§ âˆ€ z : Î², x = z",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (a : Î²)"},
 {"type": "Â¬ (p âˆ§ q)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : Â¬ p âˆ¨ Â¬ q) : Â¬ (p âˆ§ q) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : Â¬ p âˆ¨ Â¬ q) : Â¬ (p âˆ§ q)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : Â¬ p âˆ¨ Â¬ q)"},
 {"type": "p â†’  Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ p",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : p â†’  Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ p := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : p â†’  Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ p",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "Â¬(x = 0 â†’ y = 0)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : x = 0 âˆ§ y â‰  0) : Â¬(x = 0 â†’ y = 0) := by push_neg; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_neg",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : x = 0 âˆ§ y â‰  0) : Â¬(x = 0 â†’ y = 0)",
  "args":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} (h : x = 0 âˆ§ y â‰  0)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : True",
  "args": ""},
 {"type": "2 + 2 = 4",
  "tactic-prompt": "example  : 2 + 2 = 4 := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : 2 + 2 = 4",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (P : Prop)  (h1 : P)  (h2 : Â¬ P) : False := by fail_if_success triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success triv",
  "core-prompt": "(P : Prop)  (h1 : P)  (h2 : Â¬ P) : False",
  "args": "(P : Prop)  (h1 : P)  (h2 : Â¬ P)"},
 {"type":
  "374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤)",
  "tactic-prompt":
  "example  : 374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤) := by norm_num1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num1",
  "core-prompt":
  " : 374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤)",
  "args": ""},
 {"type": "2 ^ 17 - 1 = 131071",
  "tactic-prompt": "example  : 2 ^ 17 - 1 = 131071 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 2 ^ 17 - 1 = 131071",
  "args": ""},
 {"type": "(5 / 2:â„•) = 2",
  "tactic-prompt": "example  : (5 / 2:â„•) = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / 2:â„•) = 2",
  "args": ""},
 {"type": "(5 / -2:â„¤) < -1",
  "tactic-prompt": "example  : (5 / -2:â„¤) < -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / -2:â„¤) < -1",
  "args": ""},
 {"type": "(0 + 1) / 2 < 0 + 1",
  "tactic-prompt": "example  : (0 + 1) / 2 < 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (0 + 1) / 2 < 0 + 1",
  "args": ""},
 {"type": "Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "tactic-prompt":
  "example  : Nat.succ (Nat.succ (2 ^ 3)) = 10 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "args": ""},
 {"type": "(12321 - 2 : â„¤) = 12319",
  "tactic-prompt": "example  : (12321 - 2 : â„¤) = 12319 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (12321 - 2 : â„¤) = 12319",
  "args": ""},
 {"type": "100 * 30 < x",
  "tactic-prompt":
  "example (x : â„¤)  (h : 1000 + 2000 < x) : 100 * 30 < x := by norm_num at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num at *",
  "core-prompt": "(x : â„¤)  (h : 1000 + 2000 < x) : 100 * 30 < x",
  "args": "(x : â„¤)  (h : 1000 + 2000 < x)"},
 {"type": "(1103 : â„¤) â‰¤ (2102 : â„¤)",
  "tactic-prompt": "example  : (1103 : â„¤) â‰¤ (2102 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (1103 : â„¤) â‰¤ (2102 : â„¤)",
  "args": ""},
 {"type": "(110474 : â„¤) â‰¤ (210485 : â„¤)",
  "tactic-prompt":
  "example  : (110474 : â„¤) â‰¤ (210485 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (110474 : â„¤) â‰¤ (210485 : â„¤)",
  "args": ""},
 {"type": "(11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤)",
  "tactic-prompt":
  "example  : (11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤)",
  "args": ""},
 {"type": "(210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤)",
  "tactic-prompt":
  "example  : (210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤)",
  "args": ""},
 {"type": "(210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•)",
  "tactic-prompt":
  "example  : (210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•)",
  "args": ""},
 {"type": "(2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868",
  "tactic-prompt":
  "example  : (2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868",
  "args": ""},
 {"type": "true",
  "tactic-prompt": "example  : true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true",
  "args": ""},
 {"type": "true âˆ§ true",
  "tactic-prompt": "example  : true âˆ§ true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true âˆ§ true",
  "args": ""},
 {"type": "10 + 2 = 1 + 11",
  "tactic-prompt": "example  : 10 + 2 = 1 + 11 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 + 2 = 1 + 11",
  "args": ""},
 {"type": "10 - 1 = 9",
  "tactic-prompt": "example  : 10 - 1 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 1 = 9",
  "args": ""},
 {"type": "12 - 5 = 3 + 4",
  "tactic-prompt": "example  : 12 - 5 = 3 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 12 - 5 = 3 + 4",
  "args": ""},
 {"type": "5 - 20 = 0",
  "tactic-prompt": "example  : 5 - 20 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 - 20 = 0",
  "args": ""},
 {"type": "0 - 2 = 0",
  "tactic-prompt": "example  : 0 - 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 2 = 0",
  "args": ""},
 {"type": "4 - (5 - 10) = 2 + (3 - 1)",
  "tactic-prompt":
  "example  : 4 - (5 - 10) = 2 + (3 - 1) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 4 - (5 - 10) = 2 + (3 - 1)",
  "args": ""},
 {"type": "0 - 0 = 0",
  "tactic-prompt": "example  : 0 - 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 0 = 0",
  "args": ""},
 {"type": "100 - 100 = 0",
  "tactic-prompt": "example  : 100 - 100 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 100 - 100 = 0",
  "args": ""},
 {"type": "5 * (2 - 3) = 0",
  "tactic-prompt": "example  : 5 * (2 - 3) = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 * (2 - 3) = 0",
  "args": ""},
 {"type": "10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "tactic-prompt":
  "example  : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "args": ""},
 {"type": "foo = 1",
  "tactic-prompt": "example  : foo = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : foo = 1",
  "args": ""},
 {"type": "(1 + 0 : Î±) = (0 + 1 : Î±)",
  "tactic-prompt":
  "example (Î± : Type u)  [AddMonoidWithOne Î±] : (1 + 0 : Î±) = (0 + 1 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(Î± : Type u)  [AddMonoidWithOne Î±] : (1 + 0 : Î±) = (0 + 1 : Î±)",
  "args": "(Î± : Type u)  [AddMonoidWithOne Î±]"},
 {"type": "(0 + (2 + 3) + 1 : Î±) = 6",
  "tactic-prompt":
  "example (Î± : Type u)  [AddMonoidWithOne Î±] : (0 + (2 + 3) + 1 : Î±) = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(Î± : Type u)  [AddMonoidWithOne Î±] : (0 + (2 + 3) + 1 : Î±) = 6",
  "args": "(Î± : Type u)  [AddMonoidWithOne Î±]"},
 {"type": "(70 * (33 + 2) : Î±) = 2450",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (70 * (33 + 2) : Î±) = 2450 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (70 * (33 + 2) : Î±) = 2450",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(8 + 2 ^ 2 * 3 : Î±) = 20",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (8 + 2 ^ 2 * 3 : Î±) = 20 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (8 + 2 ^ 2 * 3 : Î±) = 20",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±)",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : ((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(Î± : Type u)  [Semiring Î±] : ((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±)",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(-1 : Î±) * 1 = -1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-1 : Î±) * 1 = -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-1 : Î±) * 1 = -1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * 1 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * 1 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * 1 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * -1 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * -1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * -1 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * -2 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * -2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * -2 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "((1 : Î±) + 1) * 5 = 6 + 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : ((1 : Î±) + 1) * 5 = 6 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : ((1 : Î±) + 1) * 5 = 6 + 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) = 0 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) = 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) = 0 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) = 1 + 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) = 1 + 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) = 1 + 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) = 1 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) = 1 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) = 1 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) = 0 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) = 0 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) = 0 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) = 1 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) = 1 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) = 1 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) = 2 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) = 2 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) = 2 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) = 3 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) = 3 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) = 3 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) = 2 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) = 2 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) = 2 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 4 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 4 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 4 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 3 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 3 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 3 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 2 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 2 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 2 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 0 + 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 0 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 0 + 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 3 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 3 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 3 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 4 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 4 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 4 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 5 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 5 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 5 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 4 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 4 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 4 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 1 + 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 1 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 1 + 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 6 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 6 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 6 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "33 = 5 + (28 : Î±)",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : 33 = 5 + (28 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : 33 = 5 + (28 : Î±)",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) = 0 + (2 + 3) + 7",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) = 0 + (2 + 3) + 7 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) = 0 + (2 + 3) + 7",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(105 : Î±) = 70 + (33 + 2)",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (105 : Î±) = 70 + (33 + 2) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (105 : Î±) = 70 + (33 + 2)",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(45000000000 : Î±) = 23000000000 + 22000000000",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (45000000000 : Î±) = 23000000000 + 22000000000 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "{Î± : Type} [Ring Î±] : (45000000000 : Î±) = 23000000000 + 22000000000",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 2 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 2 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 2 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) - 3 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) - 3 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) - 3 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) - 1 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) - 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) - 1 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) - 4 - (5 + -2) = 5",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) = 5 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) = 5",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) - 4 - (5 + -2) - 20 = -15",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) - 20 = -15 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) - 20 = -15",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 1 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 1 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 2 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 2 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 1 = 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 1 = 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 1 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 1 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 2 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 2 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 2 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 2 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 2 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 2 = 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 2 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 2 = 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 3 = 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 3 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 3 = 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) * 1 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) * 1 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) * 1 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 4 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 4 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 4 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 3 = 9",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 3 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 3 = 9",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 4 = 12",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 4 = 12 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 4 = 12",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) * 4 = 16",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) * 4 = 16 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) * 4 = 16",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(11 : Î±) * 2 = 22",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (11 : Î±) * 2 = 22 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (11 : Î±) * 2 = 22",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(15 : Î±) * 6 = 90",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (15 : Î±) * 6 = 90 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (15 : Î±) * 6 = 90",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(123456 : Î±) * 123456 = 15241383936",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (123456 : Î±) * 123456 = 15241383936 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (123456 : Î±) * 123456 = 15241383936",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "x â‰¤ 57",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ [0, 2, 37]) : x â‰¤ 57 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ [0, 2, 37]) : x â‰¤ 57",
  "args": "{x : Nat}  (h : x âˆˆ [0, 2, 37])"},
 {"type": "x = 0 âˆ¨ x = 2 âˆ¨ x = 37",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ [0, 2, 37]) : x = 0 âˆ¨ x = 2 âˆ¨ x = 37 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ [0, 2, 37]) : x = 0 âˆ¨ x = 2 âˆ¨ x = 37",
  "args": "{x : Nat}  (h : x âˆˆ [0, 2, 37])"},
 {"type": "x â‰¤ 4",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ List.range 5) : x â‰¤ 4 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ List.range 5) : x â‰¤ 4",
  "args": "{x : Nat}  (h : x âˆˆ List.range 5)"},
 {"type": "p i",
  "tactic-prompt":
  "example {p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i) : p i := by fin_cases i; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases i",
  "core-prompt": "{p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i) : p i",
  "args": "{p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt":
  "(f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val",
  "args": "(f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat â†’ Prop)  (p : Fin 0) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt": "(f : Nat â†’ Prop)  (p : Fin 0) : f p.val",
  "args": "(f : Nat â†’ Prop)  (p : Fin 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3) : True := by fin_cases x2, x3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2, x3",
  "core-prompt": "(x2 : Fin 2)  (x3 : Fin 3) : True",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)"},
 {"type": "x2.val * x3.val = x3.val * x2.val",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by fin_cases x2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2",
  "core-prompt":
  "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f) : True := by casesm* _âˆ¨_, _âˆ§_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ¨_, _âˆ§_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ§ d) : True := by casesm* _âˆ§_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ§_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ§ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ§ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by casesm* _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ¨_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt": "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by casesm _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm _âˆ¨_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type And; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type* Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type* Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True",
  "args": "(h : a âˆ§ b âˆ§ (c âˆ¨ d))"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True := by cases_type!* And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type!* And Or",
  "core-prompt": "(h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True",
  "args": "(h : a âˆ§ b âˆ§ (c âˆ¨ d))"},
 {"type": "True âˆ§ True âˆ§ True",
  "tactic-prompt":
  "example  : True âˆ§ True âˆ§ True := by constructorm True, _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructorm True, _âˆ¨_",
  "core-prompt": " : True âˆ§ True âˆ§ True",
  "args": ""},
 {"type": "p âˆ§ p",
  "tactic-prompt":
  "theorem {p q r : Prop} (h : p âˆ§ q âˆ¨ p âˆ§ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ âˆ§ _)` could potentially match. : p âˆ§ p := by cases h; sorry",
  "name": "foo",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q r : Prop} (h : p âˆ§ q âˆ¨ p âˆ§ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ âˆ§ _)` could potentially match. : p âˆ§ p",
  "args":
  "{p q r : Prop} (h : p âˆ§ q âˆ¨ p âˆ§ r)  -- Make sure that we don't try to work on auxiliary declarations. -- In this case, there will be an auxiliary recursive declaration for -- `foo` itself that `casesm (_ âˆ§ _)` could potentially match."},
 {"type": "P",
  "tactic-prompt": "example (P : Prop)  (h : P) : P := by convert h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert h",
  "core-prompt": "(P : Prop)  (h : P) : P",
  "args": "(P : Prop)  (h : P)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Î± := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²) : Î± := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²) : Î±",
  "args": "(Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Î± := by convert (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î² = Î±)  (b : Î²) : Nat Ã— Î± := by convert â† (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert â† (37, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î² = Î±)  (b : Î²) : Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î² = Î±)  (b : Î²)"},
 {"type": "Nat Ã— Nat Ã— Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î± := by convert (37, 57, 2, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Nat Ã— Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î± := by convert (37, 57, 2, b) using 2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 2",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Nat Ã— Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î± := by convert (37, 57, 2, b) using 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 3",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "bar0 3 4 = 7",
  "tactic-prompt": "theorem  : bar0 3 4 = 7 := by decide; sorry",
  "name": "bar0_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar0 3 4 = 7",
  "args": ""},
 {"type": "foo1 3 4 = Nat.pow 3 4",
  "tactic-prompt": "theorem  : foo1 3 4 = Nat.pow 3 4 := by decide; sorry",
  "name": "foo1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo1 3 4 = Nat.pow 3 4",
  "args": ""},
 {"type": "bar1 3 4 = 3 * 4",
  "tactic-prompt": "theorem  : bar1 3 4 = 3 * 4 := by decide; sorry",
  "name": "bar1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar1 3 4 = 3 * 4",
  "args": ""},
 {"type": "foo2 2 3 (PLift.up 2) = Nat.pow 2 5",
  "tactic-prompt":
  "theorem  : foo2 2 3 (PLift.up 2) = Nat.pow 2 5 := by decide; sorry",
  "name": "foo2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo2 2 3 (PLift.up 2) = Nat.pow 2 5",
  "args": ""},
 {"type": "bar2 2 3 (PLift.up 2) =  2 * 5",
  "tactic-prompt":
  "theorem  : bar2 2 3 (PLift.up 2) =  2 * 5 := by decide; sorry",
  "name": "bar2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar2 2 3 (PLift.up 2) =  2 * 5",
  "args": ""},
 {"type": "foo3 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo3 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo3 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar3 2 3 =  2 * 3",
  "tactic-prompt": "theorem  : bar3 2 3 =  2 * 3 := by decide; sorry",
  "name": "bar3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar3 2 3 =  2 * 3",
  "args": ""},
 {"type": "bar8 2 3 = 6",
  "tactic-prompt": "theorem  : bar8 2 3 = 6 := by decide; sorry",
  "name": "bar8_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar8 2 3 = 6",
  "args": ""},
 {"type": "bar9 = 1",
  "tactic-prompt": "theorem  : bar9 = 1 := by decide; sorry",
  "name": "bar9_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar9 = 1",
  "args": ""},
 {"type": "bar10 = foo10",
  "tactic-prompt": "theorem  : bar10 = foo10 := by rfl; sorry",
  "name": "bar10_works",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": " : bar10 = foo10",
  "args": ""},
 {"type": "bar11 = foo11",
  "tactic-prompt": "theorem  : bar11 = foo11 := by rfl; sorry",
  "name": "bar11_works",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": " : bar11 = foo11",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "def {I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L] : true := by trivial; sorry",
  "name": "foo_mul",
  "kind": "def",
  "first-tactic": "trivial",
  "core-prompt":
  "{I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L] : true",
  "args":
  "{I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L]"},
 {"type": "One ((x : Nat) â†’ Î±)",
  "tactic-prompt":
  "def {Î± : Type}  [One Î±] : One ((x : Nat) â†’ Î±) := by infer_instance; sorry",
  "name": "nat_pi_has_one",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt": "{Î± : Type}  [One Î±] : One ((x : Nat) â†’ Î±)",
  "args": "{Î± : Type}  [One Î±]"},
 {"type": "Bar.bar' = 2",
  "tactic-prompt": "theorem  : Bar.bar' = 2 := by decide; sorry",
  "name": "Bar.bar'_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Bar.bar' = 2",
  "args": ""},
 {"type": "FooClass Î±",
  "tactic-prompt": "lemma [One Î±] : FooClass Î± := by infer_instance; sorry",
  "name": "one_fooClass",
  "kind": "lemma",
  "first-tactic": "infer_instance",
  "core-prompt": "[One Î±] : FooClass Î±",
  "args": "[One Î±]"},
 {"type": "FooClass Î±",
  "tactic-prompt": "lemma [Zero Î±] : FooClass Î± := by infer_instance; sorry",
  "name": "zero_fooClass",
  "kind": "lemma",
  "first-tactic": "infer_instance",
  "core-prompt": "[Zero Î±] : FooClass Î±",
  "args": "[Zero Î±]"},
 {"type": "IsUnit' a â†” âˆƒ b, b * a = 1",
  "tactic-prompt":
  "theorem [CommMonoid M]  {a : M} : IsUnit' a â†” âˆƒ b, b * a = 1 := by simp [isUnit'_iff_exists_inv]; sorry",
  "name": "isUnit'_iff_exists_inv'",
  "kind": "theorem",
  "first-tactic": "simp [isUnit'_iff_exists_inv]",
  "core-prompt": "[CommMonoid M]  {a : M} : IsUnit' a â†” âˆƒ b, b * a = 1",
  "args": "[CommMonoid M]  {a : M}"},
 {"type": "true",
  "tactic-prompt": "example  : true := by guard_hyp_nums 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp_nums 1",
  "core-prompt": " : true",
  "args": ""},
 {"type": "Int Ã— Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int Ã— Nat := by rename' a => c, b => d; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => c, b => d",
  "core-prompt": "(a : Nat)  (b : Int) : Int Ã— Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "Int Ã— Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int Ã— Nat := by rename' a => b, b => a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => b, b => a",
  "core-prompt": "(a : Nat)  (b : Int) : Int Ã— Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "False",
  "tactic-prompt":
  "example [LinearOrderedCommRing Î±]  {a b : Î±}  (h : a < b)  (w : b < a) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "[LinearOrderedCommRing Î±]  {a b : Î±}  (h : a < b)  (w : b < a) : False",
  "args": "[LinearOrderedCommRing Î±]  {a b : Î±}  (h : a < b)  (w : b < a)"},
 {"type": "0 < 1 - a",
  "tactic-prompt":
  "example {Î± : Type}  (_inst : (a : Prop) â†’ Decidable a)  [LinearOrderedCommRing Î±]      {a b c : Î±}      (ha : a < 0)      (hb : Â¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) â‰¤ 0)      (hc : 0 â‰¤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) â‰¤ 0) : 0 < 1 - a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "{Î± : Type}  (_inst : (a : Prop) â†’ Decidable a)  [LinearOrderedCommRing Î±]      {a b c : Î±}      (ha : a < 0)      (hb : Â¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) â‰¤ 0)      (hc : 0 â‰¤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) â‰¤ 0) : 0 < 1 - a",
  "args":
  "{Î± : Type}  (_inst : (a : Prop) â†’ Decidable a)  [LinearOrderedCommRing Î±]      {a b c : Î±}      (ha : a < 0)      (hb : Â¬b = 0)      (hc' : c = 0)      (h : (1 - a) * (b * b) â‰¤ 0)      (hc : 0 â‰¤ 0)      (w : -(a * -b * -b + b * -b + 0) = (1 - a) * (b * b))      (h : (1 - a) * (b * b) â‰¤ 0)"},
 {"type": "v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "tactic-prompt":
  "example (e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "args":
  "(e b c a v0 v1 : Rat)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)  (h3 : v0 + v1 + c = 10)"},
 {"type": "v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "tactic-prompt":
  "example [LinearOrderedCommRing Î±]  (e b c a v0 v1 : Î±)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "[LinearOrderedCommRing Î±]  (e b c a v0 v1 : Î±)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10) : v0 + 5 + (v1 - 3) + (c - 2) = 10",
  "args":
  "[LinearOrderedCommRing Î±]  (e b c a v0 v1 : Î±)  (h1 : v0 = 5*a)  (h2 : v1 = 3*b)      (h3 : v0 + v1 + c = 10)"},
 {"type": "(3 : â„¤) < 7",
  "tactic-prompt":
  "example (h : (1 : â„¤) < 0)  (g : Â¬ (37 : â„¤) < 42)  (_k : True)  (l : (-7 : â„¤) < 5) : (3 : â„¤) < 7 := by linarith [(rfl : 0 = 0)]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [(rfl : 0 = 0)]",
  "core-prompt":
  "(h : (1 : â„¤) < 0)  (g : Â¬ (37 : â„¤) < 42)  (_k : True)  (l : (-7 : â„¤) < 5) : (3 : â„¤) < 7",
  "args":
  "(h : (1 : â„¤) < 0)  (g : Â¬ (37 : â„¤) < 42)  (_k : True)  (l : (-7 : â„¤) < 5)"},
 {"type": "0 < (t*(r + v) + s)*3*u",
  "tactic-prompt":
  "example (u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s)) : 0 < (t*(r + v) + s)*3*u := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s)) : 0 < (t*(r + v) + s)*3*u",
  "args": "(u v r s t : Rat)  (h : 0 < u*(t*v + t*r + s))"},
 {"type": "0 < 8*A*B",
  "tactic-prompt":
  "example (A B : Rat)  (h : 0 < A * B) : 0 < 8*A*B := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(A B : Rat)  (h : 0 < A * B) : 0 < 8*A*B",
  "args": "(A B : Rat)  (h : 0 < A * B)"},
 {"type": "0 < A*8*B",
  "tactic-prompt":
  "example (A B : Rat)  (h : 0 < A * B) : 0 < A*8*B := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(A B : Rat)  (h : 0 < A * B) : 0 < A*8*B",
  "args": "(A B : Rat)  (h : 0 < A * B)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b + 2 > 3 + b) : False := by linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (â†`(tactic| ring))}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "linarith (config := {discharger := do Lean.Elab.Tactic.evalTactic (â†`(tactic| ring))})",
  "core-prompt": "(a b c : Rat)  (h2 : b + 2 > 3 + b) : False",
  "args": "(a b c : Rat)  (h2 : b + 2 > 3 + b)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b + 2 > 3 + b) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b + 2 > 3 + b) : False",
  "args": "(a b c : Rat)  (h2 : b + 2 > 3 + b)"},
 {"type": "v â‰¤ V",
  "tactic-prompt":
  "example (g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 â‰¤ c)  (h6 : c < 1) : v â‰¤ V := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 â‰¤ c)  (h6 : c < 1) : v â‰¤ V",
  "args":
  "(g v V c h : Rat)  (h1 : h = 0)  (h2 : v = V)  (h3 : V > 0)  (h4 : g > 0)      (h5 : 0 â‰¤ c)  (h6 : c < 1)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0) : False",
  "args":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : 12*y - 4* z < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0) : False",
  "args":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)  (h3 : 12*y - 4* z < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3) : False",
  "args":
  "(a b c : Rat)  (h1 : a > 0)  (h2 : b > 5)  (h3 : c < -10)  (h4 : a + b - c < 3)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b > 0)  (h3 : Â¬ b â‰¥ 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b > 0)  (h3 : Â¬ b â‰¥ 0) : False",
  "args": "(a b c : Rat)  (h2 : b > 0)  (h3 : Â¬ b â‰¥ 0)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : Rat)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y",
  "args": "(x y z : Rat)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z)"},
 {"type": "Â¬ 12*y - 4* z < 0",
  "tactic-prompt":
  "example (x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5) : Â¬ 12*y - 4* z < 0 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5) : Â¬ 12*y - 4* z < 0",
  "args":
  "(x y z : â„¤)  (h1 : 2*x < 3*y)  (h2 : -4*x + 2*z < 0)  (h3 : x*y < 5)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : Rat)  (hx : Â¬ x > 3*y)  (h2 : Â¬ y > 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (hx : Â¬ x > 3*y)  (h2 : Â¬ y > 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y",
  "args": "(x y z : Rat)  (hx : Â¬ x > 3*y)  (h2 : Â¬ y > 2*z)  (h3 : x â‰¥ 6*z)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x â‰¥ 0)      (h'' : (6 + 3 * y) * y â‰¥ 0) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x â‰¥ 0)      (h'' : (6 + 3 * y) * y â‰¥ 0) : False",
  "args":
  "(x y : Rat)  (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3)  (h' : (x + 4) * x â‰¥ 0)      (h'' : (6 + 3 * y) * y â‰¥ 0)"},
 {"type": "0 * 0 â‰¤ 2 * a",
  "tactic-prompt":
  "example (a : Rat)  (ha : 0 â‰¤ a) : 0 * 0 â‰¤ 2 * a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a : Rat)  (ha : 0 â‰¤ a) : 0 * 0 â‰¤ 2 * a",
  "args": "(a : Rat)  (ha : 0 â‰¤ a)"},
 {"type": "x â‰  y",
  "tactic-prompt":
  "example (x y : Rat)  (h : x < y) : x â‰  y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(x y : Rat)  (h : x < y) : x â‰  y",
  "args": "(x y : Rat)  (h : x < y)"},
 {"type": "Â¬ x = y",
  "tactic-prompt":
  "example (x y : Rat)  (h : x < y) : Â¬ x = y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(x y : Rat)  (h : x < y) : Â¬ x = y",
  "args": "(x y : Rat)  (h : x < y)"},
 {"type": "id x â‰¥ x",
  "tactic-prompt":
  "example (x : Rat) : id x â‰¥ x := by fail_if_success\n    linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    linarith",
  "core-prompt": "(x : Rat) : id x â‰¥ x",
  "args": "(x : Rat)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7) : False",
  "args":
  "(x y z : Rat)  (h1 : 2*x + ((-3)*y) < 0)  (h2 : (-4)*x + 2*z < 0)  (h3 : 12*y + (-4)* z < 0)      (h4 : Nat.prime 7)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7) : False",
  "args":
  "(x y z : Rat)  (h1 : 2*1*x + (3)*(y*(-1)) < 0)  (h2 : (-2)*x*2 < -(z + z))      (h3 : 12*y + (-4)* z < 0)  (h4 : Nat.prime 7)"},
 {"type": "False",
  "tactic-prompt":
  "example (w x y z : â„¤)  (h1 : 4*x + (-3)*y + 6*w â‰¤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w â‰¥ 0)      (h5 : Nat.prime x.natAbs) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(w x y z : â„¤)  (h1 : 4*x + (-3)*y + 6*w â‰¤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w â‰¥ 0)      (h5 : Nat.prime x.natAbs) : False",
  "args":
  "(w x y z : â„¤)  (h1 : 4*x + (-3)*y + 6*w â‰¤ 0)  (h2 : (-1)*x < 0)  (h3 : y < 0)  (h4 : w â‰¥ 0)      (h5 : Nat.prime x.natAbs)"},
 {"type": "False",
  "tactic-prompt":
  "example (x : Rat)  (hx : x > 0)  (h : x.num < 0) : False := by linarith [Rat.num_pos_iff_pos.mpr hx]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [Rat.num_pos_iff_pos.mpr hx]",
  "core-prompt": "(x : Rat)  (hx : x > 0)  (h : x.num < 0) : False",
  "args": "(x : Rat)  (hx : x > 0)  (h : x.num < 0)"},
 {"type": "False",
  "tactic-prompt":
  "example (x : Rat)  (hx : x > 0)  (h : x.num < 0) : False := by fail_if_success\n    linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    linarith",
  "core-prompt": "(x : Rat)  (hx : x > 0)  (h : x.num < 0) : False",
  "args": "(x : Rat)  (hx : x > 0)  (h : x.num < 0)"},
 {"type": "Nat.prime 10",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : b > 0)  (h3 : b < 0) : Nat.prime 10 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : Rat)  (h2 : b > 0)  (h3 : b < 0) : Nat.prime 10",
  "args": "(a b c : Rat)  (h2 : b > 0)  (h3 : b < 0)"},
 {"type": "a + b - c â‰¥ 3",
  "tactic-prompt":
  "example (a b c : Rat)  (h2 : (2 : Rat) > 3) : a + b - c â‰¥ 3 := by linarith (config := {exfalso := false}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith (config := {exfalso := false})",
  "core-prompt": "(a b c : Rat)  (h2 : (2 : Rat) > 3) : a + b - c â‰¥ 3",
  "args": "(a b c : Rat)  (h2 : (2 : Rat) > 3)"},
 {"type": "False",
  "tactic-prompt":
  "example (x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 âˆ§ (x + 4) * x â‰¥ 0 âˆ§ (6 + 3 * y) * y â‰¥ 0) : False := by fail_if_success\n    linarith (config := {split_hypotheses := false}); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    linarith (config := {split_hypotheses := false})",
  "core-prompt":
  "(x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 âˆ§ (x + 4) * x â‰¥ 0 âˆ§ (6 + 3 * y) * y â‰¥ 0) : False",
  "args":
  "(x y : Rat)      (h : 6 + ((x + 4) * x + (6 + 3 * y) * y) = 3 âˆ§ (x + 4) * x â‰¥ 0 âˆ§ (6 + 3 * y) * y â‰¥ 0)"},
 {"type": "3 < 7",
  "tactic-prompt":
  "example (h : 1 < 0)  (g : Â¬ 37 < 42)  (k : True)  (l : (-7 : â„¤) < 5) : 3 < 7 := by linarith [(rfl : 0 = 0)]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [(rfl : 0 = 0)]",
  "core-prompt":
  "(h : 1 < 0)  (g : Â¬ 37 < 42)  (k : True)  (l : (-7 : â„¤) < 5) : 3 < 7",
  "args": "(h : 1 < 0)  (g : Â¬ 37 < 42)  (k : True)  (l : (-7 : â„¤) < 5)"},
 {"type": "3 = 7",
  "tactic-prompt":
  "example (h : 1 < 0) : 3 = 7 := by linarith [Int.zero_lt_one]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith [Int.zero_lt_one]",
  "core-prompt": "(h : 1 < 0) : 3 = 7",
  "args": "(h : 1 < 0)"},
 {"type": "False",
  "tactic-prompt": "example (h1 : (1 : â„•) < 1) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(h1 : (1 : â„•) < 1) : False",
  "args": "(h1 : (1 : â„•) < 1)"},
 {"type": "a + b â‰¥ a",
  "tactic-prompt": "example (a b c : â„•) : a + b â‰¥ a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : â„•) : a + b â‰¥ a",
  "args": "(a b c : â„•)"},
 {"type": "False",
  "tactic-prompt":
  "example (a b i : â„•)  (h1 :  Â¬ a < i)  (h2 : b < i)  (h3 : a â‰¤ b) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(a b i : â„•)  (h1 :  Â¬ a < i)  (h2 : b < i)  (h3 : a â‰¤ b) : False",
  "args": "(a b i : â„•)  (h1 :  Â¬ a < i)  (h2 : b < i)  (h3 : a â‰¤ b)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : â„•)  (h : x < 3 * y) : True := by zify at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h",
  "core-prompt": "(x y : â„•)  (h : x < 3 * y) : True",
  "args": "(x y : â„•)  (h : x < 3 * y)"},
 {"type": "x = 3*y",
  "tactic-prompt":
  "example (x y z : â„•)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(x y z : â„•)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z) : x = 3*y",
  "args": "(x y z : â„•)  (hx : x â‰¤ 3*y)  (h2 : y â‰¤ 2*z)  (h3 : x â‰¥ 6*z)"},
 {"type": "Â¬ a + b < a",
  "tactic-prompt": "example (a b c : â„•) : Â¬ a + b < a := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(a b c : â„•) : Â¬ a + b < a",
  "args": "(a b c : â„•)"},
 {"type": "n = 3",
  "tactic-prompt":
  "example (n : â„•)  (h1 : n â‰¤ 3)  (h2 : n > 2) : n = 3 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(n : â„•)  (h1 : n â‰¤ 3)  (h2 : n > 2) : n = 3",
  "args": "(n : â„•)  (h1 : n â‰¤ 3)  (h2 : n > 2)"},
 {"type": "False",
  "tactic-prompt":
  "example (z : â„•)  (hz : Â¬ z â‰¥ 2)  (h2 : Â¬ z + 1 â‰¤ 2) : False := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(z : â„•)  (hz : Â¬ z â‰¥ 2)  (h2 : Â¬ z + 1 â‰¤ 2) : False",
  "args": "(z : â„•)  (hz : Â¬ z â‰¥ 2)  (h2 : Â¬ z + 1 â‰¤ 2)"},
 {"type": "z + 1 â‰¤ 2",
  "tactic-prompt":
  "example (z : â„•)  (hz : Â¬ z â‰¥ 2) : z + 1 â‰¤ 2 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(z : â„•)  (hz : Â¬ z â‰¥ 2) : z + 1 â‰¤ 2",
  "args": "(z : â„•)  (hz : Â¬ z â‰¥ 2)"},
 {"type": "2 * i + 3 > 11",
  "tactic-prompt":
  "example (i : â„¤)  (hi : i > 5) : 2 * i + 3 > 11 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(i : â„¤)  (hi : i > 5) : 2 * i + 3 > 11",
  "args": "(i : â„¤)  (hi : i > 5)"},
 {"type": "m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1)",
  "tactic-prompt":
  "example (m : â„•) : m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1) := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(m : â„•) : m * m + m + (2 * m + 2) = m * m + m + (m + 1) + (m + 1)",
  "args": "(m : â„•)"},
 {"type":
  "mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2)",
  "tactic-prompt":
  "example (mess : â„• â†’ â„•)  (S n : â„•) : mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2) := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(mess : â„• â†’ â„•)  (S n : â„•) : mess S + (n * mess S + n * 2 + 1) < n * mess S + mess S + (n * 2 + 2)",
  "args": "(mess : â„• â†’ â„•)  (S n : â„•)"},
 {"type": "n + p' = n' + p",
  "tactic-prompt":
  "example (p n p' n' : â„•)  (h : p + n' = p' + n) : n + p' = n' + p := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt": "(p n p' n' : â„•)  (h : p + n' = p' + n) : n + p' = n' + p",
  "args": "(p n p' n' : â„•)  (h : p + n' = p' + n)"},
 {"type": "A < l + 1",
  "tactic-prompt":
  "example (N : â„•)  (n : â„•)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l â‰¤ -(A - l))      (h_1 : Â¬A â‰¤ -A)  (h_2 : Â¬l â‰¤ -l)  (h_3 : -(A - l) < 1) : A < l + 1 := by linarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linarith",
  "core-prompt":
  "(N : â„•)  (n : â„•)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l â‰¤ -(A - l))      (h_1 : Â¬A â‰¤ -A)  (h_2 : Â¬l â‰¤ -l)  (h_3 : -(A - l) < 1) : A < l + 1",
  "args":
  "(N : â„•)  (n : â„•)  (Hirrelevant : n > N)  (A : Rat)  (l : Rat)  (h : A - l â‰¤ -(A - l))      (h_1 : Â¬A â‰¤ -A)  (h_2 : Â¬l â‰¤ -l)  (h_3 : -(A - l) < 1)"},
 {"type": "u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : â„š)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : u * y + v * x + u * v < 3 * A * B := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "(u v x y A B : â„š)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : u * y + v * x + u * v < 3 * A * B",
  "args":
  "(u v x y A B : â„š)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type":
  "(0 < A) â†’ (A â‰¤ 1) â†’ (1 â‰¤ B)\nâ†’ (x â‰¤ B) â†’ ( y â‰¤ B)\nâ†’ (0 â‰¤ u ) â†’ (0 â‰¤ v )\nâ†’ (u < A) â†’ ( v < A)\nâ†’ (u * y + v * x + u * v < 3 * A * B)",
  "tactic-prompt":
  "example (u v x y A B : â„š) : (0 < A) â†’ (A â‰¤ 1) â†’ (1 â‰¤ B)\nâ†’ (x â‰¤ B) â†’ ( y â‰¤ B)\nâ†’ (0 â‰¤ u ) â†’ (0 â‰¤ v )\nâ†’ (u < A) â†’ ( v < A)\nâ†’ (u * y + v * x + u * v < 3 * A * B) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : â„š) : (0 < A) â†’ (A â‰¤ 1) â†’ (1 â‰¤ B)\nâ†’ (x â‰¤ B) â†’ ( y â‰¤ B)\nâ†’ (0 â‰¤ u ) â†’ (0 â‰¤ v )\nâ†’ (u < A) â†’ ( v < A)\nâ†’ (u * y + v * x + u * v < 3 * A * B)",
  "args": "(u v x y A B : â„š)"},
 {"type":
  "(0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 < A * (A - u))\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * v)\n-> (0 <= (B - y) * u)\n-> (0 <= u * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "args": "(u v x y A B : Rat)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type":
  "(0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "tactic-prompt":
  "example (u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v) : (0 < A * A)\n-> (0 <= A * (1 - A))\n-> (0 <= A * (B - 1))\n-> (0 <= A * (B - x))\n-> (0 <= A * (B - y))\n-> (0 <= A * u)\n-> (0 <= A * v)\n-> (0 < A * (A - u))\n-> (0 < A * (A - v))\n-> (0 <= (1 - A) * A)\n-> (0 <= (1 - A) * (1 - A))\n-> (0 <= (1 - A) * (B - 1))\n-> (0 <= (1 - A) * (B - x))\n-> (0 <= (1 - A) * (B - y))\n-> (0 <= (1 - A) * u)\n-> (0 <= (1 - A) * v)\n-> (0 <= (1 - A) * (A - u))\n-> (0 <= (1 - A) * (A - v))\n-> (0 <= (B - 1) * A)\n-> (0 <= (B - 1) * (1 - A))\n-> (0 <= (B - 1) * (B - 1))\n-> (0 <= (B - 1) * (B - x))\n-> (0 <= (B - 1) * (B - y))\n-> (0 <= (B - 1) * u)\n-> (0 <= (B - 1) * v)\n-> (0 <= (B - 1) * (A - u))\n-> (0 <= (B - 1) * (A - v))\n-> (0 <= (B - x) * A)\n-> (0 <= (B - x) * (1 - A))\n-> (0 <= (B - x) * (B - 1))\n-> (0 <= (B - x) * (B - x))\n-> (0 <= (B - x) * (B - y))\n-> (0 <= (B - x) * u)\n-> (0 <= (B - x) * v)\n-> (0 <= (B - x) * (A - u))\n-> (0 <= (B - x) * (A - v))\n-> (0 <= (B - y) * A)\n-> (0 <= (B - y) * (1 - A))\n-> (0 <= (B - y) * (B - 1))\n-> (0 <= (B - y) * (B - x))\n-> (0 <= (B - y) * (B - y))\n-> (0 <= (B - y) * u)\n-> (0 <= (B - y) * v)\n-> (0 <= (B - y) * (A - u))\n-> (0 <= (B - y) * (A - v))\n-> (0 <= u * A)\n-> (0 <= u * (1 - A))\n-> (0 <= u * (B - 1))\n-> (0 <= u * (B - x))\n-> (0 <= u * (B - y))\n-> (0 <= u * u)\n-> (0 <= u * v)\n-> (0 <= u * (A - u))\n-> (0 <= u * (A - v))\n-> (0 <= v * A)\n-> (0 <= v * (1 - A))\n-> (0 <= v * (B - 1))\n-> (0 <= v * (B - x))\n-> (0 <= v * (B - y))\n-> (0 <= v * u)\n-> (0 <= v * v)\n-> (0 <= v * (A - u))\n-> (0 <= v * (A - v))\n-> (0 < (A - u) * A)\n-> (0 <= (A - u) * (1 - A))\n-> (0 <= (A - u) * (B - 1))\n-> (0 <= (A - u) * (B - x))\n-> (0 <= (A - u) * (B - y))\n-> (0 <= (A - u) * u)\n-> (0 <= (A - u) * v)\n-> (0 < (A - u) * (A - u))\n-> (0 < (A - u) * (A - v))\n-> (0 < (A - v) * A)\n-> (0 <= (A - v) * (1 - A))\n-> (0 <= (A - v) * (B - 1))\n-> (0 <= (A - v) * (B - x))\n-> (0 <= (A - v) * (B - y))\n-> (0 <= (A - v) * u)\n-> (0 <= (A - v) * v)\n-> (0 < (A - v) * (A - u))\n-> (0 < (A - v) * (A - v))\n->\n u * y + v * x + u * v < 3 * A * B",
  "args":
  "(u v x y A B : Rat)  (a : 0 < A)  (a_1 : 0 <= 1 - A)  (a_2 : 0 <= B - 1)  (a_3 : 0 <= B - x)  (a_4 : 0 <= B - y)  (a_5 : 0 <= u)  (a_6 : 0 <= v)  (a_7 : 0 < A - u)  (a_8 : 0 < A - v)"},
 {"type": "0 â‰¤ x ^2 + y ^2",
  "tactic-prompt": "example (x y : â„š) : 0 â‰¤ x ^2 + y ^2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : â„š) : 0 â‰¤ x ^2 + y ^2",
  "args": "(x y : â„š)"},
 {"type": "0 â‰¤ x*x + y*y",
  "tactic-prompt": "example (x y : â„š) : 0 â‰¤ x*x + y*y := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : â„š) : 0 â‰¤ x*x + y*y",
  "args": "(x y : â„š)"},
 {"type": "x = 0 â†’ y = 0 â†’ x*x + y*y = 0",
  "tactic-prompt":
  "example (x y : â„š) : x = 0 â†’ y = 0 â†’ x*x + y*y = 0 := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(x y : â„š) : x = 0 â†’ y = 0 â†’ x*x + y*y = 0",
  "args": "(x y : â„š)"},
 {"type": "x * x + y * y = 0 â†” x = 0 âˆ§ y = 0",
  "tactic-prompt":
  "lemma {x y : â„š} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 := by constructor; sorry",
  "name": "norm_eq_zero_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": "{x y : â„š} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0",
  "args": "{x y : â„š}"},
 {"type": "x = 0",
  "tactic-prompt":
  "lemma {x y : â„š}  (h1 : x * x + y * y = 0) : x = 0 := by nlinarith; sorry",
  "name": "norm_zero_left",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "{x y : â„š}  (h1 : x * x + y * y = 0) : x = 0",
  "args": "{x y : â„š}  (h1 : x * x + y * y = 0)"},
 {"type": "y = 0",
  "tactic-prompt":
  "lemma {x y : â„š}  (h1 : x * x + y * y â‰¤ 0) : y = 0 := by nlinarith; sorry",
  "name": "norm_nonpos_right",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "{x y : â„š}  (h1 : x * x + y * y â‰¤ 0) : y = 0",
  "args": "{x y : â„š}  (h1 : x * x + y * y â‰¤ 0)"},
 {"type": "x = 0",
  "tactic-prompt":
  "lemma (x y : â„š)  (h1 : x * x + y * y â‰¤ 0) : x = 0 := by nlinarith; sorry",
  "name": "norm_nonpos_left",
  "kind": "lemma",
  "first-tactic": "nlinarith",
  "core-prompt": "(x y : â„š)  (h1 : x * x + y * y â‰¤ 0) : x = 0",
  "args": "(x y : â„š)  (h1 : x * x + y * y â‰¤ 0)"},
 {"type": "1 â‰¤ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (f : â„¤ â†’ E)  (h : 0 = f 0) : 1 â‰¤ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (f : â„¤ â†’ E)  (h : 0 = f 0) : 1 â‰¤ 2",
  "args": "{E : Type _}  [AddGroup E] (f : â„¤ â†’ E)  (h : 0 = f 0)"},
 {"type": "1 â‰¤ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (a : E)  (h : a = a) : 1 â‰¤ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt": "{E : Type _}  [AddGroup E] (a : E)  (h : a = a) : 1 â‰¤ 2",
  "args": "{E : Type _}  [AddGroup E] (a : E)  (h : a = a)"},
 {"type": "p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w)",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (p q r s t u v w : â„•)  (h1 : p + u = q + t)  (h2 : r + w = s + v) : p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w) := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (p q r s t u v w : â„•)  (h1 : p + u = q + t)  (h2 : r + w = s + v) : p * r + q * s + (t * w + u * v) = p * s + q * r + (t * v + u * w)",
  "args":
  "{E : Type _}  [AddGroup E] (p q r s t u v w : â„•)  (h1 : p + u = q + t)  (h2 : r + w = s + v)"},
 {"type": "y * x â‰¤ x * x",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x) : y * x â‰¤ x * x := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x) : y * x â‰¤ x * x",
  "args": "{E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x)"},
 {"type": "y * x â‰¤ x ^ 2",
  "tactic-prompt":
  "example {E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x) : y * x â‰¤ x ^ 2 := by nlinarith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nlinarith",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x) : y * x â‰¤ x ^ 2",
  "args": "{E : Type _}  [AddGroup E] (x y : â„š)  (hâ‚ : 0 â‰¤ y)  (hâ‚‚ : y â‰¤ x)"},
 {"type": "1 â‰¤ y + x * x",
  "tactic-prompt":
  "lemma {E : Type _}  [AddGroup E] (x y: Int)  (h : 0 â‰¤ y âˆ§ 1 â‰¤ x) : 1 â‰¤ y + x * x := by linarith [foo h.2]; sorry",
  "name": "bar",
  "kind": "lemma",
  "first-tactic": "linarith [foo h.2]",
  "core-prompt":
  "{E : Type _}  [AddGroup E] (x y: Int)  (h : 0 â‰¤ y âˆ§ 1 â‰¤ x) : 1 â‰¤ y + x * x",
  "args": "{E : Type _}  [AddGroup E] (x y: Int)  (h : 0 â‰¤ y âˆ§ 1 â‰¤ x)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "False â†’ Î±",
  "tactic-prompt": "example  : False â†’ Î± := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : False â†’ Î±",
  "args": ""},
 {"type": "Â¬ False",
  "tactic-prompt": "example  : Â¬ False := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : Â¬ False",
  "args": ""},
 {"type": "P âˆ§ Q",
  "tactic-prompt":
  "example {P Q : Prop}  (q : P)  (p : Q) : P âˆ§ Q := by swap_var p â†” q; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var p â†” q",
  "core-prompt": "{P Q : Prop}  (q : P)  (p : Q) : P âˆ§ Q",
  "args": "{P Q : Prop}  (q : P)  (p : Q)"},
 {"type": "a = b âˆ§ a = a",
  "tactic-prompt":
  "example {a b : Nat}  (h : a = b) : a = b âˆ§ a = a := by swap_var a â†” b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var a â†” b",
  "core-prompt": "{a b : Nat}  (h : a = b) : a = b âˆ§ a = a",
  "args": "{a b : Nat}  (h : a = b)"},
 {"type": "a = b âˆ§ c = d",
  "tactic-prompt":
  "example {a b c d : Nat}  (h : a = b âˆ§ c = d) : a = b âˆ§ c = d := by swap_var a â†” b, b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var a â†” b, b c",
  "core-prompt": "{a b c d : Nat}  (h : a = b âˆ§ c = d) : a = b âˆ§ c = d",
  "args": "{a b c d : Nat}  (h : a = b âˆ§ c = d)"},
 {"type": "frobnicate a 0 = a",
  "tactic-prompt":
  "example  : frobnicate a 0 = a := by simp [frobnicate_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp [frobnicate_def]",
  "core-prompt": " : frobnicate a 0 = a",
  "args": ""},
 {"type": "withUniv.{u, v} = (Type v, Type u)",
  "tactic-prompt":
  "example  : withUniv.{u, v} = (Type v, Type u) := by rw [withUniv_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [withUniv_def]",
  "core-prompt": " : withUniv.{u, v} = (Type v, Type u)",
  "args": ""},
 {"type": "0 < a",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 0 < a := by nontriviality; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality",
  "core-prompt": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 0 < a",
  "args": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a)"},
 {"type": "r * s = s * r",
  "tactic-prompt":
  "example {R : Type}  [CommRing R]  {r s : R} : r * s = s * r := by nontriviality; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality",
  "core-prompt": "{R : Type}  [CommRing R]  {r s : R} : r * s = s * r",
  "args": "{R : Type}  [CommRing R]  {r s : R}"},
 {"type": "0 â‰¤ (1 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 â‰¤ (1 : R) := by nontriviality R; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality R",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 â‰¤ (1 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "0 â‰¤ (1 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 â‰¤ (1 : R) := by nontriviality â„•; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality â„•",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 â‰¤ (1 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "0 â‰¤ (2 : R)",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R] : 0 â‰¤ (2 : R) := by fail_if_success nontriviality PUnit; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality PUnit",
  "core-prompt": "{R : Type}  [OrderedRing R] : 0 â‰¤ (2 : R)",
  "args": "{R : Type}  [OrderedRing R]"},
 {"type": "2 âˆ£ 4",
  "tactic-prompt":
  "example {R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 2 âˆ£ 4 := by nontriviality R; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality R",
  "core-prompt": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a) : 2 âˆ£ 4",
  "args": "{R : Type}  [OrderedRing R]  {a : R}  (h : 0 < a)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s := by fail_if_success nontriviality Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality Î±",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s",
  "args": "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s := by fail_if_success nontriviality Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success nontriviality Î±",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s",
  "args": "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ)"},
 {"type": "EmptyOrUniv s",
  "tactic-prompt":
  "example {Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s := by nontriviality Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality Î±",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ) : EmptyOrUniv s",
  "args": "{Î± : Type _}  (s : Set Î±)  (hs : s = âˆ… âˆª Set.univ)"},
 {"type": "a = b",
  "tactic-prompt":
  "example (Î± : â„• â†’ Type)  (a b : Î± 0)  (h : a = b) : a = b := by nontriviality Î± 0 using Nat.zero_lt_one; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nontriviality Î± 0 using Nat.zero_lt_one",
  "core-prompt": "(Î± : â„• â†’ Type)  (a b : Î± 0)  (h : a = b) : a = b",
  "args": "(Î± : â„• â†’ Type)  (a b : Î± 0)  (h : a = b)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := {}) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := {}) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := { newGoals := .nonDependentOnly }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .nonDependentOnly }) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := { newGoals := .all }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .all }) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "P",
  "tactic-prompt":
  "example (p : P) : P := by expect_failure_msg \"unknown identifier 'x'\" have h := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "expect_failure_msg \"unknown identifier 'x'\" have h := x",
  "core-prompt": "(p : P) : P",
  "args": "(p : P)"},
 {"type": "x + 0 = y â†’ x = y",
  "tactic-prompt": "example  : x + 0 = y â†’ x = y := by simp_intro; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro",
  "core-prompt": " : x + 0 = y â†’ x = y",
  "args": ""},
 {"type": "x + 0 = y â†’ x = y",
  "tactic-prompt": "example  : x + 0 = y â†’ x = y := by simp_intro hâ‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚",
  "core-prompt": " : x + 0 = y â†’ x = y",
  "args": ""},
 {"type": "x + 0 â‰  y â†’ x â‰  y",
  "tactic-prompt": "example  : x + 0 â‰  y â†’ x â‰  y := by simp_intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚ hâ‚‚",
  "core-prompt": " : x + 0 â‰  y â†’ x â‰  y",
  "args": ""},
 {"type": "x + 0 â‰  y â†’ x â‰  y",
  "tactic-prompt":
  "example  : x + 0 â‰  y â†’ x â‰  y := by simp_intro hâ‚ hâ‚‚ hâ‚ƒ; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚ hâ‚‚ hâ‚ƒ",
  "core-prompt": " : x + 0 â‰  y â†’ x â‰  y",
  "args": ""},
 {"type": "x + 0 = y â†’ x = z",
  "tactic-prompt":
  "example (h : x = z) : x + 0 = y â†’ x = z := by simp_intro [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro [h]",
  "core-prompt": "(h : x = z) : x + 0 = y â†’ x = z",
  "args": "(h : x = z)"},
 {"type": "x + 0 = y â†’ x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y â†’ x = z := by simp_intro; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro",
  "core-prompt": "(h : y = z) : x + 0 = y â†’ x = z",
  "args": "(h : y = z)"},
 {"type": "x + 0 = y â†’ x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y â†’ x = z := by simp_intro _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro _",
  "core-prompt": "(h : y = z) : x + 0 = y â†’ x = z",
  "args": "(h : y = z)"},
 {"type": "a + (b + a) = a + a + b",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±] : a + (b + a) = a + a + b := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±] : a + (b + a) = a + a + b",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]"},
 {"type": "(a + b) - ((b + a) + a) = -a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±] : (a + b) - ((b + a) + a) = -a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±] : (a + b) - ((b + a) + a) = -a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]"},
 {"type": "x - 0 = x",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±) : x - 0 = x := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±) : x - 0 = x",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±)"},
 {"type": "(3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±] : (3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±] : (3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]"},
 {"type": "(3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±] : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±] : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]"},
 {"type": "a-2â€¢b = a -2â€¢b",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a-2â€¢b = a -2â€¢b := by abel; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a-2â€¢b = a -2â€¢b",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±)"},
 {"type": "a + (b + a) = a + a + b",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b : Î±) : a + (b + a) = a + a + b := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b : Î±) : a + (b + a) = a + a + b",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b : Î±)"},
 {"type": "(a + b) - ((b + a) + a) = -a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : (a + b) - ((b + a) + a) = -a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : (a + b) - ((b + a) + a) = -a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±)"},
 {"type": "x - 0 = x",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±) : x - 0 = x := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±) : x - 0 = x",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (x : Î±)"},
 {"type": "(3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a : Î±) : (3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a : Î±) : (3 : â„•) â€¢ a = a + (2 : â„•) â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a : Î±)"},
 {"type": "(3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±) : (3 : â„¤) â€¢ a = a + (2 : â„¤) â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±)"},
 {"type": "a - 2â€¢b = a - 2â€¢b",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a - 2â€¢b = a - 2â€¢b := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a - 2â€¢b = a - 2â€¢b",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±)"},
 {"type": "0 + a = a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±) : 0 + a = a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±) : 0 + a = a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a : Î±)"},
 {"type": "n â€¢ a = n â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±) : n â€¢ a = n â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±) : n â€¢ a = n â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±)"},
 {"type": "0 + n â€¢ a = n â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±) : 0 + n â€¢ a = n â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±) : 0 + n â€¢ a = n â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (n : â„•)  (a : Î±)"},
 {"type": "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±)"},
 {"type": "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 4 â€¢ a",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±)"},
 {"type": "a + b + (c + d - a) = b + c + d",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±) : a + b + (c + d - a) = b + c + d := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±) : a + b + (c + d - a) = b + c + d",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±)"},
 {"type": "a + b + c + (c - a - a) = (-1)â€¢a + b + 2â€¢c",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±) : a + b + c + (c - a - a) = (-1)â€¢a + b + 2â€¢c := by abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±) : a + b + c + (c - a - a) = (-1)â€¢a + b + 2â€¢c",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±)"},
 {"type":
  "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommMonoid Î±]  (a b c d e : Î±)"},
 {"type":
  "a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±) : a + (b + (a + (c + (a + (d + (a + e)))))) = e + d + c + b + 3 â€¢ a âˆ¨ True",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d e : Î±)"},
 {"type": "a + b + (c + d - a) = b + c - d âˆ¨ True",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±) : a + b + (c + d - a) = b + c - d âˆ¨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±) : a + b + (c + d - a) = b + c - d âˆ¨ True",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c d : Î±)"},
 {"type": "a + b + c + (c - a - a) = (-1)â€¢a + b + c âˆ¨ True",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±) : a + b + c + (c - a - a) = (-1)â€¢a + b + c âˆ¨ True := by fail_if_success\n    left; abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    left; abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±) : a + b + c + (c - a - a) = (-1)â€¢a + b + c âˆ¨ True",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b c : Î±)"},
 {"type": "a + b - b - id' a = 0",
  "tactic-prompt":
  "example {Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a + b - b - id' a = 0 := by fail_if_success\n    abel1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    abel1",
  "core-prompt":
  "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±) : a + b - b - id' a = 0",
  "args": "{Î± : Type _}  {a b : Î±} [AddCommGroup Î±]  (a b : Î±)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace 2 + 2 + 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace 2 + 2 + 3",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace \"hello\" ++ \" world\"; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace \"hello\" ++ \" world\"",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (_delete_this : Nat) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat) : Nat",
  "args": "(_delete_this : Nat)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "[_dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[_dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat",
  "args":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep)"},
 {"type": "_dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this",
  "args": "(_dont_delete_this : Type)  (dep : _dont_delete_this)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this",
  "args": "(_dont_delete_this : Type)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this",
  "args":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this)"},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by existsi 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "tactic-prompt":
  "example  : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by existsi 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42, 42",
  "core-prompt": " : âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "args": ""},
 {"type": "âˆ€ a b : Nat, a = b â†’ b = a",
  "tactic-prompt":
  "example  : âˆ€ a b : Nat, a = b â†’ b = a := by introv h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "introv h",
  "core-prompt": " : âˆ€ a b : Nat, a = b â†’ b = a",
  "args": ""},
 {"type": "n = n",
  "tactic-prompt": "example (n : Nat) : n = n := by induction n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by guard_hyp n : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp n : Nat",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "a â‰  b â†’ Â¬ a = b",
  "tactic-prompt": "example (a b : Nat) : a â‰  b â†’ Â¬ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a â‰  b â†’ Â¬ a = b",
  "args": "(a b : Nat)"},
 {"type": "Â¬Â¬ a = b â†’ a = b",
  "tactic-prompt": "example (a b : Nat) : Â¬Â¬ a = b â†’ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : Â¬Â¬ a = b â†’ a = b",
  "args": "(a b : Nat)"},
 {"type": "Â¬Â¬ p â†’ p",
  "tactic-prompt": "example (p _q : Prop) : Â¬Â¬ p â†’ p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p _q : Prop) : Â¬Â¬ p â†’ p",
  "args": "(p _q : Prop)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by iterate exact (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "iterate exact ()",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q)",
  "tactic-prompt":
  "example (p q r s : Prop) : p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(p q r s : Prop) : p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q)",
  "args": "(p q r s : Prop)"},
 {"type": "p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p)",
  "tactic-prompt":
  "example (p q : Prop) : p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p)",
  "args": "(p q : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt":
  "(delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat",
  "args":
  "(delete_this : Nat)  (_delete_this2 : delete_this = delete_this)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat := by clear * - dont_delete_this dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this dont_delete_this2",
  "core-prompt":
  "(_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat",
  "args":
  "(_delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int)"},
 {"type": "(Î± : Type) Ã— List Î±",
  "tactic-prompt": "example  : (Î± : Type) Ã— List Î± := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (Î± : Type) Ã— List Î±",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := âˆ€ p, decide p; sorry",
  "name": "foo",
  "kind": "def",
  "first-tactic": "fail_if_success have := âˆ€ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := âˆ€ p, decide p; sorry",
  "name": "bar",
  "kind": "def",
  "first-tactic": "fail_if_success have := âˆ€ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := âˆ€ p, decide p; sorry",
  "name": "bar'",
  "kind": "def",
  "first-tactic": "fail_if_success have := âˆ€ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "Bool",
  "tactic-prompt":
  "def  : Bool := by fail_if_success have := âˆ€ p, decide p; sorry",
  "name": "bar''",
  "kind": "def",
  "first-tactic": "fail_if_success have := âˆ€ p, decide p",
  "core-prompt": " : Bool",
  "args": ""},
 {"type": "3 âˆ£ n ^ 3 - n",
  "tactic-prompt":
  "example (n : â„¤) : 3 âˆ£ n ^ 3 - n := by mod_cases n % 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mod_cases n % 3",
  "core-prompt": "(n : â„¤) : 3 âˆ£ n ^ 3 - n",
  "args": "(n : â„¤)"},
 {"type": "true âˆ§ true",
  "tactic-prompt": "example  : true âˆ§ true := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : true âˆ§ true",
  "args": ""},
 {"type": "(true âˆ§ true) âˆ§ (true âˆ§ true)",
  "tactic-prompt":
  "example  : (true âˆ§ true) âˆ§ (true âˆ§ true) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (true âˆ§ true) âˆ§ (true âˆ§ true)",
  "args": ""},
 {"type": "x = if p then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x := by split_ifs with h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "x = y",
  "tactic-prompt":
  "example (x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y",
  "args":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x)"},
 {"type": "x = if p then (if q then x else x) else x",
  "tactic-prompt":
  "example (x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x",
  "args": "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "x = if (if p then False else True) then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "if if Â¬p then p else True then p else Â¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p := by split_ifs with h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q := by split_ifs with h1 h2 h3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2 h3",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "False",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False",
  "args": "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3)"},
 {"type": "x < (if Â¬p then 1 else 0) + 1",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if Â¬p then 1 else 0) + 1 := by split_ifs at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at *",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if Â¬p then 1 else 0) + 1",
  "args":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x)"},
 {"type": "if if Â¬p then p else True then p else Â¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "True",
  "tactic-prompt": "example  : True := by fail_if_success { split_ifs }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { split_ifs }",
  "core-prompt": " : True",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "example (P Q : Prop)  (w : if P then (if Q then true else true) else true = true) : true := by split_ifs at w; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at w",
  "core-prompt":
  "(P Q : Prop)  (w : if P then (if Q then true else true) else true = true) : true",
  "args":
  "(P Q : Prop)  (w : if P then (if Q then true else true) else true = true)"},
 {"type": "a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e)"},
 {"type": "a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e)"},
 {"type": "P 2",
  "tactic-prompt":
  "example (P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0) : P 2 := by apply_rules [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [f]",
  "core-prompt":
  "(P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0) : P 2",
  "args": "(P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0)"},
 {"type": "Int Ã— Q",
  "tactic-prompt":
  "example (Q : Type)  (f : Nat â†’ Q) : Int Ã— Q := by apply_rules [Prod.mk]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [Prod.mk]",
  "core-prompt": "(Q : Type)  (f : Nat â†’ Q) : Int Ã— Q",
  "args": "(Q : Type)  (f : Nat â†’ Q)"},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by left; sorry",
  "name": "zero",
  "kind": "def",
  "first-tactic": "left",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by right; sorry",
  "name": "two",
  "kind": "def",
  "first-tactic": "right",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "(1 = 1) âˆ¨ (2 = 3)",
  "tactic-prompt": "example  : (1 = 1) âˆ¨ (2 = 3) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : (1 = 1) âˆ¨ (2 = 3)",
  "args": ""},
 {"type": "(1 = 2) âˆ¨ (3 = 3)",
  "tactic-prompt": "example  : (1 = 2) âˆ¨ (3 = 3) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : (1 = 2) âˆ¨ (3 = 3)",
  "args": ""},
 {"type": "c < a + 3*b",
  "tactic-prompt":
  "example (a b c x y z : â„•)  (h : Â¬ x*y*z < 0) : c < a + 3*b := by zify; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify",
  "core-prompt": "(a b c x y z : â„•)  (h : Â¬ x*y*z < 0) : c < a + 3*b",
  "args": "(a b c x y z : â„•)  (h : Â¬ x*y*z < 0)"},
 {"type": "a + 3*b > c",
  "tactic-prompt":
  "example (a b c x y z : â„•)  (h : Â¬ x*y*z < 0)  (h2 : (c : â„¤) < a + 3 * b) : a + 3*b > c := by zify at h âŠ¢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h âŠ¢",
  "core-prompt":
  "(a b c x y z : â„•)  (h : Â¬ x*y*z < 0)  (h2 : (c : â„¤) < a + 3 * b) : a + 3*b > c",
  "args": "(a b c x y z : â„•)  (h : Â¬ x*y*z < 0)  (h2 : (c : â„¤) < a + 3 * b)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "example (a b : â„•)  (h : (a : â„¤) â‰¤ b) : a â‰¤ b := by zify; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify",
  "core-prompt": "(a b : â„•)  (h : (a : â„¤) â‰¤ b) : a â‰¤ b",
  "args": "(a b : â„•)  (h : (a : â„¤) â‰¤ b)"},
 {"type": "True",
  "tactic-prompt":
  "example (a b c : â„•)  (h : a - b < c)  (hab : b â‰¤ a) : True := by zify [hab] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify [hab] at h",
  "core-prompt": "(a b c : â„•)  (h : a - b < c)  (hab : b â‰¤ a) : True",
  "args": "(a b c : â„•)  (h : a - b < c)  (hab : b â‰¤ a)"},
 {"type": "True",
  "tactic-prompt":
  "example (a b c : â„•)  (h : a + b â‰  c) : True := by zify at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "zify at h",
  "core-prompt": "(a b c : â„•)  (h : a + b â‰  c) : True",
  "args": "(a b c : â„•)  (h : a + b â‰  c)"},
 {"type": "0 â‰¤ 2 + 2",
  "tactic-prompt":
  "example  : 0 â‰¤ 2 + 2 := by fail_if_success infer_param; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success infer_param",
  "core-prompt": " : 0 â‰¤ 2 + 2",
  "args": ""},
 {"type": "0 â‰¤ 2 + 2",
  "tactic-prompt": "example  : 0 â‰¤ 2 + 2 := by apply zero_le_add; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply zero_le_add",
  "core-prompt": " : 0 â‰¤ 2 + 2",
  "args": ""},
 {"type": "0 â‰¤ 2 + 2",
  "tactic-prompt": "example  : 0 â‰¤ 2 + 2 := by apply zero_le_add'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply zero_le_add'",
  "core-prompt": " : 0 â‰¤ 2 + 2",
  "args": ""},
 {"type": "p â†’ q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬q â†’ Â¬p) : p â†’ q := by contrapose; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose",
  "core-prompt": "(p q : Prop)  (h : Â¬q â†’ Â¬p) : p â†’ q",
  "args": "(p q : Prop)  (h : Â¬q â†’ Â¬p)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p) : q := by contrapose h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose h",
  "core-prompt": "(p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p) : q",
  "args": "(p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p) : q := by contrapose h with h'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose h with h'",
  "core-prompt": "(p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p) : q",
  "args": "(p q : Prop)  (h : p)  (hpq : Â¬q â†’ Â¬p)"},
 {"type": "Â¬p â†’ Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : q â†’ p) : Â¬p â†’ Â¬q := by contrapose!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose!",
  "core-prompt": "(p q : Prop)  (h : q â†’ p) : Â¬p â†’ Â¬q",
  "args": "(p q : Prop)  (h : q â†’ p)"},
 {"type": "Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬p)  (hpq : q â†’ p) : Â¬q := by contrapose! h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose! h",
  "core-prompt": "(p q : Prop)  (h : Â¬p)  (hpq : q â†’ p) : Â¬q",
  "args": "(p q : Prop)  (h : Â¬p)  (hpq : q â†’ p)"},
 {"type": "Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬p)  (hpq : q â†’ p) : Â¬q := by contrapose! h with h'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "contrapose! h with h'",
  "core-prompt": "(p q : Prop)  (h : Â¬p)  (hpq : q â†’ p) : Â¬q",
  "args": "(p q : Prop)  (h : Â¬p)  (hpq : q â†’ p)"},
 {"type": "p",
  "tactic-prompt":
  "example (p : Prop)  (h : p) : p := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p : Prop)  (h : p) : p",
  "args": "(p : Prop)  (h : p)"},
 {"type": "p â†’ q",
  "tactic-prompt":
  "example (p q : Type)  (h : p â†’ q) : p â†’ q := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p q : Type)  (h : p â†’ q) : p â†’ q",
  "args": "(p q : Type)  (h : p â†’ q)"},
 {"type": "a = b â†’ b = a",
  "tactic-prompt": "example (a b : Nat) : a = b â†’ b = a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a = b â†’ b = a",
  "args": "(a b : Nat)"},
 {"type": "a = b â†’ True â†’ b = a",
  "tactic-prompt":
  "example (a b : Nat) : a = b â†’ True â†’ b = a := by intro h _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h _",
  "core-prompt": "(a b : Nat) : a = b â†’ True â†’ b = a",
  "args": "(a b : Nat)"},
 {"type": "sameParity a b â†’ sameParity b a",
  "tactic-prompt":
  "example (a b : Nat) : sameParity a b â†’ sameParity b a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : sameParity a b â†’ sameParity b a",
  "args": "(a b : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    evalApplyLikeTactic MVarId.apply (â† `(True.intro)); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    evalApplyLikeTactic MVarId.apply (â† `(True.intro))",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³ := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³",
  "args": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³ := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³",
  "args": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²)"},
 {"type": "Î± 5",
  "tactic-prompt":
  "example {Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5 := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5",
  "args": "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³ := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³",
  "args": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³ := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³",
  "args": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²)"},
 {"type": "Î± 5",
  "tactic-prompt":
  "example {Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5 := by solve_by_elim []; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim []",
  "core-prompt":
  "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5",
  "args": "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î² := by fail_if_success solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only [f]",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (h : Nat) : Nat := by solve_by_elim only [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [h]",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³ := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³",
  "args": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³ := by solve_by_elim only [g]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [g]",
  "core-prompt": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³",
  "args": "{Î± Î² Î³ : Type}  (_f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²)"},
 {"type": "Î± 5",
  "tactic-prompt":
  "example {Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5 := by solve_by_elim only [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim only [f]",
  "core-prompt":
  "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5",
  "args": "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0)"},
 {"type": "Î²",
  "tactic-prompt":
  "example (Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a : Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (haâ‚ : Pâ‚ a)  (haâ‚‚ : Pâ‚‚ a) : Î² := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "(Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a : Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (haâ‚ : Pâ‚ a)  (haâ‚‚ : Pâ‚‚ a) : Î²",
  "args":
  "(Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a : Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (haâ‚ : Pâ‚ a)  (haâ‚‚ : Pâ‚‚ a)"},
 {"type": "x = x",
  "tactic-prompt":
  "example {X : Type}  (x : X) : x = x := by fail_if_success solve_by_elim only; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only",
  "core-prompt": "{X : Type}  (x : X) : x = x",
  "args": "{X : Type}  (x : X)"},
 {"type": "p",
  "tactic-prompt":
  "example {X : Type}  (x y : X)  (p : Prop)  (h : x = x â†’ y = y â†’ p) : p := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{X : Type}  (x y : X)  (p : Prop)  (h : x = x â†’ y = y â†’ p) : p",
  "args": "{X : Type}  (x y : X)  (p : Prop)  (h : x = x â†’ y = y â†’ p)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success solve_by_elim only; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success solve_by_elim only",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Î²",
  "tactic-prompt":
  "example (Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a: Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (_haâ‚ : Pâ‚ a)      (a' : Î±)  (ha'â‚ : Pâ‚ a')  (ha'â‚‚ : Pâ‚‚ a') : Î² := by solve_by_elim; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "(Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a: Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (_haâ‚ : Pâ‚ a)      (a' : Î±)  (ha'â‚ : Pâ‚ a')  (ha'â‚‚ : Pâ‚‚ a') : Î²",
  "args":
  "(Pâ‚ Pâ‚‚ : Î± â†’ Prop)  (f : âˆ€ (a: Î±), Pâ‚ a â†’ Pâ‚‚ a â†’ Î²)      (a : Î±)  (_haâ‚ : Pâ‚ a)      (a' : Î±)  (ha'â‚ : Pâ‚ a')  (ha'â‚‚ : Pâ‚‚ a')"},
 {"type": "b",
  "tactic-prompt":
  "example {a b : Type}  (hâ‚€ : a â†’ b)  (hâ‚ : a) : b := by apply_assumption; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_assumption",
  "core-prompt": "{a b : Type}  (hâ‚€ : a â†’ b)  (hâ‚ : a) : b",
  "args": "{a b : Type}  (hâ‚€ : a â†’ b)  (hâ‚ : a)"},
 {"type": "p y",
  "tactic-prompt":
  "example {Î± : Type}  {p : Î± â†’ Prop}  (hâ‚€ : âˆ€ x, p x)  (y : Î±) : p y := by apply_assumption; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_assumption",
  "core-prompt": "{Î± : Type}  {p : Î± â†’ Prop}  (hâ‚€ : âˆ€ x, p x)  (y : Î±) : p y",
  "args": "{Î± : Type}  {p : Î± â†’ Prop}  (hâ‚€ : âˆ€ x, p x)  (y : Î±)"},
 {"type": "x + y = y + x",
  "tactic-prompt":
  "example (x y : Nat) : x + y = y + x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(x y : Nat) : x + y = y + x",
  "args": "(x y : Nat)"},
 {"type": "n â‰¤ m â†’ n + k â‰¤ m + k",
  "tactic-prompt":
  "example (n m k : Nat) : n â‰¤ m â†’ n + k â‰¤ m + k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : Nat) : n â‰¤ m â†’ n + k â‰¤ m + k",
  "args": "(n m k : Nat)"},
 {"type": "a * b âˆ£ a * c",
  "tactic-prompt":
  "example (ha : a > 0)  (w : b âˆ£ c) : a * b âˆ£ a * c := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(ha : a > 0)  (w : b âˆ£ c) : a * b âˆ£ a * c",
  "args": "(ha : a > 0)  (w : b âˆ£ c)"},
 {"type": "Int",
  "tactic-prompt": "example  : Int := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : Int",
  "args": ""},
 {"type": "P",
  "tactic-prompt":
  "example (P : Prop)  (p : P) : P := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P) : P",
  "args": "(P : Prop)  (p : P)"},
 {"type": "false",
  "tactic-prompt":
  "example (P : Prop)  (p : P)  (np : Â¬P) : false := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P)  (np : Â¬P) : false",
  "args": "(P : Prop)  (p : P)  (np : Â¬P)"},
 {"type": "Î± â†’ Î±",
  "tactic-prompt": "example (Î± : Prop) : Î± â†’ Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(Î± : Prop) : Î± â†’ Î±",
  "args": "(Î± : Prop)"},
 {"type": "(Â¬Â¬p) â†’ p",
  "tactic-prompt": "example (p : Prop) : (Â¬Â¬p) â†’ p := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(p : Prop) : (Â¬Â¬p) â†’ p",
  "args": "(p : Prop)"},
 {"type": "a + b = b + a",
  "tactic-prompt":
  "example (a b : â„•) : a + b = b + a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : â„•) : a + b = b + a",
  "args": "(a b : â„•)"},
 {"type": "n * (m - k) = n * m - n * k",
  "tactic-prompt":
  "example (n m k : â„•) : n * (m - k) = n * m - n * k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : â„•) : n * (m - k) = n * m - n * k",
  "args": "(n m k : â„•)"},
 {"type": "x = y â†” y = x",
  "tactic-prompt":
  "example {Î± : Type}  (x y : Î±) : x = y â†” y = x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Type}  (x y : Î±) : x = y â†” y = x",
  "args": "{Î± : Type}  (x y : Î±)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "example (a b : â„•)  (h : a âˆ£ b)  (w : b > 0) : a â‰¤ b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : â„•)  (h : a âˆ£ b)  (w : b > 0) : a â‰¤ b",
  "args": "(a b : â„•)  (h : a âˆ£ b)  (w : b > 0)"},
 {"type": "Â¬ (a < 0)",
  "tactic-prompt": "example (a : â„•) : Â¬ (a < 0) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : â„•) : Â¬ (a < 0)",
  "args": "(a : â„•)"},
 {"type": "0 > a",
  "tactic-prompt": "theorem (a : â„•)  (h : P a) : 0 > a := by cases h; sorry",
  "name": "lemma_with_gt_in_head",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "(a : â„•)  (h : P a) : 0 > a",
  "args": "(a : â„•)  (h : P a)"},
 {"type": "False",
  "tactic-prompt":
  "theorem (a b : â„•)  (_h1 : a < b)  (h2 : P a) : False := by apply Nat.not_lt_zero; sorry",
  "name": "lemma_with_false_in_head",
  "kind": "theorem",
  "first-tactic": "apply Nat.not_lt_zero",
  "core-prompt": "(a b : â„•)  (_h1 : a < b)  (h2 : P a) : False",
  "args": "(a b : â„•)  (_h1 : a < b)  (h2 : P a)"},
 {"type": "0 > a",
  "tactic-prompt":
  "example (a : â„•)  (h : P a) : 0 > a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : â„•)  (h : P a) : 0 > a",
  "args": "(a : â„•)  (h : P a)"},
 {"type": "âˆ€ P : Prop, Â¬(P â†” Â¬P)",
  "tactic-prompt":
  "example  : âˆ€ P : Prop, Â¬(P â†” Â¬P) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : âˆ€ P : Prop, Â¬(P â†” Â¬P)",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Sort u}  (h : Empty) : Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Sort u}  (h : Empty) : Î±",
  "args": "{Î± : Sort u}  (h : Empty)"},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Type _}  (h : Empty) : Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Type _}  (h : Empty) : Î±",
  "args": "{Î± : Type _}  (h : Empty)"},
 {"type": "List â„•",
  "tactic-prompt":
  "example (L _M : List (List â„•)) : List â„• := by library_search using L; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search using L",
  "core-prompt": "(L _M : List (List â„•)) : List â„•",
  "args": "(L _M : List (List â„•))"},
 {"type": "List â„•",
  "tactic-prompt":
  "example (P _Q : List â„•)  (h : â„•) : List â„• := by library_search using h, P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search using h, P",
  "core-prompt": "(P _Q : List â„•)  (h : â„•) : List â„•",
  "args": "(P _Q : List â„•)  (h : â„•)"},
 {"type": "List.nthLe [1, 2] 1 (by simp) = 2",
  "tactic-prompt":
  "example  : List.nthLe [1, 2] 1 (by simp) = 2 := by generalize_proofs h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs h",
  "core-prompt": " : List.nthLe [1, 2] 1 (by simp) = 2",
  "args": ""},
 {"type": "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2 := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2",
  "args": "(x : â„•)  (h : x < 2)"},
 {"type":
  "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) = Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2)",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) = Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) = Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2)",
  "args": "(x : â„•)  (h : x < 2)"},
 {"type":
  "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3) := by generalize_proofs a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a",
  "core-prompt":
  "(x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "args": "(x : â„•)  (h : x < 2)"},
 {"type":
  "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3) := by generalize_proofs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs",
  "core-prompt":
  "(x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "args": "(x : â„•)  (h : x < 2)"},
 {"type":
  "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3) := by generalize_proofs _ a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs _ a",
  "core-prompt":
  "(x : â„•)  (h : x < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) =\n  Classical.choose (âŸ¨x, Nat.lt_succ_of_lt hâŸ© : âˆƒ x, x < 3)",
  "args": "(x : â„•)  (h : x < 2)"},
 {"type": "Classical.choose a < 2",
  "tactic-prompt":
  "example (a : âˆƒ x, x < 2) : Classical.choose a < 2 := by generalize_proofs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs",
  "core-prompt": "(a : âˆƒ x, x < 2) : Classical.choose a < 2",
  "args": "(a : âˆƒ x, x < 2)"},
 {"type": "Classical.choose a < 2",
  "tactic-prompt":
  "example (a : âˆƒ x, x < 2) : Classical.choose a < 2 := by generalize_proofs t; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs t",
  "core-prompt": "(a : âˆƒ x, x < 2) : Classical.choose a < 2",
  "args": "(a : âˆƒ x, x < 2)"},
 {"type": "Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2",
  "tactic-prompt":
  "example (x : â„•)  (h : x < 2)  (H : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2 := by generalize_proofs a at H âŠ¢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "generalize_proofs a at H âŠ¢",
  "core-prompt":
  "(x : â„•)  (h : x < 2)  (H : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2) : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2",
  "args":
  "(x : â„•)  (h : x < 2)  (H : Classical.choose (âŸ¨x, hâŸ© : âˆƒ x, x < 2) < 2)"},
 {"type": "(if h : âˆƒ (k : â„•), k = 1 then Classical.choose h else 0) = 1",
  "tactic-prompt":
  "example (H : âˆ€ x, x = 1) : (if h : âˆƒ (k : â„•), k = 1 then Classical.choose h else 0) = 1 := by rw [dif_pos]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [dif_pos]",
  "core-prompt":
  "(H : âˆ€ x, x = 1) : (if h : âˆƒ (k : â„•), k = 1 then Classical.choose h else 0) = 1",
  "args": "(H : âˆ€ x, x = 1)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (_delete_this_dep : delete_this = delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(delete_this : Nat)  (_delete_this_dep : delete_this = delete_this) : Nat",
  "args":
  "(delete_this : Nat)  (_delete_this_dep : delete_this = delete_this)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [delete_this : Inhabited Nat] : Inhabited Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "[delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2) : Nat := by clear! delete_this delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : Nat)  (_delete_this_dep : delete_this = delete_this2)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this)"},
 {"type": "foo.rfl.toFun n = n",
  "tactic-prompt":
  "example (n : â„•) : foo.rfl.toFun n = n := by rw [foo.rfl_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo.rfl_toFun]",
  "core-prompt": "(n : â„•) : foo.rfl.toFun n = n",
  "args": "(n : â„•)"},
 {"type": "foo.rfl.invFun n = n",
  "tactic-prompt":
  "example (n : â„•) : foo.rfl.invFun n = n := by rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/",
  "core-prompt": "(n : â„•) : foo.rfl.invFun n = n",
  "args": "(n : â„•)"},
 {"type": "foo.1 = 1",
  "tactic-prompt": "example  : foo.1 = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": " : foo.1 = 1",
  "args": ""},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : â„•}  {h : 1 = a} : foo.1 = a := by rw [foo_fst]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo_fst]",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt": "example {a : â„•}  {h : 1 = a} : foo.1 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt": "example {a : â„¤}  {h : 2 = a} : foo.2 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : â„¤}  {h : 2 = a} : foo.2 = a",
  "args": "{a : â„¤}  {h : 2 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : â„•}  {h : 1 = a} : foo.1 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt":
  "example {a : â„¤}  {h : 2 = a} : foo.2 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : â„¤}  {h : 2 = a} : foo.2 = a",
  "args": "{a : â„¤}  {h : 2 = a}"},
 {"type": "(f.trans g).toFun x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z := by dsimp only [Equiv'.trans_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv'.trans_toFun]",
  "core-prompt":
  "{Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z",
  "args":
  "{Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z)"},
 {"type": "myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "tactic-prompt":
  "example (n : â„•) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n := by simp only [myNatEquiv_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [myNatEquiv_toFun]",
  "core-prompt":
  "(n : â„•) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "args": "(n : â„•)"},
 {"type": "(X âŸ¶ X) = x",
  "tactic-prompt":
  "example (X : Type u)  {x : Type u}  (h : (X â†’ X) = x) : (X âŸ¶ X) = x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(X : Type u)  {x : Type u}  (h : (X â†’ X) = x) : (X âŸ¶ X) = x",
  "args": "(X : Type u)  {x : Type u}  (h : (X â†’ X) = x)"},
 {"type": "ðŸ™ X = f",
  "tactic-prompt":
  "example (X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x) : ðŸ™ X = f := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x) : ðŸ™ X = f",
  "args": "(X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x)"},
 {"type": "f â‰« g = k",
  "tactic-prompt":
  "example (X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x) : f â‰« g = k := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt":
  "(X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x) : f â‰« g = k",
  "args":
  "(X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x)"},
 {"type": "foo = x",
  "tactic-prompt":
  "example {x : Type}  (h : â„• = x) : foo = x := by simp only [foo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_c]",
  "core-prompt": "{x : Type}  (h : â„• = x) : foo = x",
  "args": "{x : Type}  (h : â„• = x)"},
 {"type": "foo.x = x",
  "tactic-prompt":
  "example {x : â„•}  (h : (3 : â„•) = x) : foo.x = x := by simp only [foo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_x]",
  "core-prompt": "{x : â„•}  (h : (3 : â„•) = x) : foo.x = x",
  "args": "{x : â„•}  (h : (3 : â„•) = x)"},
 {"type": "voo = x",
  "tactic-prompt":
  "example {x : Type}  (h : â„• = x) : voo = x := by simp only [voo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_c]",
  "core-prompt": "{x : Type}  (h : â„• = x) : voo = x",
  "args": "{x : Type}  (h : â„• = x)"},
 {"type": "voo.x = x",
  "tactic-prompt":
  "example {x : â„•}  (h : (3 : â„•) = x) : voo.x = x := by simp only [voo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_x]",
  "core-prompt": "{x : â„•}  (h : (3 : â„•) = x) : voo.x = x",
  "args": "{x : â„•}  (h : (3 : â„•) = x)"},
 {"type": "x * - 0 âŠ† - x",
  "tactic-prompt": "example (x : â„•) : x * - 0 âŠ† - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : â„•) : x * - 0 âŠ† - x",
  "args": "(x : â„•)"},
 {"type": "x * - 0 âŠ† - x",
  "tactic-prompt": "example (x : â„•) : x * - 0 âŠ† - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : â„•) : x * - 0 âŠ† - x",
  "args": "(x : â„•)"},
 {"type": "Nat.SetPlus1.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus1.s = x := by dsimp only [Nat.SetPlus1_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus1_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus1.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus2.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus2.s = x := by dsimp only [Nat.SetPlus2_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus2_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus2.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus3.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus3.s = x := by dsimp only [Nat.SetPlus3_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus3_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus3.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "(Equiv.symm2.invFun e).toFun = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x := by dsimp only [Equiv.symm2_invFun_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv.symm2_invFun_toFun]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x)"},
 {"type": "(foo Î±).symm x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (foo Î±).symm x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (foo Î±).symm x = z",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z)"},
 {"type": "(foo2 Î±).toEquiv' x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : foo.rfl x = z) : (foo2 Î±).toEquiv' x = z := by dsimp only [foo2_toEquiv']; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [foo2_toEquiv']",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : foo.rfl x = z) : (foo2 Î±).toEquiv' x = z",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : foo.rfl x = z)"},
 {"type": "(foo2 Î±).toEquiv' x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (foo2 Î±).toEquiv' x = z := by dsimp only [foo2_apply]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [foo2_apply]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (foo2 Î±).toEquiv' x = z",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z)"},
 {"type": "foo2 Î± x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : foo2 Î± x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : foo2 Î± x = z",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z)"},
 {"type": "(ffoo Î±).symm x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (ffoo Î±).symm x = z := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z) : (ffoo Î±).symm x = z",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x z : Î±)  (h : x = z)"},
 {"type": "(fffoo Î±).symm x = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x : Î±) : (fffoo Î±).symm x = x := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x : Î±) : (fffoo Î±).symm x = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _}  {Î± : Type}  (x : Î±)"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type}  [Nonempty Î±] : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": "{Î± : Type}  [Nonempty Î±] : Inhabited Î±",
  "args": "{Î± : Type}  [Nonempty Î±]"},
 {"type": "Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type 3}  [Nonempty Î±] : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": "{Î± : Type 3}  [Nonempty Î±] : Inhabited Î±",
  "args": "{Î± : Type 3}  [Nonempty Î±]"},
 {"type": "Nonempty Î± â†’ Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type} : Nonempty Î± â†’ Inhabited Î± := by intro nonempty_Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro nonempty_Î±",
  "core-prompt": "{Î± : Type} : Nonempty Î± â†’ Inhabited Î±",
  "args": "{Î± : Type}"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p_inhabited : p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p_inhabited : p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Unique Î±",
  "tactic-prompt":
  "example {Î± : Sort u}  [Subsingleton Î±]  [Nonempty Î±] : Unique Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": "{Î± : Sort u}  [Subsingleton Î±]  [Nonempty Î±] : Unique Î±",
  "args": "{Î± : Sort u}  [Subsingleton Î±]  [Nonempty Î±]"},
 {"type": "Inhabited Î±",
  "tactic-prompt": "example  : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": " : Inhabited Î±",
  "args": ""},
 {"type": "a = (a + 0)",
  "tactic-prompt":
  "example [AddZeroClass G]  {a : G}  (h : a = a) : a = (a + 0) := by nth_rewrite 2 [â†add_zero a] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nth_rewrite 2 [â†add_zero a] at h",
  "core-prompt": "[AddZeroClass G]  {a : G}  (h : a = a) : a = (a + 0)",
  "args": "[AddZeroClass G]  {a : G}  (h : a = a)"},
 {"type": "a + a = a + (a + 0)",
  "tactic-prompt":
  "example [AddZeroClass G]  {a : G} : a + a = a + (a + 0) := by nth_rw 2 [â†add_zero a]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "nth_rw 2 [â†add_zero a]",
  "core-prompt": "[AddZeroClass G]  {a : G} : a + a = a + (a + 0)",
  "args": "[AddZeroClass G]  {a : G}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by type_check Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "type_check Nat",
  "core-prompt": " : True",
  "args": ""},
 {"type": "(an : â„¤) = bn â†’ an = bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) = bn â†’ an = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) = bn â†’ an = bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "an = bn â†’ (an : â„¤) = bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : an = bn â†’ (an : â„¤) = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : an = bn â†’ (an : â„¤) = bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) < bn â†” an < bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) < bn â†” an < bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) < bn â†” an < bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "az > (1 : â„•) â†” az > 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (1 : â„•) â†” az > 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (1 : â„•) â†” az > 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "az > (0 : â„•) â†” az > 0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (0 : â„•) â†” az > 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (0 : â„•) â†” az > 0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) â‰  0 â†” an â‰  0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  0 â†” an â‰  0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  0 â†” an â‰  0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) + bn = (an + bn : â„•)",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) + bn = (an + bn : â„•) := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) + bn = (an + bn : â„•)",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "True",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an + bn : â„•) : â„¤) = (an : â„¤) + (bn : â„¤)) : True := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an + bn : â„•) : â„¤) = (an : â„¤) + (bn : â„¤)) : True",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an + bn : â„•) : â„¤) = (an : â„¤) + (bn : â„¤))"},
 {"type": "True",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an * bn : â„•) : â„¤) = (an : â„¤) * (bn : â„¤)) : True := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an * bn : â„•) : â„¤) = (an : â„¤) * (bn : â„¤)) : True",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : ((an * bn : â„•) : â„¤) = (an : â„¤) * (bn : â„¤))"},
 {"type": "((42 : â„•) : â„¤) = 42",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : ((42 : â„•) : â„¤) = 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : ((42 : â„•) : â„¤) = 42",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "p 42",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : p 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : p 42",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "an - bn = 1 â†” (an - bn : â„¤) = 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an) : an - bn = 1 â†” (an - bn : â„¤) = 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an) : an - bn = 1 â†” (an - bn : â„¤) = 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an)"},
 {"type": "x * y = 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1) : x * y = 1 := by exact_mod_cast h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "exact_mod_cast h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1) : x * y = 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1)"},
 {"type":
  "(x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k)",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•} : (x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k) := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•} : (x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k)",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}"},
 {"type": "x + y + k = 0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0) : x + y + k = 0 := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0) : x + y + k = 0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0)"},
 {"type": "((a + b : â„•) : â„¤) = 10",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10) : ((a + b : â„•) : â„¤) = 10 := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10) : ((a + b : â„•) : â„¤) = 10",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10)"},
 {"type": "true âˆ§ true",
  "tactic-prompt":
  "lemma (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true) : true âˆ§ true := by constructor; sorry",
  "name": "b",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true) : true âˆ§ true",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by cases' x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³) : True := by cases' h: x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x with a b",
  "core-prompt": "{Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³) : True",
  "args": "{Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : â„•) : True := by cases' h: x using my_rec with y; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x using my_rec with y",
  "core-prompt": "(x : â„•) : True",
  "args": "(x : â„•)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo Î± Î²) : True := by cases' x with aâ‚€ aâ‚ _ aâ‚‚ bâ‚‚ câ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with aâ‚€ aâ‚ _ aâ‚‚ bâ‚‚ câ‚‚",
  "core-prompt": "(x : Foo Î± Î²) : True",
  "args": "(x : Foo Î± Î²)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Bar 0) : True := by cases' x with a b c d h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b c d h",
  "core-prompt": "(x : Bar 0) : True",
  "args": "(x : Bar 0)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' n with n ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat)  (h : n < 5) : n = n := by induction' n with n ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : Nat)  (h : n < 5) : n = n",
  "args": "(n : Nat)  (h : n < 5)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' e : n with m ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' e : n with m ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "n = n",
  "tactic-prompt":
  "example (n : Nat) : n = n := by induction' e : n using my_rec with m ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' e : n using my_rec with m ih",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo Î± Nat) : True := by induction' x with a a' b' a'' b'' c'' ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a a' b' a'' b'' c'' ih",
  "core-prompt": "(x : Foo Î± Nat) : True",
  "args": "(x : Foo Î± Nat)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Bar n) : x = x := by induction' x with a b c d h ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a b c d h ih",
  "core-prompt": "(x : Bar n) : x = x",
  "args": "(x : Bar n)"},
 {"type": "3 < 4",
  "tactic-prompt": "example  : 3 < 4 := by recover decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover decide",
  "core-prompt": " : 3 < 4",
  "args": ""},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by recover skip ; rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip ; rfl",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "2 = 2",
  "tactic-prompt": "example  : 2 = 2 := by recover skip; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip",
  "core-prompt": " : 2 = 2",
  "args": ""},
 {"type": "p âˆ§ p",
  "tactic-prompt":
  "example (p q r : Prop) (h : p âˆ§ q âˆ¨ p âˆ§ r) : p âˆ§ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) (h : p âˆ§ q âˆ¨ p âˆ§ r) : p âˆ§ p",
  "args": "(p q r : Prop) (h : p âˆ§ q âˆ¨ p âˆ§ r)"},
 {"type": "âˆƒ x, p x",
  "tactic-prompt":
  "example (Î± : Type) (p q r : Î± â†’ Prop) (h : (âˆƒ x, p x âˆ§ q x) âˆ¨ (âˆƒ x, p x âˆ§ r x)) : âˆƒ x, p x := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(Î± : Type) (p q r : Î± â†’ Prop) (h : (âˆƒ x, p x âˆ§ q x) âˆ¨ (âˆƒ x, p x âˆ§ r x)) : âˆƒ x, p x",
  "args":
  "(Î± : Type) (p q r : Î± â†’ Prop) (h : (âˆƒ x, p x âˆ§ q x) âˆ¨ (âˆƒ x, p x âˆ§ r x))"},
 {"type": "âˆƒ x, r x",
  "tactic-prompt":
  "example (Î± : Type) (x : Î±) (p q r : Î± â†’ Prop) (hâ‚€ : (âˆ€ x, p x â†’ q x â†’ r x) âˆ¨ r x) (hâ‚ : p x) (hâ‚‚ : q x) : âˆƒ x, r x := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(Î± : Type) (x : Î±) (p q r : Î± â†’ Prop) (hâ‚€ : (âˆ€ x, p x â†’ q x â†’ r x) âˆ¨ r x) (hâ‚ : p x) (hâ‚‚ : q x) : âˆƒ x, r x",
  "args":
  "(Î± : Type) (x : Î±) (p q r : Î± â†’ Prop) (hâ‚€ : (âˆ€ x, p x â†’ q x â†’ r x) âˆ¨ r x) (hâ‚ : p x) (hâ‚‚ : q x)"},
 {"type": "p âˆ§ True â†” p",
  "tactic-prompt": "example (p : Prop) : p âˆ§ True â†” p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p âˆ§ True â†” p",
  "args": "(p : Prop)"},
 {"type": "p âˆ¨ False â†” p",
  "tactic-prompt": "example (p : Prop) : p âˆ¨ False â†” p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p âˆ¨ False â†” p",
  "args": "(p : Prop)"},
 {"type": "Â¬ p â†” q",
  "tactic-prompt":
  "example (p q : Prop)  (h : p â‰  q) : Â¬ p â†” q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : p â‰  q) : Â¬ p â†” q",
  "args": "(p q : Prop)  (h : p â‰  q)"},
 {"type": "Â¬ p â†” q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ p = q) : Â¬ p â†” q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : Â¬ p = q) : Â¬ p â†” q",
  "args": "(p q : Prop)  (h : Â¬ p = q)"},
 {"type": "p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r)",
  "tactic-prompt":
  "example (p q r : Prop) : p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) : p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r)",
  "args": "(p q r : Prop)"},
 {"type": "p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r)",
  "tactic-prompt":
  "example (p q r : Prop) : p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop) : p âˆ¨ (q âˆ§ r) â†” (p âˆ¨ q) âˆ§ (r âˆ¨ p âˆ¨ r)",
  "args": "(p q r : Prop)"},
 {"type": "q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ p) : q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ p) : q",
  "args": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ p)"},
 {"type": "Â¬ q",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ (p â†” q))  (h' : p) : Â¬ q := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : p) : Â¬ q",
  "args": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : p)"},
 {"type": "Â¬ p",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ (p â†” q))  (h' : q) : Â¬ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : q) : Â¬ p",
  "args": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : q)"},
 {"type": "p",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q) : p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q) : p",
  "args": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q)"},
 {"type": "False",
  "tactic-prompt":
  "example (p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q)  (h'' : Â¬ p) : False := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q)  (h'' : Â¬ p) : False",
  "args": "(p q : Prop)  (h : Â¬ (p â†” q))  (h' : Â¬ q)  (h'' : Â¬ p)"},
 {"type": "Â¬ p",
  "tactic-prompt":
  "example (p q r : Prop)  (h : p â†” q)  (h' : r â†” q)  (h'' : Â¬ r) : Â¬ p := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : p â†” q)  (h' : r â†” q)  (h'' : Â¬ r) : Â¬ p",
  "args": "(p q r : Prop)  (h : p â†” q)  (h' : r â†” q)  (h'' : Â¬ r)"},
 {"type": "p â†” r",
  "tactic-prompt":
  "example (p q r : Prop)  (h : p â†” q)  (h' : r â†” q) : p â†” r := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : p â†” q)  (h' : r â†” q) : p â†” r",
  "args": "(p q r : Prop)  (h : p â†” q)  (h' : r â†” q)"},
 {"type": "p â†” Â¬ r",
  "tactic-prompt":
  "example (p q r : Prop)  (h : Â¬ p = q)  (h' : r = q) : p â†” Â¬ r := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p q r : Prop)  (h : Â¬ p = q)  (h' : r = q) : p â†” Â¬ r",
  "args": "(p q r : Prop)  (h : Â¬ p = q)  (h' : r = q)"},
 {"type": "p â†’ Â¬ (p â†’ Â¬ p)",
  "tactic-prompt": "example (p : Prop) : p â†’ Â¬ (p â†’ Â¬ p) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop) : p â†’ Â¬ (p â†’ Â¬ p)",
  "args": "(p : Prop)"},
 {"type": "Â¬ (p â†” Â¬ p)",
  "tactic-prompt":
  "example (p : Prop)  (em : p âˆ¨ Â¬ p) : Â¬ (p â†” Â¬ p) := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "(p : Prop)  (em : p âˆ¨ Â¬ p) : Â¬ (p â†” Â¬ p)",
  "args": "(p : Prop)  (em : p âˆ¨ Â¬ p)"},
 {"type": "P n â†’ n = 7 âˆ¨ n = 0 âˆ¨ Â¬ (n = 7 âˆ¨ n = 0) âˆ§ P n",
  "tactic-prompt":
  "example (P : Nat â†’ Prop)  (n : Nat) : P n â†’ n = 7 âˆ¨ n = 0 âˆ¨ Â¬ (n = 7 âˆ¨ n = 0) âˆ§ P n := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt":
  "(P : Nat â†’ Prop)  (n : Nat) : P n â†’ n = 7 âˆ¨ n = 0 âˆ¨ Â¬ (n = 7 âˆ¨ n = 0) âˆ§ P n",
  "args": "(P : Nat â†’ Prop)  (n : Nat)"},
 {"type": "x = y",
  "tactic-prompt":
  "example {x y : Nat}  (h : Â¬x â‰  y) : x = y := by tauto; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "tauto",
  "core-prompt": "{x y : Nat}  (h : Â¬x â‰  y) : x = y",
  "args": "{x y : Nat}  (h : Â¬x â‰  y)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination 1 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * h1",
  "core-prompt": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination h1",
  "core-prompt": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "2 * x + 4 = -6",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x + 2 = -3)  (_h2 : y = 10) : 2 * x + 4 = -6 := by linear_combination 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1",
  "core-prompt":
  "(x y : â„¤)  (h1 : x + 2 = -3)  (_h2 : y = 10) : 2 * x + 4 = -6",
  "args": "(x y : â„¤)  (h1 : x + 2 = -3)  (_h2 : y = 10)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination 1 * h1 - 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * h1 - 2 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination -2 * h2 + h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -2 * h2 + h1",
  "core-prompt":
  "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "2 * x + 4 - y = -16",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : 2 * x + 4 - y = -16 := by linear_combination 2 * h1 + -1 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 + -1 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : 2 * x + 4 - y = -16",
  "args": "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "-y + 2 * x + 4 = -16",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16 := by linear_combination -h2 + 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -h2 + 2 * h1",
  "core-prompt":
  "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16",
  "args": "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "11 * y = -11",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : 11 * y = -11 := by linear_combination -2 * h1 + 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination -2 * h1 + 3 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : 11 * y = -11",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y = 11",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y = 11 + 1 - 1",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 + 1 - 1 := by linear_combination 2 * h1 + -3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 + -3 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y = 11 + 1 - 1",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "11 + 1 - 1 = -11 * y",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y) : 11 + 1 - 1 = -11 * y := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y) : 11 + 1 - 1 = -11 * y",
  "args": "(x y : â„¤)  (h1 : 10 = 3 * x + 2 * y)  (h2 : 3 = 2 * x + 5 * y)"},
 {"type": "-y + 2 * x + 4 = -16",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16 := by linear_combination 2 * h1 - h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10) : -y + 2 * x + 4 = -16",
  "args": "(x y : â„¤)  (h1 : x + 2 = -3)  (h2 : y = 10)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-3 * x - 3 * y - 4 * z = 2",
  "tactic-prompt":
  "example (x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : -3 * x - 3 * y - 4 * z = 2 := by linear_combination ha - hb - 2 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination ha - hb - 2 * hc",
  "core-prompt":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : -3 * x - 3 * y - 4 * z = 2",
  "args":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "6 * x = -10",
  "tactic-prompt":
  "example (x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 6 * x = -10 := by linear_combination 1 * ha + 4 * hb - 3 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 1 * ha + 4 * hb - 3 * hc",
  "core-prompt":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 6 * x = -10",
  "args":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "10 = 6 * -x",
  "tactic-prompt":
  "example (x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 10 = 6 * -x := by linear_combination ha + 4 * hb - 3 * hc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination ha + 4 * hb - 3 * hc",
  "core-prompt":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2) : 10 = 6 * -x",
  "args":
  "(x y z : â„)  (ha : x + 2 * y - z = 4)  (hb : 2 * x + y + z = -2)  (hc : x + 2 * y + z = 2)"},
 {"type": "2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a",
  "tactic-prompt":
  "example (a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a := by linear_combination 2 * h1 - 1 * h2 + 3 * h3 - 3 * h4; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h1 - 1 * h2 + 3 * h3 - 3 * h4",
  "core-prompt":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 2 * a - 3 + 9 * c + 3 * d = 8 - b + 3 * d - 3 * a",
  "args":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "tactic-prompt":
  "example (a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a := by linear_combination 2 * h2 - h3 + 3 * h1 - 3 * h4; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 2 * h2 - h3 + 3 * h1 - 3 * h4",
  "core-prompt":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "args":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "3 * a + qc = 3 * b + 2 * qc",
  "tactic-prompt":
  "example (a b : â„š)  (h : âˆ€ p q : â„š, p = q) : 3 * a + qc = 3 * b + 2 * qc := by linear_combination 3 * h a b + hqc; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination 3 * h a b + hqc",
  "core-prompt":
  "(a b : â„š)  (h : âˆ€ p q : â„š, p = q) : 3 * a + qc = 3 * b + 2 * qc",
  "args": "(a b : â„š)  (h : âˆ€ p q : â„š, p = q)"},
 {"type": "a + b ^ 3 = 0",
  "tactic-prompt":
  "example (a b : â„š) : a + b ^ 3 = 0 := by linear_combination bad a + b * bad (b * b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination bad a + b * bad (b * b)",
  "core-prompt": "(a b : â„š) : a + b ^ 3 = 0",
  "args": "(a b : â„š)"},
 {"type": "a * a = a * b",
  "tactic-prompt":
  "example (a b : â„¤)  (h : a = b) : a * a = a * b := by linear_combination a * h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination a * h",
  "core-prompt": "(a b : â„¤)  (h : a = b) : a * a = a * b",
  "args": "(a b : â„¤)  (h : a = b)"},
 {"type": "a * c = b * c",
  "tactic-prompt":
  "example (a b c : â„¤)  (h : a = b) : a * c = b * c := by linear_combination c * h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination c * h",
  "core-prompt": "(a b c : â„¤)  (h : a = b) : a * c = b * c",
  "args": "(a b c : â„¤)  (h : a = b)"},
 {"type": "c * a + b = c * b + 1",
  "tactic-prompt":
  "example (a b c : â„¤)  (h1 : a = b)  (h2 : b = 1) : c * a + b = c * b + 1 := by linear_combination c * h1 + h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination c * h1 + h2",
  "core-prompt":
  "(a b c : â„¤)  (h1 : a = b)  (h2 : b = 1) : c * a + b = c * b + 1",
  "args": "(a b c : â„¤)  (h1 : a = b)  (h2 : b = 1)"},
 {"type": "x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "tactic-prompt":
  "example (x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14 := by linear_combination x * y * h1 + 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination x * y * h1 + 2 * h2",
  "core-prompt":
  "(x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "args": "(x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7)"},
 {"type": "x * z + 2 * y * z = x * w + 2 * y * w",
  "tactic-prompt":
  "example (x y z w : â„š)  (hzw : z = w) : x * z + 2 * y * z = x * w + 2 * y * w := by linear_combination (x + 2 * y) * hzw; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (x + 2 * y) * hzw",
  "core-prompt":
  "(x y z w : â„š)  (hzw : z = w) : x * z + 2 * y * z = x * w + 2 * y * w",
  "args": "(x y z w : â„š)  (hzw : z = w)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination (norm := ring) 2 * h1 - 3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring) 2 * h1 - 3 * h2",
  "core-prompt":
  "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "-11 * y + 1 = 11 + 1",
  "tactic-prompt":
  "example (x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1 := by linear_combination (norm := ring1) 2 * h1 + -3 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring1) 2 * h1 + -3 * h2",
  "core-prompt":
  "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3) : -11 * y + 1 = 11 + 1",
  "args": "(x y : â„š)  (h1 : 3 * x + 2 * y = 10)  (h2 : 2 * x + 5 * y = 3)"},
 {"type": "3 * x + 2 * y = 10",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10 := by linear_combination (norm := simp) h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := simp) h1",
  "core-prompt": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10) : 3 * x + 2 * y = 10",
  "args": "(x y : â„¤)  (h1 : 3 * x + 2 * y = 10)"},
 {"type": "2 * x = -6",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x = -3)  (_h2 : y = 10) : 2 * x = -6 := by linear_combination (norm := skip) 2 * h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := skip) 2 * h1",
  "core-prompt": "(x y : â„¤)  (h1 : x = -3)  (_h2 : y = 10) : 2 * x = -6",
  "args": "(x y : â„¤)  (h1 : x = -3)  (_h2 : y = 10)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z := by linear_combination; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination",
  "core-prompt":
  "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z := by linear_combination (norm := skip); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := skip)",
  "core-prompt":
  "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1)"},
 {"type": "z + w = w + z",
  "tactic-prompt":
  "example {x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z := by linear_combination (norm := simp [add_comm]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := simp [add_comm])",
  "core-prompt":
  "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1) : z + w = w + z",
  "args": "{x y z w : â„¤}  (_hâ‚ : 3 * x = 4 + y)  (_hâ‚‚ : x + 2 * y = 1)"},
 {"type": "x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "tactic-prompt":
  "example (x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14 := by linear_combination (norm := ring_nf) x * y * h1 + h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf) x * y * h1 + h2",
  "core-prompt":
  "(x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7) : x * x * y + y * x * y + 6 * x = 3 * x * y + 14",
  "args": "(x y : â„š)  (h1 : x + y = 3)  (h2 : 3 * x = 7)"},
 {"type": "6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "tactic-prompt":
  "example (a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a := by linear_combination (norm := ring_nf) 2 * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf) 2 * h2",
  "core-prompt":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a) : 6 - 3 * c + 3 * a + 3 * d = 2 * b - d + 12 - 3 * a",
  "args":
  "(a b c d : â„š)  (h1 : a = 4)  (h2 : 3 = b)  (h3 : c * 3 = d)  (h4 : -d = a)"},
 {"type": "x * y = -2 * y + 1",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1 := by linear_combination (norm := ring_nf); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "linear_combination (norm := ring_nf)",
  "core-prompt":
  "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y = -2 * y + 1",
  "args": "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "x * y + 2 * x = 1",
  "tactic-prompt":
  "example (x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y + 2 * x = 1 := by fail_if_success linear_combination h1 + (0 : â„) * h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination h1 + (0 : â„) * h2",
  "core-prompt":
  "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y) : x * y + 2 * x = 1",
  "args": "(x y : â„¤)  (h1 : x * y + 2 * x = 1)  (h2 : x = y)"},
 {"type": "a = 3",
  "tactic-prompt":
  "example (a _b : â„•)  (h1 : a = 3) : a = 3 := by fail_if_success linear_combination h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination h1",
  "core-prompt": "(a _b : â„•)  (h1 : a = 3) : a = 3",
  "args": "(a _b : â„•)  (h1 : a = 3)"},
 {"type": "2 * x = 2 * y",
  "tactic-prompt":
  "example (a b : â„¤)  (x y : â„)  (hab : a = b)  (hxy : x = y) : 2 * x = 2 * y := by fail_if_success linear_combination 2 * hab; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success linear_combination 2 * hab",
  "core-prompt":
  "(a b : â„¤)  (x y : â„)  (hab : a = b)  (hxy : x = y) : 2 * x = 2 * y",
  "args": "(a b : â„¤)  (x y : â„)  (hab : a = b)  (hxy : x = y)"},
 {"type": "x + y = y + x",
  "tactic-prompt": "example (x y : â„•) : x + y = y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„•) : x + y = y + x",
  "args": "(x y : â„•)"},
 {"type": "x + y + y = 2 * y + x",
  "tactic-prompt":
  "example (x y : â„•) : x + y + y = 2 * y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„•) : x + y + y = 2 * y + x",
  "args": "(x y : â„•)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : â„•) : x + id y = y + id x := by ring!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring!",
  "core-prompt": "(x y : â„•) : x + id y = y + id x",
  "args": "(x y : â„•)"},
 {"type": "x / 2 + x / 2 = x",
  "tactic-prompt": "example (x y : â„š) : x / 2 + x / 2 = x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„š) : x / 2 + x / 2 = x",
  "args": "(x y : â„š)"},
 {"type": "(x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "tactic-prompt":
  "example (x y : â„•) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(x y : â„•) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "args": "(x y : â„•)"},
 {"type": "(n / 2) + (n / 2) = 2 * (n / 2)",
  "tactic-prompt":
  "example (n : â„•) : (n / 2) + (n / 2) = 2 * (n / 2) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : â„•) : (n / 2) + (n / 2) = 2 * (n / 2)",
  "args": "(n : â„•)"},
 {"type": "a * (n - s) = (n - s) * a",
  "tactic-prompt":
  "example (a n s: â„•) : a * (n - s) = (n - s) * a := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(a n s: â„•) : a * (n - s) = (n - s) * a",
  "args": "(a n s: â„•)"},
 {"type": "(2 * A) ^ 2 = (2 * A) ^ 2",
  "tactic-prompt":
  "example (A : â„•) : (2 * A) ^ 2 = (2 * A) ^ 2 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(A : â„•) : (2 * A) ^ 2 = (2 * A) ^ 2",
  "args": "(A : â„•)"},
 {"type": "(876544 : â„¤) * -1 + (1000000 - 123456) = 0",
  "tactic-prompt":
  "example  : (876544 : â„¤) * -1 + (1000000 - 123456) = 0 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": " : (876544 : â„¤) * -1 + (1000000 - 123456) = 0",
  "args": ""},
 {"type": "A * B = 2",
  "tactic-prompt":
  "example (A B : â„•)  (H : B * A = 2) : A * B = 2 := by ring_nf at H âŠ¢; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring_nf at H âŠ¢",
  "core-prompt": "(A B : â„•)  (H : B * A = 2) : A * B = 2",
  "args": "(A B : â„•)  (H : B * A = 2)"},
 {"type":
  "2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1)",
  "tactic-prompt":
  "example (f : â„• â†’ â„•) : 2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1) := by ring_nf; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring_nf",
  "core-prompt":
  "(f : â„• â†’ â„•) : 2 + f (2 * f 3 * f 3) + f 3 = 1 + f (f 3 ^ 2 + f 3 * f 3) + 1 + f (2 + 1)",
  "args": "(f : â„• â†’ â„•)"},
 {"type": "2^(n+1) * m = 2 * 2^n * m",
  "tactic-prompt":
  "example (n : â„•)  (m : â„¤) : 2^(n+1) * m = 2 * 2^n * m := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : â„•)  (m : â„¤) : 2^(n+1) * m = 2 * 2^n * m",
  "args": "(n : â„•)  (m : â„¤)"},
 {"type": "(a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n",
  "tactic-prompt":
  "example (a b : â„¤)  (n : â„•) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(a b : â„¤)  (n : â„•) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n",
  "args": "(a b : â„¤)  (n : â„•)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : â„•) : x + id y = y + id x := by ring!; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring!",
  "core-prompt": "(x y : â„•) : x + id y = y + id x",
  "args": "(x y : â„•)"},
 {"type": "22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46",
  "tactic-prompt":
  "example  : 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46 := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": " : 22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 46",
  "args": ""},
 {"type": "(22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75)",
  "tactic-prompt":
  "example  : (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75) := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": " : (22 + 7 * 4 + 3 * 8 = 0 + 7 * 4 + 47) = (74 = 75)",
  "args": ""},
 {"type": "22 + 7 * x + 3 * 8 = 0 + 7 * x + 46",
  "tactic-prompt":
  "example (x : â„•) : 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt": "(x : â„•) : 22 + 7 * x + 3 * 8 = 0 + 7 * x + 46",
  "args": "(x : â„•)"},
 {"type":
  "(22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47)",
  "tactic-prompt":
  "example (x : â„•) : (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47) := by conv => ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "conv => ring",
  "core-prompt":
  "(x : â„•) : (22 + 7 * x + 3 * 8 = 0 + 7 * x + 46 + 1)\n                    = (7 * x + 46 = 7 * x + 47)",
  "args": "(x : â„•)"},
 {"type": "nleq a b â†’ nleq b c â†’ nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "nleq a b â†’ nleq b c â†’ nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "def {a b c : Î±} : a = b â†’ b = c â†’ a = c := by intro hâ‚ hâ‚‚; sorry",
  "name": "eq_trans",
  "kind": "def",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "{a b c : Î±} : a = b â†’ b = c â†’ a = c",
  "args": "{a b c : Î±}"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b â†’ b = c â†’ a = c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a = b â†’ b = c â†’ a = c",
  "args": "(a b c : Nat)"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b â†’ b = c â†’ a = c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a = b â†’ b = c â†’ a = c",
  "args": "(a b c : Nat)"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "R a b â†’ R b c â†’ R a c",
  "tactic-prompt":
  "example (a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R] : R a b â†’ R b c â†’ R a c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt":
  "(a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R] : R a b â†’ R b c â†’ R a c",
  "args": "(a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R]"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "a < b â†’ b < c â†’ a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b â†’ b < c â†’ a < c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a < b â†’ b < c â†’ a < c",
  "args": "(a b c : Nat)"},
 {"type": "a < b â†’ b < c â†’ a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b â†’ b < c â†’ a < c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a < b â†’ b < c â†’ a < c",
  "args": "(a b c : Nat)"},
 {"type": "n * p â‰¤ x",
  "tactic-prompt":
  "example (x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x) : n * p â‰¤ x := by trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trans",
  "core-prompt": "(x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x) : n * p â‰¤ x",
  "args": "(x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x)"},
 {"type": "âˆ€ b : Î², HEq a b â†’ HEq b c â†’ HEq a c",
  "tactic-prompt":
  "example (a : Î±) (c : Î³) : âˆ€ b : Î², HEq a b â†’ HEq b c â†’ HEq a c := by intro b hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro b hâ‚ hâ‚‚",
  "core-prompt": "(a : Î±) (c : Î³) : âˆ€ b : Î², HEq a b â†’ HEq b c â†’ HEq a c",
  "args": "(a : Î±) (c : Î³)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x = x) : x = x := by set! p := h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! p := h",
  "core-prompt": "(x : Nat)  (h : x = x) : x = x",
  "args": "(x : Nat)  (h : x = x)"},
 {"type": "x + x - x = 3",
  "tactic-prompt":
  "example (x : Nat)  (h : x + x - x = 3) : x + x - x = 3 := by set! y := x with â† h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! y := x with â† h2",
  "core-prompt": "(x : Nat)  (h : x + x - x = 3) : x + x - x = 3",
  "args": "(x : Nat)  (h : x + x - x = 3)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x - x = 0) : x = x := by set y : Nat := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set y : Nat := x",
  "core-prompt": "(x : Nat)  (h : x - x = 0) : x = x",
  "args": "(x : Nat)  (h : x - x = 0)"},
 {"type": "(Î» (x y : Nat) => x + y) = (Î» x y => y + x)",
  "tactic-prompt":
  "example  : (Î» (x y : Nat) => x + y) = (Î» x y => y + x) := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": " : (Î» (x y : Nat) => x + y) = (Î» x y => y + x)",
  "args": ""},
 {"type": "a = c",
  "tactic-prompt":
  "example (f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c := by simp_rw [â† ha]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [â† ha]",
  "core-prompt":
  "(f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c",
  "args": "(f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c)"},
 {"type": "a + (b + (c + d)) = ((d + c) + b) + a",
  "tactic-prompt":
  "example (a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": "(a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a",
  "args": "(a b c d : Nat)"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h",
  "core-prompt": "(p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b))"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at hâ‚ hâ‚‚",
  "core-prompt":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (b + a)",
  "args":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b))"},
 {"type": "p (a + b)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (a + b) := by simp_rw [Nat.add_comm a b] at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at *",
  "core-prompt":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (a + b)",
  "args":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b))"},
 {"type": "(âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1",
  "tactic-prompt":
  "example {a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b) : (âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1 := by simp_rw [h1]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [h1]",
  "core-prompt":
  "{a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b) : (âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1",
  "args":
  "{a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b)"},
 {"type": "p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "tactic-prompt":
  "example (p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "args": "(p q r : Prop)"},
 {"type": "p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "tactic-prompt":
  "example (p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r := by intros a b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b c",
  "core-prompt": "(p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "args": "(p q r : Prop)"},
 {"type": "p â†’ q â†’ p âˆ§ q",
  "tactic-prompt":
  "example (p q : Prop) : p â†’ q â†’ p âˆ§ q := by intros a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b",
  "core-prompt": "(p q : Prop) : p â†’ q â†’ p âˆ§ q",
  "args": "(p q : Prop)"},
 {"type": "p â†’ p",
  "tactic-prompt": "example (p : Prop) : p â†’ p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p : Prop) : p â†’ p",
  "args": "(p : Prop)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Int) : Nat := by replace h : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Nat := 0",
  "core-prompt": "(h : Int) : Nat",
  "args": "(h : Int)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by have h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by replace h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Int := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt":
  "example {a : Nat} : a = a := by replace a : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace a : Int := 0",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "Nat",
  "tactic-prompt": "example (z : Int) : Nat := by replace z : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace z : Nat",
  "core-prompt": "(z : Int) : Nat",
  "args": "(z : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by have : 1 + 1 = 2 := by simp_arith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : 1 + 1 = 2 := by simp_arith",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have h : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have h : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by (let _N); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(let _N)",
  "core-prompt": " : True",
  "args": ""},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "tactic-prompt":
  "example  : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by use 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42, 42",
  "core-prompt": " : âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "args": ""},
 {"type": "âˆƒ x : String Ã— String, x.1 = x.2",
  "tactic-prompt":
  "example  : âˆƒ x : String Ã— String, x.1 = x.2 := by use (\"a\", \"a\"); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use (\"a\", \"a\")",
  "core-prompt": " : âˆƒ x : String Ã— String, x.1 = x.2",
  "args": ""},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by use ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ?_",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ S : List Î±, S = S",
  "tactic-prompt":
  "example (Î± : Type) : âˆƒ S : List Î±, S = S := by use âˆ…; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use âˆ…",
  "core-prompt": "(Î± : Type) : âˆƒ S : List Î±, S = S",
  "args": "(Î± : Type)"},
 {"type": "âˆƒ x : Int, x = x",
  "tactic-prompt": "example  : âˆƒ x : Int, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : âˆƒ x : Int, x = x",
  "args": ""},
 {"type": "âˆƒ a b c : Int, a + b + c = 6",
  "tactic-prompt":
  "example  : âˆƒ a b c : Int, a + b + c = 6 := by use 1, 2, 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 1, 2, 3",
  "core-prompt": " : âˆƒ a b c : Int, a + b + c = 6",
  "args": ""},
 {"type": "âˆƒ p : Int Ã— Int, p.1 = 1",
  "tactic-prompt":
  "example  : âˆƒ p : Int Ã— Int, p.1 = 1 := by use âŸ¨1, 42âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use âŸ¨1, 42âŸ©",
  "core-prompt": " : âˆƒ p : Int Ã— Int, p.1 = 1",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example (a : Nat) : a = a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "(a : Nat) : a = a",
  "args": "(a : Nat)"},
 {"type": "a â‰ˆ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Î±) : a â‰ˆ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Î±) : a â‰ˆ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Î±)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a := by (fail_if_success rfl); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(fail_if_success rfl)",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Nat)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Nat)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a := by apply Foo.le_refl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Foo.le_refl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Foo)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Foo)"},
 {"type": "0 â‰¤ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/"},
 {"type": "0 â‰¤ 3",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 3 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 3",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/"},
 {"type": "0 < 3",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 < 3 := by positivity\n\n/- ## Goals working directly from a hypothesis -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/- ## Goals working directly from a hypothesis -/",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 < 3",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 < a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0) : 0 â‰¤ a := by positivity\n\n/- ### Reversing hypotheses -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity\n\n/- ### Reversing hypotheses -/",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 < a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰¥ 0) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰¥ 0) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰¥ 0)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰  a) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰  a) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰  a)"},
 {"type": "a > 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a > 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a > 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰¥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "0 â‰  a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 â‰  a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : 0 â‰  a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a) : a â‰¥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 â‰¤ a)"},
 {"type": "0 â‰  a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0) : 0 â‰  a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0) : 0 â‰  a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a â‰  0)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0) : a â‰¥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = 0)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a) : a â‰¥ 0 := by positivity\n\n/- ### Calling `norm_num` -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity\n\n/- ### Calling `norm_num` -/",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 = a)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a) : 0 < a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 = a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = -1) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = -1) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a = -1)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a) : 0 < a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 â‰¤ a)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : a â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : a â‰  0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 â‰¤ a + b",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (h : 0 â‰¤ a + b) : 0 â‰¤ a + b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (h : 0 â‰¤ a + b) : 0 â‰¤ a + b",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (h : 0 â‰¤ a + b)"},
 {"type": "0 < a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (hlt : 0 â‰¤ a)  (hne : a â‰  0) : 0 < a := by positivity\n\n/- ## Tests of the @[positivity] plugin tactics (addition]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/- ## Tests of the @[positivity] plugin tactics (addition]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (hlt : 0 â‰¤ a)  (hne : a â‰  0) : 0 < a",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (hlt : 0 â‰¤ a)  (hne : a â‰  0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : 0 â‰¤ b)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 < b) : 0 â‰¤ a * b := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 < b) : 0 â‰¤ a * b",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 < b)"},
 {"type": "a * b â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : b â‰  0) : a * b â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : b â‰  0) : a * b â‰  0",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : 0 < a)  (hb : b â‰  0)"},
 {"type": "a * b â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : 0 < b) : a * b â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : 0 < b) : a * b â‰  0",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : 0 < b)"},
 {"type": "a * b â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : b â‰  0) : a * b â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : b â‰  0) : a * b â‰  0",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„š}  (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 < a) : 0 < a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 < a) : 0 < a ^ n",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 < a)"},
 {"type": "0 â‰¤ a ^ n",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 â‰¤ a) : 0 â‰¤ a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 â‰¤ a) : 0 â‰¤ a ^ n",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : 0 â‰¤ a)"},
 {"type": "a ^ n â‰  0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : a â‰  0) : a ^ n â‰  0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : a â‰  0) : a ^ n â‰  0",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (n : â„•)  (ha : a â‰  0)"},
 {"type": "0 â‰¤ a ^ 18",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š} : 0 â‰¤ a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š} : 0 â‰¤ a ^ 18",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}"},
 {"type": "0 < a ^ 18",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (ha : a â‰  0) : 0 < a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (ha : a â‰  0) : 0 < a ^ 18",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„š}  (ha : a â‰  0)"},
 {"type": "0 â‰¤ a + a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a + a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 â‰¤ 3 + a + b + b + 14",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : 4 â‰¤ b) : 0 â‰¤ 3 + a + b + b + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : 4 â‰¤ b) : 0 â‰¤ 3 + a + b + b + 14",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : 4 â‰¤ b)"},
 {"type": "0 < a + a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a + a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 < a ^ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  [Nontrivial Î±]  (a : Î±) : 0 < a ^ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  [Nontrivial Î±]  (a : Î±) : 0 < a ^ 0",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  [Nontrivial Î±]  (a : Î±)"},
 {"type": "0 â‰¤ a ^ 18",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [LinearOrderedRing Î±]  (a : Î±) : 0 â‰¤ a ^ 18 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [LinearOrderedRing Î±]  (a : Î±) : 0 â‰¤ a ^ 18",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [LinearOrderedRing Î±]  (a : Î±)"},
 {"type": "0 â‰¤ a ^ n",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 â‰¤ a) : 0 â‰¤ a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 â‰¤ a) : 0 â‰¤ a ^ n",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [OrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 â‰¤ a)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 < a) : 0 < a ^ n := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 < a) : 0 < a ^ n",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ [StrictOrderedSemiring Î±]  {a : Î±}  {n : â„•}  (ha : 0 < a)"},
 {"type": "0 â‰¤ a ^ 2 + a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a ^ 2 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a ^ 2 + a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 â‰¤ a ^ 3 + a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a ^ 3 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 â‰¤ a ^ 3 + a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 < a ^ 2 + a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a ^ 2 + a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a) : 0 < a ^ 2 + a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 3 < a)"},
 {"type": "0 â‰¤ 3 * a ^ 2 * b + b * 7 + 14",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4) : 0 â‰¤ 3 * a ^ 2 * b + b * 7 + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4) : 0 â‰¤ 3 * a ^ 2 * b + b * 7 + 14",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4)"},
 {"type": "0 < 3 * a ^ 2 * b + b * 7 + 14",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4) : 0 < 3 * a ^ 2 * b + b * 7 + 14 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4) : 0 < 3 * a ^ 2 * b + b * 7 + 14",
  "args":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a b : â„¤}  (ha : 3 < a)  (hb : b â‰¥ 4)"},
 {"type": "0 â‰¤ max 3 4",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ max 3 4 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ max 3 4",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„•} : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„•} : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„•}"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 â‰¤ a := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : 0 â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰¥ 0 := by positivity; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "positivity",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : 0 < a)"},
 {"type": "a â‰¥ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : a â‰¥ 0 := by positivity\n\n/-\n## Test for meta-variable instantiation\n\nReported on\nhttps://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300639970\n-/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "positivity\n\n/-\n## Test for meta-variable instantiation\n\nReported on\nhttps://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/New.20tactic.3A.20.60positivity.60/near/300639970\n-/",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0) : a â‰¥ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ {a : â„¤}  (ha : a > 0)"},
 {"type": "0 â‰¤ 0",
  "tactic-prompt":
  "example {Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 0 := by apply le_trans _ (le_refl _); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply le_trans _ (le_refl _)",
  "core-prompt": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/ : 0 â‰¤ 0",
  "args": "{Î¹ Î± Î² : Type _}  /- ## Numeric goals -/"},
 {"type": "True",
  "tactic-prompt": "example  : True := by if 1 + 1 = 2 then _ else ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if 1 + 1 = 2 then _ else ?_",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (p : Prop) : True := by if p then ?foo else trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if p then ?foo else trivial",
  "core-prompt": "(p : Prop) : True",
  "args": "(p : Prop)"},
 {"type": "unop x = unop y â†” x = y",
  "tactic-prompt":
  "theorem {x y : Î±áµáµ’áµ–} : unop x = unop y â†” x = y := by cases x; sorry",
  "name": "unop_inj",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x y : Î±áµáµ’áµ–} : unop x = unop y â†” x = y",
  "args": "{x y : Î±áµáµ’áµ–}"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : False) : P := by simp at p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp at p",
  "core-prompt": "{P : Prop}  (p : False) : P",
  "args": "{P : Prop}  (p : False)"},
 {"type": "foo n = [n]",
  "tactic-prompt": "example  : foo n = [n] := by simpa only [foo]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [foo]",
  "core-prompt": " : foo n = [n]",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (h : foo n â‰  [n]) : False := by simpa [foo] using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa [foo] using h",
  "core-prompt": "(h : foo n â‰  [n]) : False",
  "args": "(h : foo n â‰  [n])"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (h : p (a + b)) : p (b + a) := by have : a + b = b + a := Nat.add_comm _ _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a + b = b + a := Nat.add_comm _ _",
  "core-prompt": "(p : Nat â†’ Prop)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat â†’ Prop)  (h : p (a + b))"},
 {"type": "Injective fun a => a / b",
  "tactic-prompt":
  "theorem [Group G] (b : G) : Injective fun a => a / b := by simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h",
  "core-prompt": "[Group G] (b : G) : Injective fun a => a / b",
  "args": "[Group G] (b : G)"},
 {"type": "Injective (Prod.mk a : Î² â†’ Î± Ã— Î²)",
  "tactic-prompt":
  "theorem [Group G] {Î± Î² : Type _}  (a : Î±) : Injective (Prod.mk a : Î² â†’ Î± Ã— Î²) := by intro bâ‚ bâ‚‚ h; sorry",
  "name": "mk.inj_left",
  "kind": "theorem",
  "first-tactic": "intro bâ‚ bâ‚‚ h",
  "core-prompt":
  "[Group G] {Î± Î² : Type _}  (a : Î±) : Injective (Prod.mk a : Î² â†’ Î± Ã— Î²)",
  "args": "[Group G] {Î± Î² : Type _}  (a : Î±)"},
 {"type": "a = 2",
  "tactic-prompt":
  "theorem [Group G] (h : âˆ€ {x : Nat}, a = x) : a = 2 := by simpa using h; sorry",
  "name": "implicit_lambda",
  "kind": "theorem",
  "first-tactic": "simpa using h",
  "core-prompt": "[Group G] (h : âˆ€ {x : Nat}, a = x) : a = 2",
  "args": "[Group G] (h : âˆ€ {x : Nat}, a = x)"},
 {"type": "âˆ€ {x : Nat}, a = 2",
  "tactic-prompt":
  "theorem [Group G] (h : a = 2) : âˆ€ {x : Nat}, a = 2 := by simpa using h; sorry",
  "name": "implicit_lambda2",
  "kind": "theorem",
  "first-tactic": "simpa using h",
  "core-prompt": "[Group G] (h : a = 2) : âˆ€ {x : Nat}, a = 2",
  "args": "[Group G] (h : a = 2)"},
 {"type": "âˆ€ {x : Nat}, a = x",
  "tactic-prompt":
  "theorem [Group G] (h : âˆ€ {x : Nat}, a = x) : âˆ€ {x : Nat}, a = x := by simpa using @h; sorry",
  "name": "no_implicit_lambda",
  "kind": "theorem",
  "first-tactic": "simpa using @h",
  "core-prompt": "[Group G] (h : âˆ€ {x : Nat}, a = x) : âˆ€ {x : Nat}, a = x",
  "args": "[Group G] (h : âˆ€ {x : Nat}, a = x)"},
 {"type": "(b - c : Int) + (a - b) + a â‰¤ c",
  "tactic-prompt":
  "example [Group G] : (b - c : Int) + (a - b) + a â‰¤ c := by simpa only [thm] using thm2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [thm] using thm2",
  "core-prompt": "[Group G] : (b - c : Int) + (a - b) + a â‰¤ c",
  "args": "[Group G]"},
 {"type": "(b - c : Int) + (a - b) + a â‰¤ c",
  "tactic-prompt":
  "example [Group G] : (b - c : Int) + (a - b) + a â‰¤ c := by simpa only [thm] using @thm2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa only [thm] using @thm2",
  "core-prompt": "[Group G] : (b - c : Int) + (a - b) + a â‰¤ c",
  "args": "[Group G]"},
 {"type": "Nat Ã— Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat Ã— Nat := by show_term\n    constructor\n    exact n\n    exact 37; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term\n    constructor\n    exact n\n    exact 37",
  "core-prompt": "(n : Nat) : Nat Ã— Nat",
  "args": "(n : Nat)"},
 {"type": "Nat Ã— Nat",
  "tactic-prompt": "example  : Nat Ã— Nat := by show_term constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term constructor",
  "core-prompt": " : Nat Ã— Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by guard_hyp n :â‚› Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp n :â‚› Nat",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "P",
  "tactic-prompt": "def (P : Prop)  (x : P) : P := by by_contra h; sorry",
  "name": "nonDecid",
  "kind": "def",
  "first-tactic": "by_contra h",
  "core-prompt": "(P : Prop)  (x : P) : P",
  "args": "(P : Prop)  (x : P)"},
 {"type": "P",
  "tactic-prompt":
  "def (P : Prop)  [Decidable P]  (x : P) : P := by by_contra h; sorry",
  "name": "decid",
  "kind": "def",
  "first-tactic": "by_contra h",
  "core-prompt": "(P : Prop)  [Decidable P]  (x : P) : P",
  "args": "(P : Prop)  [Decidable P]  (x : P)"},
 {"type": "nonDecid P = decid P",
  "tactic-prompt":
  "example (P : Prop)  [Decidable P] : nonDecid P = decid P := by delta nonDecid nonDecid.proof_1 decid decid.proof_1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "delta nonDecid nonDecid.proof_1 decid decid.proof_1",
  "core-prompt": "(P : Prop)  [Decidable P] : nonDecid P = decid P",
  "args": "(P : Prop)  [Decidable P]"},
 {"type": "P â†’ P",
  "tactic-prompt": "example (P : Prop) : P â†’ P := by by_contra; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra",
  "core-prompt": "(P : Prop) : P â†’ P",
  "args": "(P : Prop)"},
 {"type": "(True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "tactic-prompt":
  "example  : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "args": ""},
 {"type": "((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x))",
  "tactic-prompt":
  "example  : ((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x)) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt":
  " : ((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x))",
  "args": ""},
 {"type": "(True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "tactic-prompt":
  "example  : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "args": ""},
 {"type": "a = b âˆ¨ True",
  "tactic-prompt":
  "example (a b : A n) : a = b âˆ¨ True := by fail_if_success\n    apply Or.inl; ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    apply Or.inl; ext",
  "core-prompt": "(a b : A n) : a = b âˆ¨ True",
  "args": "(a b : A n)"},
 {"type": "a = b",
  "tactic-prompt": "example (a b : C n) : a = b := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(a b : C n) : a = b",
  "args": "(a b : C n)"},
 {"type": "f = g",
  "tactic-prompt":
  "example (f g : Nat Ã— Nat â†’ Nat) : f = g := by ext âŸ¨x, yâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt": "(f g : Nat Ã— Nat â†’ Nat) : f = g",
  "args": "(f g : Nat Ã— Nat â†’ Nat)"},
 {"type": "x + 1 = 1 + x",
  "tactic-prompt": "example  : x + 1 = 1 + x := by simp? [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp? [Nat.add_comm]",
  "core-prompt": " : x + 1 = 1 + x",
  "args": ""},
 {"type": "1 + 1 = 2",
  "tactic-prompt": "example  : 1 + 1 = 2 := by dsimp?; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp?",
  "core-prompt": " : 1 + 1 = 2",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt": "example  : foo x y = 1 + y := by cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt":
  "example  : foo x y = 1 + y := by squeeze_scope\n    cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "squeeze_scope\n    cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "c x y z â†” c x' y z'",
  "tactic-prompt":
  "example (c : Prop â†’ Prop â†’ Prop â†’ Prop)  (x x' y z z' : Prop)      (hâ‚€ : x â†” x')  (hâ‚ : z â†” z') : c x y z â†” c x' y z' := by apply Iff.of_eq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Iff.of_eq",
  "core-prompt":
  "(c : Prop â†’ Prop â†’ Prop â†’ Prop)  (x x' y z z' : Prop)      (hâ‚€ : x â†” x')  (hâ‚ : z â†” z') : c x y z â†” c x' y z'",
  "args":
  "(c : Prop â†’ Prop â†’ Prop â†’ Prop)  (x x' y z z' : Prop)      (hâ‚€ : x â†” x')  (hâ‚ : z â†” z')"},
 {"type": "f x = f y",
  "tactic-prompt":
  "example {Î± Î² : Type _}  {f : _ â†’ Î²}  {x y : { x : { x : Î± // x = x } // x = x }}      (h : x.1 = y.1) : f x = f y := by congr with x : 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "congr with x : 1",
  "core-prompt":
  "{Î± Î² : Type _}  {f : _ â†’ Î²}  {x y : { x : { x : Î± // x = x } // x = x }}      (h : x.1 = y.1) : f x = f y",
  "args":
  "{Î± Î² : Type _}  {f : _ â†’ Î²}  {x y : { x : { x : Î± // x = x } // x = x }}      (h : x.1 = y.1)"},
 {"type": "F f = F g",
  "tactic-prompt":
  "example {Î± Î² : Type _}  {F : _ â†’ Î²}  {f g : { f : Î± â†’ Î² // f = f }}      (h : âˆ€ x : Î±, (f : Î± â†’ Î²) x = (g : Î± â†’ Î²) x) : F f = F g := by rcongr x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr x",
  "core-prompt":
  "{Î± Î² : Type _}  {F : _ â†’ Î²}  {f g : { f : Î± â†’ Î² // f = f }}      (h : âˆ€ x : Î±, (f : Î± â†’ Î²) x = (g : Î± â†’ Î²) x) : F f = F g",
  "args":
  "{Î± Î² : Type _}  {F : _ â†’ Î²}  {f g : { f : Î± â†’ Î² // f = f }}      (h : âˆ€ x : Î±, (f : Î± â†’ Î²) x = (g : Î± â†’ Î²) x)"},
 {"type":
  "(ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1)",
  "tactic-prompt":
  "example {ls : List Nat} : (ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1) := by rcongr (_x y); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr (_x y)",
  "core-prompt":
  "{ls : List Nat} : (ls.map fun x => (ls.map fun y => 1 + y).sum + 1) =\n    (ls.map fun x => (ls.map fun y => Nat.succ y).sum + 1)",
  "args": "{ls : List Nat}"},
 {"type": "(ls.map fun x => f x + 3) = ls.map fun x => g x + 3",
  "tactic-prompt":
  "example {ls : List Nat}  {f g : Nat â†’ Nat}  {h : âˆ€ x, f x = g x} : (ls.map fun x => f x + 3) = ls.map fun x => g x + 3 := by rcongr x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr x",
  "core-prompt":
  "{ls : List Nat}  {f g : Nat â†’ Nat}  {h : âˆ€ x, f x = g x} : (ls.map fun x => f x + 3) = ls.map fun x => g x + 3",
  "args": "{ls : List Nat}  {f g : Nat â†’ Nat}  {h : âˆ€ x, f x = g x}"},
 {"type": "() = ()",
  "tactic-prompt": "example  : () = () := by rcongr; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr",
  "core-prompt": " : () = ()",
  "args": ""},
 {"type": "0 = 0",
  "tactic-prompt": "example  : 0 = 0 := by rcongr; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcongr",
  "core-prompt": " : 0 = 0",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by rcases x with âŸ¨a, b, câŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with âŸ¨a, b, câŸ©",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by rcases x with âŸ¨(a : Î±) : id Î±, -, c : id Î³âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with âŸ¨(a : Î±) : id Î±, -, c : id Î³âŸ©",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : (Î± Ã— Î²) Ã— Î³) : True := by fail_if_success rcases x with âŸ¨_a, b, câŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success rcases x with âŸ¨_a, b, câŸ©",
  "core-prompt": "(x : (Î± Ã— Î²) Ã— Î³) : True",
  "args": "(x : (Î± Ã— Î²) Ã— Î³)"},
 {"type": "@Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True",
  "tactic-prompt":
  "example  : @Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True := by rintro (âŸ¨âŸ¨aâŸ©, _ | bâŸ© | c); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (âŸ¨âŸ¨aâŸ©, _ | bâŸ© | c)",
  "core-prompt": " : @Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True",
  "args": ""},
 {"type": "cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True",
  "tactic-prompt":
  "example  : cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True := by rintro (x y : Int) (z | u); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (x y : Int) (z | u)",
  "core-prompt":
  " : cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Nat)  (h : x = y) : True := by rcases x with _|âŸ¨âŸ©|z; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with _|âŸ¨âŸ©|z",
  "core-prompt": "(x y : Nat)  (h : x = y) : True",
  "args": "(x y : Nat)  (h : x = y)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : x = 3)  (hâ‚‚ : x < 4) : x < 4 := by rcases h with âŸ¨âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with âŸ¨âŸ©",
  "core-prompt": "(h : x = 3)  (hâ‚‚ : x < 4) : x < 4",
  "args": "(h : x = 3)  (hâ‚‚ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : x = 3)  (hâ‚‚ : x < 4) : x < 4 := by rcases h with rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with rfl",
  "core-prompt": "(h : x = 3)  (hâ‚‚ : x < 4) : x < 4",
  "args": "(h : x = 3)  (hâ‚‚ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : 3 = x)  (hâ‚‚ : x < 4) : x < 4 := by rcases h with âŸ¨âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with âŸ¨âŸ©",
  "core-prompt": "(h : 3 = x)  (hâ‚‚ : x < 4) : x < 4",
  "args": "(h : 3 = x)  (hâ‚‚ : x < 4)"},
 {"type": "x < 4",
  "tactic-prompt":
  "example (h : 3 = x)  (hâ‚‚ : x < 4) : x < 4 := by rcases h with rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases h with rfl",
  "core-prompt": "(h : 3 = x)  (hâ‚‚ : x < 4) : x < 4",
  "args": "(h : 3 = x)  (hâ‚‚ : x < 4)"},
 {"type": "True",
  "tactic-prompt":
  "example (s : Î± âŠ• Empty) : True := by rcases s with s|âŸ¨âŸ¨âŸ©âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases s with s|âŸ¨âŸ¨âŸ©âŸ©",
  "core-prompt": "(s : Î± âŠ• Empty) : True",
  "args": "(s : Î± âŠ• Empty)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain âŸ¨n : Nat, _h : n = n, -âŸ© : âˆƒ n : Nat, n = n âˆ§ True; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain âŸ¨n : Nat, _h : n = n, -âŸ© : âˆƒ n : Nat, n = n âˆ§ True",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain (h : True) | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain (h : True) | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain h | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False := Or.inl trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain h | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False := Or.inl trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain âŸ¨h, h2âŸ© := And.intro trivial trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain âŸ¨h, h2âŸ© := And.intro trivial trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success obtain âŸ¨h, h2âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success obtain âŸ¨h, h2âŸ©",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Î± Ã— Î²) : True := by rcases x, y with âŸ¨âŸ¨a, bâŸ©, c, dâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with âŸ¨âŸ¨a, bâŸ©, c, dâŸ©",
  "core-prompt": "(x y : Î± Ã— Î²) : True",
  "args": "(x y : Î± Ã— Î²)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Î± âŠ• Î²) : True := by rcases x, y with âŸ¨a|b, c|dâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with âŸ¨a|b, c|dâŸ©",
  "core-prompt": "(x y : Î± âŠ• Î²) : True",
  "args": "(x y : Î± âŠ• Î²)"},
 {"type": "(Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j",
  "tactic-prompt":
  "example (i j : Nat) : (Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt": "(i j : Nat) : (Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j",
  "args": "(i j : Nat)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Quot fun _ _ : Î± => True)  (h : x = x) : x = x := by rcases x with âŸ¨zâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with âŸ¨zâŸ©",
  "core-prompt": "(x : Quot fun _ _ : Î± => True)  (h : x = x) : x = x",
  "args": "(x : Quot fun _ _ : Î± => True)  (h : x = x)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain _one_lt_n | _n_le_one : 1 < n + 1 âˆ¨ n + 1 â‰¤ 1 := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain _one_lt_n | _n_le_one : 1 < n + 1 âˆ¨ n + 1 â‰¤ 1 := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain _one_lt_n | (_n_le_one : n + 1 â‰¤ 1) := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain _one_lt_n | (_n_le_one : n + 1 â‰¤ 1) := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "(b : Bool) â†’ cond b False False â†’ True",
  "tactic-prompt":
  "example  : (b : Bool) â†’ cond b False False â†’ True := by rintro âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt": " : (b : Bool) â†’ cond b False False â†’ True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by cases (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases ()",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c)",
  "tactic-prompt":
  "theorem  : a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c) := by rw [â† and_assoc]; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† and_assoc]",
  "core-prompt": " : a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c)",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b := by simp only [and_left_comm]; sorry",
  "name": "and_right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b",
  "args": ""},
 {"type": "a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a",
  "tactic-prompt":
  "theorem  : a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a := by simp only [and_left_comm]; sorry",
  "name": "and_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d := by rw [â† and_assoc]; sorry",
  "name": "and_and_and_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† and_assoc]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d",
  "args": ""},
 {"type": "a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c",
  "tactic-prompt":
  "theorem  : a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_left",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_right",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c",
  "args": ""},
 {"type": "(p â†” p âˆ§ q) â†” (p â†’ q)",
  "tactic-prompt":
  "theorem  : (p â†” p âˆ§ q) â†” (p â†’ q) := by rw [@Iff.comm p]; sorry",
  "name": "iff_self_and",
  "kind": "theorem",
  "first-tactic": "rw [@Iff.comm p]",
  "core-prompt": " : (p â†” p âˆ§ q) â†” (p â†’ q)",
  "args": ""},
 {"type": "(p â†” q âˆ§ p) â†” (p â†’ q)",
  "tactic-prompt":
  "theorem  : (p â†” q âˆ§ p) â†” (p â†’ q) := by rw [and_comm]; sorry",
  "name": "iff_and_self",
  "kind": "theorem",
  "first-tactic": "rw [and_comm]",
  "core-prompt": " : (p â†” q âˆ§ p) â†” (p â†’ q)",
  "args": ""},
 {"type": "(a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b)",
  "tactic-prompt":
  "theorem  : (a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b) := by simp only [and_comm]; sorry",
  "name": "and_congr_left_iff",
  "kind": "theorem",
  "first-tactic": "simp only [and_comm]",
  "core-prompt": " : (a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b)",
  "args": ""},
 {"type": "a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c)",
  "tactic-prompt":
  "theorem  : a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c) := by rw [â† or_assoc]; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† or_assoc]",
  "core-prompt": " : a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c)",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b := by rw [or_assoc]; sorry",
  "name": "or_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [or_assoc]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d := by rw [â† or_assoc]; sorry",
  "name": "or_or_or_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† or_assoc]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d",
  "args": ""},
 {"type": "a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c",
  "tactic-prompt":
  "theorem  : a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c",
  "args": ""},
 {"type": "a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a",
  "tactic-prompt":
  "theorem  : a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a := by simp only [or_left_comm]; sorry",
  "name": "or_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [or_left_comm]",
  "core-prompt": " : a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a",
  "args": ""},
 {"type": "(a âˆ¨ b â†” b) â†” (a â†’ b)",
  "tactic-prompt": "theorem  : (a âˆ¨ b â†” b) â†” (a â†’ b) := by rw [or_comm]; sorry",
  "name": "or_iff_right_iff_imp",
  "kind": "theorem",
  "first-tactic": "rw [or_comm]",
  "core-prompt": " : (a âˆ¨ b â†” b) â†” (a â†’ b)",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c)",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c) := by simp [and_comm]; sorry",
  "name": "or_and_right",
  "kind": "theorem",
  "first-tactic": "simp [and_comm]",
  "core-prompt": " : (a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c)",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c) := by simp [or_comm]; sorry",
  "name": "and_or_right",
  "kind": "theorem",
  "first-tactic": "simp [or_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
  "args": ""},
 {"type": "(âˆ€ a, a' = a â†’ p a) â†” p a'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±} : (âˆ€ a, a' = a â†’ p a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "forall_eq'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±} : (âˆ€ a, a' = a â†’ p a) â†” p a'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±}"},
 {"type": "(âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b := by simp [And.comm]; sorry",
  "name": "exists_and_right",
  "kind": "theorem",
  "first-tactic": "simp [And.comm]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ a, a' = a âˆ§ p a) â†” p a'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, a' = a âˆ§ p a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_left'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, a' = a âˆ§ p a) â†” p a'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a := by simp only [or_imp]; sorry",
  "name": "forall_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_imp]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a := by simp only [or_and_right]; sorry",
  "name": "exists_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_and_right]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b := by simp [â† and_assoc]; sorry",
  "name": "exists_eq_right_right",
  "kind": "theorem",
  "first-tactic": "simp [â† and_assoc]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b := by (conv in _=_ => rw [eq_comm]); sorry",
  "name": "exists_eq_right_right'",
  "kind": "theorem",
  "first-tactic": "(conv in _=_ => rw [eq_comm])",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(decide p = true) â†” p",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p] : (decide p = true) â†” p := by simp; sorry",
  "name": "decide_eq_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p] : (decide p = true) â†” p",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p]"},
 {"type": "(Â¬a â†’ a) â†” a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (Â¬a â†’ a) â†” a := by have := @imp_not_self (Â¬a); sorry",
  "name": "Decidable.not_imp_self",
  "kind": "theorem",
  "first-tactic": "have := @imp_not_self (Â¬a)",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (Â¬a â†’ a) â†” a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]"},
 {"type": "(a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c) := by by_cases a; sorry",
  "name": "Decidable.imp_or",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]"},
 {"type": "(Â¬a â†” Â¬b) â†” (a â†” b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” Â¬b) â†” (a â†” b) := by rw [@iff_def (Â¬a)]; sorry",
  "name": "Decidable.not_iff_not",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (Â¬a)]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” Â¬b) â†” (a â†” b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(Â¬a â†” b) â†” (Â¬b â†” a)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” b) â†” (Â¬b â†” a) := by rw [@iff_def (Â¬a)]; sorry",
  "name": "Decidable.not_iff_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (Â¬a)]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” b) â†” (Â¬b â†” a)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "Â¬(a â†” b) â†” (Â¬a â†” b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b] : Â¬(a â†” b) â†” (Â¬a â†” b) := by by_cases h : b; sorry",
  "name": "Decidable.not_iff",
  "kind": "theorem",
  "first-tactic": "by_cases h : b",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b] : Â¬(a â†” b) â†” (Â¬a â†” b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b]"},
 {"type": "(a â†” Â¬b) â†” (b â†” Â¬a)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” Â¬b) â†” (b â†” Â¬a) := by rw [@iff_def a]; sorry",
  "name": "Decidable.iff_not_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def a]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” Â¬b) â†” (b â†” Â¬a)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b) := by rw [iff_iff_implies_and_implies a b]; sorry",
  "name": "Decidable.iff_iff_not_or_and_or_not",
  "kind": "theorem",
  "first-tactic": "rw [iff_iff_implies_and_implies a b]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b) := by rw [â† not_or]; sorry",
  "name": "Decidable.or_iff_not_and_not",
  "kind": "theorem",
  "first-tactic": "rw [â† not_or]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b) := by rw [â† not_and]; sorry",
  "name": "Decidable.and_iff_not_or_not",
  "kind": "theorem",
  "first-tactic": "rw [â† not_and]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ¨ c â†” b âˆ¨ c",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b)) : a âˆ¨ c â†” b âˆ¨ c := by rw [or_iff_not_imp_right]; sorry",
  "name": "Decidable.or_congr_left'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b)) : a âˆ¨ c â†” b âˆ¨ c",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b))"},
 {"type": "a âˆ¨ b â†” a âˆ¨ c",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c)) : a âˆ¨ b â†” a âˆ¨ c := by rw [or_iff_not_imp_left]; sorry",
  "name": "Decidable.or_congr_right'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_left]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c)) : a âˆ¨ b â†” a âˆ¨ c",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c))"},
 {"type": "HEq hp hq",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq := by cases propext (iff_of_true hp hq); sorry",
  "name": "proof_irrel_heq",
  "kind": "theorem",
  "first-tactic": "cases propext (iff_of_true hp hq)",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q)"},
 {"type": "(@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a') : (@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y := by cases h; sorry",
  "name": "eq_rec_constant",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a') : (@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a')"},
 {"type": "f x y = f x' y'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y') : f x y = f x' y' := by subst hx hy; sorry",
  "name": "congrArgâ‚‚",
  "kind": "theorem",
  "first-tactic": "subst hx hy",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y') : f x y = f x' y'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y')"},
 {"type": "f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h)) := by by_cases h : P; sorry",
  "name": "apply_dite",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±)"},
 {"type": "dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x := by by_cases h : P; sorry",
  "name": "dite_not",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±)"},
 {"type": "(a == b) = false â†” a â‰  b",
  "tactic-prompt":
  "theorem [BEq Î±]  [LawfulBEq Î±]      (a b : Î±) : (a == b) = false â†” a â‰  b := by rw [ne_eq]; sorry",
  "name": "beq_eq_false_iff_ne",
  "kind": "theorem",
  "first-tactic": "rw [ne_eq]",
  "core-prompt":
  "[BEq Î±]  [LawfulBEq Î±]      (a b : Î±) : (a == b) = false â†” a â‰  b",
  "args": "[BEq Î±]  [LawfulBEq Î±]      (a b : Î±)"},
 {"type": "SatisfiesM q (f <$> x)",
  "tactic-prompt":
  "theorem [Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a)) : SatisfiesM q (f <$> x) := by let âŸ¨x', hxâŸ© := hx; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "let âŸ¨x', hxâŸ© := hx",
  "core-prompt":
  "[Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a)) : SatisfiesM q (f <$> x)",
  "args":
  "[Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a))"},
 {"type": "SatisfiesM q (f <*> x)",
  "tactic-prompt":
  "theorem [Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a)) : SatisfiesM q (f <*> x) := by match f, x, hf, hx with | _, _, âŸ¨f, rflâŸ©, âŸ¨x, rflâŸ© => ?_; sorry",
  "name": "seq",
  "kind": "theorem",
  "first-tactic": "match f, x, hf, hx with | _, _, âŸ¨f, rflâŸ©, âŸ¨x, rflâŸ© => ?_",
  "core-prompt":
  "[Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a)) : SatisfiesM q (f <*> x)",
  "args":
  "[Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a))"},
 {"type": "SatisfiesM q (x >>= f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a)) : SatisfiesM q (x >>= f) := by match x, hx with | _, âŸ¨x, rflâŸ© => ?_; sorry",
  "name": "bind",
  "kind": "theorem",
  "first-tactic": "match x, hx with | _, âŸ¨x, rflâŸ© => ?_",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a)) : SatisfiesM q (x >>= f)",
  "args":
  "[Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a))"},
 {"type": "SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s)",
  "tactic-prompt":
  "theorem [Monad m] : SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s) := by simp; sorry",
  "name": "SatisfiesM_StateRefT_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "[Monad m] : SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s)",
  "args": "[Monad m]"},
 {"type":
  "SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s) := by refine .trans âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, hâŸ© => ?_âŸ© Classical.skolem.symm; sorry",
  "name": "SatisfiesM_StateT_eq",
  "kind": "theorem",
  "first-tactic":
  "refine .trans âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, hâŸ© => ?_âŸ© Classical.skolem.symm",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s)",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type":
  "SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x := by refine âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, eqâŸ© => eq â–¸ ?_âŸ©; sorry",
  "name": "SatisfiesM_ExceptT_eq",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, eqâŸ© => eq â–¸ ?_âŸ©",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type": "o.swap.swap = o",
  "tactic-prompt":
  "theorem {o : Ordering} : o.swap.swap = o := by cases o; sorry",
  "name": "Ordering.swap_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": "{o : Ordering} : o.swap.swap = o",
  "args": "{o : Ordering}"},
 {"type": "cmp x y = .gt â†” cmp y x = .lt",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .gt â†” cmp y x = .lt := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_eq_gt",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .gt â†” cmp y x = .lt",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x y = .eq â†” cmp y x = .eq",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .eq â†” cmp y x = .eq := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_eq_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .eq â†” cmp y x = .eq",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x z â‰  .lt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt) : cmp x z â‰  .lt := by have := @TransCmp.le_trans _ cmp _ z y x; sorry",
  "name": "ge_trans",
  "kind": "theorem",
  "first-tactic": "have := @TransCmp.le_trans _ cmp _ z y x",
  "core-prompt":
  "[TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt) : cmp x z â‰  .lt",
  "args": "[TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt)"},
 {"type": "cmp x z = .gt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt) : cmp x z = .gt := by rw [cmp_eq_gt] at hâ‚ hâ‚‚ âŠ¢; sorry",
  "name": "gt_trans",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_gt] at hâ‚ hâ‚‚ âŠ¢",
  "core-prompt":
  "[TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt) : cmp x z = .gt",
  "args": "[TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt)"},
 {"type": "cmp x y = cmp x z",
  "tactic-prompt":
  "theorem [TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_congr_right",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt":
  "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z",
  "args": "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq)"},
 {"type": "WF (empty n : Imp Î± Î²)",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±] : WF (empty n : Imp Î± Î²) := by unfold empty; sorry",
  "name": "WF.empty",
  "kind": "theorem",
  "first-tactic": "unfold empty",
  "core-prompt": "[BEq Î±]  [Hashable Î±] : WF (empty n : Imp Î± Î²)",
  "args": "[BEq Î±]  [Hashable Î±]"},
 {"type": "(reinsertAux data a b).size = data.size.succ",
  "tactic-prompt":
  "theorem [Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²) : (reinsertAux data a b).size = data.size.succ := by simp [Bucket.size_eq]; sorry",
  "name": "reinsertAux_size",
  "kind": "theorem",
  "first-tactic": "simp [Bucket.size_eq]",
  "core-prompt":
  "[Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²) : (reinsertAux data a b).size = data.size.succ",
  "args": "[Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²)"},
 {"type": "(expand sz buckets).buckets.size = buckets.size",
  "tactic-prompt":
  "theorem [Hashable Î±]  {buckets : Bucket Î± Î²} : (expand sz buckets).buckets.size = buckets.size := by rw [expand]; sorry",
  "name": "expand_size",
  "kind": "theorem",
  "first-tactic": "rw [expand]",
  "core-prompt":
  "[Hashable Î±]  {buckets : Bucket Î± Î²} : (expand sz buckets).buckets.size = buckets.size",
  "args": "[Hashable Î±]  {buckets : Bucket Î± Î²}"},
 {"type":
  "(l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i := by induction l generalizing target with\n  | nil => exact âŸ¨htâ‚, fun _ hâ‚ _ hâ‚‚ => (htâ‚‚ _ hâ‚ _ hâ‚‚).1âŸ©\n  | cons _ _ ih =>\n    simp at hlâ‚ hlâ‚‚ htâ‚‚\n    refine ih hlâ‚.2 hlâ‚‚.2\n      (reinsertAux_WF htâ‚ fun _ h => (htâ‚‚ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ h _ hf\n      exact âŸ¨hâ‚, hâ‚‚.2âŸ©\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact âŸ¨hlâ‚‚.1 â–¸ Nat.le_refl _, fun _ h h' => hlâ‚.1 _ h (PartialEquivBEq.symm h')âŸ©\n      | _, .tail _ h =>\n        have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ (Array.getElem_mem_data ..) _ h\n        exact âŸ¨hâ‚, hâ‚‚.2âŸ©; sorry",
  "name": "expand_WF.foldl",
  "kind": "theorem",
  "first-tactic":
  "induction l generalizing target with\n  | nil => exact âŸ¨htâ‚, fun _ hâ‚ _ hâ‚‚ => (htâ‚‚ _ hâ‚ _ hâ‚‚).1âŸ©\n  | cons _ _ ih =>\n    simp at hlâ‚ hlâ‚‚ htâ‚‚\n    refine ih hlâ‚.2 hlâ‚‚.2\n      (reinsertAux_WF htâ‚ fun _ h => (htâ‚‚ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ h _ hf\n      exact âŸ¨hâ‚, hâ‚‚.2âŸ©\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact âŸ¨hlâ‚‚.1 â–¸ Nat.le_refl _, fun _ h h' => hlâ‚.1 _ h (PartialEquivBEq.symm h')âŸ©\n      | _, .tail _ h =>\n        have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ (Array.getElem_mem_data ..) _ h\n        exact âŸ¨hâ‚, hâ‚‚.2âŸ©",
  "core-prompt":
  "[BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i",
  "args":
  "[BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k))"},
 {"type":
  "x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l",
  "tactic-prompt":
  "theorem {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool} : x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l := by induction l; sorry",
  "name": "mem_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool} : x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l",
  "args": "{l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool}"},
 {"type":
  "(l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst)",
  "tactic-prompt":
  "theorem [BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst) := by induction hxâ‚; sorry",
  "name": "pairwise_replaceF",
  "kind": "theorem",
  "first-tactic": "induction hxâ‚",
  "core-prompt":
  "[BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst)",
  "args":
  "[BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst))"},
 {"type": "m.size = m.buckets.size âˆ§ m.buckets.WF",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF) : m.size = m.buckets.size âˆ§ m.buckets.WF := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "[BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF) : m.size = m.buckets.size âˆ§ m.buckets.WF",
  "args": "[BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF)"},
 {"type": "s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1 := by cases s; sorry",
  "name": "Heap.realSize_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1",
  "args": "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±} : s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.realSize_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap Î±} : s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1",
  "args": "{s : Heap Î±}"},
 {"type":
  "(merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n)",
  "tactic-prompt":
  "theorem (hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n) : (merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n) := by unfold merge; sorry",
  "name": "Heap.WellFormed.merge'",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n) : (merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n)",
  "args": "(hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n)"},
 {"type": "s.toHeap.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : HeapNode Î±}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0 := by rw [toHeap]; sorry",
  "name": "HeapNode.WellFormed.toHeap",
  "kind": "theorem",
  "first-tactic": "rw [toHeap]",
  "core-prompt":
  "{s : HeapNode Î±}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0",
  "args": "{s : HeapNode Î±}      (h : s.WellFormed le a n)"},
 {"type": "s'.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0 := by cases s; sorry",
  "name": "Heap.WellFormed.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0",
  "args":
  "{s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl â†’\n  tl.WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WellFormed le n) : s.tail? le = some tl â†’\n  tl.WellFormed le 0 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WellFormed.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap Î±).WellFormed le n) : s.tail? le = some tl â†’\n  tl.WellFormed le 0",
  "args": "(hwf : (s : Heap Î±).WellFormed le n)"},
 {"type": "(s.tail le).WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WellFormed le n) : (s.tail le).WellFormed le 0 := by simp only [Heap.tail]; sorry",
  "name": "Heap.WellFormed.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt":
  "(hwf : (s : Heap Î±).WellFormed le n) : (s.tail le).WellFormed le 0",
  "args": "(hwf : (s : Heap Î±).WellFormed le n)"},
 {"type": "(gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n) := by induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact âŸ¨Nat.dvd_zero n, Nat.dvd_refl nâŸ©\n  | H1 m n _ IH => rw [â† gcd_rec] at IH; exact âŸ¨IH.2, (dvd_mod_iff IH.2).1 IH.1âŸ©; sorry",
  "name": "gcd_dvd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact âŸ¨Nat.dvd_zero n, Nat.dvd_refl nâŸ©\n  | H1 m n _ IH => rw [â† gcd_rec] at IH; exact âŸ¨IH.2, (dvd_mod_iff IH.2).1 IH.1âŸ©",
  "core-prompt": "(m n : Nat) : (gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n)",
  "args": "(m n : Nat)"},
 {"type": "k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n",
  "tactic-prompt":
  "theorem  : k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n := by induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km; sorry",
  "name": "dvd_gcd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km",
  "core-prompt": " : k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n",
  "args": ""},
 {"type": "m âˆ£ n â†” gcd n m = m",
  "tactic-prompt": "theorem  : m âˆ£ n â†” gcd n m = m := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right_iff_dvd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": " : m âˆ£ n â†” gcd n m = m",
  "args": ""},
 {"type": "gcd (m * n) (m * k) = m * gcd n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k := by induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [â† mul_mod_mul_left, â† gcd_rec, â† gcd_rec] at IH; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic":
  "induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [â† mul_mod_mul_left, â† gcd_rec, â† gcd_rec] at IH",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k",
  "args": "(m n k : Nat)"},
 {"type": "gcd (m * n) (k * n) = gcd m k * n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n := by rw [Nat.mul_comm m n]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m n]",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n",
  "args": "(m n k : Nat)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : gcd m n = 0) : n = 0 := by rw [gcd_comm] at H; sorry",
  "name": "eq_zero_of_gcd_eq_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm] at H",
  "core-prompt": "{m n : Nat}  (H : gcd m n = 0) : n = 0",
  "args": "{m n : Nat}  (H : gcd m n = 0)"},
 {"type": "gcd m n = n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n âˆ£ m) : gcd m n = n := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{m n : Nat}  (H : n âˆ£ m) : gcd m n = n",
  "args": "{m n : Nat}  (H : n âˆ£ m)"},
 {"type": "gcd n (m * n) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (m * n) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (m * n) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd (n * m) n = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (n * m) n = n := by rw [Nat.mul_comm]; sorry",
  "name": "gcd_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : gcd (n * m) n = n",
  "args": "(m n : Nat)"},
 {"type": "gcd n (n * m) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (n * m) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (n * m) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (gcd n m) = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m (gcd n m) = gcd n m := by rw [gcd_comm n m]; sorry",
  "name": "gcd_gcd_self_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm n m]",
  "core-prompt": "(m n : Nat) : gcd m (gcd n m) = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd n m) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd n m) m = gcd n m := by rw [gcd_comm]; sorry",
  "name": "gcd_gcd_self_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd (gcd n m) m = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd m n) m = gcd m n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd m n) m = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "gcd_gcd_self_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(m n : Nat) : gcd (gcd m n) m = gcd m n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : Nat) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : Nat)"},
 {"type": "lcm m n = lcm n m",
  "tactic-prompt":
  "theorem (m n : Nat) : lcm m n = lcm n m := by rw [lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : lcm m n = lcm n m",
  "args": "(m n : Nat)"},
 {"type": "lcm 0 m = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm 0 m = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 0 m = 0",
  "args": "(m : Nat)"},
 {"type": "lcm m 0 = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm m 0 = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 0 = 0",
  "args": "(m : Nat)"},
 {"type": "lcm 1 m = m",
  "tactic-prompt": "theorem (m : Nat) : lcm 1 m = m := by simp [lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 1 m = m",
  "args": "(m : Nat)"},
 {"type": "lcm m 1 = m",
  "tactic-prompt": "theorem (m : Nat) : lcm m 1 = m := by simp [lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 1 = m",
  "args": "(m : Nat)"},
 {"type": "lcm m m = m",
  "tactic-prompt":
  "theorem (m : Nat) : lcm m m = m := by match eq_zero_or_pos m with\n  | .inl h => rw [h]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos m with\n  | .inl h => rw [h]",
  "core-prompt": "(m : Nat) : lcm m m = m",
  "args": "(m : Nat)"},
 {"type": "gcd m n * lcm m n = m * n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m n * lcm m n = m * n := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : gcd m n * lcm m n = m * n",
  "args": "(m n : Nat)"},
 {"type": "lcm m n âˆ£ k",
  "tactic-prompt":
  "theorem {m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k) : lcm m n âˆ£ k := by match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]",
  "core-prompt": "{m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k) : lcm m n âˆ£ k",
  "args": "{m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k)"},
 {"type": "lcm m n â‰  0",
  "tactic-prompt":
  "theorem (hm : m â‰  0)  (hn : n â‰  0) : lcm m n â‰  0 := by intro h; sorry",
  "name": "lcm_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "(hm : m â‰  0)  (hn : n â‰  0) : lcm m n â‰  0",
  "args": "(hm : m â‰  0)  (hn : n â‰  0)"},
 {"type": "k âˆ£ m",
  "tactic-prompt":
  "theorem (H1 : coprime k n)  (H2 : k âˆ£ m * n) : k âˆ£ m := by let t := dvd_gcd (Nat.dvd_mul_left k m) H2; sorry",
  "name": "coprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let t := dvd_gcd (Nat.dvd_mul_left k m) H2",
  "core-prompt": "(H1 : coprime k n)  (H2 : k âˆ£ m * n) : k âˆ£ m",
  "args": "(H1 : coprime k n)  (H2 : k âˆ£ m * n)"},
 {"type": "gcd (m * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n := by rw [Nat.mul_comm m k]; sorry",
  "name": "coprime.gcd_mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n",
  "args": "(m : Nat)  (H : coprime k n)"},
 {"type": "gcd m (k * n) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "coprime.gcd_mul_left_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "gcd m (n * k) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n := by rw [Nat.mul_comm n k]; sorry",
  "name": "coprime.gcd_mul_right_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm n k]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "coprime (m / gcd m n) (n / gcd m n)",
  "tactic-prompt":
  "theorem (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n) := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "(H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n)",
  "args": "(H : 0 < gcd m n)"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem (H1 : m âˆ£ k)  (H2 : coprime k n) : coprime m n := by apply eq_one_of_dvd_one; sorry",
  "name": "coprime.coprime_dvd_left",
  "kind": "theorem",
  "first-tactic": "apply eq_one_of_dvd_one",
  "core-prompt": "(H1 : m âˆ£ k)  (H2 : coprime k n) : coprime m n",
  "args": "(H1 : m âˆ£ k)  (H2 : coprime k n)"},
 {"type": "coprime (m / a) n",
  "tactic-prompt":
  "theorem (cmn : coprime m n)  (dvd : a âˆ£ m) : coprime (m / a) n := by match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn âŠ¢\n    simp; assumption\n  | .inr hpos =>\n    let âŸ¨k]; sorry",
  "name": "coprime.coprime_div_left",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn âŠ¢\n    simp; assumption\n  | .inr hpos =>\n    let âŸ¨k]",
  "core-prompt": "(cmn : coprime m n)  (dvd : a âˆ£ m) : coprime (m / a) n",
  "args": "(cmn : coprime m n)  (dvd : a âˆ£ m)"},
 {"type": "coprime k (m * n) â†” coprime k m âˆ§ coprime k n",
  "tactic-prompt":
  "theorem  : coprime k (m * n) â†” coprime k m âˆ§ coprime k n := by rw [@coprime_comm k]; sorry",
  "name": "coprime_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [@coprime_comm k]",
  "core-prompt": " : coprime k (m * n) â†” coprime k m âˆ§ coprime k n",
  "args": ""},
 {"type": "coprime 0 n â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime 0 n â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime 0 n â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n 0 â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n 0 â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n 0 â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n n â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n n â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_self",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n n â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime (m ^ n) k",
  "tactic-prompt":
  "theorem (n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k := by induction n; sorry",
  "name": "coprime.pow_left",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k",
  "args": "(n : Nat)  (H1 : coprime m k)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {k m : Nat}  (H : coprime k m)  (d : k âˆ£ m) : k = 1 := by rw [â† H.gcd_eq_one]; sorry",
  "name": "coprime.eq_one_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [â† H.gcd_eq_one]",
  "core-prompt": "{k m : Nat}  (H : coprime k m)  (d : k âˆ£ m) : k = 1",
  "args": "{k m : Nat}  (H : coprime k m)  (d : k âˆ£ m)"},
 {"type": "gcd k (m * n) âˆ£ gcd k m * gcd k n",
  "tactic-prompt":
  "theorem (k m n : Nat) : gcd k (m * n) âˆ£ gcd k m * gcd k n := by let âŸ¨âŸ¨âŸ¨m', hm'âŸ©, âŸ¨n', hn'âŸ©âŸ©, (h : gcd k (m * n) = m' * n')âŸ© :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n); sorry",
  "name": "gcd_mul_dvd_mul_gcd",
  "kind": "theorem",
  "first-tactic":
  "let âŸ¨âŸ¨âŸ¨m', hm'âŸ©, âŸ¨n', hn'âŸ©âŸ©, (h : gcd k (m * n) = m' * n')âŸ© :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n)",
  "core-prompt": "(k m n : Nat) : gcd k (m * n) âˆ£ gcd k m * gcd k n",
  "args": "(k m n : Nat)"},
 {"type": "a.gcd c * b.gcd c = c",
  "tactic-prompt":
  "theorem (cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c := by apply dvd_antisymm; sorry",
  "name": "gcd_mul_gcd_of_coprime_of_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "apply dvd_antisymm",
  "core-prompt":
  "(cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c",
  "args": "(cop : coprime c d)  (h : a * b = c * d)"},
 {"type": "n < k + n",
  "tactic-prompt":
  "theorem {n k : Nat}  (h : 0 < k) : n < k + n := by rw [Nat.add_comm]; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n k : Nat}  (h : 0 < k) : n < k + n",
  "args": "{n k : Nat}  (h : 0 < k)"},
 {"type": "x + k â‰¤ y â†” x â‰¤ y - k",
  "tactic-prompt":
  "theorem (x : Nat)  {y k : Nat}  (h : k â‰¤ y) : x + k â‰¤ y â†” x â‰¤ y - k := by rw [â† Nat.add_sub_cancel x k]; sorry",
  "name": "add_le_to_le_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.add_sub_cancel x k]",
  "core-prompt": "(x : Nat)  {y k : Nat}  (h : k â‰¤ y) : x + k â‰¤ y â†” x â‰¤ y - k",
  "args": "(x : Nat)  {y k : Nat}  (h : k â‰¤ y)"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b = min b a := by simp [Nat.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b = min b a",
  "args": "(a b : Nat)"},
 {"type": "min a b â‰¤ b",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b â‰¤ b := by rw [Nat.min_def]; sorry",
  "name": "min_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b â‰¤ b",
  "args": "(a b : Nat)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a â‰¤ b) : min a b = a := by simp [Nat.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "{a b : Nat}  (h : a â‰¤ b) : min a b = a",
  "args": "{a b : Nat}  (h : a â‰¤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b â‰¤ a) : min a b = b := by rw [Nat.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_comm a b]",
  "core-prompt": "{a b : Nat}  (h : b â‰¤ a) : min a b = b",
  "args": "{a b : Nat}  (h : b â‰¤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Nat) : max a b = max b a := by simp only [Nat.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Nat.max_def]",
  "core-prompt": "(a b : Nat) : max a b = max b a",
  "args": "(a b : Nat)"},
 {"type": "a â‰¤ max a b",
  "tactic-prompt":
  "theorem (a b : Nat) : a â‰¤ max a b := by rw [Nat.max_def]; sorry",
  "name": "le_max_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.max_def]",
  "core-prompt": "(a b : Nat) : a â‰¤ max a b",
  "args": "(a b : Nat)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a â‰¤ b) : max a b = b := by simp [Nat.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Nat.max_def]",
  "core-prompt": "{a b : Nat}  (h : a â‰¤ b) : max a b = b",
  "args": "{a b : Nat}  (h : a â‰¤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b â‰¤ a) : max a b = a := by rw [â† Nat.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.max_comm b a]",
  "core-prompt": "{a b : Nat}  (h : b â‰¤ a) : max a b = a",
  "args": "{a b : Nat}  (h : b â‰¤ a)"},
 {"type": "min (succ x) (succ y) = succ (min x y)",
  "tactic-prompt":
  "theorem (x y : Nat) : min (succ x) (succ y) = succ (min x y) := by simp [Nat.min_def]; sorry",
  "name": "min_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(x y : Nat) : min (succ x) (succ y) = succ (min x y)",
  "args": "(x y : Nat)"},
 {"type": "n - m = n - min n m",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m = n - min n m := by rw [Nat.min_def]; sorry",
  "name": "sub_eq_sub_min",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(n m : Nat) : n - m = n - min n m",
  "args": "(n m : Nat)"},
 {"type": "n - m + min n m = n",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m + min n m = n := by rw [sub_eq_sub_min]; sorry",
  "name": "sub_add_min_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_sub_min]",
  "core-prompt": "(n m : Nat) : n - m + min n m = n",
  "args": "(n m : Nat)"},
 {"type": "n * m * k = n * k * m",
  "tactic-prompt":
  "theorem (n m k : Nat) : n * m * k = n * k * m := by rw [Nat.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_assoc]",
  "core-prompt": "(n m k : Nat) : n * m * k = n * k * m",
  "args": "(n m k : Nat)"},
 {"type": "n * 2 = n + n",
  "tactic-prompt":
  "theorem (n : Nat) : n * 2 = n + n := by simp [Nat.mul_succ]; sorry",
  "name": "mul_two",
  "kind": "theorem",
  "first-tactic": "simp [Nat.mul_succ]",
  "core-prompt": "(n : Nat) : n * 2 = n + n",
  "args": "(n : Nat)"},
 {"type": "2 * n = n + n",
  "tactic-prompt":
  "theorem (n : Nat) : 2 * n = n + n := by simp [Nat.succ_mul]\n\n/- mod -/; sorry",
  "name": "two_mul",
  "kind": "theorem",
  "first-tactic": "simp [Nat.succ_mul]\n\n/- mod -/",
  "core-prompt": "(n : Nat) : 2 * n = n + n",
  "args": "(n : Nat)"},
 {"type": "m % k + k * (m / k) = m",
  "tactic-prompt":
  "theorem (m k : Nat) : m % k + k * (m / k) = m := by induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, â† Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/; sorry",
  "name": "mod_add_div",
  "kind": "theorem",
  "first-tactic":
  "induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, â† Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/",
  "core-prompt": "(m k : Nat) : m % k + k * (m / k) = m",
  "args": "(m k : Nat)"},
 {"type": "n / 1 = n",
  "tactic-prompt":
  "theorem (n : Nat) : n / 1 = n := by have := mod_add_div n 1; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div n 1",
  "core-prompt": "(n : Nat) : n / 1 = n",
  "args": "(n : Nat)"},
 {"type": "n / 0 = 0",
  "tactic-prompt": "theorem (n : Nat) : n / 0 = 0 := by rw [div_eq]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq]",
  "core-prompt": "(n : Nat) : n / 0 = 0",
  "args": "(n : Nat)"},
 {"type": "x â‰¤ y / k â†” x * k â‰¤ y",
  "tactic-prompt":
  "theorem (k0 : 0 < k) : x â‰¤ y / k â†” x * k â‰¤ y := by induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h âŸ¨k0, h'âŸ©\n  | ind y k h IH =>\n    rw [â† add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        â† Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic":
  "induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h âŸ¨k0, h'âŸ©\n  | ind y k h IH =>\n    rw [â† add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        â† Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]",
  "core-prompt": "(k0 : 0 < k) : x â‰¤ y / k â†” x * k â‰¤ y",
  "args": "(k0 : 0 < k)"},
 {"type": "a / b = (a - b) / b + 1",
  "tactic-prompt":
  "theorem (hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a) : a / b = (a - b) / b + 1 := by rw [div_eq a]; sorry",
  "name": "div_eq_sub_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a) : a / b = (a - b) / b + 1",
  "args": "(hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a)"},
 {"type": "a / b = 0",
  "tactic-prompt":
  "theorem (hâ‚€ : a < b) : a / b = 0 := by rw [div_eq a]; sorry",
  "name": "div_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(hâ‚€ : a < b) : a / b = 0",
  "args": "(hâ‚€ : a < b)"},
 {"type": "x / k < y â†” x < y * k",
  "tactic-prompt":
  "theorem (Hk : 0 < k) : x / k < y â†” x < y * k := by rw [â† Nat.not_le]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.not_le]",
  "core-prompt": "(Hk : 0 < k) : x / k < y â†” x < y * k",
  "args": "(Hk : 0 < k)"},
 {"type": "n = 0 âˆ¨ n = succ (pred n)",
  "tactic-prompt":
  "theorem (n : Nat) : n = 0 âˆ¨ n = succ (pred n) := by cases n; sorry",
  "name": "eq_zero_or_eq_succ_pred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : n = 0 âˆ¨ n = succ (pred n)",
  "args": "(n : Nat)"},
 {"type": "n.succ = 1 + n",
  "tactic-prompt":
  "theorem (n : Nat) : n.succ = 1 + n := by rw [Nat.succ_eq_add_one]; sorry",
  "name": "succ_eq_one_add",
  "kind": "theorem",
  "first-tactic": "rw [Nat.succ_eq_add_one]",
  "core-prompt": "(n : Nat) : n.succ = 1 + n",
  "args": "(n : Nat)"},
 {"type": "succ n + m = n + succ m",
  "tactic-prompt":
  "theorem (n m : Nat) : succ n + m = n + succ m := by simp [succ_add]; sorry",
  "name": "succ_add_eq_succ_add",
  "kind": "theorem",
  "first-tactic": "simp [succ_add]",
  "core-prompt": "(n m : Nat) : succ n + m = n + succ m",
  "args": "(n m : Nat)"},
 {"type": "1 + n = succ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 + n = succ n := by simp [Nat.add_comm]; sorry",
  "name": "one_add",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_comm]",
  "core-prompt": "(n : Nat) : 1 + n = succ n",
  "args": "(n : Nat)"},
 {"type": "n * m â‰  0 â†” n â‰  0 âˆ§ m â‰  0",
  "tactic-prompt":
  "theorem  : n * m â‰  0 â†” n â‰  0 âˆ§ m â‰  0 := by simp [mul_eq_zero]; sorry",
  "name": "mul_ne_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [mul_eq_zero]",
  "core-prompt": " : n * m â‰  0 â†” n â‰  0 âˆ§ m â‰  0",
  "args": ""},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {a b : Nat} : a - b + b = max a b := by match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]; sorry",
  "name": "sub_add_eq_max",
  "kind": "theorem",
  "first-tactic":
  "match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]",
  "core-prompt": "{a b : Nat} : a - b + b = max a b",
  "args": "{a b : Nat}"},
 {"type": "succ n - m - succ k = n - m - k",
  "tactic-prompt":
  "theorem (n m k : Nat) : succ n - m - succ k = n - m - k := by rw [Nat.sub_sub]; sorry",
  "name": "succ_sub_sub_succ",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(n m k : Nat) : succ n - m - succ k = n - m - k",
  "args": "(n m k : Nat)"},
 {"type": "m - n - k = m - k - n",
  "tactic-prompt":
  "theorem (m n k : Nat) : m - n - k = m - k - n := by rw [Nat.sub_sub]; sorry",
  "name": "sub.right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(m n k : Nat) : m - n - k = m - k - n",
  "args": "(m n k : Nat)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : Nat) : a * a - b * b = (a + b) * (a - b) := by rw [Nat.mul_sub_left_distrib]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_sub_left_distrib]",
  "core-prompt": "(a b : Nat) : a * a - b * b = (a + b) * (a - b)",
  "args": "(a b : Nat)"},
 {"type": "succ a * succ b = a * b + a + b + 1",
  "tactic-prompt":
  "theorem (a b : Nat) : succ a * succ b = a * b + a + b + 1 := by rw [mul_succ]; sorry",
  "name": "succ_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_succ]",
  "core-prompt": "(a b : Nat) : succ a * succ b = a * b + a + b + 1",
  "args": "(a b : Nat)"},
 {"type": "succ m - n = succ (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n â‰¤ m) : succ m - n = succ (m - n) := by let âŸ¨k, hkâŸ© := Nat.le.dest h; sorry",
  "name": "succ_sub",
  "kind": "theorem",
  "first-tactic": "let âŸ¨k, hkâŸ© := Nat.le.dest h",
  "core-prompt": "{m n : Nat}  (h : n â‰¤ m) : succ m - n = succ (m - n)",
  "args": "{m n : Nat}  (h : n â‰¤ m)"},
 {"type": "0 < n - m",
  "tactic-prompt":
  "theorem (h : m < n) : 0 < n - m := by apply Nat.lt_of_add_lt_add_right (b := m); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Nat.lt_of_add_lt_add_right (b := m)",
  "core-prompt": "(h : m < n) : 0 < n - m",
  "args": "(h : m < n)"},
 {"type": "n + m - k = n - k + m",
  "tactic-prompt":
  "theorem {n m k : Nat}  (h : k â‰¤ n) : n + m - k = n - k + m := by rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]; sorry",
  "name": "sub_add_comm",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]",
  "core-prompt": "{n m k : Nat}  (h : k â‰¤ n) : n + m - k = n - k + m",
  "args": "{n m k : Nat}  (h : k â‰¤ n)"},
 {"type": "n - 1 - i < n",
  "tactic-prompt":
  "theorem (h : i < n) : n - 1 - i < n := by rw [Nat.sub_sub]; sorry",
  "name": "sub_one_sub_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(h : i < n) : n - 1 - i < n",
  "args": "(h : i < n)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "theorem {a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b) : b - a < b := by apply sub_lt _ hâ‚€; sorry",
  "name": "sub_lt_self",
  "kind": "theorem",
  "first-tactic": "apply sub_lt _ hâ‚€",
  "core-prompt": "{a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b) : b - a < b",
  "args": "{a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b)"},
 {"type": "m + (n - m) = n",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : m â‰¤ n) : m + (n - m) = n := by rw [Nat.add_comm]; sorry",
  "name": "add_sub_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n m : Nat}  (h : m â‰¤ n) : m + (n - m) = n",
  "args": "{n m : Nat}  (h : m â‰¤ n)"},
 {"type": "k - n < m",
  "tactic-prompt":
  "theorem {n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m) : k - n < m := by have := Nat.sub_le_sub_right (succ_le_of_lt h) n; sorry",
  "name": "sub_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have := Nat.sub_le_sub_right (succ_le_of_lt h) n",
  "core-prompt": "{n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m) : k - n < m",
  "args": "{n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m)"},
 {"type": "x â‰¤ y - k â†” x + k â‰¤ y",
  "tactic-prompt":
  "theorem {x y k : Nat}  (h : k â‰¤ y) : x â‰¤ y - k â†” x + k â‰¤ y := by rw [â† Nat.add_sub_cancel x k]; sorry",
  "name": "le_sub_iff_add_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.add_sub_cancel x k]",
  "core-prompt": "{x y k : Nat}  (h : k â‰¤ y) : x â‰¤ y - k â†” x + k â‰¤ y",
  "args": "{x y k : Nat}  (h : k â‰¤ y)"},
 {"type": "(x + z) % z = x % z",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % z = x % z := by rw [mod_eq_sub_mod (Nat.le_add_left ..)]; sorry",
  "name": "add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_sub_mod (Nat.le_add_left ..)]",
  "core-prompt": "(x z : Nat) : (x + z) % z = x % z",
  "args": "(x z : Nat)"},
 {"type": "(x + z) % x = z % x",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % x = z % x := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(x z : Nat) : (x + z) % x = z % x",
  "args": "(x z : Nat)"},
 {"type": "(x + y * z) % y = x % y",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % y = x % y := by match z with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "add_mul_mod_self_left",
  "kind": "theorem",
  "first-tactic": "match z with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % y = x % y",
  "args": "(x y z : Nat)"},
 {"type": "(x + y * z) % z = x % z",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % z = x % z := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_mod_self_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % z = x % z",
  "args": "(x y z : Nat)"},
 {"type": "(m * n) % m = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % m = 0 := by rw [â† Nat.zero_add (m * n)]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.zero_add (m * n)]",
  "core-prompt": "(m n : Nat) : (m * n) % m = 0",
  "args": "(m n : Nat)"},
 {"type": "(m * n) % n = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % n = 0 := by rw [Nat.mul_comm]; sorry",
  "name": "mul_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : (m * n) % n = 0",
  "args": "(m n : Nat)"},
 {"type": "(x * z) % (y * z) = (x % y) * z",
  "tactic-prompt":
  "theorem (z x y : Nat) : (x * z) % (y * z) = (x % y) * z := by rw [Nat.mul_comm x z]; sorry",
  "name": "mul_mod_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm x z]",
  "core-prompt": "(z x y : Nat) : (x * z) % (y * z) = (x % y) * z",
  "args": "(z x y : Nat)"},
 {"type": "(x - n*k) % n = x % n",
  "tactic-prompt":
  "theorem {x k n : Nat}  (hâ‚ : n*k â‰¤ x) : (x - n*k) % n = x % n := by match k with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "sub_mul_mod",
  "kind": "theorem",
  "first-tactic": "match k with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "{x k n : Nat}  (hâ‚ : n*k â‰¤ x) : (x - n*k) % n = x % n",
  "args": "{x k n : Nat}  (hâ‚ : n*k â‰¤ x)"},
 {"type": "(x - n*p) / n = x / n - p",
  "tactic-prompt":
  "theorem (x n p : Nat)  (hâ‚ : n*p â‰¤ x) : (x - n*p) / n = x / n - p := by match eq_zero_or_pos n with\n  | .inl hâ‚€ => rw [hâ‚€]; sorry",
  "name": "sub_mul_div",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos n with\n  | .inl hâ‚€ => rw [hâ‚€]",
  "core-prompt": "(x n p : Nat)  (hâ‚ : n*p â‰¤ x) : (x - n*p) / n = x / n - p",
  "args": "(x n p : Nat)  (hâ‚ : n*p â‰¤ x)"},
 {"type": "(x + z) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z) := by rw [div_eq_sub_div H (Nat.le_add_left _ _)]; sorry",
  "name": "add_div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_sub_div H (Nat.le_add_left _ _)]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "(z + x) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z) := by rw [Nat.add_comm]; sorry",
  "name": "add_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / m = n",
  "tactic-prompt":
  "theorem (n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n := by induction n; sorry",
  "name": "mul_div_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n",
  "args": "(n : Nat)  {m : Nat}  (H : 0 < m)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n / n = 1",
  "tactic-prompt":
  "theorem (H : 0 < n) : n / n = 1 := by let t := add_div_right 0 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "let t := add_div_right 0 H",
  "core-prompt": "(H : 0 < n) : n / n = 1",
  "args": "(H : 0 < n)"},
 {"type": "(x + y * z) / y = x / y + z",
  "tactic-prompt":
  "theorem (x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z := by induction z; sorry",
  "name": "add_mul_div_left",
  "kind": "theorem",
  "first-tactic": "induction z",
  "core-prompt":
  "(x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z",
  "args": "(x z : Nat)  {y : Nat}  (H : 0 < y)"},
 {"type": "(x + y * z) / z = x / z + y",
  "tactic-prompt":
  "theorem (x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_div_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "(x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y",
  "args": "(x y : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by let t := add_mul_div_right 0 m H; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "let t := add_mul_div_right 0 m H",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n * m / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = k * n) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = k * n) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = k * n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = n * k) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = n * k) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = n * k)"},
 {"type": "(n * p - succ x) / n = p - succ (x / n)",
  "tactic-prompt":
  "theorem (x n p : Nat)  (hâ‚ : x < n*p) : (n * p - succ x) / n = p - succ (x / n) := by have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]; sorry",
  "name": "mul_sub_div",
  "kind": "theorem",
  "first-tactic":
  "have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]",
  "core-prompt":
  "(x n p : Nat)  (hâ‚ : x < n*p) : (n * p - succ x) / n = p - succ (x / n)",
  "args": "(x n p : Nat)  (hâ‚ : x < n*p)"},
 {"type": "m / n / k = m / (n * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m / n / k = m / (n * k) := by cases eq_zero_or_pos k; sorry",
  "name": "div_div_eq_div_mul",
  "kind": "theorem",
  "first-tactic": "cases eq_zero_or_pos k",
  "core-prompt": "(m n k : Nat) : m / n / k = m / (n * k)",
  "args": "(m n k : Nat)"},
 {"type": "m * n / (m * k) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k := by rw [â† Nat.div_div_eq_div_mul]; sorry",
  "name": "mul_div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.div_div_eq_div_mul]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * m / (k * m) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : n * m / (k * m) = n / k := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : n * m / (k * m) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * (m / n) â‰¤ m",
  "tactic-prompt":
  "theorem (m n : Nat) : n * (m / n) â‰¤ m := by match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, â† Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/; sorry",
  "name": "mul_div_le",
  "kind": "theorem",
  "first-tactic":
  "match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, â† Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/",
  "core-prompt": "(m n : Nat) : n * (m / n) â‰¤ m",
  "args": "(m n : Nat)"},
 {"type": "k âˆ£ m â†” k âˆ£ m + n",
  "tactic-prompt":
  "theorem {k m n : Nat}  (h : k âˆ£ n) : k âˆ£ m â†” k âˆ£ m + n := by rw [Nat.add_comm]; sorry",
  "name": "dvd_add_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{k m n : Nat}  (h : k âˆ£ n) : k âˆ£ m â†” k âˆ£ m + n",
  "args": "{k m n : Nat}  (h : k âˆ£ n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n % m = 0) : m âˆ£ n := by exists n / m; sorry",
  "name": "dvd_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "exists n / m",
  "core-prompt": "{m n : Nat}  (H : n % m = 0) : m âˆ£ n",
  "args": "{m n : Nat}  (H : n % m = 0)"},
 {"type": "n % m = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : m âˆ£ n) : n % m = 0 := by let âŸ¨z, HâŸ© := H; sorry",
  "name": "mod_eq_zero_of_dvd",
  "kind": "theorem",
  "first-tactic": "let âŸ¨z, HâŸ© := H",
  "core-prompt": "{m n : Nat}  (H : m âˆ£ n) : n % m = 0",
  "args": "{m n : Nat}  (H : m âˆ£ n)"},
 {"type": "n * (m / n) = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n âˆ£ m) : n * (m / n) = m := by have := mod_add_div m n; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div m n",
  "core-prompt": "{n m : Nat}  (H : n âˆ£ m) : n * (m / n) = m",
  "args": "{n m : Nat}  (H : n âˆ£ m)"},
 {"type": "m / n * n = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n âˆ£ m) : m / n * n = m := by rw [Nat.mul_comm]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "{n m : Nat}  (H : n âˆ£ m) : m / n * n = m",
  "args": "{n m : Nat}  (H : n âˆ£ m)"},
 {"type": "m * n / k = m * (n / k)",
  "tactic-prompt":
  "theorem (m : Nat)  (H : k âˆ£ n) : m * n / k = m * (n / k) := by match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]",
  "core-prompt": "(m : Nat)  (H : k âˆ£ n) : m * n / k = m * (n / k)",
  "args": "(m : Nat)  (H : k âˆ£ n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : k * m âˆ£ k * n) : m âˆ£ n := by let âŸ¨l, HâŸ© := H; sorry",
  "name": "dvd_of_mul_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let âŸ¨l, HâŸ© := H",
  "core-prompt": "(kpos : 0 < k)  (H : k * m âˆ£ k * n) : m âˆ£ n",
  "args": "(kpos : 0 < k)  (H : k * m âˆ£ k * n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : m * k âˆ£ n * k) : m âˆ£ n := by rw [Nat.mul_comm m k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(kpos : 0 < k)  (H : m * k âˆ£ n * k) : m âˆ£ n",
  "args": "(kpos : 0 < k)  (H : m * k âˆ£ n * k)"},
 {"type": "c * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Nat}  (hâ‚ : a â‰¤ b) : c * a â‰¤ c * b := by if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (hâ‚ : a â‰¤ b) : c * a â‰¤ c * b",
  "args": "{a b c : Nat}  (hâ‚ : a â‰¤ b)"},
 {"type": "a * c â‰¤ b * c",
  "tactic-prompt":
  "theorem {a b c : Nat}  (hâ‚ : a â‰¤ b) : a * c â‰¤ b * c := by if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (hâ‚ : a â‰¤ b) : a * c â‰¤ b * c",
  "args": "{a b c : Nat}  (hâ‚ : a â‰¤ b)"},
 {"type": "a * b % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : a * b % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    â† mod_add_div a n]; sorry",
  "name": "mul_mod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    â† mod_add_div a n]",
  "core-prompt": "(a b n : Nat) : a * b % n = (a % n) * (b % n) % n",
  "args": "(a b n : Nat)"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m % n + k) % n = (m + k) % n := by have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "mod_add_mod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Nat) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Nat)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m + n % k) % k = (m + n) % k := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_mod",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(m n k : Nat) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Nat)"},
 {"type": "(a + b) % n = ((a % n) + (b % n)) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n := by rw [add_mod_mod]; sorry",
  "name": "add_mod",
  "kind": "theorem",
  "first-tactic": "rw [add_mod_mod]",
  "core-prompt": "(a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n",
  "args": "(a b n : Nat)"},
 {"type": "m ^ n.succ = m * m ^ n",
  "tactic-prompt":
  "theorem {m n : Nat} : m ^ n.succ = m * m ^ n := by rw [Nat.pow_succ]; sorry",
  "name": "pow_succ'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_succ]",
  "core-prompt": "{m n : Nat} : m ^ n.succ = m * m ^ n",
  "args": "{m n : Nat}"},
 {"type": "1 <<< n = 2 ^ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 <<< n = 2 ^ n := by rw [shiftLeft_eq]; sorry",
  "name": "one_shiftLeft",
  "kind": "theorem",
  "first-tactic": "rw [shiftLeft_eq]",
  "core-prompt": "(n : Nat) : 1 <<< n = 2 ^ n",
  "args": "(n : Nat)"},
 {"type": "k â‰¤ n.log2 â†” 2 ^ k â‰¤ n",
  "tactic-prompt":
  "theorem (h : n â‰  0) : k â‰¤ n.log2 â†” 2 ^ k â‰¤ n := by match k with\n  | 0 => simp [show 1 â‰¤ n from Nat.pos_of_ne_zero h]\n  | k+1 =>\n    rw [log2]; split\n    Â· have n0 : 0 < n / 2 := (Nat.le_div_iff_mul_le (by decide)).2 â€¹_â€º\n      simp [Nat.add_le_add_iff_le_right]; sorry",
  "name": "le_log2",
  "kind": "theorem",
  "first-tactic":
  "match k with\n  | 0 => simp [show 1 â‰¤ n from Nat.pos_of_ne_zero h]\n  | k+1 =>\n    rw [log2]; split\n    Â· have n0 : 0 < n / 2 := (Nat.le_div_iff_mul_le (by decide)).2 â€¹_â€º\n      simp [Nat.add_le_add_iff_le_right]",
  "core-prompt": "(h : n â‰  0) : k â‰¤ n.log2 â†” 2 ^ k â‰¤ n",
  "args": "(h : n â‰  0)"},
 {"type": "n.log2 < k â†” n < 2 ^ k",
  "tactic-prompt":
  "theorem (h : n â‰  0) : n.log2 < k â†” n < 2 ^ k := by rw [â† Nat.not_le]; sorry",
  "name": "log2_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.not_le]",
  "core-prompt": "(h : n â‰  0) : n.log2 < k â†” n < 2 ^ k",
  "args": "(h : n â‰  0)"},
 {"type": "Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚",
  "tactic-prompt":
  "theorem  : Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚ := by induction lâ‚; sorry",
  "name": "sum_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt": " : Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚",
  "args": ""},
 {"type": "fdiv 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fdiv 0 b = 0 := by cases b; sorry",
  "name": "zero_fdiv",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fdiv 0 b = 0",
  "args": "(b : Int)"},
 {"type": "(-a).div (-b) = a.div b",
  "tactic-prompt":
  "theorem (a b : Int) : (-a).div (-b) = a.div b := by simp [Int.div_neg]; sorry",
  "name": "neg_div_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.div_neg]",
  "core-prompt": "(a b : Int) : (-a).div (-b) = a.div b",
  "args": "(a b : Int)"},
 {"type": "(a + b) / c = a / c + b / c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : c âˆ£ a) : (a + b) / c = a / c + b / c := by rw [Int.add_comm]; sorry",
  "name": "add_ediv_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : c âˆ£ a) : (a + b) / c = a / c + b / c",
  "args": "{a b c : Int}  (H : c âˆ£ a)"},
 {"type": "(a * b) / b = a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : b â‰  0) : (a * b) / b = a := by have := Int.add_mul_ediv_right 0 a H; sorry",
  "name": "mul_ediv_cancel",
  "kind": "theorem",
  "first-tactic": "have := Int.add_mul_ediv_right 0 a H",
  "core-prompt": "(a : Int)  {b : Int}  (H : b â‰  0) : (a * b) / b = a",
  "args": "(a : Int)  {b : Int}  (H : b â‰  0)"},
 {"type": "a.div a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a.div a = 1 := by have := Int.mul_div_cancel 1 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_div_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a.div a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "a.fdiv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a.fdiv a = 1 := by have := Int.mul_fdiv_cancel 1 H; sorry",
  "name": "fdiv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_fdiv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a.fdiv a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a / a = 1 := by have := Int.mul_ediv_cancel 1 H; sorry",
  "name": "ediv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_ediv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a / a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "â†‘(m % n) = fmod m n",
  "tactic-prompt":
  "theorem (m n : Nat) : â†‘(m % n) = fmod m n := by cases m; sorry",
  "name": "ofNat_fmod",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : â†‘(m % n) = fmod m n",
  "args": "(m n : Nat)"},
 {"type": "mod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : mod 0 b = 0 := by cases b; sorry",
  "name": "zero_mod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : mod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "fmod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fmod 0 b = 0 := by cases b; sorry",
  "name": "zero_fmod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fmod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "0 % b = 0",
  "tactic-prompt": "theorem (b : Int) : 0 % b = 0 := by simp [mod_def']; sorry",
  "name": "zero_emod",
  "kind": "theorem",
  "first-tactic": "simp [mod_def']",
  "core-prompt": "(b : Int) : 0 % b = 0",
  "args": "(b : Int)"},
 {"type": "mod a b = a - b * a.div b",
  "tactic-prompt":
  "theorem (a b : Int) : mod a b = a - b * a.div b := by rw [â† Int.add_sub_cancel (mod a b)]; sorry",
  "name": "mod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (mod a b)]",
  "core-prompt": "(a b : Int) : mod a b = a - b * a.div b",
  "args": "(a b : Int)"},
 {"type": "a.fmod b = a - b * a.fdiv b",
  "tactic-prompt":
  "theorem (a b : Int) : a.fmod b = a - b * a.fdiv b := by rw [â† Int.add_sub_cancel (a.fmod b)]; sorry",
  "name": "fmod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (a.fmod b)]",
  "core-prompt": "(a b : Int) : a.fmod b = a - b * a.fdiv b",
  "args": "(a b : Int)"},
 {"type": "a % b = a - b * (a / b)",
  "tactic-prompt":
  "theorem (a b : Int) : a % b = a - b * (a / b) := by rw [â† Int.add_sub_cancel (a % b)]; sorry",
  "name": "emod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (a % b)]",
  "core-prompt": "(a b : Int) : a % b = a - b * (a / b)",
  "args": "(a b : Int)"},
 {"type": "fmod a b = a % b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (hb : 0 â‰¤ b) : fmod a b = a % b := by simp [fmod_def]; sorry",
  "name": "fmod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int)  {b : Int}  (hb : 0 â‰¤ b) : fmod a b = a % b",
  "args": "(a : Int)  {b : Int}  (hb : 0 â‰¤ b)"},
 {"type": "mod a b = a % b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : mod a b = a % b := by simp [emod_def]; sorry",
  "name": "mod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : mod a b = a % b",
  "args": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "mod a (-b) = mod a b",
  "tactic-prompt":
  "theorem (a b : Int) : mod a (-b) = mod a b := by rw [mod_def]; sorry",
  "name": "mod_neg",
  "kind": "theorem",
  "first-tactic": "rw [mod_def]",
  "core-prompt": "(a b : Int) : mod a (-b) = mod a b",
  "args": "(a b : Int)"},
 {"type": "a % -b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : a % -b = a % b := by rw [emod_def]; sorry",
  "name": "emod_neg",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt": "(a b : Int) : a % -b = a % b",
  "args": "(a b : Int)"},
 {"type": "mod a 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : mod a 1 = 0 := by simp [mod_def]; sorry",
  "name": "mod_one",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt": "(a : Int) : mod a 1 = 0",
  "args": "(a : Int)"},
 {"type": "a % 1 = 0",
  "tactic-prompt": "theorem (a : Int) : a % 1 = 0 := by simp [emod_def]; sorry",
  "name": "emod_one",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "(a : Int) : a % 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.fmod 1 = 0 := by simp [fmod_def]; sorry",
  "name": "fmod_one",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int) : a.fmod 1 = 0",
  "args": "(a : Int)"},
 {"type": "mod a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : mod a b = a := by rw [mod_eq_emod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_emod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : mod a b = a",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b)"},
 {"type": "a.fmod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.fmod b = a := by rw [fmod_eq_emod _ (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "fmod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [fmod_eq_emod _ (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.fmod b = a",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b)"},
 {"type": "mod m k + m.div k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : mod m k + m.div k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : mod m k + m.div k * k = m",
  "args": "(m k : Int)"},
 {"type": "m.div k * k + mod m k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.div k * k + mod m k = m := by rw [Int.mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.div k * k + mod m k = m",
  "args": "(m k : Int)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m % k + m / k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "emod_add_ediv'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m % k + m / k * k = m",
  "args": "(m k : Int)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m / k * k + m % k = m := by rw [Int.mul_comm]; sorry",
  "name": "ediv_add_emod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m / k * k + m % k = m",
  "args": "(m k : Int)"},
 {"type": "(a + b * c) % b = a % b",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b * c) % b = a % b := by rw [Int.mul_comm]; sorry",
  "name": "add_mul_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b * c) % b = a % b",
  "args": "(a b c : Int)"},
 {"type": "(a + b) % b = a % b",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b) % b = a % b := by have := add_mul_emod_self_left a b 1; sorry",
  "name": "add_emod_self",
  "kind": "theorem",
  "first-tactic": "have := add_mul_emod_self_left a b 1",
  "core-prompt": "{a b : Int} : (a + b) % b = a % b",
  "args": "{a b : Int}"},
 {"type": "(a + b) % a = b % a",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b) % a = b % a := by rw [Int.add_comm]; sorry",
  "name": "add_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b : Int} : (a + b) % a = b % a",
  "args": "{a b : Int}"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Int) : (m % n + k) % n = (m + k) % n := by have := (add_mul_emod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "emod_add_emod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_emod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Int) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Int)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Int) : (m + n % k) % k = (m + n) % k := by rw [Int.add_comm]; sorry",
  "name": "add_emod_emod",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(m n k : Int) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Int)"},
 {"type": "(a + b) % n = (a % n + b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a + b) % n = (a % n + b % n) % n := by rw [add_emod_emod]; sorry",
  "name": "add_emod",
  "kind": "theorem",
  "first-tactic": "rw [add_emod_emod]",
  "core-prompt": "(a b n : Int) : (a + b) % n = (a % n + b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [â† emod_add_emod]; sorry",
  "name": "add_emod_eq_add_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† emod_add_emod]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{m n k : Int}  (i : Int)      (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m % n = k % n) : (i + m) % n = (i + k) % n := by rw [Int.add_comm]; sorry",
  "name": "add_emod_eq_add_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m % n = k % n) : (i + m) % n = (i + k) % n",
  "args": "{m n k : Int}  (i : Int)      (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n â†” m % n = k % n",
  "tactic-prompt":
  "theorem {m n k i : Int} : (i + m) % n = (i + k) % n â†” m % n = k % n := by rw [Int.add_comm]; sorry",
  "name": "emod_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{m n k i : Int} : (i + m) % n = (i + k) % n â†” m % n = k % n",
  "args": "{m n k i : Int}"},
 {"type": "(a * b) % b = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b) % b = 0 := by rw [â† Int.zero_add (a * b)]; sorry",
  "name": "mul_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.zero_add (a * b)]",
  "core-prompt": "(a b : Int) : (a * b) % b = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).mod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).mod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).mod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).fmod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).fmod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_fmod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).fmod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b) % a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b) % a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b) % a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b) % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a * b) % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    â† emod_add_ediv a n]; sorry",
  "name": "mul_emod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    â† emod_add_ediv a n]",
  "core-prompt": "(a b n : Int) : (a * b) % n = (a % n) * (b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "a.mod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.mod a = 0 := by have := mul_mod_left 1 a; sorry",
  "name": "mod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_mod_left 1 a",
  "core-prompt": "{a : Int} : a.mod a = 0",
  "args": "{a : Int}"},
 {"type": "a.fmod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.fmod a = 0 := by have := mul_fmod_left 1 a; sorry",
  "name": "fmod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_fmod_left 1 a",
  "core-prompt": "{a : Int} : a.fmod a = 0",
  "args": "{a : Int}"},
 {"type": "a % a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a % a = 0 := by have := mul_emod_left 1 a; sorry",
  "name": "emod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_emod_left 1 a",
  "core-prompt": "{a : Int} : a % a = 0",
  "args": "{a : Int}"},
 {"type": "(n % k) % m = n % m",
  "tactic-prompt":
  "theorem (n : Int)  {m k : Int}      (h : m âˆ£ k) : (n % k) % m = n % m := by conv => rhs; rw [â† emod_add_ediv n k]; sorry",
  "name": "emod_emod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [â† emod_add_ediv n k]",
  "core-prompt":
  "(n : Int)  {m k : Int}      (h : m âˆ£ k) : (n % k) % m = n % m",
  "args": "(n : Int)  {m k : Int}      (h : m âˆ£ k)"},
 {"type": "(a % b) % b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : (a % b) % b = a % b := by conv => rhs; rw [â† emod_add_ediv a b]; sorry",
  "name": "emod_emod",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [â† emod_add_ediv a b]",
  "core-prompt": "(a b : Int) : (a % b) % b = a % b",
  "args": "(a b : Int)"},
 {"type": "(a - b) % n = (a % n - b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a - b) % n = (a % n - b % n) % n := by apply (emod_add_cancel_right b).mp; sorry",
  "name": "sub_emod",
  "kind": "theorem",
  "first-tactic": "apply (emod_add_cancel_right b).mp",
  "core-prompt": "(a b n : Int) : (a - b) % n = (a % n - b % n) % n",
  "args": "(a b n : Int)"},
 {"type": "a / b = q âˆ§ a % b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b",
  "tactic-prompt":
  "theorem {a b r q : Int}  (h : 0 < b) : a / b = q âˆ§ a % b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b := by constructor; sorry",
  "name": "ediv_emod_unique",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b r q : Int}  (h : 0 < b) : a / b = q âˆ§ a % b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b",
  "args": "{a b r q : Int}  (h : 0 < b)"},
 {"type": "(a * b) / (c * b) = a / c",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b) / (c * b) = a / c := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b) / (c * b) = a / c",
  "args": "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b)"},
 {"type": "(a * b) % (a * c) = a * (b % c)",
  "tactic-prompt":
  "theorem {a : Int}  (b c : Int)  (H : 0 < a) : (a * b) % (a * c) = a * (b % c) := by rw [emod_def]; sorry",
  "name": "mul_emod_mul_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt":
  "{a : Int}  (b c : Int)  (H : 0 < a) : (a * b) % (a * c) = a * (b % c)",
  "args": "{a : Int}  (b c : Int)  (H : 0 < a)"},
 {"type": "a < (a.div b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a.div b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_div_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a.div b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a < (a / b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_ediv_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a / b â‰¤ a",
  "tactic-prompt":
  "theorem {a : Int}  (b : Int)  (Ha : 0 â‰¤ a) : a / b â‰¤ a := by have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b); sorry",
  "name": "ediv_le_self",
  "kind": "theorem",
  "first-tactic":
  "have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b)",
  "core-prompt": "{a : Int}  (b : Int)  (Ha : 0 â‰¤ a) : a / b â‰¤ a",
  "args": "{a : Int}  (b : Int)  (Ha : 0 â‰¤ a)"},
 {"type": "b * (a.div b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.mod b = 0) : b * (a.div b) = a := by have := mod_add_div a b; sorry",
  "name": "mul_div_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div a b",
  "core-prompt": "{a b : Int}  (H : a.mod b = 0) : b * (a.div b) = a",
  "args": "{a b : Int}  (H : a.mod b = 0)"},
 {"type": "a.div b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.mod b = 0) : a.div b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "div_mul_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a.mod b = 0) : a.div b * b = a",
  "args": "{a b : Int}  (H : a.mod b = 0)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : b * (a / b) = a := by have := emod_add_ediv a b; sorry",
  "name": "mul_ediv_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := emod_add_ediv a b",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : b * (a / b) = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : a / b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "ediv_mul_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : a / b * b = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "-a âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : -a âˆ£ b â†” a âˆ£ b := by constructor; sorry",
  "name": "neg_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : -a âˆ£ b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "a âˆ£ -b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : a âˆ£ -b â†” a âˆ£ b := by constructor; sorry",
  "name": "dvd_neg",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a âˆ£ -b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "a âˆ£ b + c â†” a âˆ£ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c := by rw [Int.add_comm]; sorry",
  "name": "dvd_add_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c",
  "args": "{a b c : Int}  (H : a âˆ£ b)"},
 {"type": "a âˆ£ b â†” a âˆ£ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a âˆ£ b + c) : a âˆ£ b â†” a âˆ£ c := by rw [â† Int.sub_neg] at H; sorry",
  "name": "dvd_iff_dvd_of_dvd_add",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.sub_neg] at H",
  "core-prompt": "{a b c : Int}  (H : a âˆ£ b + c) : a âˆ£ b â†” a âˆ£ c",
  "args": "{a b c : Int}  (H : a âˆ£ b + c)"},
 {"type": "(â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n",
  "tactic-prompt":
  "theorem {m n : Nat} : (â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n := by refine âŸ¨fun âŸ¨a, aeâŸ© => ?_, fun âŸ¨k, eâŸ© => âŸ¨k, by rw [e, Int.ofNat_mul]âŸ©âŸ©; sorry",
  "name": "ofNat_dvd",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun âŸ¨a, aeâŸ© => ?_, fun âŸ¨k, eâŸ© => âŸ¨k, by rw [e, Int.ofNat_mul]âŸ©âŸ©",
  "core-prompt": "{m n : Nat} : (â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n",
  "args": "{m n : Nat}"},
 {"type": "natAbs a âˆ£ natAbs b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : natAbs a âˆ£ natAbs b â†” a âˆ£ b := by refine âŸ¨fun âŸ¨k, hkâŸ© => ?_, fun âŸ¨k, hkâŸ© => âŸ¨natAbs k, hk.symm â–¸ natAbs_mul a kâŸ©âŸ©; sorry",
  "name": "natAbs_dvd_natAbs",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun âŸ¨k, hkâŸ© => ?_, fun âŸ¨k, hkâŸ© => âŸ¨natAbs k, hk.symm â–¸ natAbs_mul a kâŸ©âŸ©",
  "core-prompt": "{a b : Int} : natAbs a âˆ£ natAbs b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "(â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : (â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs := by rw [â† natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : (â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n := by rw [â† natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "a âˆ£ b â†’ b âˆ£ a â†’ a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b) : a âˆ£ b â†’ b âˆ£ a â†’ a = b := by rw [â† natAbs_of_nonneg H1]; sorry",
  "name": "dvd_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_of_nonneg H1]",
  "core-prompt":
  "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b) : a âˆ£ b â†’ b âˆ£ a â†’ a = b",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b)"},
 {"type": "b âˆ£ a - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a % b = c) : b âˆ£ a - c := by have hx : (a % b) % b = c % b := by\n    rw [h]; sorry",
  "name": "dvd_sub_of_emod_eq",
  "kind": "theorem",
  "first-tactic": "have hx : (a % b) % b = c % b := by\n    rw [h]",
  "core-prompt": "{a b c : Int}  (h : a % b = c) : b âˆ£ a - c",
  "args": "{a b c : Int}  (h : a % b = c)"},
 {"type": "a * b.div a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a âˆ£ b) : a * b.div a = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a âˆ£ b) : a * b.div a = b",
  "args": "{a b : Int}  (H : a âˆ£ b)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a âˆ£ b) : a * (b / a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a âˆ£ b) : a * (b / a) = b",
  "args": "{a b : Int}  (H : a âˆ£ b)"},
 {"type": "(a * b).div c = a.div c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}  (h : c âˆ£ a) : (a * b).div c = a.div c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}  (h : c âˆ£ a) : (a * b).div c = a.div c * b",
  "args": "(b : Int)  {a c : Int}  (h : c âˆ£ a)"},
 {"type": "(a * b) / c = a / c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}      (h : c âˆ£ a) : (a * b) / c = a / c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}      (h : c âˆ£ a) : (a * b) / c = a / c * b",
  "args": "(b : Int)  {a c : Int}      (h : c âˆ£ a)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c) : a = b * c := by rw [â† H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c := by rw [â† H2]; sorry",
  "name": "eq_mul_of_ediv_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "a.div b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a.div b = c := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a.div b = c",
  "args": "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a / b = c := by rw [H2]; sorry",
  "name": "ediv_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a / b = c",
  "args": "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c)"},
 {"type": "a.div b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a.div b = c â†” a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a.div b = c â†” a = c * b",
  "args": "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a)"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a / b = c â†” a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "ediv_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a / b = c â†” a = c * b",
  "args": "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.div b = c)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_ediv_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d âˆ£ n)  (H : n.div d = 0) : n = 0 := by rw [â† Int.mul_div_cancel' h]; sorry",
  "name": "eq_zero_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_div_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d âˆ£ n)  (H : n.div d = 0) : n = 0",
  "args": "{d n : Int}  (h : d âˆ£ n)  (H : n.div d = 0)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d âˆ£ n)  (H : n / d = 0) : n = 0 := by rw [â† Int.mul_ediv_cancel' h]; sorry",
  "name": "eq_zero_of_ediv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_ediv_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d âˆ£ n)  (H : n / d = 0) : n = 0",
  "args": "{d n : Int}  (h : d âˆ£ n)  (H : n / d = 0)"},
 {"type": "a.div b = a / b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b âˆ£ a) : a.div b = a / b := by if b0 : b = 0 then simp [b0]\n  else rw [Int.div_eq_iff_eq_mul_left b0 h]; sorry",
  "name": "div_eq_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic":
  "if b0 : b = 0 then simp [b0]\n  else rw [Int.div_eq_iff_eq_mul_left b0 h]",
  "core-prompt": "{a b : Int}  (h : b âˆ£ a) : a.div b = a / b",
  "args": "{a b : Int}  (h : b âˆ£ a)"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem (a : Int)  {b c : Int}      (hcb : c âˆ£ b) : (a - b) / c = a / c - b / c := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt":
  "(a : Int)  {b c : Int}      (hcb : c âˆ£ b) : (a - b) / c = a / c - b / c",
  "args": "(a : Int)  {b c : Int}      (hcb : c âˆ£ b)"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hcab : c âˆ£ a - b) : (a - b) / c = a / c - b / c := by rw [â† Int.add_sub_cancel ((a-b) / c)]; sorry",
  "name": "sub_ediv_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel ((a-b) / c)]",
  "core-prompt":
  "{a b c : Int}      (hcab : c âˆ£ a - b) : (a - b) / c = a / c - b / c",
  "args": "{a b c : Int}      (hcab : c âˆ£ a - b)"},
 {"type": "a.div d = b.div d â†” a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a.div d = b.div d â†” a = b := by refine âŸ¨fun h => ?_, congrArg (div Â· d)âŸ©; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, congrArg (div Â· d)âŸ©",
  "core-prompt":
  "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a.div d = b.div d â†” a = b",
  "args": "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b)"},
 {"type": "a / d = b / d â†” a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b := by refine âŸ¨fun h => ?_, congrArg (ediv Â· d)âŸ©; sorry",
  "name": "ediv_left_inj",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, congrArg (ediv Â· d)âŸ©",
  "core-prompt":
  "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b",
  "args": "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b)"},
 {"type": "a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b := by rw [â† Int.div_mul_cancel H2]; sorry",
  "name": "le_mul_of_div_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.div_mul_cancel H2]",
  "core-prompt":
  "{a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b",
  "args": "{a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d) : a = c / b * d",
  "args": "{a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [â† natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_ofNatAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd]",
  "core-prompt": "{a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a)"},
 {"type": "t / s âˆ£ t",
  "tactic-prompt":
  "theorem {s t : Int}  (hst : s âˆ£ t) : t / s âˆ£ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{s t : Int}  (hst : s âˆ£ t) : t / s âˆ£ t",
  "args": "{s t : Int}  (hst : s âˆ£ t)"},
 {"type": "b âˆ£ c / a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a * b âˆ£ c) : b âˆ£ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b c : Int}  (h : a * b âˆ£ c) : b âˆ£ c / a",
  "args": "{a b c : Int}  (h : a * b âˆ£ c)"},
 {"type": "subNatNat m n = â†‘(m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n - m = 0) : subNatNat m n = â†‘(m - n) := by rw [subNatNat]; sorry",
  "name": "subNatNat_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [subNatNat]",
  "core-prompt": "{m n : Nat}  (h : n - m = 0) : subNatNat m n = â†‘(m - n)",
  "args": "{m n : Nat}  (h : n - m = 0)"},
 {"type": "subNatNat (m + n) m = n",
  "tactic-prompt":
  "theorem  : subNatNat (m + n) m = n := by unfold subNatNat; sorry",
  "name": "subNatNat_add_left",
  "kind": "theorem",
  "first-tactic": "unfold subNatNat",
  "core-prompt": " : subNatNat (m + n) m = n",
  "args": ""},
 {"type": "subNatNat m (m + n + 1) = negSucc n",
  "tactic-prompt":
  "theorem  : subNatNat m (m + n + 1) = negSucc n := by simp [subNatNat]; sorry",
  "name": "subNatNat_add_right",
  "kind": "theorem",
  "first-tactic": "simp [subNatNat]",
  "core-prompt": " : subNatNat m (m + n + 1) = negSucc n",
  "args": ""},
 {"type": "subNatNat (m + k) (n + k) = subNatNat m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n := by apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i); sorry",
  "name": "subNatNat_add_add",
  "kind": "theorem",
  "first-tactic":
  "apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)",
  "core-prompt": "(m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n",
  "args": "(m n k : Nat)"},
 {"type": "0 < natAbs a â†” a â‰  0",
  "tactic-prompt":
  "theorem  : 0 < natAbs a â†” a â‰  0 := by rw [Nat.pos_iff_ne_zero]; sorry",
  "name": "natAbs_pos",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pos_iff_ne_zero]",
  "core-prompt": " : 0 < natAbs a â†” a â‰  0",
  "args": ""},
 {"type": "natAbs (negOfNat n) = n",
  "tactic-prompt":
  "theorem (n : Nat) : natAbs (negOfNat n) = n := by cases n; sorry",
  "name": "natAbs_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : natAbs (negOfNat n) = n",
  "args": "(n : Nat)"},
 {"type": "natAbs (a * b) = natAbs a * natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a * b) = natAbs a * natAbs b := by cases a; sorry",
  "name": "natAbs_mul",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : natAbs (a * b) = natAbs a * natAbs b",
  "args": "(a b : Int)"},
 {"type": "a.natAbs * b.natAbs = c",
  "tactic-prompt":
  "theorem {a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c := by rw [â† natAbs_mul]; sorry",
  "name": "natAbs_mul_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_mul]",
  "core-prompt":
  "{a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c",
  "args": "{a b : Int}  {c : Nat}      (h : a * b = (c : Int))"},
 {"type": "(natAbs a * natAbs a : Int) = a * a",
  "tactic-prompt":
  "theorem (a : Int) : (natAbs a * natAbs a : Int) = a * a := by rw [â† Int.ofNat_mul]; sorry",
  "name": "natAbs_mul_self'",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.ofNat_mul]",
  "core-prompt": "(a : Int) : (natAbs a * natAbs a : Int) = a * a",
  "args": "(a : Int)"},
 {"type": "a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {a b : Int} : a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b := by constructor; sorry",
  "name": "natAbs_eq_natAbs_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b",
  "args": "{a b : Int}"},
 {"type": "a.natAbs = n â†” a = n âˆ¨ a = -â†‘n",
  "tactic-prompt":
  "theorem {a : Int}  {n : Nat} : a.natAbs = n â†” a = n âˆ¨ a = -â†‘n := by rw [â† Int.natAbs_eq_natAbs_iff]; sorry",
  "name": "natAbs_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.natAbs_eq_natAbs_iff]",
  "core-prompt": "{a : Int}  {n : Nat} : a.natAbs = n â†” a = n âˆ¨ a = -â†‘n",
  "args": "{a : Int}  {n : Nat}"},
 {"type": "z.sign.natAbs = 1",
  "tactic-prompt":
  "theorem {z : Int}  (hz : z â‰  0) : z.sign.natAbs = 1 := by rw [Int.natAbs_sign]; sorry",
  "name": "natAbs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [Int.natAbs_sign]",
  "core-prompt": "{z : Int}  (hz : z â‰  0) : z.sign.natAbs = 1",
  "args": "{z : Int}  (hz : z â‰  0)"},
 {"type": "subNatNat (m - n) k = subNatNat m (k + n)",
  "tactic-prompt":
  "theorem (h : n â‰¤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n) := by rwa [â† subNatNat_add_add _ _ n]; sorry",
  "name": "subNatNat_sub",
  "kind": "theorem",
  "first-tactic": "rwa [â† subNatNat_add_add _ _ n]",
  "core-prompt":
  "(h : n â‰¤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n)",
  "args": "(h : n â‰¤ m)  (k : Nat)"},
 {"type": "subNatNat (m + n) k = m + subNatNat n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + n) k = m + subNatNat n k := by cases n.lt_or_ge k; sorry",
  "name": "subNatNat_add",
  "kind": "theorem",
  "first-tactic": "cases n.lt_or_ge k",
  "core-prompt": "(m n k : Nat) : subNatNat (m + n) k = m + subNatNat n k",
  "args": "(m n k : Nat)"},
 {"type": "a + (b + c) = b + (a + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + (b + c) = b + (a + c) := by rw [â† Int.add_assoc]; sorry",
  "name": "add_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + (b + c) = b + (a + c)",
  "args": "(a b c : Int)"},
 {"type": "a + b + c = a + c + b",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b + c = a + c + b := by rw [Int.add_assoc]; sorry",
  "name": "add_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + b + c = a + c + b",
  "args": "(a b c : Int)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a + -a = 0 := by rw [Int.add_comm]; sorry",
  "name": "add_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(a : Int) : a + -a = 0",
  "args": "(a : Int)"},
 {"type": "-a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a + b = 0) : -a = b := by rw [â† Int.add_zero (-a)]; sorry",
  "name": "neg_eq_of_add_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_zero (-a)]",
  "core-prompt": "{a b : Int}  (h : a + b = 0) : -a = b",
  "args": "{a b : Int}  (h : a + b = 0)"},
 {"type": "b = -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = -b) : b = -a := by rw [h]; sorry",
  "name": "eq_neg_of_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = -b) : b = -a",
  "args": "{a b : Int}  (h : a = -b)"},
 {"type": "-a = b â†” -b = a",
  "tactic-prompt":
  "theorem {a b : Int} : -a = b â†” -b = a := by rw [eq_comm]; sorry",
  "name": "neg_eq_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "{a b : Int} : -a = b â†” -b = a",
  "args": "{a b : Int}"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : -a + (a + b) = b := by rw [â† Int.add_assoc]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b : Int) : -a + (a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + (-a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a + (-a + b) = b := by rw [â† Int.add_assoc]; sorry",
  "name": "add_neg_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + (-a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + b + -b = a := by rw [Int.add_assoc]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + b + -b = a",
  "args": "(a b : Int)"},
 {"type": "a + -b + b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + -b + b = a := by rw [Int.add_assoc]; sorry",
  "name": "neg_add_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + -b + b = a",
  "args": "(a b : Int)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b = a + c) : b = c := by have hâ‚ : -a + (a + b) = -a + (a + c) := by rw [h]; sorry",
  "name": "add_left_cancel",
  "kind": "theorem",
  "first-tactic": "have hâ‚ : -a + (a + b) = -a + (a + c) := by rw [h]",
  "core-prompt": "{a b c : Int}  (h : a + b = a + c) : b = c",
  "args": "{a b c : Int}  (h : a + b = a + c)"},
 {"type": "-(a + b) = -a + -b",
  "tactic-prompt":
  "theorem {a b : Int} : -(a + b) = -a + -b := by apply Int.add_left_cancel (a := a + b); sorry",
  "name": "neg_add",
  "kind": "theorem",
  "first-tactic": "apply Int.add_left_cancel (a := a + b)",
  "core-prompt": "{a b : Int} : -(a + b) = -a + -b",
  "args": "{a b : Int}"},
 {"type": "a - a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a - a = 0 := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - a = 0",
  "args": "(a : Int)"},
 {"type": "a - 0 = a",
  "tactic-prompt":
  "theorem (a : Int) : a - 0 = a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_zero",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - 0 = a",
  "args": "(a : Int)"},
 {"type": "0 - a = -a",
  "tactic-prompt":
  "theorem (a : Int) : 0 - a = -a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "zero_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : 0 - a = -a",
  "args": "(a : Int)"},
 {"type": "a - b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = b) : a - b = 0 := by rw [h]; sorry",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = b) : a - b = 0",
  "args": "{a b : Int}  (h : a = b)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b = 0) : a = b := by have : 0 + b = b := by rw [Int.zero_add]; sorry",
  "name": "eq_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "have : 0 + b = b := by rw [Int.zero_add]",
  "core-prompt": "{a b : Int}  (h : a - b = 0) : a = b",
  "args": "{a b : Int}  (h : a - b = 0)"},
 {"type": "a - b - c = a - (b + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a - b - c = a - (b + c) := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a - b - c = a - (b + c)",
  "args": "(a b c : Int)"},
 {"type": "-(a - b) = b - a",
  "tactic-prompt":
  "theorem (a b : Int) : -(a - b) = b - a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "neg_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : -(a - b) = b - a",
  "args": "(a b : Int)"},
 {"type": "a - (a - b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a - (a - b) = b := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub_self",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : a - (a - b) = b",
  "args": "(a b : Int)"},
 {"type": "a - -b = a + b",
  "tactic-prompt":
  "theorem (a b : Int) : a - -b = a + b := by simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/; sorry",
  "name": "sub_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/",
  "core-prompt": "(a b : Int) : a - -b = a + b",
  "args": "(a b : Int)"},
 {"type": "a * b = b * a",
  "tactic-prompt": "theorem (a b : Int) : a * b = b * a := by cases a; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : a * b = b * a",
  "args": "(a b : Int)"},
 {"type": "(m : Nat) * negOfNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (m : Nat) * negOfNat n = negOfNat (m * n) := by cases n; sorry",
  "name": "ofNat_mul_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(m n : Nat) : (m : Nat) * negOfNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "negOfNat m * (n : Nat) = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m * (n : Nat) = negOfNat (m * n) := by rw [Int.mul_comm]; sorry",
  "name": "negOfNat_mul_ofNat",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m n : Nat) : negOfNat m * (n : Nat) = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "a * b * c = a * (b * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * (b * c) := by cases a; sorry",
  "name": "mul_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Int) : a * b * c = a * (b * c)",
  "args": "(a b c : Int)"},
 {"type": "a * (b * c) = b * (a * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b * c) = b * (a * c) := by rw [â† Int.mul_assoc]; sorry",
  "name": "mul_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * (b * c) = b * (a * c)",
  "args": "(a b c : Int)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * c * b := by rw [Int.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * b * c = a * c * b",
  "args": "(a b c : Int)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Int) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Int) : a * 0 = 0",
  "args": "(a : Int)"},
 {"type": "m * subNatNat n k = subNatNat (m * n) (m * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m * subNatNat n k = subNatNat (m * n) (m * k) := by cases m; sorry",
  "name": "ofNat_mul_subNatNat",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "(m n k : Nat) : m * subNatNat n k = subNatNat (m * n) (m * k)",
  "args": "(m n k : Nat)"},
 {"type": "negOfNat m + negOfNat n = negOfNat (m + n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n) := by cases m; sorry",
  "name": "negOfNat_add",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n)",
  "args": "(m n : Nat)"},
 {"type": "(a + b) * c = a * c + b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b) * c = a * c + b * c := by simp [Int.mul_comm]; sorry",
  "name": "add_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b) * c = a * c + b * c",
  "args": "(a b c : Int)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt": "theorem (a b : Int) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * -b = a * b",
  "args": "(a b : Int)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt": "theorem (a b : Int) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * b = a * -b",
  "args": "(a b : Int)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b - c) = a * b - a * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "mul_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a * (b - c) = a * b - a * c",
  "args": "(a b c : Int)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a - b) * c = a * c - b * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : (a - b) * c = a * c - b * c",
  "args": "(a b c : Int)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b - c = a + (b - c) := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "add_sub_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a + b - c = a + (b - c)",
  "args": "(a b c : Int)"},
 {"type": "((n - m : Nat) : Int) = n - m",
  "tactic-prompt":
  "theorem (h : m â‰¤ n) : ((n - m : Nat) : Int) = n - m := by match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]; sorry",
  "name": "ofNat_sub",
  "kind": "theorem",
  "first-tactic":
  "match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]",
  "core-prompt": "(h : m â‰¤ n) : ((n - m : Nat) : Int) = n - m",
  "args": "(h : m â‰¤ n)"},
 {"type": "subNatNat m n = â†‘m - â†‘n",
  "tactic-prompt":
  "theorem {m n : Nat} : subNatNat m n = â†‘m - â†‘n := by apply subNatNat_elim m n fun m n i => i = m - n; sorry",
  "name": "subNatNat_eq_coe",
  "kind": "theorem",
  "first-tactic": "apply subNatNat_elim m n fun m n i => i = m - n",
  "core-prompt": "{m n : Nat} : subNatNat m n = â†‘m - â†‘n",
  "args": "{m n : Nat}"},
 {"type": "toNat (m - n) = m - n",
  "tactic-prompt":
  "theorem (m n : Nat) : toNat (m - n) = m - n := by rw [â† Int.subNatNat_eq_coe]; sorry",
  "name": "toNat_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.subNatNat_eq_coe]",
  "core-prompt": "(m n : Nat) : toNat (m - n) = m - n",
  "args": "(m n : Nat)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem (a : Int) : a * 1 = a := by rw [Int.mul_comm]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a : Int) : a * 1 = a",
  "args": "(a : Int)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem (a : Int) : a * -1 = -a := by rw [Int.mul_neg]; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_neg]",
  "core-prompt": "(a : Int) : a * -1 = -a",
  "args": "(a : Int)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (n : Nat)  (h : b - a = n) : a â‰¤ b := by simp [le_def]; sorry",
  "name": "le.intro_sub",
  "kind": "theorem",
  "first-tactic": "simp [le_def]",
  "core-prompt": "{a b : Int}  (n : Nat)  (h : b - a = n) : a â‰¤ b",
  "args": "{a b : Int}  (n : Nat)  (h : b - a = n)"},
 {"type": "âˆƒ n : Nat, a = n",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : âˆƒ n : Nat, a = n := by have t := le.dest_sub h; sorry",
  "name": "eq_ofNat_of_zero_le",
  "kind": "theorem",
  "first-tactic": "have t := le.dest_sub h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : âˆƒ n : Nat, a = n",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "(â†‘n : Int) < â†‘m â†” n < m",
  "tactic-prompt":
  "theorem {n m : Nat} : (â†‘n : Int) < â†‘m â†” n < m := by rw [lt_iff_add_one_le]; sorry",
  "name": "ofNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_add_one_le]",
  "core-prompt": "{n m : Nat} : (â†‘n : Int) < â†‘m â†” n < m",
  "args": "{n m : Nat}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a) : a = b := by let âŸ¨n, hnâŸ© := le.dest hâ‚; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := le.dest hâ‚",
  "core-prompt": "{a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a) : a = b",
  "args": "{a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a)"},
 {"type": "a < b â†” a â‰¤ b âˆ§ a â‰  b",
  "tactic-prompt":
  "theorem {a b : Int} : a < b â†” a â‰¤ b âˆ§ a â‰  b := by refine âŸ¨fun h => âŸ¨Int.le_of_lt h, Int.ne_of_lt hâŸ©, fun âŸ¨aleb, anebâŸ© => ?_âŸ©; sorry",
  "name": "lt_iff_le_and_ne",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun h => âŸ¨Int.le_of_lt h, Int.ne_of_lt hâŸ©, fun âŸ¨aleb, anebâŸ© => ?_âŸ©",
  "core-prompt": "{a b : Int} : a < b â†” a â‰¤ b âˆ§ a â‰  b",
  "args": "{a b : Int}"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by let âŸ¨n, hnâŸ© := eq_ofNat_of_zero_le ha; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := eq_ofNat_of_zero_le ha",
  "core-prompt": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by let âŸ¨n, hnâŸ© := eq_succ_of_zero_lt ha; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := eq_succ_of_zero_lt ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int} : a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a := by rw [Int.lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_le_not_le",
  "kind": "theorem",
  "first-tactic": "rw [Int.lt_iff_le_and_ne]",
  "core-prompt": "{a b : Int} : a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "args": "{a b : Int}"},
 {"type": "Â¬a < b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int} : Â¬a < b â†” b â‰¤ a := by rw [â† Int.not_le]; sorry",
  "name": "not_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.not_le]",
  "core-prompt": "{a b : Int} : Â¬a < b â†” b â‰¤ a",
  "args": "{a b : Int}"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Int) : min a b = min b a := by simp [Int.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Int.min_def]",
  "core-prompt": "(a b : Int) : min a b = min b a",
  "args": "(a b : Int)"},
 {"type": "min a b â‰¤ b",
  "tactic-prompt":
  "theorem (a b : Int) : min a b â‰¤ b := by rw [Int.min_def]; sorry",
  "name": "min_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.min_def]",
  "core-prompt": "(a b : Int) : min a b â‰¤ b",
  "args": "(a b : Int)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : min a b = a := by simp [Int.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Int.min_def]",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : min a b = a",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b â‰¤ a) : min a b = b := by rw [Int.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.min_comm a b]",
  "core-prompt": "{a b : Int}  (h : b â‰¤ a) : min a b = b",
  "args": "{a b : Int}  (h : b â‰¤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Int) : max a b = max b a := by simp only [Int.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Int.max_def]",
  "core-prompt": "(a b : Int) : max a b = max b a",
  "args": "(a b : Int)"},
 {"type": "a â‰¤ max a b",
  "tactic-prompt":
  "theorem (a b : Int) : a â‰¤ max a b := by rw [Int.max_def]; sorry",
  "name": "le_max_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.max_def]",
  "core-prompt": "(a b : Int) : a â‰¤ max a b",
  "args": "(a b : Int)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : max a b = b := by simp [Int.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Int.max_def]",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : max a b = b",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b â‰¤ a) : max a b = a := by rw [â† Int.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.max_comm b a]",
  "core-prompt": "{a b : Int}  (h : b â‰¤ a) : max a b = a",
  "args": "{a b : Int}  (h : b â‰¤ a)"},
 {"type": "a = natAbs a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : a = natAbs a := by let âŸ¨n, eâŸ© := eq_ofNat_of_zero_le h; sorry",
  "name": "eq_natAbs_of_zero_le",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, eâŸ© := eq_ofNat_of_zero_le h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : a = natAbs a",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ a + c) : b â‰¤ c := by have : -a + (a + b) â‰¤ -a + (a + c) := Int.add_le_add_left h _; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) â‰¤ -a + (a + c) := Int.add_le_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ a + c) : b â‰¤ c",
  "args": "{a b c : Int}  (h : a + b â‰¤ a + c)"},
 {"type": "b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < a + c) : b < c := by have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _; sorry",
  "name": "lt_of_add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b < a + c) : b < c",
  "args": "{a b c : Int}  (h : a + b < a + c)"},
 {"type": "a â‰¤ a + b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ b) : a â‰¤ a + b := by have : a + b â‰¥ a + 0 := Int.add_le_add_left h a; sorry",
  "name": "le_add_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "have : a + b â‰¥ a + 0 := Int.add_le_add_left h a",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ b) : a â‰¤ a + b",
  "args": "{a b : Int}  (h : 0 â‰¤ b)"},
 {"type": "a â‰¤ b + a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ b) : a â‰¤ b + a := by have : 0 + a â‰¤ b + a := Int.add_le_add_right h a; sorry",
  "name": "le_add_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a â‰¤ b + a := Int.add_le_add_right h a",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ b) : a â‰¤ b + a",
  "args": "{a b : Int}  (h : 0 â‰¤ b)"},
 {"type": "a < a + b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < a + b := by have : a + 0 < a + b := Int.add_lt_add_left h a; sorry",
  "name": "lt_add_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : a + 0 < a + b := Int.add_lt_add_left h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < a + b",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "a < b + a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < b + a := by have : 0 + a < b + a := Int.add_lt_add_right h a; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a < b + a := Int.add_lt_add_right h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < b + a",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "-b â‰¤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : -b â‰¤ -a := by have : 0 â‰¤ -a + b := Int.add_left_neg a â–¸ Int.add_le_add_left h (-a); sorry",
  "name": "neg_le_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 â‰¤ -a + b := Int.add_left_neg a â–¸ Int.add_le_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : -b â‰¤ -a",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "-a â‰¤ 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : -a â‰¤ 0 := by have : -a â‰¤ -0 := Int.neg_le_neg h; sorry",
  "name": "neg_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "have : -a â‰¤ -0 := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : -a â‰¤ 0",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "0 â‰¤ -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a â‰¤ 0) : 0 â‰¤ -a := by have : -0 â‰¤ -a := Int.neg_le_neg h; sorry",
  "name": "neg_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "have : -0 â‰¤ -a := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : a â‰¤ 0) : 0 â‰¤ -a",
  "args": "{a : Int}  (h : a â‰¤ 0)"},
 {"type": "-b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : -b < -a := by have : 0 < -a + b := Int.add_left_neg a â–¸ Int.add_lt_add_left h (-a); sorry",
  "name": "neg_lt_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < -a + b := Int.add_left_neg a â–¸ Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a < b) : -b < -a",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "-a < 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 < a) : -a < 0 := by have : -a < -0 := Int.neg_lt_neg h; sorry",
  "name": "neg_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have : -a < -0 := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : 0 < a) : -a < 0",
  "args": "{a : Int}  (h : 0 < a)"},
 {"type": "0 < -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a < 0) : 0 < -a := by have : -0 < -a := Int.neg_lt_neg h; sorry",
  "name": "neg_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have : -0 < -a := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : a < 0) : 0 < -a",
  "args": "{a : Int}  (h : a < 0)"},
 {"type": "b â‰¤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ -b) : b â‰¤ -a := by have h := Int.neg_le_neg h; sorry",
  "name": "le_neg_of_le_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : a â‰¤ -b) : b â‰¤ -a",
  "args": "{a b : Int}  (h : a â‰¤ -b)"},
 {"type": "-b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a â‰¤ b) : -b â‰¤ a := by have h := Int.neg_le_neg h; sorry",
  "name": "neg_le_of_neg_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : -a â‰¤ b) : -b â‰¤ a",
  "args": "{a b : Int}  (h : -a â‰¤ b)"},
 {"type": "b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < -b) : b < -a := by have h := Int.neg_lt_neg h; sorry",
  "name": "lt_neg_of_lt_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : a < -b) : b < -a",
  "args": "{a b : Int}  (h : a < -b)"},
 {"type": "-b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a < b) : -b < a := by have h := Int.neg_lt_neg h; sorry",
  "name": "neg_lt_of_neg_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : -a < b) : -b < a",
  "args": "{a b : Int}  (h : -a < b)"},
 {"type": "0 â‰¤ a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b â‰¤ a) : 0 â‰¤ a - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b â‰¤ a) : 0 â‰¤ a - b",
  "args": "{a b : Int}  (h : b â‰¤ a)"},
 {"type": "b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ a - b) : b â‰¤ a := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ a - b) : b â‰¤ a",
  "args": "{a b : Int}  (h : 0 â‰¤ a - b)"},
 {"type": "a - b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : a - b â‰¤ 0 := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : a - b â‰¤ 0",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b â‰¤ 0) : a â‰¤ b := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b â‰¤ 0) : a â‰¤ b",
  "args": "{a b : Int}  (h : a - b â‰¤ 0)"},
 {"type": "0 < a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b < a) : 0 < a - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b < a) : 0 < a - b",
  "args": "{a b : Int}  (h : b < a)"},
 {"type": "b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 < a - b) : b < a := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 < a - b) : b < a",
  "args": "{a b : Int}  (h : 0 < a - b)"},
 {"type": "a - b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : a - b < 0 := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a < b) : a - b < 0",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b < 0) : a < b := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b < 0) : a < b",
  "args": "{a b : Int}  (h : a - b < 0)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b â‰¤ -a + c) : a + b â‰¤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b â‰¤ -a + c) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : b â‰¤ -a + c)"},
 {"type": "b â‰¤ -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ -a + c := by have h := Int.add_le_add_left h (-a); sorry",
  "name": "le_neg_add_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ -a + c",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b â‰¤ c - a) : a + b â‰¤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b â‰¤ c - a) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : b â‰¤ c - a)"},
 {"type": "b â‰¤ c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ c - a := by have h := Int.add_le_add_right h (-a); sorry",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ c - a",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ c - b) : a + b â‰¤ c := by have h := Int.add_le_add_right h b; sorry",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ c - b) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ c - b)"},
 {"type": "a â‰¤ c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : a â‰¤ c - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : a â‰¤ c - b",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c := by have h := Int.add_le_add_left h b; sorry",
  "name": "le_add_of_neg_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -b + a â‰¤ c)"},
 {"type": "-b + a â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c := by have h := Int.add_le_add_left h (-b); sorry",
  "name": "neg_add_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b â‰¤ c) : a â‰¤ b + c := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : a - b â‰¤ c)"},
 {"type": "a - b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : a - b â‰¤ c := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : a - b â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c â‰¤ b) : a â‰¤ b + c := by have h := Int.add_le_add_right h c; sorry",
  "name": "le_add_of_sub_right_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c â‰¤ b) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : a - c â‰¤ b)"},
 {"type": "a - c â‰¤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : a - c â‰¤ b := by have h := Int.add_le_add_right h (-c); sorry",
  "name": "sub_right_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : a - c â‰¤ b",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -b + a â‰¤ c)"},
 {"type": "-b + a â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_le_left_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a â‰¤ b) : a â‰¤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a â‰¤ b) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -c + a â‰¤ b)"},
 {"type": "-c + a â‰¤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -c + a â‰¤ b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_le_right_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -c + a â‰¤ b",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "-a â‰¤ b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c â‰¤ a + b) : -a â‰¤ b - c := by have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h); sorry",
  "name": "neg_le_sub_left_of_le_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h)",
  "core-prompt": "{a b c : Int}  (h : c â‰¤ a + b) : -a â‰¤ b - c",
  "args": "{a b c : Int}  (h : c â‰¤ a + b)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < -a + c) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < -a + c) : a + b < c",
  "args": "{a b c : Int}  (h : b < -a + c)"},
 {"type": "b < -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < -a + c := by have h := Int.add_lt_add_left h (-a); sorry",
  "name": "lt_neg_add_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < -a + c",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < c - a) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < c - a) : a + b < c",
  "args": "{a b c : Int}  (h : b < c - a)"},
 {"type": "b < c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < c - a := by have h := Int.add_lt_add_right h (-a); sorry",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < c - a",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < c - b) : a + b < c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a < c - b) : a + b < c",
  "args": "{a b c : Int}  (h : a < c - b)"},
 {"type": "a < c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : a < c - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : a < c - b",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by have h := Int.add_lt_add_left h b; sorry",
  "name": "lt_add_of_neg_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by have h := Int.add_lt_add_left h (-b); sorry",
  "name": "neg_add_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b < c) : a < b + c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b < c) : a < b + c",
  "args": "{a b c : Int}  (h : a - b < c)"},
 {"type": "a - b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - b < c := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - b < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c < b) : a < b + c := by have h := Int.add_lt_add_right h c; sorry",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c < b) : a < b + c",
  "args": "{a b c : Int}  (h : a - c < b)"},
 {"type": "a - c < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - c < b := by have h := Int.add_lt_add_right h (-c); sorry",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - c < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a < b) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a < b) : a < b + c",
  "args": "{a b c : Int}  (h : -c + a < b)"},
 {"type": "-c + a < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -c + a < b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_lt_right_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -c + a < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "-a < b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c < a + b) : -a < b - c := by have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h); sorry",
  "name": "neg_lt_sub_left_of_lt_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h)",
  "core-prompt": "{a b c : Int}  (h : c < a + b) : -a < b - c",
  "args": "{a b c : Int}  (h : c < a + b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : c * a < c * b := by have : 0 < c * (b - a) := Int.mul_pos hâ‚‚ (Int.sub_pos_of_lt hâ‚); sorry",
  "name": "mul_lt_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < c * (b - a) := Int.mul_pos hâ‚‚ (Int.sub_pos_of_lt hâ‚)",
  "core-prompt": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : c * a < c * b",
  "args": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : a * c < b * c := by have : 0 < b - a := Int.sub_pos_of_lt hâ‚; sorry",
  "name": "mul_lt_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : 0 < b - a := Int.sub_pos_of_lt hâ‚",
  "core-prompt": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : a * c < b * c",
  "args": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c)"},
 {"type": "c * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : c * a â‰¤ c * b := by if hba : b â‰¤ a then rw [Int.le_antisymm hba hâ‚]; apply Int.le_refl else\n  if hc0 : c â‰¤ 0 then simp [Int.le_antisymm hc0 hâ‚‚]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then rw [Int.le_antisymm hba hâ‚]; apply Int.le_refl else\n  if hc0 : c â‰¤ 0 then simp [Int.le_antisymm hc0 hâ‚‚]",
  "core-prompt":
  "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : c * a â‰¤ c * b",
  "args": "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c)"},
 {"type": "a * c â‰¤ b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : a * c â‰¤ b * c := by rw [Int.mul_comm]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : a * c â‰¤ b * c",
  "args": "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0 := by have h : a * b â‰¤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b â‰¤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha",
  "core-prompt": "{a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0",
  "args": "{a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0 := by have h : a * b â‰¤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b â‰¤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0",
  "args": "{a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args": "{a b : Int}  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b := by have : 0 * b â‰¤ a * b := Int.mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have : 0 * b â‰¤ a * b := Int.mul_le_mul_of_nonpos_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b",
  "args": "{a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args": "{a b : Int}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "(natAbs a : Int) = -a",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰¤ 0) : (natAbs a : Int) = -a := by rw [â† natAbs_neg]; sorry",
  "name": "ofNat_natAbs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_neg]",
  "core-prompt": "{a : Int}  (H : a â‰¤ 0) : (natAbs a : Int) = -a",
  "args": "{a : Int}  (H : a â‰¤ 0)"},
 {"type": "a * b = 0 â†” a = 0 âˆ¨ b = 0",
  "tactic-prompt":
  "theorem {a b : Int} : a * b = 0 â†” a = 0 âˆ¨ b = 0 := by refine âŸ¨fun h => ?_, fun h => h.elim (by simp [Â·, Int.zero_mul]) (by simp [Â·, Int.mul_zero])âŸ©; sorry",
  "name": "mul_eq_zero",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun h => ?_, fun h => h.elim (by simp [Â·, Int.zero_mul]) (by simp [Â·, Int.mul_zero])âŸ©",
  "core-prompt": "{a b : Int} : a * b = 0 â†” a = 0 âˆ¨ b = 0",
  "args": "{a b : Int}"},
 {"type": "natAbs a = n â†” (a - n) * (a + n) = 0",
  "tactic-prompt":
  "theorem  : natAbs a = n â†” (a - n) * (a + n) = 0 := by rw [natAbs_eq_iff]; sorry",
  "name": "eq_natAbs_iff_mul_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [natAbs_eq_iff]",
  "core-prompt": " : natAbs a = n â†” (a - n) * (a + n) = 0",
  "args": ""},
 {"type": "natAbs (a - b) â‰¤ natAbs a + natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a - b) â‰¤ natAbs a + natAbs b := by rw [â† Int.natAbs_neg b]; sorry",
  "name": "natAbs_sub_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.natAbs_neg b]",
  "core-prompt": "(a b : Int) : natAbs (a - b) â‰¤ natAbs a + natAbs b",
  "args": "(a b : Int)"},
 {"type": "(toNat a : Int) = a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : (toNat a : Int) = a := by rw [toNat_eq_max]; sorry",
  "name": "toNat_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [toNat_eq_max]",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : (toNat a : Int) = a",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "a â‰¤ toNat a",
  "tactic-prompt":
  "theorem (a : Int) : a â‰¤ toNat a := by rw [toNat_eq_max]; sorry",
  "name": "self_le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [toNat_eq_max]",
  "core-prompt": "(a : Int) : a â‰¤ toNat a",
  "args": "(a : Int)"},
 {"type": "n â‰¤ z.toNat â†” (n : Int) â‰¤ z",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int}  (h : 0 â‰¤ z) : n â‰¤ z.toNat â†” (n : Int) â‰¤ z := by rw [â† Int.ofNat_le]; sorry",
  "name": "le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.ofNat_le]",
  "core-prompt":
  "{n : Nat}  {z : Int}  (h : 0 â‰¤ z) : n â‰¤ z.toNat â†” (n : Int) â‰¤ z",
  "args": "{n : Nat}  {z : Int}  (h : 0 â‰¤ z)"},
 {"type": "z.toNat < n â†” z < (n : Int)",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int}  (h : 0 â‰¤ z) : z.toNat < n â†” z < (n : Int) := by rw [â† Int.not_le]; sorry",
  "name": "toNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.not_le]",
  "core-prompt":
  "{n : Nat}  {z : Int}  (h : 0 â‰¤ z) : z.toNat < n â†” z < (n : Int)",
  "args": "{n : Nat}  {z : Int}  (h : 0 â‰¤ z)"},
 {"type": "(num / g).natAbs.coprime (den / g)",
  "tactic-prompt":
  "theorem {num : Int}  {den g : Nat}  (den_nz : den â‰  0)      (e : g = num.natAbs.gcd den) : (num / g).natAbs.coprime (den / g) := by rw [â† Int.div_eq_ediv_of_dvd (e â–¸ Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]; sorry",
  "name": "normalize.reduced'",
  "kind": "theorem",
  "first-tactic":
  "rw [â† Int.div_eq_ediv_of_dvd (e â–¸ Int.ofNat_dvd_left.2 (Nat.gcd_dvd_left ..))]",
  "core-prompt":
  "{num : Int}  {den g : Nat}  (den_nz : den â‰  0)      (e : g = num.natAbs.gcd den) : (num / g).natAbs.coprime (den / g)",
  "args":
  "{num : Int}  {den g : Nat}  (den_nz : den â‰  0)      (e : g = num.natAbs.gcd den)"},
 {"type":
  "normalize (â†‘a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0",
  "tactic-prompt":
  "theorem {a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0) : normalize (â†‘a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0 := by simp [normalize_eq]; sorry",
  "name": "normalize_mul_left",
  "kind": "theorem",
  "first-tactic": "simp [normalize_eq]",
  "core-prompt":
  "{a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0) : normalize (â†‘a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0",
  "args": "{a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0)"},
 {"type":
  "normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0",
  "tactic-prompt":
  "theorem {a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0) : normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0 := by rw [â† normalize_mul_left (d0 := d0) a0]; sorry",
  "name": "normalize_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [â† normalize_mul_left (d0 := d0) a0]",
  "core-prompt":
  "{a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0) : normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0",
  "args": "{a : Nat}  (d0 : d â‰  0)  (a0 : a â‰  0)"},
 {"type": "normalize nâ‚ dâ‚ zâ‚ = normalize nâ‚‚ dâ‚‚ zâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "tactic-prompt":
  "theorem (zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : normalize nâ‚ dâ‚ zâ‚ = normalize nâ‚‚ dâ‚‚ zâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚ := by constructor; sorry",
  "name": "normalize_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : normalize nâ‚ dâ‚ zâ‚ = normalize nâ‚‚ dâ‚‚ zâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "args": "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0)"},
 {"type": "normalize n d d0 = 0 â†” n = 0",
  "tactic-prompt":
  "theorem (d0 : d â‰  0) : normalize n d d0 = 0 â†” n = 0 := by have' := normalize_eq_iff d0 Nat.one_ne_zero; sorry",
  "name": "normalize_eq_zero",
  "kind": "theorem",
  "first-tactic": "have' := normalize_eq_iff d0 Nat.one_ne_zero",
  "core-prompt": "(d0 : d â‰  0) : normalize n d d0 = 0 â†” n = 0",
  "args": "(d0 : d â‰  0)"},
 {"type": "âˆƒ m : Nat, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m",
  "tactic-prompt":
  "theorem (h : normalize n d z = âŸ¨n', d', z', câŸ©) : âˆƒ m : Nat, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m := by have := normalize_num_den' n d z; sorry",
  "name": "normalize_num_den",
  "kind": "theorem",
  "first-tactic": "have := normalize_num_den' n d z",
  "core-prompt":
  "(h : normalize n d z = âŸ¨n', d', z', câŸ©) : âˆƒ m : Nat, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m",
  "args": "(h : normalize n d z = âŸ¨n', d', z', câŸ©)"},
 {"type": "mkRat a.num a.den = a",
  "tactic-prompt":
  "theorem (a : Rat) : mkRat a.num a.den = a := by rw [â† normalize_eq_mkRat a.den_nz]; sorry",
  "name": "mkRat_self",
  "kind": "theorem",
  "first-tactic": "rw [â† normalize_eq_mkRat a.den_nz]",
  "core-prompt": "(a : Rat) : mkRat a.num a.den = a",
  "args": "(a : Rat)"},
 {"type": "mkRat n d = 0 â†” n = 0",
  "tactic-prompt":
  "theorem (d0 : d â‰  0) : mkRat n d = 0 â†” n = 0 := by simp [mkRat_def]; sorry",
  "name": "mkRat_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp [mkRat_def]",
  "core-prompt": "(d0 : d â‰  0) : mkRat n d = 0 â†” n = 0",
  "args": "(d0 : d â‰  0)"},
 {"type": "mkRat (â†‘a * n) (a * d) = mkRat n d",
  "tactic-prompt":
  "theorem {a : Nat}  (a0 : a â‰  0) : mkRat (â†‘a * n) (a * d) = mkRat n d := by if d0 : d = 0 then simp [d0] else\n  rw [â† normalize_eq_mkRat d0]; sorry",
  "name": "mkRat_mul_left",
  "kind": "theorem",
  "first-tactic":
  "if d0 : d = 0 then simp [d0] else\n  rw [â† normalize_eq_mkRat d0]",
  "core-prompt": "{a : Nat}  (a0 : a â‰  0) : mkRat (â†‘a * n) (a * d) = mkRat n d",
  "args": "{a : Nat}  (a0 : a â‰  0)"},
 {"type": "mkRat (n * a) (d * a) = mkRat n d",
  "tactic-prompt":
  "theorem {a : Nat}  (a0 : a â‰  0) : mkRat (n * a) (d * a) = mkRat n d := by rw [â† mkRat_mul_left (d := d) a0]; sorry",
  "name": "mkRat_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [â† mkRat_mul_left (d := d) a0]",
  "core-prompt": "{a : Nat}  (a0 : a â‰  0) : mkRat (n * a) (d * a) = mkRat n d",
  "args": "{a : Nat}  (a0 : a â‰  0)"},
 {"type": "mkRat nâ‚ dâ‚ = mkRat nâ‚‚ dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "tactic-prompt":
  "theorem (zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : mkRat nâ‚ dâ‚ = mkRat nâ‚‚ dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚ := by rw [â† normalize_eq_mkRat zâ‚]; sorry",
  "name": "mkRat_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† normalize_eq_mkRat zâ‚]",
  "core-prompt":
  "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : mkRat nâ‚ dâ‚ = mkRat nâ‚‚ dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "args": "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0)"},
 {"type": "a.num /. a.den = a",
  "tactic-prompt":
  "theorem (a : Rat) : a.num /. a.den = a := by rw [divInt_ofNat]; sorry",
  "name": "divInt_self",
  "kind": "theorem",
  "first-tactic": "rw [divInt_ofNat]",
  "core-prompt": "(a : Rat) : a.num /. a.den = a",
  "args": "(a : Rat)"},
 {"type": "nâ‚ /. dâ‚ = nâ‚‚ /. dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "tactic-prompt":
  "theorem (zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : nâ‚ /. dâ‚ = nâ‚‚ /. dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚ := by rcases Int.eq_nat_or_neg dâ‚ with âŸ¨_, rfl | rflâŸ©; sorry",
  "name": "divInt_eq_iff",
  "kind": "theorem",
  "first-tactic": "rcases Int.eq_nat_or_neg dâ‚ with âŸ¨_, rfl | rflâŸ©",
  "core-prompt":
  "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0) : nâ‚ /. dâ‚ = nâ‚‚ /. dâ‚‚ â†” nâ‚ * dâ‚‚ = nâ‚‚ * dâ‚",
  "args": "(zâ‚ : dâ‚ â‰  0)  (zâ‚‚ : dâ‚‚ â‰  0)"},
 {"type": "(a * n) /. (a * d) = n /. d",
  "tactic-prompt":
  "theorem {a : Int}  (a0 : a â‰  0) : (a * n) /. (a * d) = n /. d := by if d0 : d = 0 then simp [d0] else\n  simp [divInt_eq_iff (Int.mul_ne_zero a0 d0) d0]; sorry",
  "name": "divInt_mul_left",
  "kind": "theorem",
  "first-tactic":
  "if d0 : d = 0 then simp [d0] else\n  simp [divInt_eq_iff (Int.mul_ne_zero a0 d0) d0]",
  "core-prompt": "{a : Int}  (a0 : a â‰  0) : (a * n) /. (a * d) = n /. d",
  "args": "{a : Int}  (a0 : a â‰  0)"},
 {"type": "(n * a) /. (d * a) = n /. d",
  "tactic-prompt":
  "theorem {a : Int}  (a0 : a â‰  0) : (n * a) /. (d * a) = n /. d := by simp [â† divInt_mul_left (d := d) a0]; sorry",
  "name": "divInt_mul_right",
  "kind": "theorem",
  "first-tactic": "simp [â† divInt_mul_left (d := d) a0]",
  "core-prompt": "{a : Int}  (a0 : a â‰  0) : (n * a) /. (d * a) = n /. d",
  "args": "{a : Int}  (a0 : a â‰  0)"},
 {"type": "âˆƒ m, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m",
  "tactic-prompt":
  "theorem (z : d â‰  0)  (h : n /. d = âŸ¨n', d', z', câŸ©) : âˆƒ m, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m := by rcases Int.eq_nat_or_neg d with âŸ¨_, rfl | rflâŸ©; sorry",
  "name": "divInt_num_den",
  "kind": "theorem",
  "first-tactic": "rcases Int.eq_nat_or_neg d with âŸ¨_, rfl | rflâŸ©",
  "core-prompt":
  "(z : d â‰  0)  (h : n /. d = âŸ¨n', d', z', câŸ©) : âˆƒ m, m â‰  0 âˆ§ n = n' * m âˆ§ d = d' * m",
  "args": "(z : d â‰  0)  (h : n /. d = âŸ¨n', d', z', câŸ©)"},
 {"type":
  "a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.add .. = _; sorry",
  "name": "add_def",
  "kind": "theorem",
  "first-tactic": "show Rat.add .. = _",
  "core-prompt":
  "(a b : Rat) : a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den)",
  "tactic-prompt":
  "theorem (a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den) := by rw [add_def]; sorry",
  "name": "add_def'",
  "kind": "theorem",
  "first-tactic": "rw [add_def]",
  "core-prompt":
  "(a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den)",
  "args": "(a b : Rat)"},
 {"type":
  "a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.sub .. = _; sorry",
  "name": "sub_def",
  "kind": "theorem",
  "first-tactic": "show Rat.sub .. = _",
  "core-prompt":
  "(a b : Rat) : a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den)",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den) := by rw [sub_def]; sorry",
  "name": "sub_def'",
  "kind": "theorem",
  "first-tactic": "rw [sub_def]",
  "core-prompt":
  "(a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den)",
  "args": "(a b : Rat)"},
 {"type": "a - b = a + -b",
  "tactic-prompt":
  "theorem (a b : Rat) : a - b = a + -b := by simp [add_def]; sorry",
  "name": "sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [add_def]",
  "core-prompt": "(a b : Rat) : a - b = a + -b",
  "args": "(a b : Rat)"},
 {"type":
  "a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "tactic-prompt":
  "theorem (a b : Rat) : a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz) := by show Rat.mul .. = _; sorry",
  "name": "mul_def",
  "kind": "theorem",
  "first-tactic": "show Rat.mul .. = _",
  "core-prompt":
  "(a b : Rat) : a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz)",
  "args": "(a b : Rat)"},
 {"type": "a * b = b * a",
  "tactic-prompt":
  "theorem (a b : Rat) : a * b = b * a := by simp [mul_def]; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a b : Rat) : a * b = b * a",
  "args": "(a b : Rat)"},
 {"type": "0 * a = 0",
  "tactic-prompt": "theorem (a : Rat) : 0 * a = 0 := by simp [mul_def]; sorry",
  "name": "zero_mul",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : 0 * a = 0",
  "args": "(a : Rat)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Rat) : a * 0 = 0 := by simp [mul_def]; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : a * 0 = 0",
  "args": "(a : Rat)"},
 {"type": "1 * a = a",
  "tactic-prompt": "theorem (a : Rat) : 1 * a = a := by simp [mul_def]; sorry",
  "name": "one_mul",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : 1 * a = a",
  "args": "(a : Rat)"},
 {"type": "a * 1 = a",
  "tactic-prompt": "theorem (a : Rat) : a * 1 = a := by simp [mul_def]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt": "(a : Rat) : a * 1 = a",
  "args": "(a : Rat)"},
 {"type": "a.inv = a.den /. a.num",
  "tactic-prompt":
  "theorem (a : Rat) : a.inv = a.den /. a.num := by unfold Rat.inv; sorry",
  "name": "inv_def",
  "kind": "theorem",
  "first-tactic": "unfold Rat.inv",
  "core-prompt": "(a : Rat) : a.inv = a.den /. a.num",
  "args": "(a : Rat)"},
 {"type": "(n /. d).inv = d /. n",
  "tactic-prompt":
  "theorem (n d : Int) : (n /. d).inv = d /. n := by if z : d = 0 then simp [z] else\n  cases e : n /. d; rcases divInt_num_den z e with âŸ¨g]; sorry",
  "name": "inv_divInt",
  "kind": "theorem",
  "first-tactic":
  "if z : d = 0 then simp [z] else\n  cases e : n /. d; rcases divInt_num_den z e with âŸ¨g]",
  "core-prompt": "(n d : Int) : (n /. d).inv = d /. n",
  "args": "(n d : Int)"},
 {"type": "as.toArray.size = as.length",
  "tactic-prompt":
  "theorem (as : List Î±) : as.toArray.size = as.length := by simp [size]; sorry",
  "name": "size_toArray",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List Î±) : as.toArray.size = as.length",
  "args": "(as : List Î±)"},
 {"type": "(Array.mk as).size = as.length",
  "tactic-prompt":
  "theorem (as : List Î±) : (Array.mk as).size = as.length := by simp [size]; sorry",
  "name": "size_mk",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List Î±) : (Array.mk as).size = as.length",
  "args": "(as : List Î±)"},
 {"type": "a[i] = a.data.get âŸ¨i, hâŸ©",
  "tactic-prompt":
  "theorem (a : Array Î±)  (h : i < a.size) : a[i] = a.data.get âŸ¨i, hâŸ© := by by_cases i < a.size; sorry",
  "name": "getElem_eq_data_get",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array Î±)  (h : i < a.size) : a[i] = a.data.get âŸ¨i, hâŸ©",
  "args": "(a : Array Î±)  (h : i < a.size)"},
 {"type": "arr.foldlM f init = arr.data.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldlM f init = arr.data.foldlM f init := by simp [foldlM]; sorry",
  "name": "foldlM_eq_foldlM_data",
  "kind": "theorem",
  "first-tactic": "simp [foldlM]",
  "core-prompt":
  "[Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldlM f init = arr.data.foldlM f init",
  "args": "[Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init := by have : arr = #[] âˆ¨ 0 < arr.size :=\n    match arr with | âŸ¨[]âŸ© => .inl rfl | âŸ¨a::lâŸ© => .inr (Nat.zero_lt_succ _); sorry",
  "name": "foldrM_eq_reverse_foldlM_data",
  "kind": "theorem",
  "first-tactic":
  "have : arr = #[] âˆ¨ 0 < arr.size :=\n    match arr with | âŸ¨[]âŸ© => .inl rfl | âŸ¨a::lâŸ© => .inr (Nat.zero_lt_succ _)",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "arr.foldrM f init = arr.data.foldrM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.foldrM f init := by rw [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_eq_foldrM_data",
  "kind": "theorem",
  "first-tactic": "rw [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.foldrM f init",
  "args": "[Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "(arr.push a).data = arr.data ++ [a]",
  "tactic-prompt":
  "theorem (arr : Array Î±)  (a : Î±) : (arr.push a).data = arr.data ++ [a] := by simp [push]; sorry",
  "name": "push_data",
  "kind": "theorem",
  "first-tactic": "simp [push]",
  "core-prompt":
  "(arr : Array Î±)  (a : Î±) : (arr.push a).data = arr.data ++ [a]",
  "args": "(arr : Array Î±)  (a : Î±)"},
 {"type": "(arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f := by simp [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_push",
  "kind": "theorem",
  "first-tactic": "simp [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±)"},
 {"type":
  "(arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f := by simp [â† foldrM_push]; sorry",
  "name": "foldrM_push'",
  "kind": "theorem",
  "first-tactic": "simp [â† foldrM_push]",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±)"},
 {"type": "arr.toList = arr.data",
  "tactic-prompt":
  "theorem (arr : Array Î±) : arr.toList = arr.data := by simp [toList]; sorry",
  "name": "toList_eq",
  "kind": "theorem",
  "first-tactic": "simp [toList]",
  "core-prompt": "(arr : Array Î±) : arr.toList = arr.data",
  "args": "(arr : Array Î±)"},
 {"type": "arr.toListRev = arr.data.reverse",
  "tactic-prompt":
  "theorem (arr : Array Î±) : arr.toListRev = arr.data.reverse := by rw [toListRev]; sorry",
  "name": "toListRev_eq",
  "kind": "theorem",
  "first-tactic": "rw [toListRev]",
  "core-prompt": "(arr : Array Î±) : arr.toListRev = arr.data.reverse",
  "args": "(arr : Array Î±)"},
 {"type": "SatisfiesM (motive as.size) (as.foldlM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init) := by let rec go {i j b} (hâ‚ : j â‰¤ as.size) (hâ‚‚ : as.size â‰¤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    Â· next hj =>\n      split\n      Â· cases Nat.not_le_of_gt (by simp [hj]) hâ‚‚\n      Â· exact (hf âŸ¨j]; sorry",
  "name": "SatisfiesM_foldlM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i j b} (hâ‚ : j â‰¤ as.size) (hâ‚‚ : as.size â‰¤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    Â· next hj =>\n      split\n      Â· cases Nat.not_le_of_gt (by simp [hj]) hâ‚‚\n      Â· exact (hf âŸ¨j]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i]))"},
 {"type": "motive as.size (as.foldl f init)",
  "tactic-prompt":
  "theorem {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init) := by have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldl_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init)",
  "args":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i]))"},
 {"type":
  "haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i] := by simp only [push]; sorry",
  "name": "get_push_lt",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size] = x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±) : (a.push x)[a.size] = x := by simp only [push]; sorry",
  "name": "get_push_eq",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt": "(a : Array Î±)  (x : Î±) : (a.push x)[a.size] = x",
  "args": "(a : Array Î±)  (x : Î±)"},
 {"type": "(a.push x)[i] = if h : i < a.size then a[i] else x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x := by if h' : i < a.size then\n    simp [get_push_lt]; sorry",
  "name": "get_push",
  "kind": "theorem",
  "first-tactic": "if h' : i < a.size then\n    simp [get_push_lt]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as) := by unfold mapM; sorry",
  "name": "SatisfiesM_mapM",
  "kind": "theorem",
  "first-tactic": "unfold mapM",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i]))"},
 {"type": "(arr.map f).data = arr.data.map f",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).data = arr.data.map f := by apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans; sorry",
  "name": "map_data",
  "kind": "theorem",
  "first-tactic":
  "apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans",
  "core-prompt":
  "(f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).data = arr.data.map f",
  "args": "(f : Î± â†’ Î²)  (arr : Array Î±)"},
 {"type": "(arr.map f).size = arr.size",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).size = arr.size := by simp [size]; sorry",
  "name": "size_map",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).size = arr.size",
  "args": "(f : Î± â†’ Î²)  (arr : Array Î±)"},
 {"type": "(arr ++ arr').data = arr.data ++ arr'.data",
  "tactic-prompt":
  "theorem (arr arr' : Array Î±) : (arr ++ arr').data = arr.data ++ arr'.data := by rw [â† append_eq_append]; sorry",
  "name": "append_data",
  "kind": "theorem",
  "first-tactic": "rw [â† append_eq_append]",
  "core-prompt":
  "(arr arr' : Array Î±) : (arr ++ arr').data = arr.data ++ arr'.data",
  "args": "(arr arr' : Array Î±)"},
 {"type": "(arr ++ l).data = arr.data ++ l",
  "tactic-prompt":
  "theorem (arr : Array Î±)  (l : List Î±) : (arr ++ l).data = arr.data ++ l := by rw [â† appendList_eq_append]; sorry",
  "name": "appendList_data",
  "kind": "theorem",
  "first-tactic": "rw [â† appendList_eq_append]",
  "core-prompt":
  "(arr : Array Î±)  (l : List Î±) : (arr ++ l).data = arr.data ++ l",
  "args": "(arr : Array Î±)  (l : List Î±)"},
 {"type": "(l.foldl F acc).data = acc.data ++ l.bind G",
  "tactic-prompt":
  "theorem (l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_bind",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G",
  "args":
  "(l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a)"},
 {"type":
  "(l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "tactic-prompt":
  "theorem (l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "args": "(l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²)"},
 {"type": "a[i]? = none",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i) : a[i]? = none := by simp [getElem?_neg]; sorry",
  "name": "get?_len_le",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_neg]",
  "core-prompt": "(a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i) : a[i]? = none",
  "args": "(a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i)"},
 {"type": "a[i] âˆˆ a.data",
  "tactic-prompt":
  "theorem (a : Array Î±)  (h : i < a.size) : a[i] âˆˆ a.data := by simp [getElem_eq_data_get]; sorry",
  "name": "getElem_mem_data",
  "kind": "theorem",
  "first-tactic": "simp [getElem_eq_data_get]",
  "core-prompt": "(a : Array Î±)  (h : i < a.size) : a[i] âˆˆ a.data",
  "args": "(a : Array Î±)  (h : i < a.size)"},
 {"type": "a[i]? = a.data.get? i",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat) : a[i]? = a.data.get? i := by by_cases i < a.size; sorry",
  "name": "getElem?_eq_data_get?",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array Î±)  (i : Nat) : a[i]? = a.data.get? i",
  "args": "(a : Array Î±)  (i : Nat)"},
 {"type": "a.get! n = (a.get? n).getD default",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : a.get! n = (a.get? n).getD default := by simp [get!_eq_getD]; sorry",
  "name": "get!_eq_get?",
  "kind": "theorem",
  "first-tactic": "simp [get!_eq_getD]",
  "core-prompt":
  "[Inhabited Î±]  (a : Array Î±) : a.get! n = (a.get? n).getD default",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "a.back = a.back?.getD default",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : a.back = a.back?.getD default := by simp [back]; sorry",
  "name": "back_eq_back?",
  "kind": "theorem",
  "first-tactic": "simp [back]",
  "core-prompt": "[Inhabited Î±]  (a : Array Î±) : a.back = a.back?.getD default",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "(a.push x).back? = some x",
  "tactic-prompt":
  "theorem (a : Array Î±) : (a.push x).back? = some x := by simp [back?]; sorry",
  "name": "back?_push",
  "kind": "theorem",
  "first-tactic": "simp [back?]",
  "core-prompt": "(a : Array Î±) : (a.push x).back? = some x",
  "args": "(a : Array Î±)"},
 {"type": "(a.push x).back = x",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : (a.push x).back = x := by simp; sorry",
  "name": "back_push",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[Inhabited Î±]  (a : Array Î±) : (a.push x).back = x",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "(a.push x)[i]? = some a[i]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i] := by rw [getElem?_pos]; sorry",
  "name": "get?_push_lt",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i]",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size]? = some x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±) : (a.push x)[a.size]? = some x := by rw [getElem?_pos]; sorry",
  "name": "get?_push_eq",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt": "(a : Array Î±)  (x : Î±) : (a.push x)[a.size]? = some x",
  "args": "(a : Array Î±)  (x : Î±)"},
 {"type": "(a.set i v)[i.1]'(by simp [i.2]) = v",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]'(by simp [i.2]) = v := by simp only [set]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]'(by simp [i.2]) = v",
  "args": "(a : Array Î±)  (i : Fin a.size)  (v : Î±)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = a[j]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j) : (a.set i v)[j]'(by simp [*]) = a[j] := by simp only [set]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j) : (a.set i v)[j]'(by simp [*]) = a[j]",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j)"},
 {"type": "(a.set i v)[i.1]? = v",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]? = v := by simp [getElem?_pos]; sorry",
  "name": "get?_set_eq",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_pos]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]? = v",
  "args": "(a : Array Î±)  (i : Fin a.size)  (v : Î±)"},
 {"type": "(a.set i v)[j]? = a[j]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j) : (a.set i v)[j]? = a[j]? := by by_cases j < a.size; sorry",
  "name": "get?_set_ne",
  "kind": "theorem",
  "first-tactic": "by_cases j < a.size",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j) : (a.set i v)[j]? = a[j]?",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j)"},
 {"type": "(a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±) : (a.set i v)[j]? = if i.1 = j then some v else a[j]? := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get?_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±) : (a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "args": "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j] := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±)"},
 {"type": "e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ©",
  "tactic-prompt":
  "theorem (e : n = n')  (i : Fin n) : e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ© := by cases e; sorry",
  "name": "fin_cast_val",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt": "(e : n = n')  (i : Fin n) : e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ©",
  "args": "(e : n = n')  (i : Fin n)"},
 {"type": "a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i) := by simp [swap]; sorry",
  "name": "swap_def",
  "kind": "theorem",
  "first-tactic": "simp [swap]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i)",
  "args": "(a : Array Î±)  (i j : Fin a.size)"},
 {"type": "(a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i) := by simp [swap_def]; sorry",
  "name": "data_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "args": "(a : Array Î±)  (i j : Fin a.size)"},
 {"type":
  "(a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]? := by simp [swap_def]; sorry",
  "name": "get?_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "args": "(a : Array Î±)  (i j : Fin a.size)  (k : Nat)"},
 {"type": "a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v) := by simp [swapAt!]; sorry",
  "name": "swapAt!_def",
  "kind": "theorem",
  "first-tactic": "simp [swapAt!]",
  "core-prompt":
  "(a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v)",
  "args": "(a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size)"},
 {"type": "a.pop.data = a.data.dropLast",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.pop.data = a.data.dropLast := by simp [pop]; sorry",
  "name": "data_pop",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array Î±) : a.pop.data = a.data.dropLast",
  "args": "(a : Array Î±)"},
 {"type": "(a.push x).pop = a",
  "tactic-prompt":
  "theorem (a : Array Î±) : (a.push x).pop = a := by simp [pop]; sorry",
  "name": "pop_push",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array Î±) : (a.push x).pop = a",
  "args": "(a : Array Î±)"},
 {"type": "SatisfiesM (motive 0) (as.foldrM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init) := by let rec go {i b} (hi : i â‰¤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    Â· next hi => exact .pure (hi â–¸ H)\n    Â· next hi =>\n      split; {simp at hi}\n      Â· next i hi' =>\n        exact (hf âŸ¨i, hi'âŸ© b H).bind fun _ => go _; sorry",
  "name": "SatisfiesM_foldrM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i b} (hi : i â‰¤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    Â· next hi => exact .pure (hi â–¸ H)\n    Â· next hi =>\n      split; {simp at hi}\n      Â· next i hi' =>\n        exact (hf âŸ¨i, hi'âŸ© b H).bind fun _ => go _",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b))"},
 {"type": "motive 0 (as.foldr f init)",
  "tactic-prompt":
  "theorem {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b)) : motive 0 (as.foldr f init) := by have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldr_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b)) : motive 0 (as.foldr f init)",
  "args":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b))"},
 {"type": "arr.mapM f = return mk (â† arr.data.mapM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±) : arr.mapM f = return mk (â† arr.data.mapM f) := by rw [mapM]; sorry",
  "name": "mapM_eq_mapM_data",
  "kind": "theorem",
  "first-tactic": "rw [mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±) : arr.mapM f = return mk (â† arr.data.mapM f)",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f) := by let rec go {bs i j h} (hâ‚ : j = bs.size) (hâ‚‚ : âˆ€ i h h', p âŸ¨i, hâŸ© bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure âŸ¨this â–¸ hm, hâ‚ â–¸ this, fun _ _ => hâ‚‚ ..âŸ©\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [hâ‚]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      Â· next h => exact hâ‚‚ _ _ h\n      Â· next h => cases hâ‚.symm â–¸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1; sorry",
  "name": "SatisfiesM_mapIdxM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {bs i j h} (hâ‚ : j = bs.size) (hâ‚‚ : âˆ€ i h h', p âŸ¨i, hâŸ© bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure âŸ¨this â–¸ hm, hâ‚ â–¸ this, fun _ _ => hâ‚‚ ..âŸ©\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [hâ‚]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      Â· next h => exact hâ‚‚ _ _ h\n      Â· next h => cases hâ‚.symm â–¸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i]))"},
 {"type":
  "motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h))",
  "tactic-prompt":
  "theorem (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1)) : motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h)) := by have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "mapIdx_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "(as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1)) : motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h))",
  "args":
  "(as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1))"},
 {"type": "a.reverse.size = a.size",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.reverse.size = a.size := by let rec go (as : Array Î±) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go Â· (i+1) âŸ¨j-1]; sorry",
  "name": "size_reverse",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array Î±) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go Â· (i+1) âŸ¨j-1]",
  "core-prompt": "(a : Array Î±) : a.reverse.size = a.size",
  "args": "(a : Array Î±)"},
 {"type": "a.reverse.data = a.data.reverse",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.reverse.data = a.data.reverse := by let rec go (as : Array Î±) (i j hj)\n      (h : i + j + 1 = a.size) (hâ‚‚ : as.size = a.size)\n      (H : âˆ€ k, as.data.get? k = if i â‰¤ k âˆ§ k â‰¤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i âŸ¨j, hjâŸ©).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split; sorry",
  "name": "reverse_data",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array Î±) (i j hj)\n      (h : i + j + 1 = a.size) (hâ‚‚ : as.size = a.size)\n      (H : âˆ€ k, as.data.get? k = if i â‰¤ k âˆ§ k â‰¤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i âŸ¨j, hjâŸ©).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split",
  "core-prompt": "(a : Array Î±) : a.reverse.data = a.data.reverse",
  "args": "(a : Array Î±)"},
 {"type": "(ofFn f).size = n",
  "tactic-prompt":
  "theorem (f : Fin n â†’ Î±) : (ofFn f).size = n := by simp [ofFn]; sorry",
  "name": "size_ofFn",
  "kind": "theorem",
  "first-tactic": "simp [ofFn]",
  "core-prompt": "(f : Fin n â†’ Î±) : (ofFn f).size = n",
  "args": "(f : Fin n â†’ Î±)"},
 {"type": "isEmpty l = l.toList.isEmpty",
  "tactic-prompt":
  "theorem (l : AssocList Î± Î²) : isEmpty l = l.toList.isEmpty := by cases l; sorry",
  "name": "isEmpty_eq",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : AssocList Î± Î²) : isEmpty l = l.toList.isEmpty",
  "args": "(l : AssocList Î± Î²)"},
 {"type": "@toList = @toListTR",
  "tactic-prompt": "theorem  : @toList = @toListTR := by funext Î± Î² as; sorry",
  "name": "toList_eq_toListTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² as",
  "core-prompt": " : @toList = @toListTR",
  "args": ""},
 {"type": "(mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î´)  (l : AssocList Î± Î²) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b)) := by induction l; sorry",
  "name": "mapKey_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î´)  (l : AssocList Î± Î²) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "args": "(f : Î± â†’ Î´)  (l : AssocList Î± Î²)"},
 {"type": "(mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b)) := by induction l; sorry",
  "name": "mapVal_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "args": "(f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²)"},
 {"type": "findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : findEntryP? p l = l.toList.find? fun (a, b) => p a b := by induction l; sorry",
  "name": "findEntryP?_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "find? a l = (l.findEntry? a).map (Â·.2)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.findEntry? a).map (Â·.2) := by induction l; sorry",
  "name": "find?_eq_findEntry?",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.findEntry? a).map (Â·.2)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type": "find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2) := by simp [find?_eq_findEntry?]; sorry",
  "name": "find?_eq",
  "kind": "theorem",
  "first-tactic": "simp [find?_eq_findEntry?]",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type": "any p l = l.toList.any fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : any p l = l.toList.any fun (a, b) => p a b := by induction l; sorry",
  "name": "any_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : any p l = l.toList.any fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "all p l = l.toList.all fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : all p l = l.toList.all fun (a, b) => p a b := by induction l; sorry",
  "name": "all_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : all p l = l.toList.all fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "contains a l = l.toList.any (Â·.1 == a)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : contains a l = l.toList.any (Â·.1 == a) := by induction l; sorry",
  "name": "contains_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : contains a l = l.toList.any (Â·.1 == a)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type":
  "(replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²) : (replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none) := by induction l; sorry",
  "name": "replace_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²) : (replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none)",
  "args": "[BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²)"},
 {"type": "forIn l init f = forIn l.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´)) : forIn l init f = forIn l.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´)) : forIn l init f = forIn l.toList init f",
  "args":
  "[Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´))"},
 {"type": "l.toAssocList.toList = l",
  "tactic-prompt":
  "theorem (l : List (Î± Ã— Î²)) : l.toAssocList.toList = l := by induction l; sorry",
  "name": "_root_.List.toAssocList_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List (Î± Ã— Î²)) : l.toAssocList.toList = l",
  "args": "(l : List (Î± Ã— Î²))"},
 {"type": "l.toList.toAssocList = l",
  "tactic-prompt":
  "theorem (l : AssocList Î± Î²) : l.toList.toAssocList = l := by induction l; sorry",
  "name": "toList_toAssocList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : AssocList Î± Î²) : l.toList.toAssocList = l",
  "args": "(l : AssocList Î± Î²)"},
 {"type": "fill' (zoom cut t path) = path.fill t",
  "tactic-prompt":
  "theorem (cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±) : fill' (zoom cut t path) = path.fill t := by induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; sorry",
  "name": "zoom_fill'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split",
  "core-prompt":
  "(cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±) : fill' (zoom cut t path) = path.fill t",
  "args": "(cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±)"},
 {"type":
  "t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering} : t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v) := by unfold RBNode.ins; sorry",
  "name": "zoom_ins",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.ins",
  "core-prompt":
  "{t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering} : t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "args": "{t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering}"},
 {"type":
  "t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red) := by unfold RBNode.del; sorry",
  "name": "zoom_del",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.del",
  "core-prompt":
  "{t : RBNode Î±} : t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "args": "{t : RBNode Î±}"},
 {"type": "âˆƒ n, (path.ins t).Balanced black n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n) : âˆƒ n, (path.ins t).Balanced black n := by induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have âŸ¨c, hâŸ© := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have âŸ¨c, hâŸ© := ht.balance2 hl; ih (.balanced h); sorry",
  "name": "Balanced.ins",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have âŸ¨c, hâŸ© := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have âŸ¨c, hâŸ© := ht.balance2 hl; ih (.balanced h)",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n) : âˆƒ n, (path.ins t).Balanced black n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n)"},
 {"type": "(path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack := by have âŸ¨_, _, ht', hp'âŸ© := ht.zoom .root H; sorry",
  "name": "zoom_insert",
  "kind": "theorem",
  "first-tactic": "have âŸ¨_, _, ht', hp'âŸ© := ht.zoom .root H",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path))"},
 {"type": "âˆƒ n, (path.del t c').Balanced black n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red) : âˆƒ n, (path.del t c').Balanced black n := by induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, âŸ¨_, hâŸ© | black, âŸ¨_, _, hâŸ© => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, âŸ¨_, haâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih âŸ¨_, rfl, (hb.balLeft ha).imp fun _ => âŸ¨âŸ©âŸ© (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, âŸ¨_, hbâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih âŸ¨_, rfl, (ha.balRight hb).imp fun _ => âŸ¨âŸ©âŸ© (fun.); sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, âŸ¨_, hâŸ© | black, âŸ¨_, _, hâŸ© => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, âŸ¨_, haâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih âŸ¨_, rfl, (hb.balLeft ha).imp fun _ => âŸ¨âŸ©âŸ© (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, âŸ¨_, hbâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih âŸ¨_, rfl, (ha.balRight hb).imp fun _ => âŸ¨âŸ©âŸ© (fun.)",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red) : âˆƒ n, (path.del t c').Balanced black n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red)"},
 {"type": "(alter cut f t).Ordered cmp",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (H : âˆ€ {x t' p}, t.zoom cut = (t', p) â†’ f t'.root? = some x â†’       p.RootOrdered cmp x âˆ§ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp) : (alter cut f t).Ordered cmp := by simp [alter]; sorry",
  "name": "Ordered.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (H : âˆ€ {x t' p}, t.zoom cut = (t', p) â†’ f t'.root? = some x â†’       p.RootOrdered cmp x âˆ§ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp) : (alter cut f t).Ordered cmp",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (H : âˆ€ {x t' p}, t.zoom cut = (t', p) â†’ f t'.root? = some x â†’       p.RootOrdered cmp x âˆ§ t'.OnRoot (cmpEq cmp x))      (h : t.Ordered cmp)"},
 {"type": "âˆƒ c n, (t.alter cut f).Balanced c n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n) : âˆƒ c n, (t.alter cut f).Balanced c n := by simp [alter]; sorry",
  "name": "Balanced.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n) : âˆƒ c n, (t.alter cut f).Balanced c n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n)"},
 {"type": "t.modify cut f = t.alter cut (.map f)",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBNode Î±) : t.modify cut f = t.alter cut (.map f) := by simp [modify]; sorry",
  "name": "modify_eq_alter",
  "kind": "theorem",
  "first-tactic": "simp [modify]",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBNode Î±) : t.modify cut f = t.alter cut (.map f)",
  "args": "(câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBNode Î±)"},
 {"type": "ModifyWF t cut f",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBSet Î± cmp}      (H : âˆ€ {x}, RBNode.find? cut t.val = some x â†’ cmpEq cmp (f x) x) : ModifyWF t cut f := by refine âŸ¨.modify ?_ t.2âŸ©; sorry",
  "name": "ModifyWF.of_eq",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨.modify ?_ t.2âŸ©",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBSet Î± cmp}      (H : âˆ€ {x}, RBNode.find? cut t.val = some x â†’ cmpEq cmp (f x) x) : ModifyWF t cut f",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBSet Î± cmp}      (H : âˆ€ {x}, RBNode.find? cut t.val = some x â†’ cmpEq cmp (f x) x)"},
 {"type": "RBMap Î± Î² cmp",
  "tactic-prompt":
  "def (câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBMap Î± Î² cmp)  (k : Î±)  (f : Option Î² â†’ Option Î²) : RBMap Î± Î² cmp := by refine @RBSet.alterP _ _ t (cmp k Â·.1) (alter.adapt k f) âŸ¨.alter (@fun _ t' p eq => ?_) t.2âŸ©; sorry",
  "name": "alter",
  "kind": "def",
  "first-tactic":
  "refine @RBSet.alterP _ _ t (cmp k Â·.1) (alter.adapt k f) âŸ¨.alter (@fun _ t' p eq => ?_) t.2âŸ©",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBMap Î± Î² cmp)  (k : Î±)  (f : Option Î² â†’ Option Î²) : RBMap Î± Î² cmp",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) (t : RBMap Î± Î² cmp)  (k : Î±)  (f : Option Î² â†’ Option Î²)"},
 {"type": "t.All (fun a => p a âˆ§ q a) â†” t.All p âˆ§ t.All q",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.All (fun a => p a âˆ§ q a) â†” t.All p âˆ§ t.All q := by induction t; sorry",
  "name": "All_and",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{t : RBNode Î±} : t.All (fun a => p a âˆ§ q a) â†” t.All p âˆ§ t.All q",
  "args": "{t : RBNode Î±}"},
 {"type": "(balance1 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp := by unfold balance1; sorry",
  "name": "Ordered.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p := by unfold balance1; sorry",
  "name": "balance1_All",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}"},
 {"type": "(balance2 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp := by unfold balance2; sorry",
  "name": "Ordered.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p := by unfold balance2; sorry",
  "name": "balance2_All",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}"},
 {"type": "(setBlack t).Ordered cmp â†” t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (setBlack t).Ordered cmp â†” t.Ordered cmp := by unfold setBlack; sorry",
  "name": "Ordered.setBlack",
  "kind": "theorem",
  "first-tactic": "unfold setBlack",
  "core-prompt": "{t : RBNode Î±} : (setBlack t).Ordered cmp â†” t.Ordered cmp",
  "args": "{t : RBNode Î±}"},
 {"type": "t.setBlack.setBlack = t.setBlack",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.setBlack.setBlack = t.setBlack := by cases t; sorry",
  "name": "setBlack_idem",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode Î±} : t.setBlack.setBlack = t.setBlack",
  "args": "{t : RBNode Î±}"},
 {"type": "(t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack := by unfold insert; sorry",
  "name": "insert_setBlack",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode Î±} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "args": "{t : RBNode Î±}"},
 {"type": "(ins cmp x t).All p",
  "tactic-prompt":
  "theorem {x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p) : (ins cmp x t).All p := by induction t; sorry",
  "name": "All.ins",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p) : (ins cmp x t).All p",
  "args": "{x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p)"},
 {"type": "(insert cmp t v).Ordered cmp",
  "tactic-prompt":
  "theorem (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp := by unfold RBNode.insert; sorry",
  "name": "Ordered.insert",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.insert",
  "core-prompt": "(h : t.Ordered cmp) : (insert cmp t v).Ordered cmp",
  "args": "(h : t.Ordered cmp)"},
 {"type": "âˆƒ c, (balance1 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : âˆƒ c, (balance1 l v r).Balanced c (n + 1) := by unfold balance1; sorry",
  "name": "RedRed.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : âˆƒ c, (balance1 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n)"},
 {"type": "âˆƒ c, (balance2 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : âˆƒ c, (balance2 l v r).Balanced c (n + 1) := by unfold balance2; sorry",
  "name": "RedRed.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : âˆƒ c, (balance2 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n)"},
 {"type": "balance1 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n) : balance1 l v r = node black l v r := by unfold balance1; sorry",
  "name": "balance1_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n) : balance1 l v r = node black l v r",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)"},
 {"type": "balance2 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n) : balance2 l v r = node black l v r := by unfold balance2; sorry",
  "name": "balance2_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n) : balance2 l v r = node black l v r",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n)"},
 {"type": "âˆƒ c' n', (insert cmp t v).Balanced c' n'",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.Balanced c n) : âˆƒ c' n', (insert cmp t v).Balanced c' n' := by unfold insert; sorry",
  "name": "Balanced.insert",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode Î±}  (h : t.Balanced c n) : âˆƒ c' n', (insert cmp t v).Balanced c' n'",
  "args": "{t : RBNode Î±}  (h : t.Balanced c n)"},
 {"type": "(setRed t).All p",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.All p) : (setRed t).All p := by unfold setRed; sorry",
  "name": "All.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode Î±}  (h : t.All p) : (setRed t).All p",
  "args": "{t : RBNode Î±}  (h : t.All p)"},
 {"type": "(setRed t).Ordered cmp â†” t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (setRed t).Ordered cmp â†” t.Ordered cmp := by unfold setRed; sorry",
  "name": "Ordered.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode Î±} : (setRed t).Ordered cmp â†” t.Ordered cmp",
  "args": "{t : RBNode Î±}"},
 {"type": "(balLeft l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p := by unfold balLeft; sorry",
  "name": "All.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balLeft l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp := by unfold balLeft; sorry",
  "name": "Ordered.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balLeft l v r).RedRed (cr = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1) := by unfold balLeft; sorry",
  "name": "Balanced.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1)",
  "args": "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1))"},
 {"type": "(balRight l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p := by unfold balRight; sorry",
  "name": "All.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balRight l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp := by unfold balRight; sorry",
  "name": "Ordered.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balRight l v r).RedRed (cl = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1) := by unfold balRight; sorry",
  "name": "Balanced.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1)",
  "args": "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n)"},
 {"type": "(append l r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hr : r.All p) : (append l r).All p := by unfold append; sorry",
  "name": "All.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt": "(hl : l.All p)  (hr : r.All p) : (append l r).All p",
  "args": "(hl : l.All p)  (hr : r.All p)"},
 {"type": "(append l r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp := by unfold append; sorry",
  "name": "Ordered.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLT cmp Â· v))  (vr : r.All (cmpLT cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n",
  "tactic-prompt":
  "theorem {l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n) : (l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n := by unfold append; sorry",
  "name": "Balanced.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n) : (l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n",
  "args":
  "{l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n)"},
 {"type": "âˆƒ n', RedRed (c = black) t n'",
  "tactic-prompt":
  "theorem (h : DelProp c t n) : âˆƒ n', RedRed (c = black) t n' := by unfold DelProp at h; sorry",
  "name": "DelProp.redred",
  "kind": "theorem",
  "first-tactic": "unfold DelProp at h",
  "core-prompt": "(h : DelProp c t n) : âˆƒ n', RedRed (c = black) t n'",
  "args": "(h : DelProp c t n)"},
 {"type": "(t.del cut).DelProp t.isBlack n",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n := by induction h; sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode Î±}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n",
  "args": "{t : RBNode Î±}  (h : t.Balanced c n)"},
 {"type": "t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.WF cmp) : t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode Î±}  (h : t.WF cmp) : t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n",
  "args": "{t : RBNode Î±}  (h : t.WF cmp)"},
 {"type": "t.All p â†” âˆ€ x âˆˆ t, p x",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.All p â†” âˆ€ x âˆˆ t, p x := by induction t; sorry",
  "name": "All_def",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode Î±} : t.All p â†” âˆ€ x âˆˆ t, p x",
  "args": "{t : RBNode Î±}"},
 {"type": "t.Any p â†” âˆƒ x âˆˆ t, p x",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.Any p â†” âˆƒ x âˆˆ t, p x := by induction t; sorry",
  "name": "Any_def",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode Î±} : t.Any p â†” âˆƒ x âˆˆ t, p x",
  "args": "{t : RBNode Î±}"},
 {"type": "cut x = cut y",
  "tactic-prompt":
  "theorem [IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq) : cut x = cut y := by cases ey : cut y; sorry",
  "name": "IsCut.congr",
  "kind": "theorem",
  "first-tactic": "cases ey : cut y",
  "core-prompt":
  "[IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq) : cut x = cut y",
  "args": "[IsCut cmp cut]  [TransCmp cmp]  (H : cmp x y = .eq)"},
 {"type": "x âˆˆ t.find? cut â†’ cut x = .eq",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : x âˆˆ t.find? cut â†’ cut x = .eq := by induction t; sorry",
  "name": "find?_some_eq_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode Î±} : x âˆˆ t.find? cut â†’ cut x = .eq",
  "args": "{t : RBNode Î±}"},
 {"type": "x âˆˆ t.find? cut â†’ x âˆˆ t",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : x âˆˆ t.find? cut â†’ x âˆˆ t := by induction t; sorry",
  "name": "find?_some_mem",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode Î±} : x âˆˆ t.find? cut â†’ x âˆˆ t",
  "args": "{t : RBNode Î±}"},
 {"type": "MemP cut t â†” âˆƒ x, x âˆˆ t.find? cut",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : MemP cut t â†” âˆƒ x, x âˆˆ t.find? cut := by refine âŸ¨fun H => ?_, fun âŸ¨x, hâŸ© => find?_some_memP hâŸ©; sorry",
  "name": "Ordered.memP_iff_find?",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun H => ?_, fun âŸ¨x, hâŸ© => find?_some_memP hâŸ©",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : MemP cut t â†” âˆƒ x, x âˆˆ t.find? cut",
  "args": "[@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "x = y",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  (ht : Ordered cmp t)      (hx : x âˆˆ t)  (hy : y âˆˆ t)  (e : cmp x y = .eq) : x = y := by induction t; sorry",
  "name": "Ordered.unique",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "[@TransCmp Î± cmp]  (ht : Ordered cmp t)      (hx : x âˆˆ t)  (hy : y âˆˆ t)  (e : cmp x y = .eq) : x = y",
  "args":
  "[@TransCmp Î± cmp]  (ht : Ordered cmp t)      (hx : x âˆˆ t)  (hy : y âˆˆ t)  (e : cmp x y = .eq)"},
 {"type": "x âˆˆ t.find? cut â†” x âˆˆ t âˆ§ cut x = .eq",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t) : x âˆˆ t.find? cut â†” x âˆˆ t âˆ§ cut x = .eq := by refine âŸ¨fun h => âŸ¨find?_some_mem h, find?_some_eq_eq hâŸ©, fun âŸ¨hx, eâŸ© => ?_âŸ©; sorry",
  "name": "Ordered.mem_find?",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun h => âŸ¨find?_some_mem h, find?_some_eq_eq hâŸ©, fun âŸ¨hx, eâŸ© => ?_âŸ©",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t) : x âˆˆ t.find? cut â†” x âˆˆ t âˆ§ cut x = .eq",
  "args": "[@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "x âˆˆ t.lowerBound? cut lb â†’ cut x â‰  .lt",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (H : âˆ€ {x}, x âˆˆ lb â†’ cut x â‰  .lt) : x âˆˆ t.lowerBound? cut lb â†’ cut x â‰  .lt := by induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    Â· exact ihl H\n    Â· next hv => exact ihr fun | rfl]; sorry",
  "name": "lowerBound?_le'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    Â· exact ihl H\n    Â· next hv => exact ihr fun | rfl]",
  "core-prompt":
  "{t : RBNode Î±}  (H : âˆ€ {x}, x âˆˆ lb â†’ cut x â‰  .lt) : x âˆˆ t.lowerBound? cut lb â†’ cut x â‰  .lt",
  "args": "{t : RBNode Î±}  (H : âˆ€ {x}, x âˆˆ lb â†’ cut x â‰  .lt)"},
 {"type": "x âˆˆ t.lowerBound? cut lb â†’ p x",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (hp : t.All p)  (H : âˆ€ {x}, x âˆˆ lb â†’ p x) : x âˆˆ t.lowerBound? cut lb â†’ p x := by induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    Â· exact ihl hp.2.1 H\n    Â· exact ihr hp.2.2 fun | rfl => hp.1\n    Â· exact fun | rfl => hp.1; sorry",
  "name": "All.lowerBound?_lb",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => exact H\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split\n    Â· exact ihl hp.2.1 H\n    Â· exact ihr hp.2.2 fun | rfl => hp.1\n    Â· exact fun | rfl => hp.1",
  "core-prompt":
  "{t : RBNode Î±}  (hp : t.All p)  (H : âˆ€ {x}, x âˆˆ lb â†’ p x) : x âˆˆ t.lowerBound? cut lb â†’ p x",
  "args": "{t : RBNode Î±}  (hp : t.All p)  (H : âˆ€ {x}, x âˆˆ lb â†’ p x)"},
 {"type": "âˆƒ x, x âˆˆ t.lowerBound? cut (some y)",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : âˆƒ x, x âˆˆ t.lowerBound? cut (some y) := by simp; sorry",
  "name": "lowerBound?_of_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{t : RBNode Î±} : âˆƒ x, x âˆˆ t.lowerBound? cut (some y)",
  "args": "{t : RBNode Î±}"},
 {"type": "(âˆƒ x, x âˆˆ t.lowerBound? cut none) â†” âˆƒ x âˆˆ t, cut x â‰  .lt",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t) : (âˆƒ x, x âˆˆ t.lowerBound? cut none) â†” âˆƒ x âˆˆ t, cut x â‰  .lt := by refine âŸ¨fun âŸ¨x, hxâŸ© => âŸ¨_, lowerBound?_mem hx, lowerBound?_le hxâŸ©, fun H => ?_âŸ©; sorry",
  "name": "Ordered.lowerBound?_exists",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun âŸ¨x, hxâŸ© => âŸ¨_, lowerBound?_mem hx, lowerBound?_le hxâŸ©, fun H => ?_âŸ©",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t) : (âˆƒ x, x âˆˆ t.lowerBound? cut none) â†” âˆƒ x âˆˆ t, cut x â‰  .lt",
  "args": "[@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t)"},
 {"type":
  "x âˆˆ t.lowerBound? cut lb â†’ y âˆˆ t â†’ cut x = .gt â†’ cmp x y = .lt â†’ cut y = .lt",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : âˆ€ {x}, x âˆˆ lb â†’ t.All (cmpLT cmp x Â·)) : x âˆˆ t.lowerBound? cut lb â†’ y âˆˆ t â†’ cut x = .gt â†’ cmp x y = .lt â†’ cut y = .lt := by induction t generalizing lb with\n  | nil => intro.\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split; sorry",
  "name": "Ordered.lowerBound?_least_lb",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing lb with\n  | nil => intro.\n  | node _ _ _ _ ihl ihr =>\n    simp [lowerBound?]; split",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : âˆ€ {x}, x âˆˆ lb â†’ t.All (cmpLT cmp x Â·)) : x âˆˆ t.lowerBound? cut lb â†’ y âˆˆ t â†’ cut x = .gt â†’ cmp x y = .lt â†’ cut y = .lt",
  "args":
  "[@TransCmp Î± cmp]  [IsCut cmp cut]  (h : Ordered cmp t)      (hlb : âˆ€ {x}, x âˆˆ lb â†’ t.All (cmpLT cmp x Â·))"},
 {"type": "t.MemP cut â†” âˆƒ x âˆˆ t.lowerBound? cut none, cut x = .eq",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : t.MemP cut â†” âˆƒ x âˆˆ t.lowerBound? cut none, cut x = .eq := by refine memP_def.trans âŸ¨fun âŸ¨y, hy, eyâŸ© => ?_, fun âŸ¨x, hx, eâŸ© => âŸ¨_, lowerBound?_mem hx, eâŸ©âŸ©; sorry",
  "name": "Ordered.memP_iff_lowerBound?",
  "kind": "theorem",
  "first-tactic":
  "refine memP_def.trans âŸ¨fun âŸ¨y, hy, eyâŸ© => ?_, fun âŸ¨x, hx, eâŸ© => âŸ¨_, lowerBound?_mem hx, eâŸ©âŸ©",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t) : t.MemP cut â†” âˆƒ x âˆˆ t.lowerBound? cut none, cut x = .eq",
  "args": "[@TransCmp Î± cmp]  [IsCut cmp cut]  (ht : Ordered cmp t)"},
 {"type": "cmp x y = .lt â†” cut y = .lt",
  "tactic-prompt":
  "theorem [@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x âˆˆ t.lowerBound? cut none)  (hy : y âˆˆ t) : cmp x y = .lt â†” cut y = .lt := by refine âŸ¨fun h => ?_, fun h => OrientedCmp.cmp_eq_gt.1 ?_âŸ©; sorry",
  "name": "Ordered.lowerBound?_lt",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, fun h => OrientedCmp.cmp_eq_gt.1 ?_âŸ©",
  "core-prompt":
  "[@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x âˆˆ t.lowerBound? cut none)  (hy : y âˆˆ t) : cmp x y = .lt â†” cut y = .lt",
  "args":
  "[@TransCmp Î± cmp]  [IsStrictCut cmp cut]  (ht : Ordered cmp t)      (H : x âˆˆ t.lowerBound? cut none)  (hy : y âˆˆ t)"},
 {"type": "(.node c a x b : RBNode Î±).toList = a.toList ++ x :: b.toList",
  "tactic-prompt":
  "theorem  : (.node c a x b : RBNode Î±).toList = a.toList ++ x :: b.toList := by rw [toList]; sorry",
  "name": "toList_node",
  "kind": "theorem",
  "first-tactic": "rw [toList]",
  "core-prompt":
  " : (.node c a x b : RBNode Î±).toList = a.toList ++ x :: b.toList",
  "args": ""},
 {"type": "x âˆˆ t.toList â†” x âˆˆ t",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : x âˆˆ t.toList â†” x âˆˆ t := by induction t; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt": "{t : RBNode Î±} : x âˆˆ t.toList â†” x âˆˆ t",
  "args": "{t : RBNode Î±}"},
 {"type": "t.foldr f init = t.toList.foldr f init",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.foldr f init = t.toList.foldr f init := by induction t generalizing init; sorry",
  "name": "foldr_eq_foldr_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt": "{t : RBNode Î±} : t.foldr f init = t.toList.foldr f init",
  "args": "{t : RBNode Î±}"},
 {"type": "t.foldl f init = t.toList.foldl f init",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.foldl f init = t.toList.foldl f init := by induction t generalizing init; sorry",
  "name": "foldl_eq_foldl_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt": "{t : RBNode Î±} : t.foldl f init = t.toList.foldl f init",
  "args": "{t : RBNode Î±}"},
 {"type": "t.forM (m := m) f = t.toList.forM f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode Î±} : t.forM (m := m) f = t.toList.forM f := by induction t; sorry",
  "name": "forM_eq_forM_toList",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode Î±} : t.forM (m := m) f = t.toList.forM f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode Î±}"},
 {"type": "t.foldlM (m := m) f init = t.toList.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode Î±} : t.foldlM (m := m) f init = t.toList.foldlM f init := by induction t generalizing init; sorry",
  "name": "foldlM_eq_foldlM_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode Î±} : t.foldlM (m := m) f init = t.toList.foldlM f init",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode Î±}"},
 {"type":
  "forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList := by induction t generalizing init; sorry",
  "name": "forIn_visit_eq_bindList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode Î±}"},
 {"type": "forIn (m := m) t init f = forIn t.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn (m := m) t init f = forIn t.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq_forIn_toList",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn (m := m) t init f = forIn t.toList init f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode Î±}"},
 {"type": "(.cons x r s : RBNode.Stream Î±).toList = x :: r.toList ++ s.toList",
  "tactic-prompt":
  "theorem  : (.cons x r s : RBNode.Stream Î±).toList = x :: r.toList ++ s.toList := by rw [toList]; sorry",
  "name": "toList_cons",
  "kind": "theorem",
  "first-tactic": "rw [toList]",
  "core-prompt":
  " : (.cons x r s : RBNode.Stream Î±).toList = x :: r.toList ++ s.toList",
  "args": ""},
 {"type": "s.foldr f init = s.toList.foldr f init",
  "tactic-prompt":
  "theorem {s : RBNode.Stream Î±} : s.foldr f init = s.toList.foldr f init := by induction s; sorry",
  "name": "foldr_eq_foldr_toList",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{s : RBNode.Stream Î±} : s.foldr f init = s.toList.foldr f init",
  "args": "{s : RBNode.Stream Î±}"},
 {"type": "t.foldl f init = t.toList.foldl f init",
  "tactic-prompt":
  "theorem {t : RBNode.Stream Î±} : t.foldl f init = t.toList.foldl f init := by induction t generalizing init; sorry",
  "name": "foldl_eq_foldl_toList",
  "kind": "theorem",
  "first-tactic": "induction t generalizing init",
  "core-prompt":
  "{t : RBNode.Stream Î±} : t.foldl f init = t.toList.foldl f init",
  "args": "{t : RBNode.Stream Î±}"},
 {"type": "forIn (m := m) t init f = forIn t.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn (m := m) t init f = forIn t.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq_forIn_toList",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {t : RBNode Î±} : forIn (m := m) t init f = forIn t.toList init f",
  "args": "[Monad m]  [LawfulMonad m]  {t : RBNode Î±}"},
 {"type": "t.toStream.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.toStream.toList = t.toList := by simp [toStream_toList']; sorry",
  "name": "toStream_toList",
  "kind": "theorem",
  "first-tactic": "simp [toStream_toList']",
  "core-prompt": "{t : RBNode Î±} : t.toStream.toList = t.toList",
  "args": "{t : RBNode Î±}"},
 {"type": "(s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next?",
  "tactic-prompt":
  "theorem {s : RBNode.Stream Î±} : (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next? := by cases s; sorry",
  "name": "Stream.next?_toList",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : RBNode.Stream Î±} : (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next?",
  "args": "{s : RBNode.Stream Î±}"},
 {"type": "t.Ordered cmp â†” t.toList.Pairwise (cmpLT cmp)",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.Ordered cmp â†” t.toList.Pairwise (cmpLT cmp) := by induction t; sorry",
  "name": "ordered_iff",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{t : RBNode Î±} : t.Ordered cmp â†” t.toList.Pairwise (cmpLT cmp)",
  "args": "{t : RBNode Î±}"},
 {"type": "t.setBlack.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.setBlack.toList = t.toList := by cases t; sorry",
  "name": "setBlack_toList",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode Î±} : t.setBlack.toList = t.toList",
  "args": "{t : RBNode Î±}"},
 {"type": "t.setRed.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.setRed.toList = t.toList := by cases t; sorry",
  "name": "setRed_toList",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode Î±} : t.setRed.toList = t.toList",
  "args": "{t : RBNode Î±}"},
 {"type":
  "p.RootOrdered cmp v â†” (âˆ€ a âˆˆ p.listL, cmpLT cmp a v) âˆ§ (âˆ€ a âˆˆ p.listR, cmpLT cmp v a)",
  "tactic-prompt":
  "theorem {p : Path Î±}  (hp : p.Ordered cmp) : p.RootOrdered cmp v â†” (âˆ€ a âˆˆ p.listL, cmpLT cmp a v) âˆ§ (âˆ€ a âˆˆ p.listR, cmpLT cmp v a) := by induction p; sorry",
  "name": "rootOrdered_iff",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{p : Path Î±}  (hp : p.Ordered cmp) : p.RootOrdered cmp v â†” (âˆ€ a âˆˆ p.listL, cmpLT cmp a v) âˆ§ (âˆ€ a âˆˆ p.listR, cmpLT cmp v a)",
  "args": "{p : Path Î±}  (hp : p.Ordered cmp)"},
 {"type":
  "p.Ordered cmp â†” p.listL.Pairwise (cmpLT cmp) âˆ§ p.listR.Pairwise (cmpLT cmp) âˆ§\n      âˆ€ x âˆˆ p.listL, âˆ€ y âˆˆ p.listR, cmpLT cmp x y",
  "tactic-prompt":
  "theorem {p : Path Î±} : p.Ordered cmp â†” p.listL.Pairwise (cmpLT cmp) âˆ§ p.listR.Pairwise (cmpLT cmp) âˆ§\n      âˆ€ x âˆˆ p.listL, âˆ€ y âˆˆ p.listR, cmpLT cmp x y := by induction p; sorry",
  "name": "ordered_iff",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{p : Path Î±} : p.Ordered cmp â†” p.listL.Pairwise (cmpLT cmp) âˆ§ p.listR.Pairwise (cmpLT cmp) âˆ§\n      âˆ€ x âˆˆ p.listL, âˆ€ y âˆˆ p.listR, cmpLT cmp x y",
  "args": "{p : Path Î±}"},
 {"type": "(p.fill t).toList = p.withList t.toList",
  "tactic-prompt":
  "theorem {p : Path Î±} : (p.fill t).toList = p.withList t.toList := by induction p generalizing t; sorry",
  "name": "fill_toList",
  "kind": "theorem",
  "first-tactic": "induction p generalizing t",
  "core-prompt": "{p : Path Î±} : (p.fill t).toList = p.withList t.toList",
  "args": "{p : Path Î±}"},
 {"type": "p'.withList t'.toList = t.toList",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (eq : t.zoom cut = (t', p')) : p'.withList t'.toList = t.toList := by rw [â† fill_toList]; sorry",
  "name": "_root_.Std.RBNode.zoom_toList",
  "kind": "theorem",
  "first-tactic": "rw [â† fill_toList]",
  "core-prompt":
  "{t : RBNode Î±}  (eq : t.zoom cut = (t', p')) : p'.withList t'.toList = t.toList",
  "args": "{t : RBNode Î±}  (eq : t.zoom cut = (t', p'))"},
 {"type": "(p.ins t).toList = p.withList t.toList",
  "tactic-prompt":
  "theorem {p : Path Î±} : (p.ins t).toList = p.withList t.toList := by match p with\n  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>\n    simp [ins]; sorry",
  "name": "ins_toList",
  "kind": "theorem",
  "first-tactic":
  "match p with\n  | .root | .left red .. | .right red .. | .left black .. | .right black .. =>\n    simp [ins]",
  "core-prompt": "{p : Path Î±} : (p.ins t).toList = p.withList t.toList",
  "args": "{p : Path Î±}"},
 {"type": "(p.insertNew v).toList = p.withList [v]",
  "tactic-prompt":
  "theorem {p : Path Î±} : (p.insertNew v).toList = p.withList [v] := by simp [insertNew]; sorry",
  "name": "insertNew_toList",
  "kind": "theorem",
  "first-tactic": "simp [insertNew]",
  "core-prompt": "{p : Path Î±} : (p.insertNew v).toList = p.withList [v]",
  "args": "{p : Path Î±}"},
 {"type": "(p.insert t v).toList = p.withList (t.setRoot v).toList",
  "tactic-prompt":
  "theorem {p : Path Î±} : (p.insert t v).toList = p.withList (t.setRoot v).toList := by simp [insert]; sorry",
  "name": "insert_toList",
  "kind": "theorem",
  "first-tactic": "simp [insert]",
  "core-prompt":
  "{p : Path Î±} : (p.insert t v).toList = p.withList (t.setRoot v).toList",
  "args": "{p : Path Î±}"},
 {"type": "âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²) : âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚ := by intro lâ‚; sorry",
  "name": "map_append",
  "kind": "theorem",
  "first-tactic": "intro lâ‚",
  "core-prompt":
  "(f : Î± â†’ Î²) : âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚",
  "args": "(f : Î± â†’ Î²)"},
 {"type": "map id l = l",
  "tactic-prompt":
  "theorem (l : List Î±) : map id l = l := by induction l; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : map id l = l",
  "args": "(l : List Î±)"},
 {"type": "map g (map f l) = map (g âˆ˜ f) l",
  "tactic-prompt":
  "theorem (g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±) : map g (map f l) = map (g âˆ˜ f) l := by induction l; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±) : map g (map f l) = map (g âˆ˜ f) l",
  "args": "(g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±)"},
 {"type": "List.bind [] f = []",
  "tactic-prompt":
  "theorem (f : Î± â†’ List Î²) : List.bind [] f = [] := by simp [join]; sorry",
  "name": "nil_bind",
  "kind": "theorem",
  "first-tactic": "simp [join]",
  "core-prompt": "(f : Î± â†’ List Î²) : List.bind [] f = []",
  "args": "(f : Î± â†’ List Î²)"},
 {"type": "List.bind l id = l.join",
  "tactic-prompt":
  "theorem (l : List (List Î±)) : List.bind l id = l.join := by simp [List.bind]; sorry",
  "name": "bind_id",
  "kind": "theorem",
  "first-tactic": "simp [List.bind]",
  "core-prompt": "(l : List (List Î±)) : List.bind l id = l.join",
  "args": "(l : List (List Î±))"},
 {"type": "(l.map f).reverse = l.reverse.map f",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (l : List Î±) : (l.map f).reverse = l.reverse.map f := by induction l; sorry",
  "name": "reverse_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î²)  (l : List Î±) : (l.map f).reverse = l.reverse.map f",
  "args": "(f : Î± â†’ Î²)  (l : List Î±)"},
 {"type": "take i l = l",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : l.length â‰¤ i) : take i l = l := by have := take_append_drop i l; sorry",
  "name": "take_length_le",
  "kind": "theorem",
  "first-tactic": "have := take_append_drop i l",
  "core-prompt": "{l : List Î±}  (h : l.length â‰¤ i) : take i l = l",
  "args": "{l : List Î±}  (h : l.length â‰¤ i)"},
 {"type": "(l.concat a).reverse = a :: l.reverse",
  "tactic-prompt":
  "theorem (l : List Î±)  (a : Î±) : (l.concat a).reverse = a :: l.reverse := by rw [concat_eq_append]; sorry",
  "name": "reverse_concat",
  "kind": "theorem",
  "first-tactic": "rw [concat_eq_append]",
  "core-prompt":
  "(l : List Î±)  (a : Î±) : (l.concat a).reverse = a :: l.reverse",
  "args": "(l : List Î±)  (a : Î±)"},
 {"type": "l.foldr cons l' = l ++ l'",
  "tactic-prompt":
  "theorem (l : List Î±) : l.foldr cons l' = l ++ l' := by induction l; sorry",
  "name": "foldr_self_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : l.foldr cons l' = l ++ l'",
  "args": "(l : List Î±)"},
 {"type": "l.foldr cons [] = l",
  "tactic-prompt":
  "theorem (l : List Î±) : l.foldr cons [] = l := by simp; sorry",
  "name": "foldr_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(l : List Î±) : l.foldr cons [] = l",
  "args": "(l : List Î±)"},
 {"type": "mapM' f l = mapM f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±) : mapM' f l = mapM f l := by simp [go]; sorry",
  "name": "mapM'_eq_mapM",
  "kind": "theorem",
  "first-tactic": "simp [go]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±) : mapM' f l = mapM f l",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±)"},
 {"type": "(a :: l).mapM f = (return (â† f a) :: (â† l.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²) : (a :: l).mapM f = (return (â† f a) :: (â† l.mapM f)) := by simp [â† mapM'_eq_mapM]; sorry",
  "name": "mapM_cons",
  "kind": "theorem",
  "first-tactic": "simp [â† mapM'_eq_mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²) : (a :: l).mapM f = (return (â† f a) :: (â† l.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)"},
 {"type": "(lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f)) := by induction lâ‚; sorry",
  "name": "mapM_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "@set = @setTR",
  "tactic-prompt": "theorem  : @set = @setTR := by funext Î± l n a; sorry",
  "name": "set_eq_setTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n a",
  "core-prompt": " : @set = @setTR",
  "args": ""},
 {"type": "@List.erase = @eraseTR",
  "tactic-prompt":
  "theorem  : @List.erase = @eraseTR := by funext Î± _ l a; sorry",
  "name": "erase_eq_eraseTR",
  "kind": "theorem",
  "first-tactic": "funext Î± _ l a",
  "core-prompt": " : @List.erase = @eraseTR",
  "args": ""},
 {"type": "@eraseIdx = @eraseIdxTR",
  "tactic-prompt":
  "theorem  : @eraseIdx = @eraseIdxTR := by funext Î± l n; sorry",
  "name": "eraseIdx_eq_eraseIdxTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n",
  "core-prompt": " : @eraseIdx = @eraseIdxTR",
  "args": ""},
 {"type": "@List.bind = @bindTR",
  "tactic-prompt":
  "theorem  : @List.bind = @bindTR := by funext Î± Î² as f; sorry",
  "name": "bind_eq_bindTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² as f",
  "core-prompt": " : @List.bind = @bindTR",
  "args": ""},
 {"type": "@join = @joinTR",
  "tactic-prompt": "theorem  : @join = @joinTR := by funext Î± l; sorry",
  "name": "join_eq_joinTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @join = @joinTR",
  "args": ""},
 {"type": "@List.filterMap = @filterMapTR",
  "tactic-prompt":
  "theorem  : @List.filterMap = @filterMapTR := by funext Î± Î² f l; sorry",
  "name": "filterMap_eq_filterMapTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² f l",
  "core-prompt": " : @List.filterMap = @filterMapTR",
  "args": ""},
 {"type": "@List.replace = @replaceTR",
  "tactic-prompt":
  "theorem  : @List.replace = @replaceTR := by funext Î± _ l b c; sorry",
  "name": "replace_eq_replaceTR",
  "kind": "theorem",
  "first-tactic": "funext Î± _ l b c",
  "core-prompt": " : @List.replace = @replaceTR",
  "args": ""},
 {"type": "@take = @takeTR",
  "tactic-prompt": "theorem  : @take = @takeTR := by funext Î± n l; sorry",
  "name": "take_eq_takeTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n l",
  "core-prompt": " : @take = @takeTR",
  "args": ""},
 {"type": "@takeWhile = @takeWhileTR",
  "tactic-prompt":
  "theorem  : @takeWhile = @takeWhileTR := by funext Î± p l; sorry",
  "name": "takeWhile_eq_takeWhileTR",
  "kind": "theorem",
  "first-tactic": "funext Î± p l",
  "core-prompt": " : @takeWhile = @takeWhileTR",
  "args": ""},
 {"type": "@foldr = @foldrTR",
  "tactic-prompt":
  "theorem  : @foldr = @foldrTR := by funext Î± Î² f init l; sorry",
  "name": "foldr_eq_foldrTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² f init l",
  "core-prompt": " : @foldr = @foldrTR",
  "args": ""},
 {"type": "@zipWith = @zipWithTR",
  "tactic-prompt":
  "theorem  : @zipWith = @zipWithTR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWith_eq_zipWithTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWith = @zipWithTR",
  "args": ""},
 {"type": "@unzip = @unzipTR",
  "tactic-prompt": "theorem  : @unzip = @unzipTR := by funext Î± Î² l; sorry",
  "name": "unzip_eq_unzipTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² l",
  "core-prompt": " : @unzip = @unzipTR",
  "args": ""},
 {"type": "@enumFrom = @enumFromTR",
  "tactic-prompt":
  "theorem  : @enumFrom = @enumFromTR := by funext Î± n l; sorry",
  "name": "enumFrom_eq_enumFromTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n l",
  "core-prompt": " : @enumFrom = @enumFromTR",
  "args": ""},
 {"type": "@dropLast = @dropLastTR",
  "tactic-prompt": "theorem  : @dropLast = @dropLastTR := by funext Î± l; sorry",
  "name": "dropLast_eq_dropLastTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @dropLast = @dropLastTR",
  "args": ""},
 {"type": "@intersperse = @intersperseTR",
  "tactic-prompt":
  "theorem  : @intersperse = @intersperseTR := by funext Î± sep l; sorry",
  "name": "intersperse_eq_intersperseTR",
  "kind": "theorem",
  "first-tactic": "funext Î± sep l",
  "core-prompt": " : @intersperse = @intersperseTR",
  "args": ""},
 {"type": "@intercalate = @intercalateTR",
  "tactic-prompt":
  "theorem  : @intercalate = @intercalateTR := by funext Î± sep l; sorry",
  "name": "intercalate_eq_intercalateTR",
  "kind": "theorem",
  "first-tactic": "funext Î± sep l",
  "core-prompt": " : @intercalate = @intercalateTR",
  "args": ""},
 {"type": "@removeNth = @removeNthTR",
  "tactic-prompt":
  "theorem  : @removeNth = @removeNthTR := by funext Î± l n; sorry",
  "name": "removeNth_eq_removeNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n",
  "core-prompt": " : @removeNth = @removeNthTR",
  "args": ""},
 {"type": "@replaceF = @replaceFTR",
  "tactic-prompt":
  "theorem  : @replaceF = @replaceFTR := by funext Î± f l; sorry",
  "name": "replaceF_eq_replaceFTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f l",
  "core-prompt": " : @replaceF = @replaceFTR",
  "args": ""},
 {"type": "@modifyNth = @modifyNthTR",
  "tactic-prompt":
  "theorem  : @modifyNth = @modifyNthTR := by funext Î± f n l; sorry",
  "name": "modifyNth_eq_modifyNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @modifyNth = @modifyNthTR",
  "args": ""},
 {"type": "@insertNth = @insertNthTR",
  "tactic-prompt":
  "theorem  : @insertNth = @insertNthTR := by funext Î± f n l; sorry",
  "name": "insertNth_eq_insertNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @insertNth = @insertNthTR",
  "args": ""},
 {"type": "@takeD = @takeDTR",
  "tactic-prompt": "theorem  : @takeD = @takeDTR := by funext Î± f n l; sorry",
  "name": "takeD_eq_takeDTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @takeD = @takeDTR",
  "args": ""},
 {"type": "@leftpad = @leftpadTR",
  "tactic-prompt":
  "theorem  : @leftpad = @leftpadTR := by funext Î± n a l; sorry",
  "name": "leftpad_eq_leftpadTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n a l",
  "core-prompt": " : @leftpad = @leftpadTR",
  "args": ""},
 {"type": "@scanl = @scanlTR",
  "tactic-prompt": "theorem  : @scanl = @scanlTR := by funext Î± f n l; sorry",
  "name": "scanl_eq_scanlTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @scanl = @scanlTR",
  "args": ""},
 {"type": "@inits = @initsTR",
  "tactic-prompt": "theorem  : @inits = @initsTR := by funext Î± l; sorry",
  "name": "inits_eq_initsTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @inits = @initsTR",
  "args": ""},
 {"type": "@tails = @tailsTR",
  "tactic-prompt": "theorem  : @tails = @tailsTR := by funext Î±; sorry",
  "name": "tails_eq_tailsTR",
  "kind": "theorem",
  "first-tactic": "funext Î±",
  "core-prompt": " : @tails = @tailsTR",
  "args": ""},
 {"type": "@sections = @sectionsTR",
  "tactic-prompt": "theorem  : @sections = @sectionsTR := by funext Î± L; sorry",
  "name": "sections_eq_sectionsTR",
  "kind": "theorem",
  "first-tactic": "funext Î± L",
  "core-prompt": " : @sections = @sectionsTR",
  "args": ""},
 {"type": "@eraseP = @erasePTR",
  "tactic-prompt": "theorem  : @eraseP = @erasePTR := by funext Î± p l; sorry",
  "name": "eraseP_eq_erasePTR",
  "kind": "theorem",
  "first-tactic": "funext Î± p l",
  "core-prompt": " : @eraseP = @erasePTR",
  "args": ""},
 {"type": "@product = @productTR",
  "tactic-prompt":
  "theorem  : @product = @productTR := by funext Î± Î² lâ‚ lâ‚‚; sorry",
  "name": "product_eq_productTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² lâ‚ lâ‚‚",
  "core-prompt": " : @product = @productTR",
  "args": ""},
 {"type": "@List.sigma = @sigmaTR",
  "tactic-prompt":
  "theorem  : @List.sigma = @sigmaTR := by funext Î± Î² lâ‚ lâ‚‚; sorry",
  "name": "sigma_eq_sigmaTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² lâ‚ lâ‚‚",
  "core-prompt": " : @List.sigma = @sigmaTR",
  "args": ""},
 {"type": "@range' = @range'TR",
  "tactic-prompt": "theorem  : @range' = @range'TR := by funext s n; sorry",
  "name": "range'_eq_range'TR",
  "kind": "theorem",
  "first-tactic": "funext s n",
  "core-prompt": " : @range' = @range'TR",
  "args": ""},
 {"type": "@dropSlice = @dropSliceTR",
  "tactic-prompt":
  "theorem  : @dropSlice = @dropSliceTR := by funext Î± n m l; sorry",
  "name": "dropSlice_eq_dropSliceTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n m l",
  "core-prompt": " : @dropSlice = @dropSliceTR",
  "args": ""},
 {"type": "@zipWithLeft' = @zipWithLeft'TR",
  "tactic-prompt":
  "theorem  : @zipWithLeft' = @zipWithLeft'TR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWithLeft'_eq_zipWithLeft'TR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWithLeft' = @zipWithLeft'TR",
  "args": ""},
 {"type": "@zipWithLeft = @zipWithLeftTR",
  "tactic-prompt":
  "theorem  : @zipWithLeft = @zipWithLeftTR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWithLeft_eq_zipWithLeftTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWithLeft = @zipWithLeftTR",
  "args": ""},
 {"type": "@fillNones = @fillNonesTR",
  "tactic-prompt":
  "theorem  : @fillNones = @fillNonesTR := by funext Î± as as'; sorry",
  "name": "fillNones_eq_fillNonesTR",
  "kind": "theorem",
  "first-tactic": "funext Î± as as'",
  "core-prompt": " : @fillNones = @fillNonesTR",
  "args": ""},
 {"type": "@takeList = @takeListTR",
  "tactic-prompt":
  "theorem  : @takeList = @takeListTR := by funext Î± xs ns; sorry",
  "name": "takeList_eq_takeListTR",
  "kind": "theorem",
  "first-tactic": "funext Î± xs ns",
  "core-prompt": " : @takeList = @takeListTR",
  "args": ""},
 {"type": "a âˆˆ ([] : List Î±) â†” False",
  "tactic-prompt":
  "theorem (a : Î±) : a âˆˆ ([] : List Î±) â†” False := by simp; sorry",
  "name": "mem_nil_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : Î±) : a âˆˆ ([] : List Î±) â†” False",
  "args": "(a : Î±)"},
 {"type": "l â‰  []",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  [] := by cases h; sorry",
  "name": "ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  []",
  "args": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "p ++ q = [] â†” p = [] âˆ§ q = []",
  "tactic-prompt":
  "theorem  : p ++ q = [] â†” p = [] âˆ§ q = [] := by cases p; sorry",
  "name": "append_eq_nil",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": " : p ++ q = [] â†” p = [] âˆ§ q = []",
  "args": ""},
 {"type": "s â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : s â‰  [] â†’ s ++ t â‰  [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List Î±) : s â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "t â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : t â‰  [] â†’ s ++ t â‰  [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List Î±) : t â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "[] = a ++ b â†” a = [] âˆ§ b = []",
  "tactic-prompt":
  "theorem  : [] = a ++ b â†” a = [] âˆ§ b = [] := by rw [eq_comm]; sorry",
  "name": "nil_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": " : [] = a ++ b â†” a = [] âˆ§ b = []",
  "args": ""},
 {"type": "a ++ b â‰  []",
  "tactic-prompt":
  "theorem (a b : List Î±)  (h0 : a â‰  []) : a ++ b â‰  [] := by simp [*]; sorry",
  "name": "append_ne_nil_of_left_ne_nil",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt": "(a b : List Î±)  (h0 : a â‰  []) : a ++ b â‰  []",
  "args": "(a b : List Î±)  (h0 : a â‰  [])"},
 {"type":
  "a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b) := by cases a; sorry",
  "name": "append_eq_cons",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  " : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "args": ""},
 {"type":
  "x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b) := by rw [eq_comm]; sorry",
  "name": "cons_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  " : x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "args": ""},
 {"type":
  "a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b",
  "tactic-prompt":
  "theorem {a b c d : List Î±} : a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b := by induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun âŸ¨_, âŸ¨e, rflâŸ©, hâŸ© => e â–¸ h.symm).symm\n  | cons a as ih => cases c; sorry",
  "name": "append_eq_append_iff",
  "kind": "theorem",
  "first-tactic":
  "induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun âŸ¨_, âŸ¨e, rflâŸ©, hâŸ© => e â–¸ h.symm).symm\n  | cons a as ih => cases c",
  "core-prompt":
  "{a b c d : List Î±} : a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b",
  "args": "{a b c d : List Î±}"},
 {"type": "a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "tactic-prompt":
  "theorem {a : Î±}  {s t : List Î±} : a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t := by induction s; sorry",
  "name": "mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "{a : Î±}  {s t : List Î±} : a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "args": "{a : Î±}  {s t : List Î±}"},
 {"type": "(âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j) := by simp [mem_map]; sorry",
  "name": "forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_map]",
  "core-prompt":
  "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j)",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop}"},
 {"type": "List.map f l = [] â†” l = []",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±} : List.map f l = [] â†” l = [] := by constructor; sorry",
  "name": "map_eq_nil",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{f : Î± â†’ Î²}  {l : List Î±} : List.map f l = [] â†” l = []",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}"},
 {"type": "(âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x := by simp; sorry",
  "name": "exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x := by simp; sorry",
  "name": "forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆ€ x âˆˆ [a], p x) â†” p a",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x âˆˆ [a], p x) â†” p a := by simp only [mem_singleton]; sorry",
  "name": "forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "simp only [mem_singleton]",
  "core-prompt": "{p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x âˆˆ [a], p x) â†” p a",
  "args": "{p : Î± â†’ Prop}  {a : Î±}"},
 {"type": "(âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x)",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x) := by simp only [mem_append]; sorry",
  "name": "forall_mem_append",
  "kind": "theorem",
  "first-tactic": "simp only [mem_append]",
  "core-prompt":
  "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x)",
  "args": "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "tactic-prompt":
  "theorem  : a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m := by simp only [subset_def]; sorry",
  "name": "cons_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt": " : a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "args": ""},
 {"type": "lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l := by simp [subset_def]; sorry",
  "name": "append_subset",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt": "{lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "args": "{lâ‚ lâ‚‚ l : List Î±}"},
 {"type":
  "âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚ := by induction l; sorry",
  "name": "getLast_cons'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±} : âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type": "tailD l l' = (tail? l).getD l'",
  "tactic-prompt":
  "theorem (l l' : List Î±) : tailD l l' = (tail? l).getD l' := by cases l; sorry",
  "name": "tailD_eq_tail?",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l l' : List Î±) : tailD l l' = (tail? l).getD l'",
  "args": "(l l' : List Î±)"},
 {"type": "@getLast! Î± _ (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem [Inhabited Î±] : @getLast! Î± _ (a::l) = getLastD l a := by simp [getLast!]; sorry",
  "name": "getLast!_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast!]",
  "core-prompt": "[Inhabited Î±] : @getLast! Î± _ (a::l) = getLastD l a",
  "args": "[Inhabited Î±]"},
 {"type": "@getLast? Î± (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem  : @getLast? Î± (a::l) = getLastD l a := by simp [getLast?]; sorry",
  "name": "getLast?_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast?]",
  "core-prompt": " : @getLast? Î± (a::l) = getLastD l a",
  "args": ""},
 {"type": "dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚)",
  "tactic-prompt":
  "theorem  : dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚) := by induction lâ‚; sorry",
  "name": "dropLast_append_cons",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt": " : dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚)",
  "args": ""},
 {"type": "dropLast (lâ‚ ++ [b]) = lâ‚",
  "tactic-prompt": "theorem  : dropLast (lâ‚ ++ [b]) = lâ‚ := by simp; sorry",
  "name": "dropLast_concat",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : dropLast (lâ‚ ++ [b]) = lâ‚",
  "args": ""},
 {"type": "l.get? 0 = l.head?",
  "tactic-prompt":
  "theorem (l : List Î±) : l.get? 0 = l.head? := by cases l; sorry",
  "name": "get?_zero",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List Î±) : l.get? 0 = l.head?",
  "args": "(l : List Î±)"},
 {"type": "l[i]? = l.get? i",
  "tactic-prompt":
  "theorem (l : List Î±)  (i : Nat) : l[i]? = l.get? i := by unfold getElem?; sorry",
  "name": "getElem?_eq_get?",
  "kind": "theorem",
  "first-tactic": "unfold getElem?",
  "core-prompt": "(l : List Î±)  (i : Nat) : l[i]? = l.get? i",
  "args": "(l : List Î±)  (i : Nat)"},
 {"type": "i = j",
  "tactic-prompt":
  "theorem (hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©; sorry",
  "name": "get?_inj",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©",
  "core-prompt":
  "(hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j) : i = j",
  "args":
  "(hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j)"},
 {"type": "get l i = get l' âŸ¨i, h â–¸ i.2âŸ©",
  "tactic-prompt":
  "theorem {l l' : List Î±}  (h : l = l')  (i : Fin l.length) : get l i = get l' âŸ¨i, h â–¸ i.2âŸ© := by cases h; sorry",
  "name": "get_of_eq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{l l' : List Î±}  (h : l = l')  (i : Fin l.length) : get l i = get l' âŸ¨i, h â–¸ i.2âŸ©",
  "args": "{l l' : List Î±}  (h : l = l')  (i : Fin l.length)"},
 {"type": "n - lâ‚.length < lâ‚‚.length",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length) : n - lâ‚.length < lâ‚‚.length := by rw [length_append] at hâ‚‚; sorry",
  "name": "get_append_right_aux",
  "kind": "theorem",
  "first-tactic": "rw [length_append] at hâ‚‚",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length) : n - lâ‚.length < lâ‚‚.length",
  "args":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length)"},
 {"type": "(lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length) : (lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n := by have hn' : n < (lâ‚ ++ lâ‚‚).length := Nat.lt_of_lt_of_le hn <|\n    length_append .. â–¸ Nat.le_add_right ..; sorry",
  "name": "get?_append",
  "kind": "theorem",
  "first-tactic":
  "have hn' : n < (lâ‚ ++ lâ‚‚).length := Nat.lt_of_lt_of_le hn <|\n    length_append .. â–¸ Nat.le_add_right ..",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length) : (lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n",
  "args": "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length)"},
 {"type": "getLast? (l ++ [a]) = some a",
  "tactic-prompt":
  "theorem (l : List Î±) : getLast? (l ++ [a]) = some a := by simp [getLast?_eq_get?]; sorry",
  "name": "getLast?_concat",
  "kind": "theorem",
  "first-tactic": "simp [getLast?_eq_get?]",
  "core-prompt": "(l : List Î±) : getLast? (l ++ [a]) = some a",
  "args": "(l : List Î±)"},
 {"type":
  "(x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs)",
  "tactic-prompt":
  "theorem (x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length) : (x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs) := by rw [getLast_eq_get]; sorry",
  "name": "get_cons_length",
  "kind": "theorem",
  "first-tactic": "rw [getLast_eq_get]",
  "core-prompt":
  "(x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length) : (x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs)",
  "args": "(x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length)"},
 {"type": "length (take n l) = n",
  "tactic-prompt":
  "theorem (h : n â‰¤ length l) : length (take n l) = n := by simp [Nat.min_eq_left h]; sorry",
  "name": "length_take_of_le",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_eq_left h]",
  "core-prompt": "(h : n â‰¤ length l) : length (take n l) = n",
  "args": "(h : n â‰¤ length l)"},
 {"type": "âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚) : âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚ := by have := h; sorry",
  "name": "map_eq_append_split",
  "kind": "theorem",
  "first-tactic": "have := h",
  "core-prompt":
  "{f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚) : âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚",
  "args":
  "{f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚)"},
 {"type":
  "âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : n < l.length) : âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚ := by rw [set_eq_modifyNth]; sorry",
  "name": "exists_of_set",
  "kind": "theorem",
  "first-tactic": "rw [set_eq_modifyNth]",
  "core-prompt":
  "{l : List Î±}  (h : n < l.length) : âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚",
  "args": "{l : List Î±}  (h : n < l.length)"},
 {"type": "(l.set i a).get âŸ¨i, hâŸ© = a",
  "tactic-prompt":
  "theorem (l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length) : (l.set i a).get âŸ¨i, hâŸ© = a := by rw [â† Option.some_inj]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Option.some_inj]",
  "core-prompt":
  "(l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length) : (l.set i a).get âŸ¨i, hâŸ© = a",
  "args": "(l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length)"},
 {"type": "(l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ©",
  "tactic-prompt":
  "theorem {l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length) : (l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ© := by rw [â† Option.some_inj]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "rw [â† Option.some_inj]",
  "core-prompt":
  "{l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length) : (l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ©",
  "args":
  "{l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length)"},
 {"type": "length (tail l) = length l - 1",
  "tactic-prompt":
  "theorem (l : List Î±) : length (tail l) = length l - 1 := by cases l; sorry",
  "name": "length_tail",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List Î±) : length (tail l) = length l - 1",
  "args": "(l : List Î±)"},
 {"type": "l.all p â†” âˆ€ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {l : List Î±} : l.all p â†” âˆ€ x âˆˆ l, p x := by induction l; sorry",
  "name": "all_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±} : l.all p â†” âˆ€ x âˆˆ l, p x",
  "args": "{l : List Î±}"},
 {"type": "l.any p â†” âˆƒ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {l : List Î±} : l.any p â†” âˆƒ x âˆˆ l, p x := by induction l; sorry",
  "name": "any_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±} : l.any p â†” âˆƒ x âˆˆ l, p x",
  "args": "{l : List Î±}"},
 {"type": "x âˆˆ reverse as â†” x âˆˆ as",
  "tactic-prompt":
  "theorem (x : Î±)  (as : List Î±) : x âˆˆ reverse as â†” x âˆˆ as := by simp [reverse]; sorry",
  "name": "mem_reverse",
  "kind": "theorem",
  "first-tactic": "simp [reverse]",
  "core-prompt": "(x : Î±)  (as : List Î±) : x âˆˆ reverse as â†” x âˆˆ as",
  "args": "(x : Î±)  (as : List Î±)"},
 {"type": "l.insert a = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : l.insert a = l := by simp only [List.insert]; sorry",
  "name": "insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : l.insert a = l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "l.insert a = a :: l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : l.insert a = a :: l := by simp only [List.insert]; sorry",
  "name": "insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : l.insert a = a :: l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l)"},
 {"type": "a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±} : a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l := by if h : b âˆˆ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]; sorry",
  "name": "mem_insert_iff",
  "kind": "theorem",
  "first-tactic":
  "if h : b âˆˆ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±} : a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l",
  "args": "[DecidableEq Î±] {l : List Î±}"},
 {"type": "length (l.insert a) = length l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : length (l.insert a) = length l := by rw [insert_of_mem h]; sorry",
  "name": "length_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : length (l.insert a) = length l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "length (l.insert a) = length l + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : length (l.insert a) = length l + 1 := by rw [insert_of_not_mem h]; sorry",
  "name": "length_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : length (l.insert a) = length l + 1",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l)"},
 {"type": "l.eraseP p = l",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a) : l.eraseP p = l := by induction l; sorry",
  "name": "eraseP_of_forall_not",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a) : l.eraseP p = l",
  "args": "{l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a)"},
 {"type": "length (l.eraseP p) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem (al : a âˆˆ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l) := by let âŸ¨_, lâ‚, lâ‚‚, _, _, eâ‚, eâ‚‚âŸ© := exists_of_eraseP al pa; sorry",
  "name": "length_eraseP_of_mem",
  "kind": "theorem",
  "first-tactic": "let âŸ¨_, lâ‚, lâ‚‚, _, _, eâ‚, eâ‚‚âŸ© := exists_of_eraseP al pa",
  "core-prompt":
  "(al : a âˆˆ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l)",
  "args": "(al : a âˆˆ l)  (pa : p a)"},
 {"type": "a âˆˆ l.eraseP p â†” a âˆˆ l",
  "tactic-prompt":
  "theorem {l : List Î±}  (pa : Â¬p a) : a âˆˆ l.eraseP p â†” a âˆˆ l := by refine âŸ¨mem_of_mem_eraseP, fun al => ?_âŸ©; sorry",
  "name": "mem_eraseP_of_neg",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨mem_of_mem_eraseP, fun al => ?_âŸ©",
  "core-prompt": "{l : List Î±}  (pa : Â¬p a) : a âˆˆ l.eraseP p â†” a âˆˆ l",
  "args": "{l : List Î±}  (pa : Â¬p a)"},
 {"type": "extractP p l = (find? p l, eraseP p l)",
  "tactic-prompt":
  "theorem (l : List Î±) : extractP p l = (find? p l, eraseP p l) := by let rec go (acc) : âˆ€ xs, l = acc.data ++ xs â†’\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x; sorry",
  "name": "extractP_eq_find?_eraseP",
  "kind": "theorem",
  "first-tactic":
  "let rec go (acc) : âˆ€ xs, l = acc.data ++ xs â†’\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x",
  "core-prompt": "(l : List Î±) : extractP p l = (find? p l, eraseP p l)",
  "args": "(l : List Î±)"},
 {"type": "(a :: l).erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a : Î±)  (l : List Î±) : (a :: l).erase a = l := by simp [erase_cons]; sorry",
  "name": "erase_cons_head",
  "kind": "theorem",
  "first-tactic": "simp [erase_cons]",
  "core-prompt": "[DecidableEq Î±] (a : Î±)  (l : List Î±) : (a :: l).erase a = l",
  "args": "[DecidableEq Î±] (a : Î±)  (l : List Î±)"},
 {"type": "(b :: l).erase a = b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a) : (b :: l).erase a = b :: l.erase a := by simp only [erase_cons]; sorry",
  "name": "erase_cons_tail",
  "kind": "theorem",
  "first-tactic": "simp only [erase_cons]",
  "core-prompt":
  "[DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a) : (b :: l).erase a = b :: l.erase a",
  "args": "[DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a)"},
 {"type": "âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚ := by let âŸ¨_, lâ‚, lâ‚‚, hâ‚, e, hâ‚‚, hâ‚ƒâŸ© := exists_of_eraseP h (beq_self_eq_true _); sorry",
  "name": "exists_erase_eq",
  "kind": "theorem",
  "first-tactic":
  "let âŸ¨_, lâ‚, lâ‚‚, hâ‚, e, hâ‚‚, hâ‚ƒâŸ© := exists_of_eraseP h (beq_self_eq_true _)",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚",
  "args": "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "length (l.erase a) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : length (l.erase a) = Nat.pred (length l) := by rw [erase_eq_eraseP]; sorry",
  "name": "length_erase_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : length (l.erase a) = Nat.pred (length l)",
  "args": "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "(lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a)",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚) : (lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a) := by rw [erase_eq_eraseP]; sorry",
  "name": "erase_append_right",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚) : (lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a)",
  "args":
  "[DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚)"},
 {"type": "(l.erase a).erase b = (l.erase b).erase a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a b : Î±)  (l : List Î±) : (l.erase a).erase b = (l.erase b).erase a := by if ab : a = b then rw [ab] else ?_; sorry",
  "name": "erase_comm",
  "kind": "theorem",
  "first-tactic": "if ab : a = b then rw [ab] else ?_",
  "core-prompt":
  "[DecidableEq Î±] (a b : Î±)  (l : List Î±) : (l.erase a).erase b = (l.erase b).erase a",
  "args": "[DecidableEq Î±] (a b : Î±)  (l : List Î±)"},
 {"type": "x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x",
  "tactic-prompt":
  "theorem  : x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x := by induction as; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt": " : x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x",
  "args": ""},
 {"type": "partition p l = (filter p l, filter (not âˆ˜ p) l)",
  "tactic-prompt":
  "theorem (p : Î± â†’ Bool)  (l : List Î±) : partition p l = (filter p l, filter (not âˆ˜ p) l) := by simp [partition]; sorry",
  "name": "partition_eq_filter_filter",
  "kind": "theorem",
  "first-tactic": "simp [partition]",
  "core-prompt":
  "(p : Î± â†’ Bool)  (l : List Î±) : partition p l = (filter p l, filter (not âˆ˜ p) l)",
  "args": "(p : Î± â†’ Bool)  (l : List Î±)"},
 {"type": "(l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b))",
  "tactic-prompt":
  "theorem {l : List Î±} : (l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b)) := by induction l; sorry",
  "name": "pairwise_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List Î±} : (l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b))",
  "args": "{l : List Î±}"},
 {"type":
  "(lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b := by induction lâ‚; sorry",
  "name": "pairwise_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b",
  "args": "{lâ‚ lâ‚‚ : List Î±}"},
 {"type": "l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a)",
  "tactic-prompt":
  "theorem {l : List Î±} : l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a) := by induction l; sorry",
  "name": "pairwise_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List Î±} : l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a)",
  "args": "{l : List Î±}"},
 {"type": "length (replaceF f l) = length l",
  "tactic-prompt":
  "theorem  : length (replaceF f l) = length l := by induction l; sorry",
  "name": "length_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": " : length (replaceF f l) = length l",
  "args": ""},
 {"type": "Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚",
  "tactic-prompt":
  "theorem  : Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚ := by simp [Disjoint]; sorry",
  "name": "disjoint_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚",
  "args": ""},
 {"type": "Disjoint l []",
  "tactic-prompt":
  "theorem (l : List Î±) : Disjoint l [] := by rw [disjoint_comm]; sorry",
  "name": "disjoint_nil_right",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": "(l : List Î±) : Disjoint l []",
  "args": "(l : List Î±)"},
 {"type": "Disjoint [a] l â†” a âˆ‰ l",
  "tactic-prompt":
  "theorem  : Disjoint [a] l â†” a âˆ‰ l := by simp [Disjoint]; sorry",
  "name": "singleton_disjoint",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint [a] l â†” a âˆ‰ l",
  "args": ""},
 {"type": "Disjoint l [a] â†” a âˆ‰ l",
  "tactic-prompt":
  "theorem  : Disjoint l [a] â†” a âˆ‰ l := by rw [disjoint_comm]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": " : Disjoint l [a] â†” a âˆ‰ l",
  "args": ""},
 {"type": "Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l",
  "tactic-prompt":
  "theorem  : Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l := by simp [Disjoint]; sorry",
  "name": "disjoint_append_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l",
  "args": ""},
 {"type": "(l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "tactic-prompt":
  "theorem (f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init := by induction l generalizing init; sorry",
  "name": "foldl_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "args": "(f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±)"},
 {"type": "(l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "tactic-prompt":
  "theorem (f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init := by induction l generalizing init; sorry",
  "name": "foldr_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "args": "(f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²)"},
 {"type": "l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init)",
  "tactic-prompt":
  "theorem (f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y)) : l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init) := by induction l generalizing init; sorry",
  "name": "foldl_hom",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y)) : l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init)",
  "args":
  "(f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y))"},
 {"type": "l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init)",
  "tactic-prompt":
  "theorem (f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y)) : l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init) := by induction l; sorry",
  "name": "foldr_hom",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y)) : l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init)",
  "args":
  "(f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y))"},
 {"type": "nil.union l = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (l : List Î±) : nil.union l = l := by simp [List.union]; sorry",
  "name": "nil_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt": "[DecidableEq Î±] (l : List Î±) : nil.union l = l",
  "args": "[DecidableEq Î±] (l : List Î±)"},
 {"type": "(a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : (a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a := by simp [List.union]; sorry",
  "name": "cons_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt":
  "[DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : (a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a",
  "args": "[DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚ := by induction lâ‚; sorry",
  "name": "mem_union_iff",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "[DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚",
  "args": "[DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚ := by cases lâ‚; sorry",
  "name": "mem_inter_iff",
  "kind": "theorem",
  "first-tactic": "cases lâ‚",
  "core-prompt":
  "[DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚",
  "args": "[DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "(x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "tactic-prompt":
  "theorem {xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²} : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys := by simp only [List.product]; sorry",
  "name": "pair_mem_product",
  "kind": "theorem",
  "first-tactic": "simp only [List.product]",
  "core-prompt":
  "{xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²} : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "args": "{xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²}"},
 {"type": "(leftpad n a l).length = max n l.length",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : (leftpad n a l).length = max n l.length := by simp only [leftpad]; sorry",
  "name": "leftpad_length",
  "kind": "theorem",
  "first-tactic": "simp only [leftpad]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : (leftpad n a l).length = max n l.length",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type": "isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : isPrefix (replicate (n - length l) a) (leftpad n a l) := by simp only [isPrefix]; sorry",
  "name": "leftpad_prefix",
  "kind": "theorem",
  "first-tactic": "simp only [isPrefix]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type": "isSuffix l (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : isSuffix l (leftpad n a l) := by simp only [isSuffix]; sorry",
  "name": "leftpad_suffix",
  "kind": "theorem",
  "first-tactic": "simp only [isSuffix]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : isSuffix l (leftpad n a l)",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type":
  "forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      (f : Î± â†’ Î² â†’ m (ForInStep Î²))  (l : List Î±)  (init : Î²) : forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l := by induction l generalizing init; sorry",
  "name": "forIn_eq_bindList",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      (f : Î± â†’ Î² â†’ m (ForInStep Î²))  (l : List Î±)  (init : Î²) : forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l",
  "args":
  "[Monad m]  [LawfulMonad m]      (f : Î± â†’ Î² â†’ m (ForInStep Î²))  (l : List Î±)  (init : Î²)"},
 {"type": "(lâ‚ ++ lâ‚‚).forM f = (do lâ‚.forM f; lâ‚‚.forM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (lâ‚ lâ‚‚ : List Î±)  (f : Î± â†’ m PUnit) : (lâ‚ ++ lâ‚‚).forM f = (do lâ‚.forM f; lâ‚‚.forM f) := by induction lâ‚; sorry",
  "name": "forM_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (lâ‚ lâ‚‚ : List Î±)  (f : Î± â†’ m PUnit) : (lâ‚ ++ lâ‚‚).forM f = (do lâ‚.forM f; lâ‚‚.forM f)",
  "args": "[Monad m]  [LawfulMonad m]  (lâ‚ lâ‚‚ : List Î±)  (f : Î± â†’ m PUnit)"},
 {"type": "some a = some b â†” a = b",
  "tactic-prompt":
  "theorem {a b : Î±} : some a = some b â†” a = b := by simp; sorry",
  "name": "some_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b : Î±} : some a = some b â†” a = b",
  "args": "{a b : Î±}"},
 {"type": "some (x.getD y) = x",
  "tactic-prompt":
  "theorem {x : Option Î±}  (hx : x â‰  none)  (y : Î±) : some (x.getD y) = x := by cases x; sorry",
  "name": "getD_of_ne_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option Î±}  (hx : x â‰  none)  (y : Î±) : some (x.getD y) = x",
  "args": "{x : Option Î±}  (hx : x â‰  none)  (y : Î±)"},
 {"type": "isSome x â†” âˆƒ a, x = some a",
  "tactic-prompt": "theorem  : isSome x â†” âˆƒ a, x = some a := by cases x; sorry",
  "name": "isSome_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : isSome x â†” âˆƒ a, x = some a",
  "args": ""},
 {"type": "isSome a = false â†” a.isNone = true",
  "tactic-prompt":
  "theorem  : isSome a = false â†” a.isNone = true := by cases a; sorry",
  "name": "not_isSome",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": " : isSome a = false â†” a.isNone = true",
  "args": ""},
 {"type": "o = some a â†” âˆƒ h : o.isSome, o.get h = a",
  "tactic-prompt":
  "theorem  : o = some a â†” âˆƒ h : o.isSome, o.get h = a := by cases o; sorry",
  "name": "eq_some_iff_get_eq",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o = some a â†” âˆƒ h : o.isSome, o.get h = a",
  "args": ""},
 {"type": "Â¬o.isSome â†” o = none",
  "tactic-prompt": "theorem  : Â¬o.isSome â†” o = none := by cases o; sorry",
  "name": "not_isSome_iff_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : Â¬o.isSome â†” o = none",
  "args": ""},
 {"type": "o â‰  none â†” o.isSome",
  "tactic-prompt": "theorem  : o â‰  none â†” o.isSome := by cases o; sorry",
  "name": "ne_none_iff_isSome",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o â‰  none â†” o.isSome",
  "args": ""},
 {"type": "o â‰  none â†” âˆƒ x, some x = o",
  "tactic-prompt": "theorem  : o â‰  none â†” âˆƒ x, some x = o := by cases o; sorry",
  "name": "ne_none_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o â‰  none â†” âˆƒ x, some x = o",
  "args": ""},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem (x : Option Î±) : x.bind some = x := by cases x; sorry",
  "name": "bind_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option Î±) : x.bind some = x",
  "args": "(x : Option Î±)"},
 {"type": "x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "tactic-prompt":
  "theorem  : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b := by cases x; sorry",
  "name": "bind_eq_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "args": ""},
 {"type": "o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "tactic-prompt":
  "theorem {o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "args": "{o : Option Î±}  {f : Î± â†’ Option Î²}"},
 {"type":
  "(a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y := by cases a; sorry",
  "name": "bind_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "args": "{f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²)"},
 {"type": "(x.bind f).bind g = x.bind fun y => (f y).bind g",
  "tactic-prompt":
  "theorem (x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³) : (x.bind f).bind g = x.bind fun y => (f y).bind g := by cases x; sorry",
  "name": "bind_assoc",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³) : (x.bind f).bind g = x.bind fun y => (f y).bind g",
  "args": "(x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³)"},
 {"type": "x.join = some a â†” x = some (some a)",
  "tactic-prompt":
  "theorem  : x.join = some a â†” x = some (some a) := by simp; sorry",
  "name": "join_eq_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : x.join = some a â†” x = some (some a)",
  "args": ""},
 {"type": "x.join â‰  none â†” âˆƒ z, x = some (some z)",
  "tactic-prompt":
  "theorem  : x.join â‰  none â†” âˆƒ z, x = some (some z) := by simp only [ne_none_iff_exists']; sorry",
  "name": "join_ne_none",
  "kind": "theorem",
  "first-tactic": "simp only [ne_none_iff_exists']",
  "core-prompt": " : x.join â‰  none â†” âˆƒ z, x = some (some z)",
  "args": ""},
 {"type": "x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b",
  "tactic-prompt":
  "theorem  : x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b := by cases x; sorry",
  "name": "map_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b",
  "args": ""},
 {"type": "x.map f = none â†” x = none",
  "tactic-prompt": "theorem  : x.map f = none â†” x = none := by cases x; sorry",
  "name": "map_eq_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = none â†” x = none",
  "args": ""},
 {"type": "x.map f = x.map g",
  "tactic-prompt":
  "theorem {x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a) : x.map f = x.map g := by cases x; sorry",
  "name": "map_congr",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a) : x.map f = x.map g",
  "args": "{x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a)"},
 {"type": "(x.map g).map h = x.map (h âˆ˜ g)",
  "tactic-prompt":
  "theorem (h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±) : (x.map g).map h = x.map (h âˆ˜ g) := by cases x; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±) : (x.map g).map h = x.map (h âˆ˜ g)",
  "args": "(h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±)"},
 {"type": "Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (g : Î² â†’ Î³) : Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f) := by funext x; sorry",
  "name": "map_comp_map",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "(f : Î± â†’ Î²)  (g : Î² â†’ Î³) : Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f)",
  "args": "(f : Î± â†’ Î²)  (g : Î² â†’ Î³)"},
 {"type": "(x.map (Option.map f)).join = x.join.map f",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {x : Option (Option Î±)} : (x.map (Option.map f)).join = x.join.map f := by cases x; sorry",
  "name": "join_map_eq_map_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : Î± â†’ Î²}  {x : Option (Option Î±)} : (x.map (Option.map f)).join = x.join.map f",
  "args": "{f : Î± â†’ Î²}  {x : Option (Option Î±)}"},
 {"type": "x.join.join = (x.map join).join",
  "tactic-prompt":
  "theorem {x : Option (Option (Option Î±))} : x.join.join = (x.map join).join := by cases x; sorry",
  "name": "join_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option (Option (Option Î±))} : x.join.join = (x.map join).join",
  "args": "{x : Option (Option (Option Î±))}"},
 {"type": "(x <|> none) = x",
  "tactic-prompt":
  "theorem (x : Option Î±) : (x <|> none) = x := by cases x; sorry",
  "name": "orElse_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option Î±) : (x <|> none) = x",
  "args": "(x : Option Î±)"},
 {"type": "guard p a = some b â†” a = b âˆ§ p a",
  "tactic-prompt":
  "theorem [DecidablePred p] : guard p a = some b â†” a = b âˆ§ p a := by by_cases h : p a; sorry",
  "name": "guard_eq_some",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt": "[DecidablePred p] : guard p a = some b â†” a = b âˆ§ p a",
  "args": "[DecidablePred p]"},
 {"type": "(o.map f).getD (f x) = f (getD o x)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±) : (o.map f).getD (f x) = f (getD o x) := by cases o; sorry",
  "name": "getD_map",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "(f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±) : (o.map f).getD (f x) = f (getD o x)",
  "args": "(f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±)"},
 {"type": "choice Î± = some a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Subsingleton Î±]  (a : Î±) : choice Î± = some a := by simp [choice]; sorry",
  "name": "choice_eq",
  "kind": "theorem",
  "first-tactic": "simp [choice]",
  "core-prompt": "{Î± : Type _}  [Subsingleton Î±]  (a : Î±) : choice Î± = some a",
  "args": "{Î± : Type _}  [Subsingleton Î±]  (a : Î±)"},
 {"type": "s'.NoSibling",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s'.NoSibling := by cases s; sorry",
  "name": "Heap.noSibling_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s'.NoSibling",
  "args": "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' â†’\n    s'.NoSibling",
  "tactic-prompt":
  "theorem {s : Heap Î±} : s.tail? le = some s' â†’\n    s'.NoSibling := by simp only [Heap.tail?]; sorry",
  "name": "Heap.noSibling_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt": "{s : Heap Î±} : s.tail? le = some s' â†’\n    s'.NoSibling",
  "args": "{s : Heap Î±}"},
 {"type": "s.size = s'.size + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s')) : s.size = s'.size + 1 := by cases h; sorry",
  "name": "Heap.size_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{s : Heap Î±}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s')) : s.size = s'.size + 1",
  "args":
  "{s : Heap Î±}  (h : s.NoSibling)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' â†’\n    s.size = s'.size + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (h : s.NoSibling) : s.tail? le = some s' â†’\n    s.size = s'.size + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.size_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap Î±}  (h : s.NoSibling) : s.tail? le = some s' â†’\n    s.size = s'.size + 1",
  "args": "{s : Heap Î±}  (h : s.NoSibling)"},
 {"type": "s'.size < s.size",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s'.size < s.size := by cases s; sorry",
  "name": "Heap.size_deleteMin_lt",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s'.size < s.size",
  "args": "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' â†’\n    s'.size < s.size",
  "tactic-prompt":
  "theorem {s : Heap Î±} : s.tail? le = some s' â†’\n    s'.size < s.size := by simp only [Heap.tail?]; sorry",
  "name": "Heap.size_tail?_lt",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt": "{s : Heap Î±} : s.tail? le = some s' â†’\n    s'.size < s.size",
  "args": "{s : Heap Î±}"},
 {"type": "(merge le (.node aâ‚ câ‚ sâ‚) (.node aâ‚‚ câ‚‚ sâ‚‚)).WF le",
  "tactic-prompt":
  "theorem (hâ‚ : NodeWF le aâ‚ câ‚)  (hâ‚‚ : NodeWF le aâ‚‚ câ‚‚) : (merge le (.node aâ‚ câ‚ sâ‚) (.node aâ‚‚ câ‚‚ sâ‚‚)).WF le := by unfold merge; sorry",
  "name": "Heap.WF.merge_node",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(hâ‚ : NodeWF le aâ‚ câ‚)  (hâ‚‚ : NodeWF le aâ‚‚ câ‚‚) : (merge le (.node aâ‚ câ‚ sâ‚) (.node aâ‚‚ câ‚‚ sâ‚‚)).WF le",
  "args": "(hâ‚ : NodeWF le aâ‚ câ‚)  (hâ‚‚ : NodeWF le aâ‚‚ câ‚‚)"},
 {"type": "s'.WF le",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s')) : s'.WF le := by cases h; sorry",
  "name": "Heap.WF.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{s : Heap Î±}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s')) : s'.WF le",
  "args":
  "{s : Heap Î±}  (h : s.WF le)      (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl â†’\n  tl.WF le",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WF le) : s.tail? le = some tl â†’\n  tl.WF le := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WF.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap Î±).WF le) : s.tail? le = some tl â†’\n  tl.WF le",
  "args": "(hwf : (s : Heap Î±).WF le)"},
 {"type": "(s.tail le).WF le",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WF le) : (s.tail le).WF le := by simp only [Heap.tail]; sorry",
  "name": "Heap.WF.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt": "(hwf : (s : Heap Î±).WF le) : (s.tail le).WF le",
  "args": "(hwf : (s : Heap Î±).WF le)"},
 {"type": "Inhabited RuleTac",
  "tactic-prompt": "instance  : Inhabited RuleTac := by unfold RuleTac; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold RuleTac",
  "core-prompt": " : Inhabited RuleTac",
  "args": ""},
 {"type": "NatOrBool",
  "tactic-prompt":
  "def (b : Bool) : NatOrBool := by aesop (rule_sets [persistence1]); sorry",
  "name": "test",
  "kind": "def",
  "first-tactic": "aesop (rule_sets [persistence1])",
  "core-prompt": "(b : Bool) : NatOrBool",
  "args": "(b : Bool)"},
 {"type": "NatOrBool",
  "tactic-prompt":
  "example (b : Bool) : NatOrBool := by aesop (rule_sets [persistence1]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [persistence1])",
  "core-prompt": "(b : Bool) : NatOrBool",
  "args": "(b : Bool)"},
 {"type": "âˆƒ (i : Nat), T i",
  "tactic-prompt": "example  : âˆƒ (i : Nat), T i := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : âˆƒ (i : Nat), T i",
  "args": ""},
 {"type": "âˆƒ i, U i âˆ§ i = 1",
  "tactic-prompt": "example  : âˆƒ i, U i âˆ§ i = 1 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : âˆƒ i, U i âˆ§ i = 1",
  "args": ""},
 {"type": "Iâ‚",
  "tactic-prompt": "example  : Iâ‚ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Iâ‚",
  "args": ""},
 {"type": "Iâ‚",
  "tactic-prompt":
  "example  : Iâ‚ := by aesop (options := { strategy := .bestFirst }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { strategy := .bestFirst })",
  "core-prompt": " : Iâ‚",
  "args": ""},
 {"type": "Iâ‚",
  "tactic-prompt":
  "example  : Iâ‚ := by aesop (options := { strategy := .breadthFirst }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { strategy := .breadthFirst })",
  "core-prompt": " : Iâ‚",
  "args": ""},
 {"type": "Iâ‚",
  "tactic-prompt":
  "example  : Iâ‚ := by fail_if_success\n    aesop (options :=\n      { strategy := .depthFirst,\n        maxRuleApplicationDepth := 0,\n        maxRuleApplications := 10,\n        terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop (options :=\n      { strategy := .depthFirst,\n        maxRuleApplicationDepth := 0,\n        maxRuleApplications := 10,\n        terminal := true })",
  "core-prompt": " : Iâ‚",
  "args": ""},
 {"type": "Injectiveâ‚ (@id Nat)",
  "tactic-prompt":
  "example  : Injectiveâ‚ (@id Nat) := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Injectiveâ‚ (@id Nat)",
  "args": ""},
 {"type": "Injectiveâ‚‚ (@id Nat)",
  "tactic-prompt":
  "example  : Injectiveâ‚‚ (@id Nat) := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Injectiveâ‚‚ (@id Nat)",
  "args": ""},
 {"type": "Injectiveâ‚‚ (@id Nat)",
  "tactic-prompt":
  "example  : Injectiveâ‚‚ (@id Nat) := by aesop (options := { introsTransparency? := some .default }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { introsTransparency? := some .default })",
  "core-prompt": " : Injectiveâ‚‚ (@id Nat)",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt":
  "example (h : Î±) : Î± := by fail_if_success\n    aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (rule_sets [-builtin]",
  "core-prompt": "(h : Î±) : Î±",
  "args": "(h : Î±)"},
 {"type": "A",
  "tactic-prompt":
  "example  : A := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : A",
  "args": ""},
 {"type": "B",
  "tactic-prompt": "example  : B := by aesop (rule_sets [A]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [A]",
  "core-prompt": " : B",
  "args": ""},
 {"type": "C",
  "tactic-prompt":
  "example  : C := by fail_if_success aesop (rule_sets [-default]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [-default]) (options := { terminal := true })",
  "core-prompt": " : C",
  "args": ""},
 {"type": "C",
  "tactic-prompt":
  "example  : C := by fail_if_success aesop (rule_sets [C]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [C]) (options := { terminal := true })",
  "core-prompt": " : C",
  "args": ""},
 {"type": "D",
  "tactic-prompt": "example  : D := by aesop (rule_sets [A]); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [A])",
  "core-prompt": " : D",
  "args": ""},
 {"type": "D",
  "tactic-prompt":
  "example  : D := by fail_if_success aesop (rule_sets [A]) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (rule_sets [A]) (options := { terminal := true })",
  "core-prompt": " : D",
  "args": ""},
 {"type": "Î£ (R : Ring), Morphism R R",
  "tactic-prompt": "example  : Î£ (R : Ring), Morphism R R := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Î£ (R : Ring), Morphism R R",
  "args": ""},
 {"type": "âˆƒ (R : Ring), domain R",
  "tactic-prompt": "example  : âˆƒ (R : Ring), domain R := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : âˆƒ (R : Ring), domain R",
  "args": ""},
 {"type": "MyTrue",
  "tactic-prompt":
  "example {P : Î± â†’ Prop}  (h : All P (x :: xs)) : MyTrue := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{P : Î± â†’ Prop}  (h : All P (x :: xs)) : MyTrue",
  "args": "{P : Î± â†’ Prop}  (h : All P (x :: xs))"},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Prop}  (h : Î±) : Î± := by aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [-builtin]",
  "core-prompt": "{Î± : Prop}  (h : Î±) : Î±",
  "args": "{Î± : Prop}  (h : Î±)"},
 {"type": "Î± âˆ¨ Î³",
  "tactic-prompt":
  "example (h : (Î± âˆ§ Î²) âˆ¨ Î³) : Î± âˆ¨ Î³ := by aesop (add h norm simp); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add h norm simp)",
  "core-prompt": "(h : (Î± âˆ§ Î²) âˆ¨ Î³) : Î± âˆ¨ Î³",
  "args": "(h : (Î± âˆ§ Î²) âˆ¨ Î³)"},
 {"type": "Î²",
  "tactic-prompt":
  "example {Î± Î² : Prop}  (ha : Î±)  (h : Î± â†’ Î²) : Î² := by fail_if_success aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (rule_sets [-builtin]",
  "core-prompt": "{Î± Î² : Prop}  (ha : Î±)  (h : Î± â†’ Î²) : Î²",
  "args": "{Î± Î² : Prop}  (ha : Î±)  (h : Î± â†’ Î²)"},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Prop}  (ha : Î±) : Î± := by fail_if_success aesop (rule_sets [-builtin]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (rule_sets [-builtin]",
  "core-prompt": "{Î± : Prop}  (ha : Î±) : Î±",
  "args": "{Î± : Prop}  (ha : Î±)"},
 {"type": "T",
  "tactic-prompt": "example  : T := by aesop (rule_sets [-default]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (rule_sets [-default]",
  "core-prompt": " : T",
  "args": ""},
 {"type": "All P (x :: xs) â†” (P x âˆ§ All P xs)",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : All P (x :: xs) â†” (P x âˆ§ All P xs) := by aesop; sorry",
  "name": "All.cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : All P (x :: xs) â†” (P x âˆ§ All P xs)",
  "args": "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)"},
 {"type": "All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a := by induction xs; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "args": "(P : Î± â†’ Prop)  (xs : List Î±)"},
 {"type": "All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a := by induction xs; sorry",
  "name": "mem'",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "args": "(P : Î± â†’ Prop)  (xs : List Î±)"},
 {"type": "EvenOrOdd 3",
  "tactic-prompt":
  "example  : EvenOrOdd 3 := by aesop\n    (add safe [Even.zero]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop\n    (add safe [Even.zero]",
  "core-prompt": " : EvenOrOdd 3",
  "args": ""},
 {"type": "EvenOrOdd 3",
  "tactic-prompt":
  "example  : EvenOrOdd 3 := by have h : âˆ€ n, Odd n â†’ EvenOrOdd n := Î» _ p => EvenOrOdd.odd p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have h : âˆ€ n, Odd n â†’ EvenOrOdd n := Î» _ p => EvenOrOdd.odd p",
  "core-prompt": " : EvenOrOdd 3",
  "args": ""},
 {"type": "EvenOrOdd 2",
  "tactic-prompt":
  "example  : EvenOrOdd 2 := by fail_if_success aesop (add safe EvenOrOdd.even) (erase Even.zero)\n    (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (add safe EvenOrOdd.even) (erase Even.zero)\n    (options := { terminal := true })",
  "core-prompt": " : EvenOrOdd 2",
  "args": ""},
 {"type": "EvenOrOdd 2",
  "tactic-prompt":
  "example  : EvenOrOdd 2 := by have h : âˆ€ n, Even n â†’ EvenOrOdd n := Î» _ p => EvenOrOdd.even p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "have h : âˆ€ n, Even n â†’ EvenOrOdd n := Î» _ p => EvenOrOdd.even p",
  "core-prompt": " : EvenOrOdd 2",
  "args": ""},
 {"type": "id' n = n",
  "tactic-prompt": "example  : id' n = n := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : id' n = n",
  "args": ""},
 {"type": "n = m",
  "tactic-prompt": "example (h : MyEq n (id' m)) : n = m := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : MyEq n (id' m)) : n = m",
  "args": "(h : MyEq n (id' m))"},
 {"type": "Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚",
  "tactic-prompt":
  "example (a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚) : Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚ := by aesop (add safe [forward râ‚]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe [forward râ‚]",
  "core-prompt":
  "(a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚) : Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚",
  "args":
  "(a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚)"},
 {"type": "Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚",
  "tactic-prompt":
  "example (a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚) : Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚ := by fail_if_success\n    aesop (add safe [destruct râ‚]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (add safe [destruct râ‚]",
  "core-prompt":
  "(a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚) : Î³â‚ âˆ§ Î³â‚‚ âˆ§ Î´â‚ âˆ§ Î´â‚‚",
  "args":
  "(a : Î±)  (b : Î²)  (râ‚ : (a : Î±) â†’ (b : Î²) â†’ Î³â‚ âˆ§ Î³â‚‚)      (râ‚‚ : (a : Î±) â†’ Î´â‚ âˆ§ Î´â‚‚)"},
 {"type": "Sig Î± (Î» _ => Î²)",
  "tactic-prompt": "example (h : Î± âˆ§ Î²) : Sig Î± (Î» _ => Î²) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : Î± âˆ§ Î²) : Sig Î± (Î» _ => Î²)",
  "args": "(h : Î± âˆ§ Î²)"},
 {"type": "Sig Î± (Î» _ => Î²)",
  "tactic-prompt": "example (h : Î± Ã— Î²) : Sig Î± (Î» _ => Î²) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : Î± Ã— Î²) : Sig Î± (Î» _ => Î²)",
  "args": "(h : Î± Ã— Î²)"},
 {"type": "Sig Î± (Î» _ => Î²)",
  "tactic-prompt":
  "example (h : PProd Î± Î²) : Sig Î± (Î» _ => Î²) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : PProd Î± Î²) : Sig Î± (Î» _ => Î²)",
  "args": "(h : PProd Î± Î²)"},
 {"type": "Sig Î± (Î» _ => Î²)",
  "tactic-prompt":
  "example (h : MProd Î± Î²) : Sig Î± (Î» _ => Î²) := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(h : MProd Î± Î²) : Sig Î± (Î» _ => Î²)",
  "args": "(h : MProd Î± Î²)"},
 {"type": "Ex Î± p",
  "tactic-prompt":
  "example {p : Î± â†’ Prop}  (h : âˆƒ a, p a) : Ex Î± p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : Î± â†’ Prop}  (h : âˆƒ a, p a) : Ex Î± p",
  "args": "{p : Î± â†’ Prop}  (h : âˆƒ a, p a)"},
 {"type": "Sig Î± p",
  "tactic-prompt":
  "example {p : Î± â†’ Prop}  (h : { a // p a }) : Sig Î± p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : Î± â†’ Prop}  (h : { a // p a }) : Sig Î± p",
  "args": "{p : Î± â†’ Prop}  (h : { a // p a })"},
 {"type": "Sig Î± p",
  "tactic-prompt":
  "example {p : Î± â†’ Type}  (h : Î£ a, p a) : Sig Î± p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : Î± â†’ Type}  (h : Î£ a, p a) : Sig Î± p",
  "args": "{p : Î± â†’ Type}  (h : Î£ a, p a)"},
 {"type": "Sig Î± p",
  "tactic-prompt":
  "example {p : Î± â†’ Type}  (h : Î£' a, p a) : Sig Î± p := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "{p : Î± â†’ Type}  (h : Î£' a, p a) : Sig Î± p",
  "args": "{p : Î± â†’ Type}  (h : Î£' a, p a)"},
 {"type": "Even 4",
  "tactic-prompt":
  "example  : Even 4 := by aesop (add safe limitedEvenPlusTwo); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe limitedEvenPlusTwo)",
  "core-prompt": " : Even 4",
  "args": ""},
 {"type": "Even 6",
  "tactic-prompt":
  "example  : Even 6 := by fail_if_success\n    aesop (add safe limitedEvenPlusTwo) (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop (add safe limitedEvenPlusTwo) (options := { terminal := true })",
  "core-prompt": " : Even 6",
  "args": ""},
 {"type": "False",
  "tactic-prompt": "example  : False := by aesop (add safe falso); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe falso)",
  "core-prompt": " : False",
  "args": ""},
 {"type": "False",
  "tactic-prompt": "example  : False := by aesop (add safe falsoâ‚‚); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe falsoâ‚‚)",
  "core-prompt": " : False",
  "args": ""},
 {"type": "âˆƒ a, P a",
  "tactic-prompt":
  "example (P : Î± â†’ Prop)  (a : Î±)  (h : P a) : âˆƒ a, P a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(P : Î± â†’ Prop)  (a : Î±)  (h : P a) : âˆƒ a, P a",
  "args": "(P : Î± â†’ Prop)  (a : Î±)  (h : P a)"},
 {"type": "âˆƒ a b, P a b",
  "tactic-prompt":
  "example (P : Î± â†’ Î² â†’ Prop)  (a : Î±)  (b : Î²)  (h : P a b) : âˆƒ a b, P a b := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Î² â†’ Prop)  (a : Î±)  (b : Î²)  (h : P a b) : âˆƒ a b, P a b",
  "args": "(P : Î± â†’ Î² â†’ Prop)  (a : Î±)  (b : Î²)  (h : P a b)"},
 {"type": "Î£ a, P a",
  "tactic-prompt":
  "example (P : Î± â†’ Type)  (a : Î±)  (h : P a) : Î£ a, P a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": "(P : Î± â†’ Type)  (a : Î±)  (h : P a) : Î£ a, P a",
  "args": "(P : Î± â†’ Type)  (a : Î±)  (h : P a)"},
 {"type": "Î£ a b, P a b",
  "tactic-prompt":
  "example (P : Î± â†’ Î² â†’ Type)  (a : Î±)  (b : Î²)  (h : P a b) : Î£ a b, P a b := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Î² â†’ Type)  (a : Î±)  (b : Î²)  (h : P a b) : Î£ a b, P a b",
  "args": "(P : Î± â†’ Î² â†’ Type)  (a : Î±)  (b : Î²)  (h : P a b)"},
 {"type": "âˆƒ a, Q a",
  "tactic-prompt":
  "example (P Q : Î± â†’ Prop)  (hPQ : âˆ€ a, P a â†’ Q a)  (a : Î±)  (h : P a) : âˆƒ a, Q a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P Q : Î± â†’ Prop)  (hPQ : âˆ€ a, P a â†’ Q a)  (a : Î±)  (h : P a) : âˆƒ a, Q a",
  "args": "(P Q : Î± â†’ Prop)  (hPQ : âˆ€ a, P a â†’ Q a)  (a : Î±)  (h : P a)"},
 {"type": "âˆƒ a, R a",
  "tactic-prompt":
  "example (P Q Dead R : Î± â†’ Prop)      (hPQ : âˆ€ a, P a â†’ Q a)      (hDeadR : âˆ€ a, Dead a â†’ R a)      (hQR : âˆ€ a, Q a â†’ R a)      (a : Î±)  (h : P a) : âˆƒ a, R a := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(P Q Dead R : Î± â†’ Prop)      (hPQ : âˆ€ a, P a â†’ Q a)      (hDeadR : âˆ€ a, Dead a â†’ R a)      (hQR : âˆ€ a, Q a â†’ R a)      (a : Î±)  (h : P a) : âˆƒ a, R a",
  "args":
  "(P Q Dead R : Î± â†’ Prop)      (hPQ : âˆ€ a, P a â†’ Q a)      (hDeadR : âˆ€ a, Dead a â†’ R a)      (hQR : âˆ€ a, Q a â†’ R a)      (a : Î±)  (h : P a)"},
 {"type": "List Î±",
  "tactic-prompt": "example  : List Î± := by aesop (add safe List.nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe List.nil)",
  "core-prompt": " : List Î±",
  "args": ""},
 {"type": "List Î±",
  "tactic-prompt": "example  : List Î± := by aesop (add safe List.nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe List.nil)",
  "core-prompt": " : List Î±",
  "args": ""},
 {"type": "List Î±",
  "tactic-prompt": "example  : List Î± := by aesop (add safe nil); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (add safe nil)",
  "core-prompt": " : List Î±",
  "args": ""},
 {"type": "EvenOrOdd' 3",
  "tactic-prompt": "example  : EvenOrOdd' 3 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : EvenOrOdd' 3",
  "args": ""},
 {"type": "0 = 0",
  "tactic-prompt": "example  : 0 = 0 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : 0 = 0",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt":
  "example (h : Î± â†’ Î±)  (h' : Wrap Î±) : Î± := by fail_if_success aesop (add safe h) (options := { maxRuleApplications := 20, maxGoals := 0, maxRuleApplicationDepth := 0 }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success aesop (add safe h) (options := { maxRuleApplications := 20, maxGoals := 0, maxRuleApplicationDepth := 0 })",
  "core-prompt": "(h : Î± â†’ Î±)  (h' : Wrap Î±) : Î±",
  "args": "(h : Î± â†’ Î±)  (h' : Wrap Î±)"},
 {"type": "Even 20",
  "tactic-prompt":
  "example (Even : Nat â†’ Prop)  (zero : Even 0)      (plusTwo : âˆ€ n, Even n â†’ Even (n + 2)) : Even 20 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt":
  "(Even : Nat â†’ Prop)  (zero : Even 0)      (plusTwo : âˆ€ n, Even n â†’ Even (n + 2)) : Even 20",
  "args":
  "(Even : Nat â†’ Prop)  (zero : Even 0)      (plusTwo : âˆ€ n, Even n â†’ Even (n + 2))"},
 {"type": "Even 6",
  "tactic-prompt": "example  : Even 6 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 6",
  "args": ""},
 {"type": "f x âˆˆ xs.map f",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (x : Î±)  (xs : List Î±)  (h : x âˆˆ xs) : f x âˆˆ xs.map f := by induction h; sorry",
  "name": "Mem.map",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(f : Î± â†’ Î²)  (x : Î±)  (xs : List Î±)  (h : x âˆˆ xs) : f x âˆˆ xs.map f",
  "args": "(f : Î± â†’ Î²)  (x : Î±)  (xs : List Î±)  (h : x âˆˆ xs)"},
 {"type": "Even 2",
  "tactic-prompt": "example  : Even 2 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt":
  "example  : Even 2 := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt": "example  : Even 2 := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "Even 2",
  "tactic-prompt":
  "example  : Even 2 := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : Even 2",
  "args": ""},
 {"type": "xs = nil â†’ Â¬ NonEmpty xs",
  "tactic-prompt":
  "theorem (xs : MyList Î±) : xs = nil â†’ Â¬ NonEmpty xs := by aesop (add unsafe 10% cases MyList, norm unfold Not)\n    (rule_sets [MyList.NonEmpty]); sorry",
  "name": "nil_not_NonEmpty",
  "kind": "theorem",
  "first-tactic":
  "aesop (add unsafe 10% cases MyList, norm unfold Not)\n    (rule_sets [MyList.NonEmpty])",
  "core-prompt": "(xs : MyList Î±) : xs = nil â†’ Â¬ NonEmpty xs",
  "args": "(xs : MyList Î±)"},
 {"type": "xs ++ nil = xs",
  "tactic-prompt":
  "theorem {xs : MyList Î±} : xs ++ nil = xs := by induction xs; sorry",
  "name": "append_nil",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "{xs : MyList Î±} : xs ++ nil = xs",
  "args": "{xs : MyList Î±}"},
 {"type": "(xs ++ ys) ++ zs = xs ++ (ys ++ zs)",
  "tactic-prompt":
  "theorem {xs ys zs : MyList Î±} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs) := by induction xs; sorry",
  "name": "append_assoc",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "{xs ys zs : MyList Î±} : (xs ++ ys) ++ zs = xs ++ (ys ++ zs)",
  "args": "{xs ys zs : MyList Î±}"},
 {"type": "All Q xs",
  "tactic-prompt":
  "theorem (P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs) : All Q xs := by induction h; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs) : All Q xs",
  "args":
  "(P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs)"},
 {"type": "All (Â· âˆˆ xs) xs",
  "tactic-prompt":
  "theorem (xs : List Î±) : All (Â· âˆˆ xs) xs := by induction xs; sorry",
  "name": "in_self",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "(xs : List Î±) : All (Â· âˆˆ xs) xs",
  "args": "(xs : List Î±)"},
 {"type": "Even 500",
  "tactic-prompt":
  "example  : Even 500 := by aesop (options := { maxRuleApplications := 0, maxRuleApplicationDepth := 0 }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "aesop (options := { maxRuleApplications := 0, maxRuleApplicationDepth := 0 })",
  "core-prompt": " : Even 500",
  "args": ""},
 {"type": "n < k",
  "tactic-prompt":
  "example {n m k : Nat}  (h : n < m)  (hâ‚‚ : m < k) : n < k := by apply Nat.lt_trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Nat.lt_trans",
  "core-prompt": "{n m k : Nat}  (h : n < m)  (hâ‚‚ : m < k) : n < k",
  "args": "{n m k : Nat}  (h : n < m)  (hâ‚‚ : m < k)"},
 {"type": "Unit",
  "tactic-prompt":
  "example  : Unit := by fail_if_success\n    aesop (rule_sets [-default]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success\n    aesop (rule_sets [-default]",
  "core-prompt": " : Unit",
  "args": ""},
 {"type": "filter p (a :: as) = a :: filter p as",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : p a) : filter p (a :: as) = a :: filter p as := by simp [filter]; sorry",
  "name": "filter_cons_true",
  "kind": "theorem",
  "first-tactic": "simp [filter]",
  "core-prompt":
  "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : p a) : filter p (a :: as) = a :: filter p as",
  "args": "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : p a)"},
 {"type": "filter p (a :: as) = filter p as",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : Â¬ p a) : filter p (a :: as) = filter p as := by simp [filter]; sorry",
  "name": "filter_cons_false",
  "kind": "theorem",
  "first-tactic": "simp [filter]",
  "core-prompt":
  "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : Â¬ p a) : filter p (a :: as) = filter p as",
  "args": "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} (h : Â¬ p a)"},
 {"type": "a âˆˆ filter p as â†” a âˆˆ as âˆ§ p a",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} : a âˆˆ filter p as â†” a âˆˆ as âˆ§ p a := by apply Iff.intro; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±} : a âˆˆ filter p as â†” a âˆˆ as âˆ§ p a",
  "args": "{p : Î± â†’ Prop}  [DecidablePred p]  {as bs : List Î±}"},
 {"type": "Even' 2",
  "tactic-prompt":
  "example  : Even' 2 := by fail_if_success aesop\n    (add safe [even'_of_false 0]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop\n    (add safe [even'_of_false 0]",
  "core-prompt": " : Even' 2",
  "args": ""},
 {"type": "x = y",
  "tactic-prompt":
  "example (hâ‚ : x = 5)  (hâ‚‚ : y = 5) : x = y := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(hâ‚ : x = 5)  (hâ‚‚ : y = 5) : x = y",
  "args": "(hâ‚ : x = 5)  (hâ‚‚ : y = 5)"},
 {"type": "x = z",
  "tactic-prompt":
  "example (hâ‚ : x = y)  (hâ‚‚ : y = z) : x = z := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(hâ‚ : x = y)  (hâ‚‚ : y = z) : x = z",
  "args": "(hâ‚ : x = y)  (hâ‚‚ : y = z)"},
 {"type": "x = y",
  "tactic-prompt":
  "example (P : âˆ€ x y, x = y â†’ Prop)  (hâ‚ : x = y)  (hâ‚‚ : P x y hâ‚) : x = y := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst,\n             Aesop.BuiltinRules.assumption,\n             Aesop.BuiltinRules.applyHyps)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst,\n             Aesop.BuiltinRules.assumption,\n             Aesop.BuiltinRules.applyHyps)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt":
  "(P : âˆ€ x y, x = y â†’ Prop)  (hâ‚ : x = y)  (hâ‚‚ : P x y hâ‚) : x = y",
  "args": "(P : âˆ€ x y, x = y â†’ Prop)  (hâ‚ : x = y)  (hâ‚‚ : P x y hâ‚)"},
 {"type": "R",
  "tactic-prompt":
  "example (hâ‚ : P â†” Q)  (hâ‚‚ : Q â†” R)  (hâ‚ƒ : P) : R := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt": "(hâ‚ : P â†” Q)  (hâ‚‚ : Q â†” R)  (hâ‚ƒ : P) : R",
  "args": "(hâ‚ : P â†” Q)  (hâ‚‚ : Q â†” R)  (hâ‚ƒ : P)"},
 {"type": "P z",
  "tactic-prompt":
  "example {P : Î± â†’ Prop}  {x y z : Î±}  (hâ‚ : HEq x y)  (hâ‚‚ : HEq y z)  (hâ‚ƒ : P x) : P z := by fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "fail_if_success\n    aesop\n      (erase Aesop.BuiltinRules.subst)\n      (simp_options := { useHyps := false })\n      (options := { terminal := true })",
  "core-prompt":
  "{P : Î± â†’ Prop}  {x y z : Î±}  (hâ‚ : HEq x y)  (hâ‚‚ : HEq y z)  (hâ‚ƒ : P x) : P z",
  "args":
  "{P : Î± â†’ Prop}  {x y z : Î±}  (hâ‚ : HEq x y)  (hâ‚‚ : HEq y z)  (hâ‚ƒ : P x)"},
 {"type": "f x âˆˆ xs.map f",
  "tactic-prompt":
  "theorem {x : Î±}  {xs : List Î±}  (f : Î± â†’ Î²)  (h : x âˆˆ xs) : f x âˆˆ xs.map f := by induction h; sorry",
  "name": "Mem.map",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{x : Î±}  {xs : List Î±}  (f : Î± â†’ Î²)  (h : x âˆˆ xs) : f x âˆˆ xs.map f",
  "args": "{x : Î±}  {xs : List Î±}  (f : Î± â†’ Î²)  (h : x âˆˆ xs)"},
 {"type": "âˆƒ l r, xs = l ++ v :: r",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  {xs : List Î±}  {v : Î±}  (h : v âˆˆ xs) : âˆƒ l r, xs = l ++ v :: r := by induction xs; sorry",
  "name": "Mem.split",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "[DecidableEq Î±]  {xs : List Î±}  {v : Î±}  (h : v âˆˆ xs) : âˆƒ l r, xs = l ++ v :: r",
  "args": "[DecidableEq Î±]  {xs : List Î±}  {v : Î±}  (h : v âˆˆ xs)"},
 {"type": "All P (x :: xs) â†” (P x âˆ§ All P xs)",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : All P (x :: xs) â†” (P x âˆ§ All P xs) := by aesop; sorry",
  "name": "split_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : All P (x :: xs) â†” (P x âˆ§ All P xs)",
  "args": "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)"},
 {"type": "All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a := by induction xs; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : Î± â†’ Prop)  (xs : List Î±) : All P xs â†” âˆ€ a : Î±, a âˆˆ xs â†’ P a",
  "args": "(P : Î± â†’ Prop)  (xs : List Î±)"},
 {"type": "All Q xs",
  "tactic-prompt":
  "theorem (P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs) : All Q xs := by induction h; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs) : All Q xs",
  "args":
  "(P Q : Î± â†’ Prop)  (wk : âˆ€ x, P x â†’ Q x)  (xs : List Î±)  (h : All P xs)"},
 {"type": "All (Â· âˆˆ xs) xs",
  "tactic-prompt":
  "theorem (xs : List Î±) : All (Â· âˆˆ xs) xs := by induction xs; sorry",
  "name": "in_self",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt": "(xs : List Î±) : All (Â· âˆˆ xs) xs",
  "args": "(xs : List Î±)"},
 {"type": "All P (xs.map f) â†” All (fun x => P (f x)) xs",
  "tactic-prompt":
  "theorem (P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±) : All P (xs.map f) â†” All (fun x => P (f x)) xs := by induction xs; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±) : All P (xs.map f) â†” All (fun x => P (f x)) xs",
  "args": "(P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±)"},
 {"type": "Any P (x :: xs) â†” (P x âˆ¨ Any P xs)",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : Any P (x :: xs) â†” (P x âˆ¨ Any P xs) := by aesop; sorry",
  "name": "cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±) : Any P (x :: xs) â†” (P x âˆ¨ Any P xs)",
  "args": "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)"},
 {"type": "Any P xs â†” âˆƒ a : Î±, P a âˆ§ a âˆˆ xs",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (xs : List Î±) : Any P xs â†” âˆƒ a : Î±, P a âˆ§ a âˆˆ xs := by apply Iff.intro; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "(P : Î± â†’ Prop)  (xs : List Î±) : Any P xs â†” âˆƒ a : Î±, P a âˆ§ a âˆˆ xs",
  "args": "(P : Î± â†’ Prop)  (xs : List Î±)"},
 {"type": "Any P (xs.map f) â†” Any (fun x => P (f x)) xs",
  "tactic-prompt":
  "theorem (P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±) : Any P (xs.map f) â†” Any (fun x => P (f x)) xs := by induction xs; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "(P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±) : Any P (xs.map f) â†” Any (fun x => P (f x)) xs",
  "args": "(P : Î² â†’ Prop)  (f : Î± â†’ Î²)  (xs : List Î±)"},
 {"type": "DecidablePred (Any P)",
  "tactic-prompt":
  "instance (P : Î± â†’ Prop)  [d : DecidablePred P] : DecidablePred (Any P) := by intro xs; sorry",
  "name": "instDecidablePred",
  "kind": "instance",
  "first-tactic": "intro xs",
  "core-prompt":
  "(P : Î± â†’ Prop)  [d : DecidablePred P] : DecidablePred (Any P)",
  "args": "(P : Î± â†’ Prop)  [d : DecidablePred P]"},
 {"type": "âˆƒ a : Î±, a âˆˆ xs âˆ§ a âˆˆ ys",
  "tactic-prompt":
  "theorem {xs ys : List Î±}  (h : Common xs ys) : âˆƒ a : Î±, a âˆˆ xs âˆ§ a âˆˆ ys := by induction h; sorry",
  "name": "mem",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{xs ys : List Î±}  (h : Common xs ys) : âˆƒ a : Î±, a âˆˆ xs âˆ§ a âˆˆ ys",
  "args": "{xs ys : List Î±}  (h : Common xs ys)"},
 {"type": "Common ys xs",
  "tactic-prompt":
  "theorem {xs ys : List Î±}  (h : Common xs ys) : Common ys xs := by have other : âˆƒ a, a âˆˆ ys âˆ§ a âˆˆ xs := Iff.mp (Any.mem (Â· âˆˆ ys) xs) h; sorry",
  "name": "sym",
  "kind": "theorem",
  "first-tactic":
  "have other : âˆƒ a, a âˆˆ ys âˆ§ a âˆˆ xs := Iff.mp (Any.mem (Â· âˆˆ ys) xs) h",
  "core-prompt": "{xs ys : List Î±}  (h : Common xs ys) : Common ys xs",
  "args": "{xs ys : List Î±}  (h : Common xs ys)"},
 {"type": "Decidable (Common xs ys)",
  "tactic-prompt":
  "instance [DecidableEq Î±]  (xs ys : List Î±) : Decidable (Common xs ys) := by apply Any.instDecidablePred; sorry",
  "name": "instDecidable",
  "kind": "instance",
  "first-tactic": "apply Any.instDecidablePred",
  "core-prompt": "[DecidableEq Î±]  (xs ys : List Î±) : Decidable (Common xs ys)",
  "args": "[DecidableEq Î±]  (xs ys : List Î±)"},
 {"type": "Proof Î“ (Î´ :: Î”)",
  "tactic-prompt":
  "theorem (Î“ Î” : List (Form Î¦))  (prf : Proof Î“ Î”)  (Î´ : Form Î¦) : Proof Î“ (Î´ :: Î”) := by induction prf; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(Î“ Î” : List (Form Î¦))  (prf : Proof Î“ Î”)  (Î´ : Form Î¦) : Proof Î“ (Î´ :: Î”)",
  "args": "(Î“ Î” : List (Form Î¦))  (prf : Proof Î“ Î”)  (Î´ : Form Î¦)"},
 {"type": "SC i Î“ Î”",
  "tactic-prompt":
  "theorem (i : Î¦ â†’ Prop)  [DecidablePred i]  (prf : Proof Î“ Î”) : SC i Î“ Î” := by induction prf; sorry",
  "name": "sound",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(i : Î¦ â†’ Prop)  [DecidablePred i]  (prf : Proof Î“ Î”) : SC i Î“ Î”",
  "args": "(i : Î¦ â†’ Prop)  [DecidablePred i]  (prf : Proof Î“ Î”)"},
 {"type": "Proof [] [Ï†] â†” Valid Ï†",
  "tactic-prompt":
  "theorem [DecidableEq Î¦]  (Ï† : Form Î¦) : Proof [] [Ï†] â†” Valid Ï† := by apply Iff.intro; sorry",
  "name": "Proof_sound_complete",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "[DecidableEq Î¦]  (Ï† : Form Î¦) : Proof [] [Ï†] â†” Valid Ï†",
  "args": "[DecidableEq Î¦]  (Ï† : Form Î¦)"},
 {"type": "âˆƒ (R : Ring) (_ : RingHom R R), True",
  "tactic-prompt":
  "example  : âˆƒ (R : Ring) (_ : RingHom R R), True := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : âˆƒ (R : Ring) (_ : RingHom R R), True",
  "args": ""},
 {"type": "a âˆˆ o â†” o = some a",
  "tactic-prompt":
  "theorem {o : Option Î±} : a âˆˆ o â†” o = some a := by aesop (add norm unfold Membership.mem); sorry",
  "name": "mem_spec",
  "kind": "theorem",
  "first-tactic": "aesop (add norm unfold Membership.mem)",
  "core-prompt": "{o : Option Î±} : a âˆˆ o â†” o = some a",
  "args": "{o : Option Î±}"},
 {"type": "a âˆˆ none â†” False",
  "tactic-prompt": "theorem  : a âˆˆ none â†” False := by aesop; sorry",
  "name": "mem_none",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : a âˆˆ none â†” False",
  "args": ""},
 {"type": "a âˆˆ some b â†” a = b",
  "tactic-prompt": "theorem  : a âˆˆ some b â†” a = b := by aesop; sorry",
  "name": "mem_some",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : a âˆˆ some b â†” a = b",
  "args": ""},
 {"type": "lâ‚ âŠ† lâ‚‚ â†’ lâ‚‚ âŠ† lâ‚ƒ â†’ lâ‚ âŠ† lâ‚ƒ",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ lâ‚ƒ : List Î±} : lâ‚ âŠ† lâ‚‚ â†’ lâ‚‚ âŠ† lâ‚ƒ â†’ lâ‚ âŠ† lâ‚ƒ := by intro hâ‚ hâ‚‚ a ha; sorry",
  "name": "subset_trans",
  "kind": "theorem",
  "first-tactic": "intro hâ‚ hâ‚‚ a ha",
  "core-prompt": "{lâ‚ lâ‚‚ lâ‚ƒ : List Î±} : lâ‚ âŠ† lâ‚‚ â†’ lâ‚‚ âŠ† lâ‚ƒ â†’ lâ‚ âŠ† lâ‚ƒ",
  "args": "{lâ‚ lâ‚‚ lâ‚ƒ : List Î±}"},
 {"type": "Unique (List Î±)",
  "tactic-prompt":
  "instance [IsEmpty Î±] : Unique (List Î±) := by aesop (add 1% cases List); sorry",
  "name": "unique_of_is_empty",
  "kind": "instance",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "[IsEmpty Î±] : Unique (List Î±)",
  "args": "[IsEmpty Î±]"},
 {"type": "a::l â‰  []",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : a::l â‰  [] := by aesop; sorry",
  "name": "X.cons_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : Î±)  (l : List Î±) : a::l â‰  []",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "a::l â‰  l",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : a::l â‰  l := by aesop (add 1% cases Eq); sorry",
  "name": "X.cons_ne_self",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases Eq)",
  "core-prompt": "(a : Î±)  (l : List Î±) : a::l â‰  l",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "(hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ hâ‚ = hâ‚‚",
  "tactic-prompt":
  "theorem {hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±} : (hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ hâ‚ = hâ‚‚ := by aesop; sorry",
  "name": "X.head_eq_of_cons_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±} : (hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ hâ‚ = hâ‚‚",
  "args": "{hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±}"},
 {"type": "(hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ tâ‚ = tâ‚‚",
  "tactic-prompt":
  "theorem {hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±} : (hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ tâ‚ = tâ‚‚ := by aesop; sorry",
  "name": "X.tail_eq_of_cons_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±} : (hâ‚::tâ‚) = (hâ‚‚::tâ‚‚) â†’ tâ‚ = tâ‚‚",
  "args": "{hâ‚ hâ‚‚ : Î±}  {tâ‚ tâ‚‚ : List Î±}"},
 {"type": "Injective (cons a)",
  "tactic-prompt": "theorem {a : Î±} : Injective (cons a) := by aesop; sorry",
  "name": "cons_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a : Î±} : Injective (cons a)",
  "args": "{a : Î±}"},
 {"type": "a::l = a::l' â†” l = l'",
  "tactic-prompt":
  "theorem (a : Î±)  {l l' : List Î±} : a::l = a::l' â†” l = l' := by aesop; sorry",
  "name": "X.cons_inj",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : Î±)  {l l' : List Î±} : a::l = a::l' â†” l = l'",
  "args": "(a : Î±)  {l l' : List Î±}"},
 {"type": "l â‰  nil â†’ âˆƒ b L, l = b :: L",
  "tactic-prompt":
  "theorem  : l â‰  nil â†’ âˆƒ b L, l = b :: L := by aesop (add 1% cases List); sorry",
  "name": "X.exists_cons_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : l â‰  nil â†’ âˆƒ b L, l = b :: L",
  "args": ""},
 {"type": "a âˆˆ [a]",
  "tactic-prompt": "theorem (a : Î±) : a âˆˆ [a] := by aesop; sorry",
  "name": "X.mem_singleton_self",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : Î±) : a âˆˆ [a]",
  "args": "(a : Î±)"},
 {"type": "a âˆˆ [b] â†’ a = b",
  "tactic-prompt": "theorem {a b : Î±} : a âˆˆ [b] â†’ a = b := by aesop; sorry",
  "name": "X.eq_of_mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±} : a âˆˆ [b] â†’ a = b",
  "args": "{a b : Î±}"},
 {"type": "a âˆˆ [b] â†” a = b",
  "tactic-prompt": "theorem {a b : Î±} : a âˆˆ [b] â†” a = b := by aesop; sorry",
  "name": "X.mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±} : a âˆˆ [b] â†” a = b",
  "args": "{a b : Î±}"},
 {"type": "a âˆˆ b::l â†’ b âˆˆ l â†’ a âˆˆ l",
  "tactic-prompt":
  "theorem {a b : Î±}  {l : List Î±} : a âˆˆ b::l â†’ b âˆˆ l â†’ a âˆˆ l := by aesop; sorry",
  "name": "X.mem_of_mem_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±}  {l : List Î±} : a âˆˆ b::l â†’ b âˆˆ l â†’ a âˆˆ l",
  "args": "{a b : Î±}  {l : List Î±}"},
 {"type": "a âˆˆ b :: l â†’ a = b âˆ¨ (a â‰  b âˆ§ a âˆˆ l)",
  "tactic-prompt":
  "theorem {a b : Î±}  {l : List Î±} : a âˆˆ b :: l â†’ a = b âˆ¨ (a â‰  b âˆ§ a âˆˆ l) := by open Classical in\n  aesop (add safe [decidable.list.eq_or_ne_mem_of_mem]); sorry",
  "name": "X.eq_or_ne_mem_of_mem",
  "kind": "theorem",
  "first-tactic":
  "open Classical in\n  aesop (add safe [decidable.list.eq_or_ne_mem_of_mem])",
  "core-prompt":
  "{a b : Î±}  {l : List Î±} : a âˆˆ b :: l â†’ a = b âˆ¨ (a â‰  b âˆ§ a âˆˆ l)",
  "args": "{a b : Î±}  {l : List Î±}"},
 {"type": "a âˆ‰ s ++ t",
  "tactic-prompt":
  "theorem {a : Î±}  {s t : List Î±}  (hâ‚ : a âˆ‰ s)  (hâ‚‚ : a âˆ‰ t) : a âˆ‰ s ++ t := by induction s; sorry",
  "name": "not_mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{a : Î±}  {s t : List Î±}  (hâ‚ : a âˆ‰ s)  (hâ‚‚ : a âˆ‰ t) : a âˆ‰ s ++ t",
  "args": "{a : Î±}  {s t : List Î±}  (hâ‚ : a âˆ‰ s)  (hâ‚‚ : a âˆ‰ t)"},
 {"type": "l â‰  []",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  [] := by aesop; sorry",
  "name": "X.ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  []",
  "args": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "a âˆˆ l",
  "tactic-prompt":
  "theorem {a y : Î±}  {l : List Î±}  (hâ‚ : a â‰  y)  (hâ‚‚ : a âˆˆ y :: l) : a âˆˆ l := by aesop; sorry",
  "name": "mem_of_ne_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a y : Î±}  {l : List Î±}  (hâ‚ : a â‰  y)  (hâ‚‚ : a âˆˆ y :: l) : a âˆˆ l",
  "args": "{a y : Î±}  {l : List Î±}  (hâ‚ : a â‰  y)  (hâ‚‚ : a âˆˆ y :: l)"},
 {"type": "a âˆ‰ b::l â†’ a â‰  b",
  "tactic-prompt":
  "theorem {a b : Î±}  {l : List Î±} : a âˆ‰ b::l â†’ a â‰  b := by aesop; sorry",
  "name": "ne_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±}  {l : List Î±} : a âˆ‰ b::l â†’ a â‰  b",
  "args": "{a b : Î±}  {l : List Î±}"},
 {"type": "a âˆ‰ b::l â†’ a âˆ‰ l",
  "tactic-prompt":
  "theorem {a b : Î±}  {l : List Î±} : a âˆ‰ b::l â†’ a âˆ‰ l := by aesop; sorry",
  "name": "not_mem_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±}  {l : List Î±} : a âˆ‰ b::l â†’ a âˆ‰ l",
  "args": "{a b : Î±}  {l : List Î±}"},
 {"type": "a â‰  y â†’ a âˆ‰ l â†’ a âˆ‰ y::l",
  "tactic-prompt":
  "theorem {a y : Î±}  {l : List Î±} : a â‰  y â†’ a âˆ‰ l â†’ a âˆ‰ y::l := by aesop; sorry",
  "name": "not_mem_cons_of_ne_of_not_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a y : Î±}  {l : List Î±} : a â‰  y â†’ a âˆ‰ l â†’ a âˆ‰ y::l",
  "args": "{a y : Î±}  {l : List Î±}"},
 {"type": "a âˆ‰ y::l â†’ a â‰  y âˆ§ a âˆ‰ l",
  "tactic-prompt":
  "theorem {a y : Î±}  {l : List Î±} : a âˆ‰ y::l â†’ a â‰  y âˆ§ a âˆ‰ l := by aesop; sorry",
  "name": "ne_and_not_mem_of_not_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a y : Î±}  {l : List Î±} : a âˆ‰ y::l â†’ a â‰  y âˆ§ a âˆ‰ l",
  "args": "{a y : Î±}  {l : List Î±}"},
 {"type": "b âˆˆ map f l â†” âˆƒ a, a âˆˆ l âˆ§ f a = b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {b : Î²}  {l : List Î±} : b âˆˆ map f l â†” âˆƒ a, a âˆˆ l âˆ§ f a = b := by induction l; sorry",
  "name": "X.mem_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{f : Î± â†’ Î²}  {b : Î²}  {l : List Î±} : b âˆˆ map f l â†” âˆƒ a, a âˆˆ l âˆ§ f a = b",
  "args": "{f : Î± â†’ Î²}  {b : Î²}  {l : List Î±}"},
 {"type": "f a âˆˆ map f l",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : f a âˆˆ map f l := by aesop; sorry",
  "name": "X.mem_map_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(f : Î± â†’ Î²)  {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : f a âˆˆ map f l",
  "args": "(f : Î± â†’ Î²)  {a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "f a âˆˆ map f l â†” a âˆˆ l",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  (H : Injective f)  {a : Î±}  {l : List Î±} : f a âˆˆ map f l â†” a âˆˆ l := by aesop; sorry",
  "name": "mem_map_of_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : Î± â†’ Î²}  (H : Injective f)  {a : Î±}  {l : List Î±} : f a âˆˆ map f l â†” a âˆˆ l",
  "args": "{f : Î± â†’ Î²}  (H : Injective f)  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆƒ (y : Î±), y âˆˆ l âˆ§ f y = x) â†” f x âˆˆ l",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î±}    (hf : Involutive f)  (x : Î±)  (l : List Î±) : (âˆƒ (y : Î±), y âˆˆ l âˆ§ f y = x) â†” f x âˆˆ l := by aesop; sorry",
  "name": "_root_.function.involutive.exists_mem_and_apply_eq_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : Î± â†’ Î±}    (hf : Involutive f)  (x : Î±)  (l : List Î±) : (âˆƒ (y : Î±), y âˆˆ l âˆ§ f y = x) â†” f x âˆˆ l",
  "args": "{f : Î± â†’ Î±}    (hf : Involutive f)  (x : Î±)  (l : List Î±)"},
 {"type": "a âˆˆ map f l â†” f a âˆˆ l",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î±}  (hf : Involutive f)  {a : Î±}  {l : List Î±} : a âˆˆ map f l â†” f a âˆˆ l := by aesop; sorry",
  "name": "mem_map_of_involutive",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : Î± â†’ Î±}  (hf : Involutive f)  {a : Î±}  {l : List Î±} : a âˆˆ map f l â†” f a âˆˆ l",
  "args": "{f : Î± â†’ Î±}  (hf : Involutive f)  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆ€ i, i âˆˆ l.map f â†’ P i) â†” âˆ€ j, j âˆˆ l â†’ P (f j)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i, i âˆˆ l.map f â†’ P i) â†” âˆ€ j, j âˆˆ l â†’ P (f j) := by aesop; sorry",
  "name": "X.forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i, i âˆˆ l.map f â†’ P i) â†” âˆ€ j, j âˆˆ l â†’ P (f j)",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop}"},
 {"type": "map f l = [] â†” l = []",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±} : map f l = [] â†” l = [] := by aesop (add 1% cases List); sorry",
  "name": "X.map_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{f : Î± â†’ Î²}  {l : List Î±} : map f l = [] â†” l = []",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}"},
 {"type": "âˆ€ {L : List (List Î±)}, a âˆˆ join L â†” âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l",
  "tactic-prompt":
  "theorem {a : Î±} : âˆ€ {L : List (List Î±)}, a âˆˆ join L â†” âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l := by intro L; sorry",
  "name": "X.mem_join",
  "kind": "theorem",
  "first-tactic": "intro L",
  "core-prompt":
  "{a : Î±} : âˆ€ {L : List (List Î±)}, a âˆˆ join L â†” âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l",
  "args": "{a : Î±}"},
 {"type": "a âˆˆ join L â†’ âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l",
  "tactic-prompt":
  "theorem {a : Î±}  {L : List (List Î±)} : a âˆˆ join L â†’ âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l := by aesop; sorry",
  "name": "X.exists_of_mem_join",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : Î±}  {L : List (List Î±)} : a âˆˆ join L â†’ âˆƒ l, l âˆˆ L âˆ§ a âˆˆ l",
  "args": "{a : Î±}  {L : List (List Î±)}"},
 {"type": "b âˆˆ l.bind f â†” âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a",
  "tactic-prompt":
  "theorem {b : Î²}  {l : List Î±}  {f : Î± â†’ List Î²} : b âˆˆ l.bind f â†” âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a := by induction l; sorry",
  "name": "X.mem_bind",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{b : Î²}  {l : List Î±}  {f : Î± â†’ List Î²} : b âˆˆ l.bind f â†” âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a",
  "args": "{b : Î²}  {l : List Î±}  {f : Î± â†’ List Î²}"},
 {"type": "b âˆˆ l.bind f â†’ âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a",
  "tactic-prompt":
  "theorem {l : List Î±} : b âˆˆ l.bind f â†’ âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a := by aesop; sorry",
  "name": "X.exists_of_mem_bind",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l : List Î±} : b âˆˆ l.bind f â†’ âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a",
  "args": "{l : List Î±}"},
 {"type": "(âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a) â†’ b âˆˆ l.bind f",
  "tactic-prompt":
  "theorem {l : List Î±} : (âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a) â†’ b âˆˆ l.bind f := by induction l; sorry",
  "name": "X.mem_bind_of_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±} : (âˆƒ a, a âˆˆ l âˆ§ b âˆˆ f a) â†’ b âˆˆ l.bind f",
  "args": "{l : List Î±}"},
 {"type": "âˆ€ l : List Î±, map f (l.bind g) = l.bind (Î»a => (g a).map f)",
  "tactic-prompt":
  "theorem {g : Î± â†’ List Î²}  {f : Î² â†’ Î³} : âˆ€ l : List Î±, map f (l.bind g) = l.bind (Î»a => (g a).map f) := by intro l; sorry",
  "name": "X.bind_map",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "{g : Î± â†’ List Î²}  {f : Î² â†’ Î³} : âˆ€ l : List Î±, map f (l.bind g) = l.bind (Î»a => (g a).map f)",
  "args": "{g : Î± â†’ List Î²}  {f : Î² â†’ Î³}"},
 {"type": "âˆ€ l : List Î±, (map f l).bind g = l.bind (Î» a => g (f a))",
  "tactic-prompt":
  "theorem (g : Î² â†’ List Î³)  (f : Î± â†’ Î²) : âˆ€ l : List Î±, (map f l).bind g = l.bind (Î» a => g (f a)) := by intro l; sorry",
  "name": "map_bind",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "(g : Î² â†’ List Î³)  (f : Î± â†’ Î²) : âˆ€ l : List Î±, (map f l).bind g = l.bind (Î» a => g (f a))",
  "args": "(g : Î² â†’ List Î³)  (f : Î± â†’ Î²)"},
 {"type": "length l = 0 â†” l = []",
  "tactic-prompt":
  "theorem {l : List Î±} : length l = 0 â†” l = [] := by aesop (add 1% cases List); sorry",
  "name": "X.length_eq_zero",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List Î±} : length l = 0 â†” l = []",
  "args": "{l : List Î±}"},
 {"type": "âˆ€ {l : List Î±}, a âˆˆ l â†’ 0 < length l",
  "tactic-prompt":
  "theorem {a : Î±} : âˆ€ {l : List Î±}, a âˆˆ l â†’ 0 < length l := by aesop (add 1% cases List) (simp_options := { arith := true }); sorry",
  "name": "X.length_pos_of_mem",
  "kind": "theorem",
  "first-tactic":
  "aesop (add 1% cases List) (simp_options := { arith := true })",
  "core-prompt": "{a : Î±} : âˆ€ {l : List Î±}, a âˆˆ l â†’ 0 < length l",
  "args": "{a : Î±}"},
 {"type": "âˆ€ {l : List Î±}, 0 < length l â†’ âˆƒ a, a âˆˆ l",
  "tactic-prompt":
  "theorem  : âˆ€ {l : List Î±}, 0 < length l â†’ âˆƒ a, a âˆˆ l := by aesop (add 1% cases List); sorry",
  "name": "X.exists_mem_of_length_pos",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : âˆ€ {l : List Î±}, 0 < length l â†’ âˆƒ a, a âˆˆ l",
  "args": ""},
 {"type": "0 < length l â†” âˆƒ a, a âˆˆ l",
  "tactic-prompt":
  "theorem {l : List Î±} : 0 < length l â†” âˆƒ a, a âˆˆ l := by aesop (add unsafe [length_pos_of_mem]; sorry",
  "name": "X.length_pos_iff_exists_mem",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [length_pos_of_mem]",
  "core-prompt": "{l : List Î±} : 0 < length l â†” âˆƒ a, a âˆˆ l",
  "args": "{l : List Î±}"},
 {"type": "0 < length l â†’ l â‰  []",
  "tactic-prompt":
  "theorem {l : List Î±} : 0 < length l â†’ l â‰  [] := by aesop (add 1% cases List); sorry",
  "name": "ne_nil_of_length_pos",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List Î±} : 0 < length l â†’ l â‰  []",
  "args": "{l : List Î±}"},
 {"type": "l â‰  [] â†’ 0 < length l",
  "tactic-prompt":
  "theorem {l : List Î±} : l â‰  [] â†’ 0 < length l := by aesop (add 1% cases List) (simp_options := { arith := true }); sorry",
  "name": "length_pos_of_ne_nil",
  "kind": "theorem",
  "first-tactic":
  "aesop (add 1% cases List) (simp_options := { arith := true })",
  "core-prompt": "{l : List Î±} : l â‰  [] â†’ 0 < length l",
  "args": "{l : List Î±}"},
 {"type": "0 < length l â†” l â‰  []",
  "tactic-prompt":
  "theorem {l : List Î±} : 0 < length l â†” l â‰  [] := by aesop (add unsafe [ne_nil_of_length_pos]; sorry",
  "name": "length_pos_iff_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [ne_nil_of_length_pos]",
  "core-prompt": "{l : List Î±} : 0 < length l â†” l â‰  []",
  "args": "{l : List Î±}"},
 {"type": "âˆƒ x, x âˆˆ l",
  "tactic-prompt":
  "theorem (l : List Î±)  (h : l â‰  []) : âˆƒ x, x âˆˆ l := by aesop (add 1% cases List); sorry",
  "name": "X.exists_mem_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "(l : List Î±)  (h : l â‰  []) : âˆƒ x, x âˆˆ l",
  "args": "(l : List Î±)  (h : l â‰  [])"},
 {"type": "length l = 1 â†” âˆƒ a, l = [a]",
  "tactic-prompt":
  "theorem  : length l = 1 â†” âˆƒ a, l = [a] := by aesop (add 1% cases List); sorry",
  "name": "X.length_eq_one",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": " : length l = 1 â†” âˆƒ a, l = [a]",
  "args": ""},
 {"type": "Injective (length : List Î± â†’ Nat)",
  "tactic-prompt":
  "theorem [Subsingleton Î±] : Injective (length : List Î± â†’ Nat) := by aesop; sorry",
  "name": "length_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "[Subsingleton Î±] : Injective (length : List Î± â†’ Nat)",
  "args": "[Subsingleton Î±]"},
 {"type": "l.length = 2 â†” âˆƒ a b, l = [a, b]",
  "tactic-prompt":
  "theorem {l : List Î±} : l.length = 2 â†” âˆƒ a b, l = [a, b] := by aesop (add 50% cases List); sorry",
  "name": "length_eq_two",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% cases List)",
  "core-prompt": "{l : List Î±} : l.length = 2 â†” âˆƒ a b, l = [a, b]",
  "args": "{l : List Î±}"},
 {"type": "l.length = 3 â†” âˆƒ a b c, l = [a, b, c]",
  "tactic-prompt":
  "theorem {l : List Î±} : l.length = 3 â†” âˆƒ a b c, l = [a, b, c] := by aesop (add 50% cases List); sorry",
  "name": "length_eq_three",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% cases List)",
  "core-prompt": "{l : List Î±} : l.length = 3 â†” âˆƒ a b c, l = [a, b, c]",
  "args": "{l : List Î±}"},
 {"type": "âˆ€ x, x âˆˆ @nil Î± â†’ p x",
  "tactic-prompt":
  "theorem (p : Î± â†’ Prop) : âˆ€ x, x âˆˆ @nil Î± â†’ p x := by aesop; sorry",
  "name": "X.forall_mem_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(p : Î± â†’ Prop) : âˆ€ x, x âˆˆ @nil Î± â†’ p x",
  "args": "(p : Î± â†’ Prop)"},
 {"type":
  "âˆ€ {p : Î± â†’ Prop} {a : Î±} {l : List Î±},\n    (âˆ€ x, x âˆˆ a :: l â†’ p x) â†” p a âˆ§ âˆ€ x, x âˆˆ l â†’ p x",
  "tactic-prompt":
  "theorem  : âˆ€ {p : Î± â†’ Prop} {a : Î±} {l : List Î±},\n    (âˆ€ x, x âˆˆ a :: l â†’ p x) â†” p a âˆ§ âˆ€ x, x âˆˆ l â†’ p x := by aesop; sorry",
  "name": "X.forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  " : âˆ€ {p : Î± â†’ Prop} {a : Î±} {l : List Î±},\n    (âˆ€ x, x âˆˆ a :: l â†’ p x) â†” p a âˆ§ âˆ€ x, x âˆˆ l â†’ p x",
  "args": ""},
 {"type": "âˆ€ x, x âˆˆ l â†’ p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}      (h : âˆ€ x, x âˆˆ a :: l â†’ p x) : âˆ€ x, x âˆˆ l â†’ p x := by aesop; sorry",
  "name": "forall_mem_of_forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}      (h : âˆ€ x, x âˆˆ a :: l â†’ p x) : âˆ€ x, x âˆˆ l â†’ p x",
  "args":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}      (h : âˆ€ x, x âˆˆ a :: l â†’ p x)"},
 {"type": "(âˆ€ x, x âˆˆ [a] â†’ p x) â†” p a",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x, x âˆˆ [a] â†’ p x) â†” p a := by aesop; sorry",
  "name": "X.forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x, x âˆˆ [a] â†’ p x) â†” p a",
  "args": "{p : Î± â†’ Prop}  {a : Î±}"},
 {"type":
  "(âˆ€ x, x âˆˆ lâ‚ ++ lâ‚‚ â†’ p x) â†” (âˆ€ x, x âˆˆ lâ‚ â†’ p x) âˆ§ (âˆ€ x, x âˆˆ lâ‚‚ â†’ p x)",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x, x âˆˆ lâ‚ ++ lâ‚‚ â†’ p x) â†” (âˆ€ x, x âˆˆ lâ‚ â†’ p x) âˆ§ (âˆ€ x, x âˆˆ lâ‚‚ â†’ p x) := by aesop; sorry",
  "name": "X.forall_mem_append",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x, x âˆˆ lâ‚ ++ lâ‚‚ â†’ p x) â†” (âˆ€ x, x âˆˆ lâ‚ â†’ p x) âˆ§ (âˆ€ x, x âˆˆ lâ‚‚ â†’ p x)",
  "args": "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "Â¬ âˆƒ x, x âˆˆ @nil Î± âˆ§ p x",
  "tactic-prompt":
  "theorem (p : Î± â†’ Prop) : Â¬ âˆƒ x, x âˆˆ @nil Î± âˆ§ p x := by aesop; sorry",
  "name": "not_exists_mem_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(p : Î± â†’ Prop) : Â¬ âˆƒ x, x âˆˆ @nil Î± âˆ§ p x",
  "args": "(p : Î± â†’ Prop)"},
 {"type": "âˆƒ x, x âˆˆ a :: l âˆ§ p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  (l : List Î±)  (h : p a) : âˆƒ x, x âˆˆ a :: l âˆ§ p x := by aesop; sorry",
  "name": "exists_mem_cons_of",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  (l : List Î±)  (h : p a) : âˆƒ x, x âˆˆ a :: l âˆ§ p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  (l : List Î±)  (h : p a)"},
 {"type": "âˆƒ x, x âˆˆ a :: l âˆ§ p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ l âˆ§ p x) : âˆƒ x, x âˆˆ a :: l âˆ§ p x := by aesop; sorry",
  "name": "exists_mem_cons_of_exists",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ l âˆ§ p x) : âˆƒ x, x âˆˆ a :: l âˆ§ p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ l âˆ§ p x)"},
 {"type": "p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ a :: l âˆ§ p x) : p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x := by aesop; sorry",
  "name": "or_exists_of_exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ a :: l âˆ§ p x) : p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}  (h : âˆƒ x, x âˆˆ a :: l âˆ§ p x)"},
 {"type": "(âˆƒ x, x âˆˆ a :: l âˆ§ p x) â†” p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x",
  "tactic-prompt":
  "theorem (p : Î± â†’ Prop)  (a : Î±)  (l : List Î±) : (âˆƒ x, x âˆˆ a :: l âˆ§ p x) â†” p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x := by aesop; sorry",
  "name": "exists_mem_cons_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(p : Î± â†’ Prop)  (a : Î±)  (l : List Î±) : (âˆƒ x, x âˆˆ a :: l âˆ§ p x) â†” p a âˆ¨ âˆƒ x, x âˆˆ l âˆ§ p x",
  "args": "(p : Î± â†’ Prop)  (a : Î±)  (l : List Î±)"},
 {"type": "lâ‚ âŠ† lâ‚‚ â†” âˆ€ â¦ƒa : Î±â¦„, a âˆˆ lâ‚ â†’ a âˆˆ lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±} : lâ‚ âŠ† lâ‚‚ â†” âˆ€ â¦ƒa : Î±â¦„, a âˆˆ lâ‚ â†’ a âˆˆ lâ‚‚ := by aesop; sorry",
  "name": "X.subset_def",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±} : lâ‚ âŠ† lâ‚‚ â†” âˆ€ â¦ƒa : Î±â¦„, a âˆˆ lâ‚ â†’ a âˆˆ lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}"},
 {"type": "l âŠ† lâ‚ â†’ l âŠ† lâ‚++lâ‚‚",
  "tactic-prompt":
  "theorem (l lâ‚ lâ‚‚ : List Î±) : l âŠ† lâ‚ â†’ l âŠ† lâ‚++lâ‚‚ := by aesop (add 1% subset_trans); sorry",
  "name": "X.subset_append_of_subset_left",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% subset_trans)",
  "core-prompt": "(l lâ‚ lâ‚‚ : List Î±) : l âŠ† lâ‚ â†’ l âŠ† lâ‚++lâ‚‚",
  "args": "(l lâ‚ lâ‚‚ : List Î±)"},
 {"type": "l âŠ† lâ‚‚ â†’ l âŠ† lâ‚ ++ lâ‚‚",
  "tactic-prompt":
  "theorem (l lâ‚ lâ‚‚ : List Î±) : l âŠ† lâ‚‚ â†’ l âŠ† lâ‚ ++ lâ‚‚ := by aesop (add 1% subset_trans); sorry",
  "name": "X.subset_append_of_subset_right",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% subset_trans)",
  "core-prompt": "(l lâ‚ lâ‚‚ : List Î±) : l âŠ† lâ‚‚ â†’ l âŠ† lâ‚ ++ lâ‚‚",
  "args": "(l lâ‚ lâ‚‚ : List Î±)"},
 {"type": "a::l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "tactic-prompt":
  "theorem {a : Î±}  {l m : List Î±} : a::l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m := by set_option aesop.check.script false in; sorry",
  "name": "X.cons_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt": "{a : Î±}  {l m : List Î±} : a::l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "args": "{a : Î±}  {l m : List Î±}"},
 {"type": "a::l âŠ† m",
  "tactic-prompt":
  "theorem {a : Î±}  {l m : List Î±}      (ainm : a âˆˆ m)  (lsubm : l âŠ† m) : a::l âŠ† m := by aesop; sorry",
  "name": "cons_subset_of_subset_of_mem",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : Î±}  {l m : List Î±}      (ainm : a âˆˆ m)  (lsubm : l âŠ† m) : a::l âŠ† m",
  "args": "{a : Î±}  {l m : List Î±}      (ainm : a âˆˆ m)  (lsubm : l âŠ† m)"},
 {"type": "lâ‚ ++ lâ‚‚ âŠ† l",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ l : List Î±}  (lâ‚subl : lâ‚ âŠ† l)  (lâ‚‚subl : lâ‚‚ âŠ† l) : lâ‚ ++ lâ‚‚ âŠ† l := by set_option aesop.check.script false in; sorry",
  "name": "append_subset_of_subset_of_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt":
  "{lâ‚ lâ‚‚ l : List Î±}  (lâ‚subl : lâ‚ âŠ† l)  (lâ‚‚subl : lâ‚‚ âŠ† l) : lâ‚ ++ lâ‚‚ âŠ† l",
  "args": "{lâ‚ lâ‚‚ l : List Î±}  (lâ‚subl : lâ‚ âŠ† l)  (lâ‚‚subl : lâ‚‚ âŠ† l)"},
 {"type": "lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l := by set_option aesop.check.script false in; sorry",
  "name": "append_subset_iff",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt": "{lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "args": "{lâ‚ lâ‚‚ l : List Î±}"},
 {"type": "l âŠ† [] â†’ l = []",
  "tactic-prompt":
  "theorem {l : List Î±} : l âŠ† [] â†’ l = [] := by aesop (add 1% cases List); sorry",
  "name": "eq_nil_of_subset_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List Î±} : l âŠ† [] â†’ l = []",
  "args": "{l : List Î±}"},
 {"type": "l = [] â†” âˆ€ a, a âˆ‰ l",
  "tactic-prompt":
  "theorem {l : List Î±} : l = [] â†” âˆ€ a, a âˆ‰ l := by aesop (add 1% cases List); sorry",
  "name": "X.eq_nil_iff_forall_not_mem",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{l : List Î±} : l = [] â†” âˆ€ a, a âˆ‰ l",
  "args": "{l : List Î±}"},
 {"type": "map f lâ‚ âŠ† map f lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (H : lâ‚ âŠ† lâ‚‚) : map f lâ‚ âŠ† map f lâ‚‚ := by set_option aesop.check.script false in; sorry",
  "name": "X.map_subset",
  "kind": "theorem",
  "first-tactic": "set_option aesop.check.script false in",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (H : lâ‚ âŠ† lâ‚‚) : map f lâ‚ âŠ† map f lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (H : lâ‚ âŠ† lâ‚‚)"},
 {"type": "map f lâ‚ âŠ† map f lâ‚‚ â†” lâ‚ âŠ† lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (h : Injective f) : map f lâ‚ âŠ† map f lâ‚‚ â†” lâ‚ âŠ† lâ‚‚ := by induction lâ‚; sorry",
  "name": "map_subset_iff",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (h : Injective f) : map f lâ‚ âŠ† map f lâ‚‚ â†” lâ‚ âŠ† lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (f : Î± â†’ Î²)  (h : Injective f)"},
 {"type": "s â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : s â‰  [] â†’ s ++ t â‰  [] := by induction s; sorry",
  "name": "X.append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "(s t : List Î±) : s â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "t â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : t â‰  [] â†’ s ++ t â‰  [] := by induction s; sorry",
  "name": "X.append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "(s t : List Î±) : t â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "(p ++ q) = [] â†” p = [] âˆ§ q = []",
  "tactic-prompt":
  "theorem {p q : List Î±} : (p ++ q) = [] â†” p = [] âˆ§ q = [] := by aesop (add 1% cases List); sorry",
  "name": "X.append_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "{p q : List Î±} : (p ++ q) = [] â†” p = [] âˆ§ q = []",
  "args": "{p q : List Î±}"},
 {"type": "[] = a ++ b â†” a = [] âˆ§ b = []",
  "tactic-prompt":
  "theorem {a b : List Î±} : [] = a ++ b â†” a = [] âˆ§ b = [] := by induction a; sorry",
  "name": "nil_eq_append_iff",
  "kind": "theorem",
  "first-tactic": "induction a",
  "core-prompt": "{a b : List Î±} : [] = a ++ b â†” a = [] âˆ§ b = []",
  "args": "{a b : List Î±}"},
 {"type":
  "a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem {a b c : List Î±}  {x : Î±} : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b) := by aesop (add 1% cases List); sorry",
  "name": "append_eq_cons_iff",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{a b c : List Î±}  {x : Î±} : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b)",
  "args": "{a b c : List Î±}  {x : Î±}"},
 {"type":
  "(x :: c : List Î±) = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem {a b c : List Î±}  {x : Î±} : (x :: c : List Î±) = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b) := by aesop (add norm simp [append_eq_cons_iff]; sorry",
  "name": "cons_eq_append_iff",
  "kind": "theorem",
  "first-tactic": "aesop (add norm simp [append_eq_cons_iff]",
  "core-prompt":
  "{a b c : List Î±}  {x : Î±} : (x :: c : List Î±) = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒa', a = x :: a' âˆ§ c = a' ++ b)",
  "args": "{a b c : List Î±}  {x : Î±}"},
 {"type": "tâ‚ = tâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚) : tâ‚ = tâ‚‚ := by aesop; sorry",
  "name": "X.append_inj_right",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚) : tâ‚ = tâ‚‚",
  "args":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚)"},
 {"type": "sâ‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚) : sâ‚ = sâ‚‚ := by aesop; sorry",
  "name": "X.append_inj_left",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚) : sâ‚ = sâ‚‚",
  "args":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length sâ‚ = length sâ‚‚)"},
 {"type": "sâ‚ = sâ‚‚ âˆ§ tâ‚ = tâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)  (hl : length tâ‚ = length tâ‚‚) : sâ‚ = sâ‚‚ âˆ§ tâ‚ = tâ‚‚ := by induction sâ‚ generalizing sâ‚‚; sorry",
  "name": "X.append_inj'",
  "kind": "theorem",
  "first-tactic": "induction sâ‚ generalizing sâ‚‚",
  "core-prompt":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)  (hl : length tâ‚ = length tâ‚‚) : sâ‚ = sâ‚‚ âˆ§ tâ‚ = tâ‚‚",
  "args":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)  (hl : length tâ‚ = length tâ‚‚)"},
 {"type": "tâ‚ = tâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚) : tâ‚ = tâ‚‚ := by aesop; sorry",
  "name": "X.append_inj_right'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚) : tâ‚ = tâ‚‚",
  "args":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚)"},
 {"type": "sâ‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚) : sâ‚ = sâ‚‚ := by aesop; sorry",
  "name": "X.append_inj_left'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚) : sâ‚ = sâ‚‚",
  "args":
  "{sâ‚ sâ‚‚ tâ‚ tâ‚‚ : List Î±}  (h : sâ‚ ++ tâ‚ = sâ‚‚ ++ tâ‚‚)      (hl : length tâ‚ = length tâ‚‚)"},
 {"type": "tâ‚ = tâ‚‚",
  "tactic-prompt":
  "theorem {s tâ‚ tâ‚‚ : List Î±}  (h : s ++ tâ‚ = s ++ tâ‚‚) : tâ‚ = tâ‚‚ := by aesop; sorry",
  "name": "append_left_cancel",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{s tâ‚ tâ‚‚ : List Î±}  (h : s ++ tâ‚ = s ++ tâ‚‚) : tâ‚ = tâ‚‚",
  "args": "{s tâ‚ tâ‚‚ : List Î±}  (h : s ++ tâ‚ = s ++ tâ‚‚)"},
 {"type": "sâ‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {sâ‚ sâ‚‚ t : List Î±}  (h : sâ‚ ++ t = sâ‚‚ ++ t) : sâ‚ = sâ‚‚ := by aesop; sorry",
  "name": "append_right_cancel",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{sâ‚ sâ‚‚ t : List Î±}  (h : sâ‚ ++ t = sâ‚‚ ++ t) : sâ‚ = sâ‚‚",
  "args": "{sâ‚ sâ‚‚ t : List Î±}  (h : sâ‚ ++ t = sâ‚‚ ++ t)"},
 {"type": "Injective (Î» t => s ++ t)",
  "tactic-prompt":
  "theorem (s : List Î±) : Injective (Î» t => s ++ t) := by aesop; sorry",
  "name": "append_right_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(s : List Î±) : Injective (Î» t => s ++ t)",
  "args": "(s : List Î±)"},
 {"type": "Injective (Î» s => s ++ t)",
  "tactic-prompt":
  "theorem (t : List Î±) : Injective (Î» s => s ++ t) := by aesop; sorry",
  "name": "append_left_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(t : List Î±) : Injective (Î» s => s ++ t)",
  "args": "(t : List Î±)"},
 {"type": "(âˆ€ b, b âˆˆ l â†’ b = a) â†’ l = replicate l.length a",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : (âˆ€ b, b âˆˆ l â†’ b = a) â†’ l = replicate l.length a := by induction l; sorry",
  "name": "eq_replicate_of_mem",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±} : (âˆ€ b, b âˆˆ l â†’ b = a) â†’ l = replicate l.length a",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type": "l = replicate l.length a â†” âˆ€ b, b âˆˆ l â†’ b = a",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : l = replicate l.length a â†” âˆ€ b, b âˆˆ l â†’ b = a := by induction l; sorry",
  "name": "eq_replicate'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±} : l = replicate l.length a â†” âˆ€ b, b âˆˆ l â†’ b = a",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type": "map (Î» _ => b) l = replicate l.length b",
  "tactic-prompt":
  "theorem (l : List Î±)  (b : Î²) : map (Î» _ => b) l = replicate l.length b := by induction l; sorry",
  "name": "map_const",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(l : List Î±)  (b : Î²) : map (Î» _ => b) l = replicate l.length b",
  "args": "(l : List Î±)  (b : Î²)"},
 {"type": "bâ‚ = bâ‚‚",
  "tactic-prompt":
  "theorem {bâ‚ bâ‚‚ : Î²}  {l : List Î±}  (h : bâ‚ âˆˆ map (Î» _ => bâ‚‚) l) : bâ‚ = bâ‚‚ := by aesop; sorry",
  "name": "eq_of_mem_map_const",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{bâ‚ bâ‚‚ : Î²}  {l : List Î±}  (h : bâ‚ âˆˆ map (Î» _ => bâ‚‚) l) : bâ‚ = bâ‚‚",
  "args": "{bâ‚ bâ‚‚ : Î²}  {l : List Î±}  (h : bâ‚ âˆˆ map (Î» _ => bâ‚‚) l)"},
 {"type": "join (replicate n []) = @nil Î±",
  "tactic-prompt":
  "theorem (n : Nat) : join (replicate n []) = @nil Î± := by induction n; sorry",
  "name": "join_replicate_nil",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : join (replicate n []) = @nil Î±",
  "args": "(n : Nat)"},
 {"type": "Injective (Î» a : Î± => replicate n a)",
  "tactic-prompt":
  "theorem {n : Nat}  (hn : n â‰  0) : Injective (Î» a : Î± => replicate n a) := by induction n; sorry",
  "name": "replicate_left_injective",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{n : Nat}  (hn : n â‰  0) : Injective (Î» a : Î± => replicate n a)",
  "args": "{n : Nat}  (hn : n â‰  0)"},
 {"type": "âˆ€ {n}, replicate n a = replicate n b â†” n = 0 âˆ¨ a = b",
  "tactic-prompt":
  "theorem {a b : Î±} : âˆ€ {n}, replicate n a = replicate n b â†” n = 0 âˆ¨ a = b := by intro n; sorry",
  "name": "replicate_left_inj'",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{a b : Î±} : âˆ€ {n}, replicate n a = replicate n b â†” n = 0 âˆ¨ a = b",
  "args": "{a b : Î±}"},
 {"type": "Injective (Î» n => replicate n a)",
  "tactic-prompt":
  "theorem (a : Î±) : Injective (Î» n => replicate n a) := by unfold Injective; sorry",
  "name": "replicate_right_injective",
  "kind": "theorem",
  "first-tactic": "unfold Injective",
  "core-prompt": "(a : Î±) : Injective (Î» n => replicate n a)",
  "args": "(a : Î±)"},
 {"type": "replicate n a = replicate m a â†” n = m",
  "tactic-prompt":
  "theorem {a : Î±}  {n m : Nat} : replicate n a = replicate m a â†” n = m := by induction n generalizing m; sorry",
  "name": "replicate_right_inj",
  "kind": "theorem",
  "first-tactic": "induction n generalizing m",
  "core-prompt": "{a : Î±}  {n m : Nat} : replicate n a = replicate m a â†” n = m",
  "args": "{a : Î±}  {n m : Nat}"},
 {"type": "(lâ‚ ++ lâ‚‚).bind f = lâ‚.bind f ++ lâ‚‚.bind f",
  "tactic-prompt":
  "theorem (f : Î± â†’ List Î²)  (lâ‚ lâ‚‚ : List Î±) : (lâ‚ ++ lâ‚‚).bind f = lâ‚.bind f ++ lâ‚‚.bind f := by induction lâ‚; sorry",
  "name": "bind_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "(f : Î± â†’ List Î²)  (lâ‚ lâ‚‚ : List Î±) : (lâ‚ ++ lâ‚‚).bind f = lâ‚.bind f ++ lâ‚‚.bind f",
  "args": "(f : Î± â†’ List Î²)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "[x].bind f = f x",
  "tactic-prompt":
  "theorem (f : Î± â†’ List Î²)  (x : Î±) : [x].bind f = f x := by aesop; sorry",
  "name": "bind_singleton",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(f : Î± â†’ List Î²)  (x : Î±) : [x].bind f = f x",
  "args": "(f : Î± â†’ List Î²)  (x : Î±)"},
 {"type": "l.bind (Î» x => [x]) = l",
  "tactic-prompt":
  "theorem (l : List Î±) : l.bind (Î» x => [x]) = l := by induction l; sorry",
  "name": "bind_singleton'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : l.bind (Î» x => [x]) = l",
  "args": "(l : List Î±)"},
 {"type": "concat l a = l ++ [a]",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : concat l a = l ++ [a] := by induction l; sorry",
  "name": "X.concat_eq_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(a : Î±)  (l : List Î±) : concat l a = l ++ [a]",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "concat lâ‚ a = concat lâ‚‚ a â†’ lâ‚ = lâ‚‚",
  "tactic-prompt":
  "theorem {a : Î±}  {lâ‚ lâ‚‚ : List Î±} : concat lâ‚ a = concat lâ‚‚ a â†’ lâ‚ = lâ‚‚ := by aesop; sorry",
  "name": "init_eq_of_concat_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : Î±}  {lâ‚ lâ‚‚ : List Î±} : concat lâ‚ a = concat lâ‚‚ a â†’ lâ‚ = lâ‚‚",
  "args": "{a : Î±}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "concat l a = concat l b â†’ a = b",
  "tactic-prompt":
  "theorem {a b : Î±}  {l : List Î±} : concat l a = concat l b â†’ a = b := by aesop; sorry",
  "name": "last_eq_of_concat_eq",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{a b : Î±}  {l : List Î±} : concat l a = concat l b â†’ a = b",
  "args": "{a b : Î±}  {l : List Î±}"},
 {"type": "concat l a â‰  []",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : concat l a â‰  [] := by aesop; sorry",
  "name": "concat_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "(a : Î±)  (l : List Î±) : concat l a â‰  []",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "concat lâ‚ a ++ lâ‚‚ = lâ‚ ++ a :: lâ‚‚",
  "tactic-prompt":
  "theorem (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : concat lâ‚ a ++ lâ‚‚ = lâ‚ ++ a :: lâ‚‚ := by aesop; sorry",
  "name": "concat_append",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : Î±)  (lâ‚ lâ‚‚ : List Î±) : concat lâ‚ a ++ lâ‚‚ = lâ‚ ++ a :: lâ‚‚",
  "args": "(a : Î±)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "length (concat l a) = .succ (length l)",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : length (concat l a) = .succ (length l) := by aesop; sorry",
  "name": "X.length_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : Î±)  (l : List Î±) : length (concat l a) = .succ (length l)",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "lâ‚ ++ concat lâ‚‚ a = concat (lâ‚ ++ lâ‚‚) a",
  "tactic-prompt":
  "theorem (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : lâ‚ ++ concat lâ‚‚ a = concat (lâ‚ ++ lâ‚‚) a := by aesop; sorry",
  "name": "append_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : Î±)  (lâ‚ lâ‚‚ : List Î±) : lâ‚ ++ concat lâ‚‚ a = concat (lâ‚ ++ lâ‚‚) a",
  "args": "(a : Î±)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "reverseAux lâ‚ lâ‚‚ = reverse lâ‚ ++ lâ‚‚",
  "tactic-prompt":
  "theorem (lâ‚ lâ‚‚ : List Î±) : reverseAux lâ‚ lâ‚‚ = reverse lâ‚ ++ lâ‚‚ := by induction lâ‚ generalizing lâ‚‚; sorry",
  "name": "reverse_core_eq",
  "kind": "theorem",
  "first-tactic": "induction lâ‚ generalizing lâ‚‚",
  "core-prompt": "(lâ‚ lâ‚‚ : List Î±) : reverseAux lâ‚ lâ‚‚ = reverse lâ‚ ++ lâ‚‚",
  "args": "(lâ‚ lâ‚‚ : List Î±)"},
 {"type": "reverse (a::l) = concat (reverse l) a",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : reverse (a::l) = concat (reverse l) a := by aesop; sorry",
  "name": "reverse_cons'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(a : Î±)  (l : List Î±) : reverse (a::l) = concat (reverse l) a",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "reverse (s ++ t) = (reverse t) ++ (reverse s)",
  "tactic-prompt":
  "theorem (s t : List Î±) : reverse (s ++ t) = (reverse t) ++ (reverse s) := by induction s; sorry",
  "name": "X.reverse_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(s t : List Î±) : reverse (s ++ t) = (reverse t) ++ (reverse s)",
  "args": "(s t : List Î±)"},
 {"type": "reverse (concat l a) = a :: reverse l",
  "tactic-prompt":
  "theorem (l : List Î±)  (a : Î±) : reverse (concat l a) = a :: reverse l := by aesop; sorry",
  "name": "X.reverse_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(l : List Î±)  (a : Î±) : reverse (concat l a) = a :: reverse l",
  "args": "(l : List Î±)  (a : Î±)"},
 {"type": "reverse (reverse l) = l",
  "tactic-prompt":
  "theorem (l : List Î±) : reverse (reverse l) = l := by induction l; sorry",
  "name": "X.reverse_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : reverse (reverse l) = l",
  "args": "(l : List Î±)"},
 {"type": "Involutive (@reverse Î±)",
  "tactic-prompt": "theorem  : Involutive (@reverse Î±) := by aesop; sorry",
  "name": "reverse_involutive",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : Involutive (@reverse Î±)",
  "args": ""},
 {"type": "Injective (@reverse Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u} : Injective (@reverse Î±) := by aesop; sorry",
  "name": "reverse_injective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{Î± : Type u} : Injective (@reverse Î±)",
  "args": "{Î± : Type u}"},
 {"type": "Surjective (@reverse Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u} : Surjective (@reverse Î±) := by aesop; sorry",
  "name": "reverse_surjective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{Î± : Type u} : Surjective (@reverse Î±)",
  "args": "{Î± : Type u}"},
 {"type": "Bijective (@reverse Î±)",
  "tactic-prompt": "theorem  : Bijective (@reverse Î±) := by aesop; sorry",
  "name": "reverse_bijective",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : Bijective (@reverse Î±)",
  "args": ""},
 {"type": "reverse lâ‚ = reverse lâ‚‚ â†” lâ‚ = lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±} : reverse lâ‚ = reverse lâ‚‚ â†” lâ‚ = lâ‚‚ := by aesop (add safe forward reverse_injective); sorry",
  "name": "reverse_inj",
  "kind": "theorem",
  "first-tactic": "aesop (add safe forward reverse_injective)",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±} : reverse lâ‚ = reverse lâ‚‚ â†” lâ‚ = lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}"},
 {"type": "l.reverse = l' â†” l = l'.reverse",
  "tactic-prompt":
  "theorem {l l' : List Î±} : l.reverse = l' â†” l = l'.reverse := by aesop; sorry",
  "name": "reverse_eq_iff",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l l' : List Î±} : l.reverse = l' â†” l = l'.reverse",
  "args": "{l l' : List Î±}"},
 {"type": "reverse l = [] â†” l = []",
  "tactic-prompt":
  "theorem {l : List Î±} : reverse l = [] â†” l = [] := by aesop (add norm simp reverse_eq_iff); sorry",
  "name": "reverse_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add norm simp reverse_eq_iff)",
  "core-prompt": "{l : List Î±} : reverse l = [] â†” l = []",
  "args": "{l : List Î±}"},
 {"type": "concat l a = reverse (a :: reverse l)",
  "tactic-prompt":
  "theorem (a : Î±)  (l : List Î±) : concat l a = reverse (a :: reverse l) := by induction l; sorry",
  "name": "concat_eq_reverse_cons",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(a : Î±)  (l : List Î±) : concat l a = reverse (a :: reverse l)",
  "args": "(a : Î±)  (l : List Î±)"},
 {"type": "length (reverse l) = length l",
  "tactic-prompt":
  "theorem (l : List Î±) : length (reverse l) = length l := by induction l; sorry",
  "name": "X.length_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : length (reverse l) = length l",
  "args": "(l : List Î±)"},
 {"type": "map f (reverse l) = reverse (map f l)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (l : List Î±) : map f (reverse l) = reverse (map f l) := by induction l; sorry",
  "name": "map_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î²)  (l : List Î±) : map f (reverse l) = reverse (map f l)",
  "args": "(f : Î± â†’ Î²)  (l : List Î±)"},
 {"type": "map f (reverseAux lâ‚ lâ‚‚) = reverseAux (map f lâ‚) (map f lâ‚‚)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (lâ‚ lâ‚‚ : List Î±) : map f (reverseAux lâ‚ lâ‚‚) = reverseAux (map f lâ‚) (map f lâ‚‚) := by aesop; sorry",
  "name": "map_reverse_core",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(f : Î± â†’ Î²)  (lâ‚ lâ‚‚ : List Î±) : map f (reverseAux lâ‚ lâ‚‚) = reverseAux (map f lâ‚) (map f lâ‚‚)",
  "args": "(f : Î± â†’ Î²)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "a âˆˆ reverse l â†” a âˆˆ l",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : a âˆˆ reverse l â†” a âˆˆ l := by induction l; sorry",
  "name": "X.mem_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{a : Î±}  {l : List Î±} : a âˆˆ reverse l â†” a âˆˆ l",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type": "Empty l â†” l = []",
  "tactic-prompt": "theorem {l : List Î±} : Empty l â†” l = [] := by aesop; sorry",
  "name": "empty_iff_eq_nil",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": "{l : List Î±} : Empty l â†” l = []",
  "args": "{l : List Î±}"},
 {"type": "âˆ€ (h : l â‰  nil), last (a :: l) (cons_ne_nil a l) = last l h",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : âˆ€ (h : l â‰  nil), last (a :: l) (cons_ne_nil a l) = last l h := by aesop (add 1% cases List); sorry",
  "name": "last_cons",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{a : Î±}  {l : List Î±} : âˆ€ (h : l â‰  nil), last (a :: l) (cons_ne_nil a l) = last l h",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type":
  "last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a",
  "tactic-prompt":
  "theorem {a : Î±}  (l : List Î±) : last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a := by induction l; sorry",
  "name": "last_append_singleton",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  (l : List Î±) : last (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a",
  "args": "{a : Î±}  (l : List Î±)"},
 {"type": "last (lâ‚ ++ lâ‚‚) (append_ne_nil_of_ne_nil_right lâ‚ lâ‚‚ h) = last lâ‚‚ h",
  "tactic-prompt":
  "theorem (lâ‚ lâ‚‚ : List Î±)  (h : lâ‚‚ â‰  []) : last (lâ‚ ++ lâ‚‚) (append_ne_nil_of_ne_nil_right lâ‚ lâ‚‚ h) = last lâ‚‚ h := by induction lâ‚; sorry",
  "name": "last_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "(lâ‚ lâ‚‚ : List Î±)  (h : lâ‚‚ â‰  []) : last (lâ‚ ++ lâ‚‚) (append_ne_nil_of_ne_nil_right lâ‚ lâ‚‚ h) = last lâ‚‚ h",
  "args": "(lâ‚ lâ‚‚ : List Î±)  (h : lâ‚‚ â‰  [])"},
 {"type": "last (concat l a) (concat_ne_nil a l) = a",
  "tactic-prompt":
  "theorem {a : Î±}  (l : List Î±) : last (concat l a) (concat_ne_nil a l) = a := by aesop; sorry",
  "name": "last_concat",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{a : Î±}  (l : List Î±) : last (concat l a) (concat_ne_nil a l) = a",
  "args": "{a : Î±}  (l : List Î±)"},
 {"type": "last lâ‚ hâ‚ = last lâ‚‚ hâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (hâ‚ : lâ‚ â‰  [])  (hâ‚‚ : lâ‚‚ â‰  [])  (hâ‚ƒ : lâ‚ = lâ‚‚) : last lâ‚ hâ‚ = last lâ‚‚ hâ‚‚ := by aesop; sorry",
  "name": "last_congr",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  (hâ‚ : lâ‚ â‰  [])  (hâ‚‚ : lâ‚‚ â‰  [])  (hâ‚ƒ : lâ‚ = lâ‚‚) : last lâ‚ hâ‚ = last lâ‚‚ hâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (hâ‚ : lâ‚ â‰  [])  (hâ‚‚ : lâ‚‚ â‰  [])  (hâ‚ƒ : lâ‚ = lâ‚‚)"},
 {"type": "âˆ€ {l : List Î±} (h : l â‰  []), last l h âˆˆ l",
  "tactic-prompt":
  "theorem  : âˆ€ {l : List Î±} (h : l â‰  []), last l h âˆˆ l := by intro l; sorry",
  "name": "last_mem",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt": " : âˆ€ {l : List Î±} (h : l â‰  []), last l h âˆˆ l",
  "args": ""},
 {"type":
  "(replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a",
  "tactic-prompt":
  "theorem (a m : Nat) : (replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a := by induction m; sorry",
  "name": "last_replicate_succ",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "(a m : Nat) : (replicate m.succ a).last\n    (ne_nil_of_length_eq_succ\n      (show (replicate m.succ a).length = m.succ by rw [length_replicate])) =\n  a",
  "args": "(a m : Nat)"},
 {"type": "âˆ€ {l : List Î±} (_ : x âˆˆ l.last'), x âˆˆ (y :: l).last'",
  "tactic-prompt":
  "theorem {x y : Î±} : âˆ€ {l : List Î±} (_ : x âˆˆ l.last'), x âˆˆ (y :: l).last' := by intro l; sorry",
  "name": "mem_last'_cons",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt":
  "{x y : Î±} : âˆ€ {l : List Î±} (_ : x âˆˆ l.last'), x âˆˆ (y :: l).last'",
  "args": "{x y : Î±}"},
 {"type": "a âˆˆ l",
  "tactic-prompt":
  "theorem {l : List Î±}  {a : Î±}  (ha : a âˆˆ l.last') : a âˆˆ l := by match l with\n  | [] => aesop\n  | [_] => aesop\n  | x :: y :: zs =>\n    have ih := mem_of_mem_last' (l := y :: zs) (a := a)\n    aesop; sorry",
  "name": "mem_of_mem_last'",
  "kind": "theorem",
  "first-tactic":
  "match l with\n  | [] => aesop\n  | [_] => aesop\n  | x :: y :: zs =>\n    have ih := mem_of_mem_last' (l := y :: zs) (a := a)\n    aesop",
  "core-prompt": "{l : List Î±}  {a : Î±}  (ha : a âˆˆ l.last') : a âˆˆ l",
  "args": "{l : List Î±}  {a : Î±}  (ha : a âˆˆ l.last')"},
 {"type": "x âˆˆ (lâ‚ ++ lâ‚‚).last'",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  {x : Î±}  (h : x âˆˆ lâ‚‚.last') : x âˆˆ (lâ‚ ++ lâ‚‚).last' := by aesop (add 1% cases List); sorry",
  "name": "last'_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  {x : Î±}  (h : x âˆˆ lâ‚‚.last') : x âˆˆ (lâ‚ ++ lâ‚‚).last'",
  "args": "{lâ‚ lâ‚‚ : List Î±}  {x : Î±}  (h : x âˆˆ lâ‚‚.last')"},
 {"type": "ihead l = (head' l).iget",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (l : List Î±) : ihead l = (head' l).iget := by aesop (add 1% cases List); sorry",
  "name": "head_eq_head'",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt": "[Inhabited Î±]  (l : List Î±) : ihead l = (head' l).iget",
  "args": "[Inhabited Î±]  (l : List Î±)"},
 {"type": "âˆ€ {l : List Î±}, x âˆˆ l.head' â†’ x âˆˆ l",
  "tactic-prompt":
  "theorem {x : Î±} : âˆ€ {l : List Î±}, x âˆˆ l.head' â†’ x âˆˆ l := by intro l; sorry",
  "name": "mem_of_mem_head'",
  "kind": "theorem",
  "first-tactic": "intro l",
  "core-prompt": "{x : Î±} : âˆ€ {l : List Î±}, x âˆˆ l.head' â†’ x âˆˆ l",
  "args": "{x : Î±}"},
 {"type": "ihead (s ++ t) = ihead s",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (t : List Î±)  {s : List Î±}  (h : s â‰  []) : ihead (s ++ t) = ihead s := by aesop (add 1% cases List); sorry",
  "name": "head_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "[Inhabited Î±]  (t : List Î±)  {s : List Î±}  (h : s â‰  []) : ihead (s ++ t) = ihead s",
  "args": "[Inhabited Î±]  (t : List Î±)  {s : List Î±}  (h : s â‰  [])"},
 {"type": "x âˆˆ (s ++ t).head'",
  "tactic-prompt":
  "theorem {s t : List Î±}  {x : Î±}  (h : x âˆˆ s.head') : x âˆˆ (s ++ t).head' := by aesop (add 1% cases List); sorry",
  "name": "head'_append",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  "{s t : List Î±}  {x : Î±}  (h : x âˆˆ s.head') : x âˆˆ (s ++ t).head'",
  "args": "{s t : List Î±}  {x : Î±}  (h : x âˆˆ s.head')"},
 {"type":
  "âˆ€ (lâ‚ : List Î±) {lâ‚‚ : List Î±} (_ : lâ‚ â‰  []),\n  head' (lâ‚ ++ lâ‚‚) = head' lâ‚",
  "tactic-prompt":
  "theorem  : âˆ€ (lâ‚ : List Î±) {lâ‚‚ : List Î±} (_ : lâ‚ â‰  []),\n  head' (lâ‚ ++ lâ‚‚) = head' lâ‚ := by aesop (add 1% cases List); sorry",
  "name": "head'_append_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "aesop (add 1% cases List)",
  "core-prompt":
  " : âˆ€ (lâ‚ : List Î±) {lâ‚‚ : List Î±} (_ : lâ‚ â‰  []),\n  head' (lâ‚ ++ lâ‚‚) = head' lâ‚",
  "args": ""},
 {"type": "tail (l ++ [a]) = tail l ++ [a]",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : l â‰  nil) : tail (l ++ [a]) = tail l ++ [a] := by induction l; sorry",
  "name": "tail_append_singleton_of_ne_nil",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±}  (h : l â‰  nil) : tail (l ++ [a]) = tail l ++ [a]",
  "args": "{a : Î±}  {l : List Î±}  (h : l â‰  nil)"},
 {"type": "âˆ€ {l : List Î±} {a : Î±} (_ : a âˆˆ head' l), a :: tail l = l",
  "tactic-prompt":
  "theorem  : âˆ€ {l : List Î±} {a : Î±} (_ : a âˆˆ head' l), a :: tail l = l := by aesop; sorry",
  "name": "cons_head'_tail",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt": " : âˆ€ {l : List Î±} {a : Î±} (_ : a âˆˆ head' l), a :: tail l = l",
  "args": ""},
 {"type": "âˆ€ {l : List Î±} (_ : l â‰  []), ihead l âˆˆ head' l",
  "tactic-prompt":
  "theorem [Inhabited Î±] : âˆ€ {l : List Î±} (_ : l â‰  []), ihead l âˆˆ head' l := by aesop; sorry",
  "name": "head_mem_head'",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "[Inhabited Î±] : âˆ€ {l : List Î±} (_ : l â‰  []), ihead l âˆˆ head' l",
  "args": "[Inhabited Î±]"},
 {"type": "(ihead l)::(tail l) = l",
  "tactic-prompt":
  "theorem [Inhabited Î±]  {l : List Î±}  (h : l â‰  []) : (ihead l)::(tail l) = l := by aesop; sorry",
  "name": "cons_head_tail",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "[Inhabited Î±]  {l : List Î±}  (h : l â‰  []) : (ihead l)::(tail l) = l",
  "args": "[Inhabited Î±]  {l : List Î±}  (h : l â‰  [])"},
 {"type": "MyTrueâ‚ƒ",
  "tactic-prompt": "example  : MyTrueâ‚ƒ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyTrueâ‚ƒ",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt": "example  : MyFalse := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt":
  "example  : MyFalse := by fail_if_success aesop (options := { terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success aesop (options := { terminal := true })",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalse",
  "tactic-prompt":
  "example  : MyFalse := by aesop (options := { warnOnNonterminal := false }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop (options := { warnOnNonterminal := false })",
  "core-prompt": " : MyFalse",
  "args": ""},
 {"type": "MyFalseâ‚‚",
  "tactic-prompt": "example  : MyFalseâ‚‚ := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : MyFalseâ‚‚",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt": "example  : Î± := by aesop; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "aesop",
  "core-prompt": " : Î±",
  "args": ""},
 {"type": "âˆƒ l r, xs = l ++ v :: r",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  (xs : List Î±)  (v : Î±)  (h : v âˆˆ xs) : âˆƒ l r, xs = l ++ v :: r := by induction xs; sorry",
  "name": "Mem.split",
  "kind": "theorem",
  "first-tactic": "induction xs",
  "core-prompt":
  "[DecidableEq Î±]  (xs : List Î±)  (v : Î±)  (h : v âˆˆ xs) : âˆƒ l r, xs = l ++ v :: r",
  "args": "[DecidableEq Î±]  (xs : List Î±)  (v : Î±)  (h : v âˆˆ xs)"},
 {"type": "P x âˆ§ xs.all P",
  "tactic-prompt":
  "theorem (P : Î± â†’ Bool)  (x : Î±)  (xs : List Î±)  (h : (x :: xs).all P) : P x âˆ§ xs.all P := by aesop; sorry",
  "name": "all_cons",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "(P : Î± â†’ Bool)  (x : Î±)  (xs : List Î±)  (h : (x :: xs).all P) : P x âˆ§ xs.all P",
  "args": "(P : Î± â†’ Bool)  (x : Î±)  (xs : List Î±)  (h : (x :: xs).all P)"},
 {"type": "All (Â· âˆˆ []) (@List.nil Î±)",
  "tactic-prompt":
  "example  : All (Â· âˆˆ []) (@List.nil Î±) := by aesop (options := { maxRuleApplications := 50, terminal := true }); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "aesop (options := { maxRuleApplications := 50, terminal := true })",
  "core-prompt": " : All (Â· âˆˆ []) (@List.nil Î±)",
  "args": ""},
 {"type": "Any P xs â†’ Any P ys",
  "tactic-prompt":
  "theorem {xs ys : List Î±}  (perm : Perm xs ys)  (P : Î± â†’ Prop) : Any P xs â†’ Any P ys := by induction perm; sorry",
  "name": "Perm.any",
  "kind": "theorem",
  "first-tactic": "induction perm",
  "core-prompt":
  "{xs ys : List Î±}  (perm : Perm xs ys)  (P : Î± â†’ Prop) : Any P xs â†’ Any P ys",
  "args": "{xs ys : List Î±}  (perm : Perm xs ys)  (P : Î± â†’ Prop)"},
 {"type": "Any P Î”",
  "tactic-prompt":
  "theorem (P : Nat â†’ Prop)  (Î” : List Nat) : Any P Î” := by aesop (add 50% [constructors Perm]; sorry",
  "name": "error",
  "kind": "theorem",
  "first-tactic": "aesop (add 50% [constructors Perm]",
  "core-prompt": "(P : Nat â†’ Prop)  (Î” : List Nat) : Any P Î”",
  "args": "(P : Nat â†’ Prop)  (Î” : List Nat)"},
 {"type": "Any P Î”",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (Î” : List Î±) : Any P Î” := by aesop (add unsafe [50% constructors Perm]; sorry",
  "name": "fine",
  "kind": "theorem",
  "first-tactic": "aesop (add unsafe [50% constructors Perm]",
  "core-prompt": "(P : Î± â†’ Prop)  (Î” : List Î±) : Any P Î”",
  "args": "(P : Î± â†’ Prop)  (Î” : List Î±)"},
 {"type": "Proof Î“ (Î´ :: Î”)",
  "tactic-prompt":
  "theorem (Î“ Î” : List Î¦)  (prf : Proof Î“ Î”)  (Î´ : Î¦) : Proof Î“ (Î´ :: Î”) := by induction prf; sorry",
  "name": "weaken",
  "kind": "theorem",
  "first-tactic": "induction prf",
  "core-prompt":
  "(Î“ Î” : List Î¦)  (prf : Proof Î“ Î”)  (Î´ : Î¦) : Proof Î“ (Î´ :: Î”)",
  "args": "(Î“ Î” : List Î¦)  (prf : Proof Î“ Î”)  (Î´ : Î¦)"},
 {"type": "P x âˆ§ All P xs",
  "tactic-prompt":
  "theorem (P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)  (h : All P (x :: xs)) : P x âˆ§ All P xs := by set_option trace.aesop.proof true in\n  aesop; sorry",
  "name": "All.split_cons",
  "kind": "theorem",
  "first-tactic": "set_option trace.aesop.proof true in\n  aesop",
  "core-prompt":
  "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)  (h : All P (x :: xs)) : P x âˆ§ All P xs",
  "args": "(P : Î± â†’ Prop)  (x : Î±)  (xs : List Î±)  (h : All P (x :: xs))"},
 {"type": "f = Function.const Î± (f default)",
  "tactic-prompt":
  "theorem [Unique Î±]  (f : Î± â†’ Î²) : f = Function.const Î± (f default) := by ext x; sorry",
  "name": "eq_const_of_unique",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt": "[Unique Î±]  (f : Î± â†’ Î²) : f = Function.const Î± (f default)",
  "args": "[Unique Î±]  (f : Î± â†’ Î²)"},
 {"type": "âˆƒ y, y â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  [DecidableEq Î±]  (x : Î±) : âˆƒ y, y â‰  x := by rcases exists_pair_ne Î± with âŸ¨y, y', hâŸ©; sorry",
  "name": "Decidable.exists_ne",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne Î± with âŸ¨y, y', hâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  [DecidableEq Î±]  (x : Î±) : âˆƒ y, y â‰  x",
  "args":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  [DecidableEq Î±]  (x : Î±)"},
 {"type": "âˆƒ y, y â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  (x : Î±) : âˆƒ y, y â‰  x := by letI := Classical.decEq Î±; sorry",
  "name": "exists_ne",
  "kind": "theorem",
  "first-tactic": "letI := Classical.decEq Î±",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  (x : Î±) : âˆƒ y, y â‰  x",
  "args": "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  (x : Î±)"},
 {"type": "âˆƒ x y : Î±, x < y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (Î± : Type _)  [Nontrivial Î±]  [LinearOrder Î±] : âˆƒ x y : Î±, x < y := by rcases exists_pair_ne Î± with âŸ¨x, y, hxyâŸ©; sorry",
  "name": "exists_pair_lt",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne Î± with âŸ¨x, y, hxyâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (Î± : Type _)  [Nontrivial Î±]  [LinearOrder Î±] : âˆƒ x y : Î±, x < y",
  "args":
  "{Î± : Type _}  {Î² : Type _} (Î± : Type _)  [Nontrivial Î±]  [LinearOrder Î±]"},
 {"type": "Nontrivial (Subtype p) â†” âˆƒ (y : Î±) (_ : p y), y â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (p : Î± â†’ Prop)  (x : Subtype p) : Nontrivial (Subtype p) â†” âˆƒ (y : Î±) (_ : p y), y â‰  x := by simp only [_root_.nontrivial_iff_exists_ne x]; sorry",
  "name": "Subtype.nontrivial_iff_exists_ne",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.nontrivial_iff_exists_ne x]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (p : Î± â†’ Prop)  (x : Subtype p) : Nontrivial (Subtype p) â†” âˆƒ (y : Î±) (_ : p y), y â‰  x",
  "args": "{Î± : Type _}  {Î² : Type _} (p : Î± â†’ Prop)  (x : Subtype p)"},
 {"type": "Â¬Nontrivial Î± â†” Subsingleton Î±",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} : Â¬Nontrivial Î± â†” Subsingleton Î± := by simp only [nontrivial_iff]; sorry",
  "name": "not_nontrivial_iff_subsingleton",
  "kind": "theorem",
  "first-tactic": "simp only [nontrivial_iff]",
  "core-prompt": "{Î± : Type _}  {Î² : Type _} : Â¬Nontrivial Î± â†” Subsingleton Î±",
  "args": "{Î± : Type _}  {Î² : Type _}"},
 {"type": "Subsingleton Î± âˆ¨ Nontrivial Î±",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (Î± : Type _) : Subsingleton Î± âˆ¨ Nontrivial Î± := by rw [â† not_nontrivial_iff_subsingleton]; sorry",
  "name": "subsingleton_or_nontrivial",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nontrivial_iff_subsingleton]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (Î± : Type _) : Subsingleton Î± âˆ¨ Nontrivial Î±",
  "args": "{Î± : Type _}  {Î² : Type _} (Î± : Type _)"},
 {"type": "Nontrivial (Option Î±)",
  "tactic-prompt":
  "instance {Î± : Type _}  {Î² : Type _} [Nonempty Î±] : Nontrivial (Option Î±) := by inhabit Î±; sorry",
  "name": "Option.nontrivial",
  "kind": "instance",
  "first-tactic": "inhabit Î±",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} [Nonempty Î±] : Nontrivial (Option Î±)",
  "args": "{Î± : Type _}  {Î² : Type _} [Nonempty Î±]"},
 {"type": "Nontrivial Î±",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} [Nontrivial Î²]  {f : Î± â†’ Î²}      (hf : Function.Surjective f) : Nontrivial Î± := by rcases exists_pair_ne Î² with âŸ¨x, y, hâŸ©; sorry",
  "name": "Function.Surjective.nontrivial",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne Î² with âŸ¨x, y, hâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î²]  {f : Î± â†’ Î²}      (hf : Function.Surjective f) : Nontrivial Î±",
  "args":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î²]  {f : Î± â†’ Î²}      (hf : Function.Surjective f)"},
 {"type": "âˆƒ x, f x â‰  y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (y : Î²) : âˆƒ x, f x â‰  y := by rcases exists_pair_ne Î± with âŸ¨xâ‚, xâ‚‚, hxâŸ©; sorry",
  "name": "Function.Injective.exists_ne",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne Î± with âŸ¨xâ‚, xâ‚‚, hxâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (y : Î²) : âˆƒ x, f x â‰  y",
  "args":
  "{Î± : Type _}  {Î² : Type _} [Nontrivial Î±]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (y : Î²)"},
 {"type": "Nontrivial (âˆ€ i : I, f i)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {I : Type _}  {f : I â†’ Type _} (i' : I)  [inst : âˆ€ i, Nonempty (f i)]  [Nontrivial (f i')] : Nontrivial (âˆ€ i : I, f i) := by letI := Classical.decEq (âˆ€ i : I, f i); sorry",
  "name": "nontrivial_at",
  "kind": "theorem",
  "first-tactic": "letI := Classical.decEq (âˆ€ i : I, f i)",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {I : Type _}  {f : I â†’ Type _} (i' : I)  [inst : âˆ€ i, Nonempty (f i)]  [Nontrivial (f i')] : Nontrivial (âˆ€ i : I, f i)",
  "args":
  "{Î± : Type _}  {Î² : Type _} {I : Type _}  {f : I â†’ Type _} (i' : I)  [inst : âˆ€ i, Nonempty (f i)]  [Nontrivial (f i')]"},
 {"type": "e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _",
  "tactic-prompt":
  "theorem {Î± Î² : Sort _}  (e : Î± â‰ƒ Î²) : e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _ := by ext; sorry",
  "name": "equiv_toEmbedding_trans_symm_toEmbedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² : Sort _}  (e : Î± â‰ƒ Î²) : e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _",
  "args": "{Î± Î² : Sort _}  (e : Î± â‰ƒ Î²)"},
 {"type": "e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _",
  "tactic-prompt":
  "theorem {Î± Î² : Sort _}  (e : Î± â‰ƒ Î²) : e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _ := by ext; sorry",
  "name": "equiv_symm_toEmbedding_trans_toEmbedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² : Sort _}  (e : Î± â‰ƒ Î²) : e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _",
  "args": "{Î± Î² : Sort _}  (e : Î± â‰ƒ Î²)"},
 {"type":
  "Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g)",
  "tactic-prompt":
  "theorem {Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)      (ec : Î³â‚ â‰ƒ Î³â‚‚)  (f : Î±â‚ â†ª Î²â‚)  (g : Î²â‚ â†ª Î³â‚) : Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g) := by ext; sorry",
  "name": "embeddingCongr_apply_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)      (ec : Î³â‚ â‰ƒ Î³â‚‚)  (f : Î±â‚ â†ª Î²â‚)  (g : Î²â‚ â†ª Î³â‚) : Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g)",
  "args":
  "{Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)      (ec : Î³â‚ â‰ƒ Î³â‚‚)  (f : Î±â‚ â†ª Î²â‚)  (g : Î²â‚ â†ª Î³â‚)"},
 {"type": "(e : Î± â†’ Î±) = id",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  [Subsingleton Î±]  (e : Perm Î±) : (e : Î± â†’ Î±) = id := by rw [Perm.subsingleton_eq_refl e]; sorry",
  "name": "Perm.coe_subsingleton",
  "kind": "theorem",
  "first-tactic": "rw [Perm.subsingleton_eq_refl e]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  [Subsingleton Î±]  (e : Perm Î±) : (e : Î± â†’ Î±) = id",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  [Subsingleton Î±]  (e : Perm Î±)"},
 {"type": "f x = y â†” x = f.symm y",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (f : Î± â‰ƒ Î²) : f x = y â†” x = f.symm y := by conv_lhs => rw [â† apply_symm_apply f y]; sorry",
  "name": "apply_eq_iff_eq_symm_apply",
  "kind": "theorem",
  "first-tactic": "conv_lhs => rw [â† apply_symm_apply f y]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (f : Î± â‰ƒ Î²) : f x = y â†” x = f.symm y",
  "args": "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (f : Î± â‰ƒ Î²)"},
 {"type": "e.symm.symm = e",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : e.symm.symm = e := by cases e; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : e.symm.symm = e",
  "args": "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)"},
 {"type": "e.trans (Equiv.refl Î²) = e",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : e.trans (Equiv.refl Î²) = e := by cases e; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : e.trans (Equiv.refl Î²) = e",
  "args": "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)"},
 {"type": "(Equiv.refl Î±).trans e = e",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : (Equiv.refl Î±).trans e = e := by cases e; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²) : (Equiv.refl Î±).trans e = e",
  "args": "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)"},
 {"type": "e.permCongr (Equiv.refl _) = Equiv.refl _",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²') : e.permCongr (Equiv.refl _) = Equiv.refl _ := by simp [permCongr_def]; sorry",
  "name": "permCongr_refl",
  "kind": "theorem",
  "first-tactic": "simp [permCongr_def]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²') : e.permCongr (Equiv.refl _) = Equiv.refl _",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²')"},
 {"type": "(e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p')",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²') (p p' : Equiv.Perm Î±') : (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p') := by ext; sorry",
  "name": "permCongr_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²') (p p' : Equiv.Perm Î±') : (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p')",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w}  {Î±' Î²' : Type _}  (e : Î±' â‰ƒ Î²') (p p' : Equiv.Perm Î±')"},
 {"type": "arrowCongr ea ec (g âˆ˜ f) = arrowCongr eb ec g âˆ˜ arrowCongr ea eb f",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)  (ec : Î³â‚ â‰ƒ Î³â‚‚)      (f : Î±â‚ â†’ Î²â‚)  (g : Î²â‚ â†’ Î³â‚) : arrowCongr ea ec (g âˆ˜ f) = arrowCongr eb ec g âˆ˜ arrowCongr ea eb f := by ext; sorry",
  "name": "arrowCongr_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)  (ec : Î³â‚ â‰ƒ Î³â‚‚)      (f : Î±â‚ â†’ Î²â‚)  (g : Î²â‚ â†’ Î³â‚) : arrowCongr ea ec (g âˆ˜ f) = arrowCongr eb ec g âˆ˜ arrowCongr ea eb f",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î±â‚ Î²â‚ Î³â‚ Î±â‚‚ Î²â‚‚ Î³â‚‚ : Sort _}  (ea : Î±â‚ â‰ƒ Î±â‚‚)  (eb : Î²â‚ â‰ƒ Î²â‚‚)  (ec : Î³â‚ â‰ƒ Î³â‚‚)      (f : Î±â‚ â†’ Î²â‚)  (g : Î²â‚ â†’ Î³â‚)"},
 {"type": "e.conj (fâ‚ âˆ˜ fâ‚‚) = e.conj fâ‚ âˆ˜ e.conj fâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)  (fâ‚ fâ‚‚ : Î± â†’ Î±) : e.conj (fâ‚ âˆ˜ fâ‚‚) = e.conj fâ‚ âˆ˜ e.conj fâ‚‚ := by apply arrowCongr_comp; sorry",
  "name": "conj_comp",
  "kind": "theorem",
  "first-tactic": "apply arrowCongr_comp",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)  (fâ‚ fâ‚‚ : Î± â†’ Î±) : e.conj (fâ‚ âˆ˜ fâ‚‚) = e.conj fâ‚ âˆ˜ e.conj fâ‚‚",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} (e : Î± â‰ƒ Î²)  (fâ‚ fâ‚‚ : Î± â†’ Î±)"},
 {"type": "(âˆƒ! x, p x) â†” âˆƒ! y, q y",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}      (f : Î± â‰ƒ Î²)  (h : âˆ€ {x}, p x â†” q (f x)) : (âˆƒ! x, p x) â†” âˆƒ! y, q y := by constructor; sorry",
  "name": "exists_unique_congr",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}      (f : Î± â‰ƒ Î²)  (h : âˆ€ {x}, p x â†” q (f x)) : (âˆƒ! x, p x) â†” âˆƒ! y, q y",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}      (f : Î± â‰ƒ Î²)  (h : âˆ€ {x}, p x â†” q (f x))"},
 {"type": "(âˆ€ x, p x) â†” (âˆ€ y, q y)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â‰ƒ Î²)      (h : âˆ€ {x}, p x â†” q (f x)) : (âˆ€ x, p x) â†” (âˆ€ y, q y) := by constructor; sorry",
  "name": "forall_congr",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â‰ƒ Î²)      (h : âˆ€ {x}, p x â†” q (f x)) : (âˆ€ x, p x) â†” (âˆ€ y, q y)",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â‰ƒ Î²)      (h : âˆ€ {x}, p x â†” q (f x))"},
 {"type":
  "(Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h)",
  "tactic-prompt":
  "theorem (e : Î±â‚ â‰ƒ Î²â‚)  (f : Î±â‚‚ â‰ƒ Î²â‚‚)  (g : Î²â‚ â‰ƒ Î³â‚)  (h : Î²â‚‚ â‰ƒ Î³â‚‚) : (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h) := by ext i; sorry",
  "name": "sumCongr_trans",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "(e : Î±â‚ â‰ƒ Î²â‚)  (f : Î±â‚‚ â‰ƒ Î²â‚‚)  (g : Î²â‚ â‰ƒ Î³â‚)  (h : Î²â‚‚ â‰ƒ Î³â‚‚) : (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h)",
  "args": "(e : Î±â‚ â‰ƒ Î²â‚)  (f : Î±â‚‚ â‰ƒ Î²â‚‚)  (g : Î²â‚ â‰ƒ Î³â‚)  (h : Î²â‚‚ â‰ƒ Î³â‚‚)"},
 {"type": "Equiv.sumCongr (Equiv.refl Î±) (Equiv.refl Î²) = Equiv.refl (Sum Î± Î²)",
  "tactic-prompt":
  "theorem  : Equiv.sumCongr (Equiv.refl Î±) (Equiv.refl Î²) = Equiv.refl (Sum Î± Î²) := by ext i; sorry",
  "name": "sumCongr_refl",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  " : Equiv.sumCongr (Equiv.refl Î±) (Equiv.refl Î²) = Equiv.refl (Sum Î± Î²)",
  "args": ""},
 {"type":
  "ep.subtypeCongr en a =\n    if h : p a then (ep âŸ¨a, hâŸ© : Îµ) else en âŸ¨a, hâŸ©",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) (a : Îµ) : ep.subtypeCongr en a =\n    if h : p a then (ep âŸ¨a, hâŸ© : Îµ) else en âŸ¨a, hâŸ© := by by_cases h : p a; sorry",
  "name": "Perm.subtypeCongr.apply",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) (a : Îµ) : ep.subtypeCongr en a =\n    if h : p a then (ep âŸ¨a, hâŸ© : Îµ) else en âŸ¨a, hâŸ©",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) (a : Îµ)"},
 {"type": "ep.subtypeCongr en a = ep âŸ¨a, hâŸ©",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : p a) : ep.subtypeCongr en a = ep âŸ¨a, hâŸ© := by simp [Perm.subtypeCongr.apply]; sorry",
  "name": "Perm.subtypeCongr.left_apply",
  "kind": "theorem",
  "first-tactic": "simp [Perm.subtypeCongr.apply]",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : p a) : ep.subtypeCongr en a = ep âŸ¨a, hâŸ©",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : p a)"},
 {"type": "ep.subtypeCongr en a = en âŸ¨a, hâŸ©",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : Â¬p a) : ep.subtypeCongr en a = en âŸ¨a, hâŸ© := by simp [Perm.subtypeCongr.apply]; sorry",
  "name": "Perm.subtypeCongr.right_apply",
  "kind": "theorem",
  "first-tactic": "simp [Perm.subtypeCongr.apply]",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : Â¬p a) : ep.subtypeCongr en a = en âŸ¨a, hâŸ©",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) {a : Îµ}  (h : Â¬p a)"},
 {"type":
  "Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // Â¬p a }) = Equiv.refl Îµ",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // Â¬p a }) = Equiv.refl Îµ := by ext x; sorry",
  "name": "Perm.subtypeCongr.refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // Â¬p a }) = Equiv.refl Îµ",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a })"},
 {"type": "(ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm := by ext x; sorry",
  "name": "Perm.subtypeCongr.symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a })"},
 {"type":
  "(ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en')",
  "tactic-prompt":
  "theorem {p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en') := by ext x; sorry",
  "name": "Perm.subtypeCongr.trans",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a }) : (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en')",
  "args":
  "{p : Îµ â†’ Prop}  [DecidablePred p] (ep ep' : Perm { a // p a })  (en en' : Perm { a // Â¬p a })"},
 {"type": "prodCongr e (Equiv.refl Î±â‚) = prodCongrLeft fun _ => e",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚) : prodCongr e (Equiv.refl Î±â‚) = prodCongrLeft fun _ => e := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "prodCongr_refl_right",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚) : prodCongr e (Equiv.refl Î±â‚) = prodCongrLeft fun _ => e",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type": "prodCongr (Equiv.refl Î±â‚) e = prodCongrRight fun _ => e",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚) : prodCongr (Equiv.refl Î±â‚) e = prodCongrRight fun _ => e := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "prodCongr_refl_left",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚) : prodCongr (Equiv.refl Î±â‚) e = prodCongrRight fun _ => e",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) (e : Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type":
  "(prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e)",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e) := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "prodCongrLeft_trans_prodComm",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e)",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type":
  "(prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e)",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e) := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "prodCongrRight_trans_prodComm",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e)",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type":
  "(sigmaCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚)\n    = (sigmaEquivProd Î±â‚ Î²â‚).trans (prodCongrRight e)",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (sigmaCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚)\n    = (sigmaEquivProd Î±â‚ Î²â‚).trans (prodCongrRight e) := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "sigmaCongrRight_sigmaEquivProd",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (sigmaCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚)\n    = (sigmaEquivProd Î±â‚ Î²â‚).trans (prodCongrRight e)",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type":
  "(sigmaEquivProd Î±â‚ Î²â‚).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚).symm",
  "tactic-prompt":
  "theorem (e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (sigmaEquivProd Î±â‚ Î²â‚).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚).symm := by ext âŸ¨a, bâŸ© : 1; sorry",
  "name": "sigmaEquivProd_sigmaCongrRight",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ© : 1",
  "core-prompt":
  "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚) : (sigmaEquivProd Î±â‚ Î²â‚).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd Î±â‚ Î²â‚‚).symm",
  "args": "(e : Î±â‚ â†’ Î²â‚ â‰ƒ Î²â‚‚)"},
 {"type": "a' = a",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) {e : Perm Î²â‚}  {a a' : Î±â‚}  {b : Î²â‚}      (h : prodExtendRight a e (a', b) â‰  (a', b)) : a' = a := by contrapose! h; sorry",
  "name": "eq_of_prodExtendRight_ne",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) {e : Perm Î²â‚}  {a a' : Î±â‚}  {b : Î²â‚}      (h : prodExtendRight a e (a', b) â‰  (a', b)) : a' = a",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) {e : Perm Î²â‚}  {a a' : Î±â‚}  {b : Î²â‚}      (h : prodExtendRight a e (a', b) â‰  (a', b))"},
 {"type": "(prodExtendRight a e ab).fst = ab.fst",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) (ab : Î±â‚ Ã— Î²â‚) : (prodExtendRight a e ab).fst = ab.fst := by rw [prodExtendRight]; sorry",
  "name": "fst_prodExtendRight",
  "kind": "theorem",
  "first-tactic": "rw [prodExtendRight]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) (ab : Î±â‚ Ã— Î²â‚) : (prodExtendRight a e ab).fst = ab.fst",
  "args": "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) (ab : Î±â‚ Ã— Î²â‚)"},
 {"type": "e.extendDomain f (f a) = f (e a)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (a : Î±') : e.extendDomain f (f a) = f (e a) := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_image",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (a : Î±') : e.extendDomain f (f a) = f (e a)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (a : Î±')"},
 {"type": "e.extendDomain f b = f (e (f.symm âŸ¨b, hâŸ©))",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : p b) : e.extendDomain f b = f (e (f.symm âŸ¨b, hâŸ©)) := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_subtype",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : p b) : e.extendDomain f b = f (e (f.symm âŸ¨b, hâŸ©))",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : p b)"},
 {"type": "e.extendDomain f b = b",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : Â¬p b) : e.extendDomain f b = b := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_apply_not_subtype",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : Â¬p b) : e.extendDomain f b = b",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) {b : Î²'}  (h : Â¬p b)"},
 {"type": "Perm.extendDomain (Equiv.refl _) f = Equiv.refl _",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _ := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_refl",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p)"},
 {"type":
  "(e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (e e' : Perm Î±') : (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f := by simp [Perm.extendDomain]; sorry",
  "name": "Perm.extendDomain_trans",
  "kind": "theorem",
  "first-tactic": "simp [Perm.extendDomain]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (e e' : Perm Î±') : (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {Î±' Î²' : Type _}  (e : Perm Î±')  {p : Î²' â†’ Prop}  [DecidablePred p]  (f : Î±' â‰ƒ Subtype p) (e e' : Perm Î±')"},
 {"type": "swapCore a a r = r",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a : Î±) : swapCore a a r = r := by unfold swapCore; sorry",
  "name": "swapCore_self",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a : Î±) : swapCore a a r = r",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a : Î±)"},
 {"type": "swapCore a b (swapCore a b r) = r",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±) : swapCore a b (swapCore a b r) = r := by unfold swapCore; sorry",
  "name": "swapCore_swapCore",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±) : swapCore a b (swapCore a b r) = r",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±)"},
 {"type": "swapCore a b r = swapCore b a r",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±) : swapCore a b r = swapCore b a r := by unfold swapCore; sorry",
  "name": "swapCore_comm",
  "kind": "theorem",
  "first-tactic": "unfold swapCore",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±) : swapCore a b r = swapCore b a r",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (r a b : Î±)"},
 {"type": "swap a b b = a",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (a b : Î±) : swap a b b = a := by by_cases h:b = a; sorry",
  "name": "swap_apply_right",
  "kind": "theorem",
  "first-tactic": "by_cases h:b = a",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (a b : Î±) : swap a b b = a",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (a b : Î±)"},
 {"type": "x â‰  a â†’ x â‰  b â†’ swap a b x = x",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±} : x â‰  a â†’ x â‰  b â†’ swap a b x = x := by simp (config := { contextual := true }) [swap_apply_def]; sorry",
  "name": "swap_apply_of_ne_of_ne",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [swap_apply_def]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±} : x â‰  a â†’ x â‰  b â†’ swap a b x = x",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±}"},
 {"type": "swap x y = Equiv.refl _ â†” x = y",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y : Î±} : swap x y = Equiv.refl _ â†” x = y := by refine' âŸ¨fun h => (Equiv.refl _).injective _, fun h => h â–¸ swap_self _âŸ©; sorry",
  "name": "swap_eq_refl_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun h => (Equiv.refl _).injective _, fun h => h â–¸ swap_self _âŸ©",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y : Î±} : swap x y = Equiv.refl _ â†” x = y",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y : Î±}"},
 {"type":
  "Ï€.trans (swap a b) x = if Ï€ x = a then b else if Ï€ x = b then a else Ï€ x",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±}  (Ï€ : Perm Î±) : Ï€.trans (swap a b) x = if Ï€ x = a then b else if Ï€ x = b then a else Ï€ x := by cases Ï€; sorry",
  "name": "swap_comp_apply",
  "kind": "theorem",
  "first-tactic": "cases Ï€",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±}  (Ï€ : Perm Î±) : Ï€.trans (swap a b) x = if Ï€ x = a then b else if Ï€ x = b then a else Ï€ x",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±}  (Ï€ : Perm Î±)"},
 {"type": "f âˆ˜ Equiv.swap i j = update (update f j (f i)) i (f j)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j : Î±)  (f : Î± â†’ Î²) : f âˆ˜ Equiv.swap i j = update (update f j (f i)) i (f j) := by rw [swap_eq_update]; sorry",
  "name": "comp_swap_eq_update",
  "kind": "theorem",
  "first-tactic": "rw [swap_eq_update]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j : Î±)  (f : Î± â†’ Î²) : f âˆ˜ Equiv.swap i j = update (update f j (f i)) i (f j)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j : Î±)  (f : Î± â†’ Î²)"},
 {"type": "swap i j (swap i j a) = a",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j a : Î±) : swap i j (swap i j a) = a := by rw [â† Equiv.trans_apply]; sorry",
  "name": "swap_apply_self",
  "kind": "theorem",
  "first-tactic": "rw [â† Equiv.trans_apply]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j a : Î±) : swap i j (swap i j a) = a",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (i j a : Î±)"},
 {"type": "v (swap i j k) = v k",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {v : Î± â†’ Î²}  {i j : Î±}  (hv : v i = v j)  (k : Î±) : v (swap i j k) = v k := by by_cases hi : k = i; sorry",
  "name": "apply_swap_eq_self",
  "kind": "theorem",
  "first-tactic": "by_cases hi : k = i",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {v : Î± â†’ Î²}  {i j : Î±}  (hv : v i = v j)  (k : Î±) : v (swap i j k) = v k",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {v : Î± â†’ Î²}  {i j : Î±}  (hv : v i = v j)  (k : Î±)"},
 {"type": "swap x y z = w â†” z = swap x y w",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y z w : Î±} : swap x y z = w â†” z = swap x y w := by rw [apply_eq_iff_eq_symm_apply]; sorry",
  "name": "swap_apply_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [apply_eq_iff_eq_symm_apply]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y z w : Î±} : swap x y z = w â†” z = swap x y w",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {x y z w : Î±}"},
 {"type": "swap a b x â‰  x â†” a â‰  b âˆ§ (x = a âˆ¨ x = b)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±} : swap a b x â‰  x â†” a â‰  b âˆ§ (x = a âˆ¨ x = b) := by by_cases hab : a = b; sorry",
  "name": "swap_apply_ne_self_iff",
  "kind": "theorem",
  "first-tactic": "by_cases hab : a = b",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±} : swap a b x â‰  x â†” a â‰  b âˆ§ (x = a âˆ¨ x = b)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {a b x : Î±}"},
 {"type":
  "Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl Î²) = Equiv.swap (Sum.inl i) (Sum.inl j)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î±) : Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl Î²) = Equiv.swap (Sum.inl i) (Sum.inl j) := by ext x; sorry",
  "name": "sumCongr_swap_refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î±) : Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl Î²) = Equiv.swap (Sum.inl i) (Sum.inl j)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î±)"},
 {"type":
  "Equiv.Perm.sumCongr (Equiv.refl Î±) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î²) : Equiv.Perm.sumCongr (Equiv.refl Î±) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j) := by ext x; sorry",
  "name": "sumCongr_refl_swap",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î²) : Equiv.Perm.sumCongr (Equiv.refl Î±) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] {Î± Î² : Sort _}  [DecidableEq Î±]  [DecidableEq Î²]  (i j : Î²)"},
 {"type": "setValue f a b a = b",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (f : Î± â‰ƒ Î²)  (a : Î±)  (b : Î²) : setValue f a b a = b := by simp [setValue]; sorry",
  "name": "setValue_eq",
  "kind": "theorem",
  "first-tactic": "simp [setValue]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (f : Î± â‰ƒ Î²)  (a : Î±)  (b : Î²) : setValue f a b a = b",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  [DecidableEq Î±] (f : Î± â‰ƒ Î²)  (a : Î±)  (b : Î²)"},
 {"type": "f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (x y z : Î±) : f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z) := by conv_rhs => rw [Equiv.swap_apply_def]; sorry",
  "name": "Function.Injective.map_swap",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [Equiv.swap_apply_def]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (x y z : Î±) : f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}      (hf : Function.Injective f)  (x y z : Î±)"},
 {"type": "hâ‚.piCongr hâ‚‚ f (hâ‚ a) = hâ‚‚ a (f a)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ a : Î±, W a â‰ƒ Z (hâ‚ a)) (f : âˆ€ a, W a)  (a : Î±) : hâ‚.piCongr hâ‚‚ f (hâ‚ a) = hâ‚‚ a (f a) := by change Eq.ndrec _ _ = _; sorry",
  "name": "piCongr_apply_apply",
  "kind": "theorem",
  "first-tactic": "change Eq.ndrec _ _ = _",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ a : Î±, W a â‰ƒ Z (hâ‚ a)) (f : âˆ€ a, W a)  (a : Î±) : hâ‚.piCongr hâ‚‚ f (hâ‚ a) = hâ‚‚ a (f a)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ a : Î±, W a â‰ƒ Z (hâ‚ a)) (f : âˆ€ a, W a)  (a : Î±)"},
 {"type": "(hâ‚.piCongr' hâ‚‚).symm f (hâ‚.symm b) = (hâ‚‚ b).symm (f b)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ b : Î², W (hâ‚.symm b) â‰ƒ Z b) (f : âˆ€ b, Z b)  (b : Î²) : (hâ‚.piCongr' hâ‚‚).symm f (hâ‚.symm b) = (hâ‚‚ b).symm (f b) := by change Eq.ndrec _ _ = _; sorry",
  "name": "piCongr'_symm_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "change Eq.ndrec _ _ = _",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ b : Î², W (hâ‚.symm b) â‰ƒ Z b) (f : âˆ€ b, Z b)  (b : Î²) : (hâ‚.piCongr' hâ‚‚).symm f (hâ‚.symm b) = (hâ‚‚ b).symm (f b)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚)  {W : Î± â†’ Sort w}  {Z : Î² â†’ Sort z}  (hâ‚ : Î± â‰ƒ Î²)  (hâ‚‚ : âˆ€ b : Î², W (hâ‚.symm b) â‰ƒ Z b) (f : âˆ€ b, Z b)  (b : Î²)"},
 {"type": "Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}  (hf : Function.Injective f)  (x y z : Î±) : Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z) := by by_cases hx:z = x; sorry",
  "name": "Function.Injective.swap_apply",
  "kind": "theorem",
  "first-tactic": "by_cases hx:z = x",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}  (hf : Function.Injective f)  (x y z : Î±) : Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  {f : Î± â†’ Î²}  (hf : Function.Injective f)  (x y z : Î±)"},
 {"type": "update f a v âˆ˜ g = update (f âˆ˜ g) (g.symm a) v",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±']  [DecidableEq Î±]  (f : Î± â†’ Î²)      (g : Î±' â‰ƒ Î±)  (a : Î±)  (v : Î²) : update f a v âˆ˜ g = update (f âˆ˜ g) (g.symm a) v := by rw [â† update_comp_eq_of_injective _ g.injective]; sorry",
  "name": "update_comp_equiv",
  "kind": "theorem",
  "first-tactic": "rw [â† update_comp_eq_of_injective _ g.injective]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±']  [DecidableEq Î±]  (f : Î± â†’ Î²)      (g : Î±' â‰ƒ Î±)  (a : Î±)  (v : Î²) : update f a v âˆ˜ g = update (f âˆ˜ g) (g.symm a) v",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±']  [DecidableEq Î±]  (f : Î± â†’ Î²)      (g : Î±' â‰ƒ Î±)  (a : Î±)  (v : Î²)"},
 {"type":
  "e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ a, P a)  (b : Î²)  (x : P (e.symm b)) : e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x := by ext b'; sorry",
  "name": "piCongrLeft'_update",
  "kind": "theorem",
  "first-tactic": "ext b'",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ a, P a)  (b : Î²)  (x : P (e.symm b)) : e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ a, P a)  (b : Î²)  (x : P (e.symm b))"},
 {"type":
  "(e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x",
  "tactic-prompt":
  "theorem [DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ b, P (e.symm b))  (b : Î²)  (x : P (e.symm b)) : (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x := by simp [(e.piCongrLeft' P).symm_apply_eq]; sorry",
  "name": "piCongrLeft'_symm_update",
  "kind": "theorem",
  "first-tactic": "simp [(e.piCongrLeft' P).symm_apply_eq]",
  "core-prompt":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ b, P (e.symm b))  (b : Î²)  (x : P (e.symm b)) : (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x",
  "args":
  "[DecidableEq Î±â‚]  (a : Î±â‚)  (e : Perm Î²â‚) [DecidableEq Î±]  [DecidableEq Î²]  (P : Î± â†’ Sort _)  (e : Î± â‰ƒ Î²)      (f : âˆ€ b, P (e.symm b))  (b : Î²)  (x : P (e.symm b))"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inl âŸ¨x, hxâŸ©",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆˆ s) : (Equiv.Set.sumCompl s).symm x = Sum.inl âŸ¨x, hxâŸ© := by have : ((âŸ¨x, Or.inl hxâŸ© : (s âˆª sá¶œ : Set Î±)) : Î±) âˆˆ s := hx; sorry",
  "name": "sumCompl_symm_apply_of_mem",
  "kind": "theorem",
  "first-tactic": "have : ((âŸ¨x, Or.inl hxâŸ© : (s âˆª sá¶œ : Set Î±)) : Î±) âˆˆ s := hx",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆˆ s) : (Equiv.Set.sumCompl s).symm x = Sum.inl âŸ¨x, hxâŸ©",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆˆ s)"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inr âŸ¨x, hxâŸ©",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆ‰ s) : (Equiv.Set.sumCompl s).symm x = Sum.inr âŸ¨x, hxâŸ© := by have : ((âŸ¨x, Or.inr hxâŸ© : (s âˆª sá¶œ : Set Î±)) : Î±) âˆˆ sá¶œ := hx; sorry",
  "name": "sumCompl_symm_apply_of_not_mem",
  "kind": "theorem",
  "first-tactic": "have : ((âŸ¨x, Or.inr hxâŸ© : (s âˆª sá¶œ : Set Î±)) : Î±) âˆˆ sá¶œ := hx",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆ‰ s) : (Equiv.Set.sumCompl s).symm x = Sum.inr âŸ¨x, hxâŸ©",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type u}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : Î±}      (hx : x âˆ‰ s)"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inl x",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : s} : (Equiv.Set.sumCompl s).symm x = Sum.inl x := by cases' x with x hx; sorry",
  "name": "sumCompl_symm_apply",
  "kind": "theorem",
  "first-tactic": "cases' x with x hx",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : s} : (Equiv.Set.sumCompl s).symm x = Sum.inl x",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {x : s}"},
 {"type": "(Equiv.Set.sumCompl s).symm x = Sum.inr x",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]      {x : (sá¶œ : Set Î±)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x := by cases' x with x hx; sorry",
  "name": "sumCompl_symm_apply_compl",
  "kind": "theorem",
  "first-tactic": "cases' x with x hx",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]      {x : (sá¶œ : Set Î±)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]      {x : (sá¶œ : Set Î±)}"},
 {"type":
  "ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty Î±)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton Î± := subsingleton_of_not_nonempty h\n          simp)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Nonempty Î± â†’ Î² â†’ Î±)      (hf : âˆ€ h : Nonempty Î±, LeftInverse (f_inv h) f) : ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty Î±)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton Î± := subsingleton_of_not_nonempty h\n          simp) := by ext; sorry",
  "name": "ofLeftInverse_eq_ofInjective",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Nonempty Î± â†’ Î² â†’ Î±)      (hf : âˆ€ h : Nonempty Î±, LeftInverse (f_inv h) f) : ofLeftInverse f f_inv hf =\n      ofInjective f\n        ((em (Nonempty Î±)).elim (fun h => (hf h).injective) fun h _ _ _ => by\n          haveI : Subsingleton Î± := subsingleton_of_not_nonempty h\n          simp)",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Nonempty Î± â†’ Î² â†’ Î±)      (hf : âˆ€ h : Nonempty Î±, LeftInverse (f_inv h) f)"},
 {"type": "ofLeftInverse' f f_inv hf = ofInjective f hf.injective",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Î² â†’ Î±)      (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective := by ext; sorry",
  "name": "ofLeftInverse'_eq_ofInjective",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Î² â†’ Î±)      (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± Î² : Type _}  (f : Î± â†’ Î²)  (f_inv : Î² â†’ Î±)      (hf : LeftInverse f_inv f)"},
 {"type":
  "(piEquivPiSubtypeProd p Î²).symm â»Â¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) Ã—Ë¢ pi univ fun i : { i // Â¬p i } => s i",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Î± â†’ Type _}  (p : Î± â†’ Prop)      [DecidablePred p]  (s : âˆ€ i, Set (Î² i)) : (piEquivPiSubtypeProd p Î²).symm â»Â¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) Ã—Ë¢ pi univ fun i : { i // Â¬p i } => s i := by ext âŸ¨f, gâŸ©; sorry",
  "name": "preimage_piEquivPiSubtypeProd_symm_pi",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨f, gâŸ©",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Î± â†’ Type _}  (p : Î± â†’ Prop)      [DecidablePred p]  (s : âˆ€ i, Set (Î² i)) : (piEquivPiSubtypeProd p Î²).symm â»Â¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) Ã—Ë¢ pi univ fun i : { i // Â¬p i } => s i",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Î± â†’ Type _}  (p : Î± â†’ Prop)      [DecidablePred p]  (s : âˆ€ i, Set (Î² i))"},
 {"type":
  "(fun i : Î± => if h : i âˆˆ s then (Function.update v j x) (e.symm âŸ¨i, hâŸ©) else w i) =\n      Function.update (fun i : Î± => if h : i âˆˆ s then v (e.symm âŸ¨i, hâŸ©) else w i) (e j) x",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Sort _}  {Î³ : Sort _}  {s : Set Î±}  (e : Î² â‰ƒ s)      (v : Î² â†’ Î³)  (w : Î± â†’ Î³)  (j : Î²)  (x : Î³)  [DecidableEq Î²]  [DecidableEq Î±]      [âˆ€ j, Decidable (j âˆˆ s)] : (fun i : Î± => if h : i âˆˆ s then (Function.update v j x) (e.symm âŸ¨i, hâŸ©) else w i) =\n      Function.update (fun i : Î± => if h : i âˆˆ s then v (e.symm âŸ¨i, hâŸ©) else w i) (e j) x := by ext i; sorry",
  "name": "dite_comp_equiv_update",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Sort _}  {Î³ : Sort _}  {s : Set Î±}  (e : Î² â‰ƒ s)      (v : Î² â†’ Î³)  (w : Î± â†’ Î³)  (j : Î²)  (x : Î³)  [DecidableEq Î²]  [DecidableEq Î±]      [âˆ€ j, Decidable (j âˆˆ s)] : (fun i : Î± => if h : i âˆˆ s then (Function.update v j x) (e.symm âŸ¨i, hâŸ©) else w i) =\n      Function.update (fun i : Î± => if h : i âˆˆ s then v (e.symm âŸ¨i, hâŸ©) else w i) (e j) x",
  "args":
  "{Î± : Sort u}  {Î² : Sort v}  {Î³ : Sort w} {Î± : Type _}  {Î² : Sort _}  {Î³ : Sort _}  {s : Set Î±}  (e : Î² â‰ƒ s)      (v : Î² â†’ Î³)  (w : Î± â†’ Î³)  (j : Î²)  (x : Î³)  [DecidableEq Î²]  [DecidableEq Î±]      [âˆ€ j, Decidable (j âˆˆ s)]"},
 {"type": "some (removeNone_aux e x) = e (some x)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : âˆƒ x', e (some x) = some x') : some (removeNone_aux e x) = e (some x) := by simp [removeNone_aux]; sorry",
  "name": "removeNone_aux_some",
  "kind": "theorem",
  "first-tactic": "simp [removeNone_aux]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : âˆƒ x', e (some x) = some x') : some (removeNone_aux e x) = e (some x)",
  "args":
  "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : âˆƒ x', e (some x) = some x')"},
 {"type": "some (removeNone_aux e x) = e none",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : e (some x) = none) : some (removeNone_aux e x) = e none := by simp [removeNone_aux]; sorry",
  "name": "removeNone_aux_none",
  "kind": "theorem",
  "first-tactic": "simp [removeNone_aux]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : e (some x) = none) : some (removeNone_aux e x) = e none",
  "args":
  "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}  (h : e (some x) = none)"},
 {"type": "some (removeNone e x) = e none â†” e.symm none = some x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±} : some (removeNone e x) = e none â†” e.symm none = some x := by cases' h : e (some x) with a; sorry",
  "name": "some_removeNone_iff",
  "kind": "theorem",
  "first-tactic": "cases' h : e (some x) with a",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±} : some (removeNone e x) = e none â†” e.symm none = some x",
  "args": "{Î± Î² Î³ : Type _}  (e : Option Î± â‰ƒ Option Î²) {x : Î±}"},
 {"type": "â†‘((optionSubtype x e).symm b) = (e : Option Î± â‰ƒ Î²).symm b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)      (e : { e : Option Î± â‰ƒ Î² // e none = x })      (b : { y : Î² // y â‰  x }) : â†‘((optionSubtype x e).symm b) = (e : Option Î± â‰ƒ Î²).symm b := by dsimp only [optionSubtype]; sorry",
  "name": "optionSubtype_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "dsimp only [optionSubtype]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)      (e : { e : Option Î± â‰ƒ Î² // e none = x })      (b : { y : Î² // y â‰  x }) : â†‘((optionSubtype x e).symm b) = (e : Option Î± â‰ƒ Î²).symm b",
  "args":
  "{Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)      (e : { e : Option Î± â‰ƒ Î² // e none = x })      (b : { y : Î² // y â‰  x })"},
 {"type": "((optionSubtype x).symm e : Option Î± â‰ƒ Î²).symm b = e.symm b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)  (e : Î± â‰ƒ { y : Î² // y â‰  x })      (b : { y : Î² // y â‰  x }) : ((optionSubtype x).symm e : Option Î± â‰ƒ Î²).symm b = e.symm b := by simp only [optionSubtype]; sorry",
  "name": "optionSubtype_symm_apply_symm_apply",
  "kind": "theorem",
  "first-tactic": "simp only [optionSubtype]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)  (e : Î± â‰ƒ { y : Î² // y â‰  x })      (b : { y : Î² // y â‰  x }) : ((optionSubtype x).symm e : Option Î± â‰ƒ Î²).symm b = e.symm b",
  "args":
  "{Î± Î² Î³ : Type _} [DecidableEq Î²]  (x : Î²)  (e : Î± â‰ƒ { y : Î² // y â‰  x })      (b : { y : Î² // y â‰  x })"},
 {"type": "IsEmpty (Î± â†’ Î²)",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²] : IsEmpty (Î± â†’ Î²) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²] : IsEmpty (Î± â†’ Î²)",
  "args": "{Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²]"},
 {"type": "IsEmpty p â†” Â¬p",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop} : IsEmpty p â†” Â¬p := by simp only [â† not_nonempty_iff]; sorry",
  "name": "isEmpty_Prop",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop} : IsEmpty p â†” Â¬p",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop}"},
 {"type": "IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _} : IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a) := by simp only [â† not_nonempty_iff]; sorry",
  "name": "isEmpty_pi",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _} : IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a)",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _}"},
 {"type": "IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop) : IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x := by simp only [â† not_nonempty_iff]; sorry",
  "name": "isEmpty_subtype",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop) : IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop)"},
 {"type": "IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _} : IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î² := by simp only [â† not_nonempty_iff]; sorry",
  "name": "isEmpty_prod",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _} : IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _}"},
 {"type": "IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] : IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î² := by simp only [â† not_nonempty_iff]; sorry",
  "name": "isEmpty_pprod",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] : IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±]"},
 {"type": "(f^[m + n]) x = (f^[m]) ((f^[n]) x)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) (m n : â„•)  (x : Î±) : (f^[m + n]) x = (f^[m]) ((f^[n]) x) := by rw [iterate_add f m n]; sorry",
  "name": "iterate_add_apply",
  "kind": "theorem",
  "first-tactic": "rw [iterate_add f m n]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) (m n : â„•)  (x : Î±) : (f^[m + n]) x = (f^[m]) ((f^[n]) x)",
  "args": "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) (m n : â„•)  (x : Î±)"},
 {"type": "Semiconj (f^[n]) (g k) (g <| n + k)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : â„• â†’ Î± â†’ Î±}  (H : âˆ€ n, Semiconj f (g n) (g <| n + 1))  (n k : â„•) : Semiconj (f^[n]) (g k) (g <| n + k) := by induction' n with n ihn generalizing k; sorry",
  "name": "iterate_left",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn generalizing k",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : â„• â†’ Î± â†’ Î±}  (H : âˆ€ n, Semiconj f (g n) (g <| n + 1))  (n k : â„•) : Semiconj (f^[n]) (g k) (g <| n + k)",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : â„• â†’ Î± â†’ Î±}  (H : âˆ€ n, Semiconj f (g n) (g <| n + 1))  (n k : â„•)"},
 {"type": "(f âˆ˜ g)^[n] = f^[n] âˆ˜ g^[n]",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (h : Commute f g)  (n : â„•) : (f âˆ˜ g)^[n] = f^[n] âˆ˜ g^[n] := by induction' n with n ihn; sorry",
  "name": "comp_iterate",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (h : Commute f g)  (n : â„•) : (f âˆ˜ g)^[n] = f^[n] âˆ˜ g^[n]",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (h : Commute f g)  (n : â„•)"},
 {"type": "f^[n.succ] = f âˆ˜ f^[n]",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•) : f^[n.succ] = f âˆ˜ f^[n] := by rw [iterate_succ]; sorry",
  "name": "iterate_succ'",
  "kind": "theorem",
  "first-tactic": "rw [iterate_succ]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•) : f^[n.succ] = f âˆ˜ f^[n]",
  "args": "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•)"},
 {"type": "(f^[n.succ]) x = f ((f^[n]) x)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•)  (x : Î±) : (f^[n.succ]) x = f ((f^[n]) x) := by rw [iterate_succ']; sorry",
  "name": "iterate_succ_apply'",
  "kind": "theorem",
  "first-tactic": "rw [iterate_succ']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•)  (x : Î±) : (f^[n.succ]) x = f ((f^[n]) x)",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (n : â„•)  (x : Î±)"},
 {"type": "f^[n.pred] âˆ˜ f = f^[n]",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n) : f^[n.pred] âˆ˜ f = f^[n] := by rw [â† iterate_succ]; sorry",
  "name": "iterate_pred_comp_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [â† iterate_succ]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n) : f^[n.pred] âˆ˜ f = f^[n]",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n)"},
 {"type": "f âˆ˜ f^[n.pred] = f^[n]",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n) : f âˆ˜ f^[n.pred] = f^[n] := by rw [â† iterate_succ']; sorry",
  "name": "comp_iterate_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [â† iterate_succ']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n) : f âˆ˜ f^[n.pred] = f^[n]",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} {n : â„•}  (hn : 0 < n)"},
 {"type": "l.foldl (fun b _ â†¦ f b) a = (f^[l.length]) a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (f : Î± â†’ Î±)  (a : Î±)  (l : List Î²) : l.foldl (fun b _ â†¦ f b) a = (f^[l.length]) a := by induction' l with b l H generalizing a; sorry",
  "name": "foldl_const",
  "kind": "theorem",
  "first-tactic": "induction' l with b l H generalizing a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (f : Î± â†’ Î±)  (a : Î±)  (l : List Î²) : l.foldl (fun b _ â†¦ f b) a = (f^[l.length]) a",
  "args":
  "{Î± : Type u}  {Î² : Type v} (f : Î± â†’ Î±) {g : Î± â†’ Î±} (f : Î± â†’ Î±)  (a : Î±)  (l : List Î²)"},
 {"type": "HEq f f'",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a')) : HEq f f' := by subst hÎ±; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hÎ±",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a'))"},
 {"type": "Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©)",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©) : Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©) := by intros xâ‚ xâ‚‚ h; sorry",
  "name": "Injective.dite",
  "kind": "lemma",
  "first-tactic": "intros xâ‚ xâ‚‚ h",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©) : Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©)",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©)"},
 {"type": "Surjective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (h : âˆ€ gâ‚ gâ‚‚ : Î² â†’ Prop, gâ‚ âˆ˜ f = gâ‚‚ âˆ˜ f â†’ gâ‚ = gâ‚‚) : Surjective f := by specialize h (fun y â†¦ âˆƒ x, f x = y) (fun _ â†¦ True) (funext fun x â†¦ eq_true âŸ¨_, rflâŸ©); sorry",
  "name": "surjective_of_right_cancellable_Prop",
  "kind": "theorem",
  "first-tactic":
  "specialize h (fun y â†¦ âˆƒ x, f x = y) (fun _ â†¦ True) (funext fun x â†¦ eq_true âŸ¨_, rflâŸ©)",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (h : âˆ€ gâ‚ gâ‚‚ : Î² â†’ Prop, gâ‚ âˆ˜ f = gâ‚‚ âˆ˜ f â†’ gâ‚ = gâ‚‚) : Surjective f",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (h : âˆ€ gâ‚ gâ‚‚ : Î² â†’ Prop, gâ‚ âˆ˜ f = gâ‚‚ âˆ˜ f â†’ gâ‚ = gâ‚‚)"},
 {"type": "Â¬Surjective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± : Type u}  (f : Î± â†’ Type max u v) : Â¬Surjective f := by intro hf; sorry",
  "name": "not_surjective_Type",
  "kind": "theorem",
  "first-tactic": "intro hf",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± : Type u}  (f : Î± â†’ Type max u v) : Â¬Surjective f",
  "args": "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± : Type u}  (f : Î± â†’ Type max u v)"},
 {"type": "f (invFun f b) = b",
  "tactic-prompt":
  "theorem {Î± Î² : Sort _}  [Nonempty Î±]  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a, f a = b) : f (invFun f b) = b := by simp only [invFun]; sorry",
  "name": "invFun_eq",
  "kind": "theorem",
  "first-tactic": "simp only [invFun]",
  "core-prompt":
  "{Î± Î² : Sort _}  [Nonempty Î±]  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a, f a = b) : f (invFun f b) = b",
  "args":
  "{Î± Î² : Sort _}  [Nonempty Î±]  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') â†’ Eq.rec (motive := Î» _ _ => Î²) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "theorem",
  "first-tactic":
  "have h2 : (h : a = a') â†’ Eq.rec (motive := Î» _ _ => Î²) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±) : update f a' b a = if a = a' then b else f a",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±)"},
 {"type": "(âˆ€ x, p x (update f a b x)) â†” p a b âˆ§ âˆ€ x, x â‰  a â†’ p x (f x)",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€a, Î² a â†’ Prop) : (âˆ€ x, p x (update f a b x)) â†” p a b âˆ§ âˆ€ x, x â‰  a â†’ p x (f x) := by rw [â† and_forall_ne a]; sorry",
  "name": "forall_update_iff",
  "kind": "lemma",
  "first-tactic": "rw [â† and_forall_ne a]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€a, Î² a â†’ Prop) : (âˆ€ x, p x (update f a b x)) â†” p a b âˆ§ âˆ€ x, x â‰  a â†’ p x (f x)",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€a, Î² a â†’ Prop)"},
 {"type":
  "(âˆƒ x, p x (update f a b x)) â†” p a b âˆ¨ âˆƒ (x : _)(_ : x â‰  a), p x (f x)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€ a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€ a, Î² a â†’ Prop) : (âˆƒ x, p x (update f a b x)) â†” p a b âˆ¨ âˆƒ (x : _)(_ : x â‰  a), p x (f x) := by rw [â† not_forall_not]; sorry",
  "name": "exists_update_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_forall_not]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€ a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€ a, Î² a â†’ Prop) : (âˆƒ x, p x (update f a b x)) â†” p a b âˆ¨ âˆƒ (x : _)(_ : x â‰  a), p x (f x)",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} (f : âˆ€ a, Î² a)  {a : Î±}  {b : Î² a}  (p : âˆ€ a, Î² a â†’ Prop)"},
 {"type": "update f a b = f â†” b = f a",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} : update f a b = f â†” b = f a := by simp [update_eq_iff]; sorry",
  "name": "update_eq_self_iff",
  "kind": "lemma",
  "first-tactic": "simp [update_eq_iff]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} : update f a b = f â†” b = f a",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a}"},
 {"type": "f = update f a b â†” f a = b",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} : f = update f a b â†” f a = b := by simp [eq_update_iff]; sorry",
  "name": "eq_update_self_iff",
  "kind": "lemma",
  "first-tactic": "simp [eq_update_iff]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} : f = update f a b â†” f a = b",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a}"},
 {"type": "f j (update g i v j) = update (fun k â†¦ f k (g k)) i (f i v) j",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i)      (g : âˆ€ i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹) : f j (update g i v j) = update (fun k â†¦ f k (g k)) i (f i v) j := by by_cases h:j = i; sorry",
  "name": "apply_update",
  "kind": "theorem",
  "first-tactic": "by_cases h:j = i",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i)      (g : âˆ€ i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹) : f j (update g i v j) = update (fun k â†¦ f k (g k)) i (f i v) j",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i)      (g : âˆ€ i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹)"},
 {"type":
  "f j (update g i v j) (update h i w j) = update (fun k â†¦ f k (g k) (h k)) i (f i v w) j",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² Î³ : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i â†’ Î³ i)      (g : âˆ€ i, Î± i)  (h : âˆ€ i, Î² i)  (i : Î¹)  (v : Î± i)  (w : Î² i)  (j : Î¹) : f j (update g i v j) (update h i w j) = update (fun k â†¦ f k (g k) (h k)) i (f i v w) j := by by_cases h:j = i; sorry",
  "name": "apply_updateâ‚‚",
  "kind": "theorem",
  "first-tactic": "by_cases h:j = i",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² Î³ : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i â†’ Î³ i)      (g : âˆ€ i, Î± i)  (h : âˆ€ i, Î² i)  (i : Î¹)  (v : Î± i)  (w : Î² i)  (j : Î¹) : f j (update g i v j) (update h i w j) = update (fun k â†¦ f k (g k) (h k)) i (f i v w) j",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±']    {f g : (a : Î±) â†’ Î² a}  {a : Î±}  {b : Î² a} {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² Î³ : Î¹ â†’ Sort _}  (f : âˆ€ i, Î± i â†’ Î² i â†’ Î³ i)      (g : âˆ€ i, Î± i)  (h : âˆ€ i, Î² i)  (i : Î¹)  (v : Î± i)  (w : Î² i)  (j : Î¹)"},
 {"type":
  "extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [Decidable (âˆƒ a, f a = b)] : extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b := by unfold extend; sorry",
  "name": "extend_def",
  "kind": "theorem",
  "first-tactic": "unfold extend",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [Decidable (âˆƒ a, f a = b)] : extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [Decidable (âˆƒ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {g : Î± â†’ Î³}  (hf : g.FactorsThrough f)  (e' : Î² â†’ Î³)  (a : Î±) : extend f g e' (f a) = g a := by simp only [extend_def]; sorry",
  "name": "FactorsThrough.extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {g : Î± â†’ Î³}  (hf : g.FactorsThrough f)  (e' : Î² â†’ Î³)  (a : Î±) : extend f g e' (f a) = g a",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {g : Î± â†’ Î³}  (hf : g.FactorsThrough f)  (e' : Î² â†’ Î³)  (a : Î±)"},
 {"type": "extend f g e' b = e' b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b) : extend f g e' b = e' b := by simp [Function.extend_def]; sorry",
  "name": "extend_apply'",
  "kind": "theorem",
  "first-tactic": "simp [Function.extend_def]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b) : extend f g e' b = e' b",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b)"},
 {"type": "Injective fun g â†¦ extend f g e'",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (hf : Injective f)  (e' : Î² â†’ Î³) : Injective fun g â†¦ extend f g e' := by intro gâ‚ gâ‚‚ hg; sorry",
  "name": "extend_injective",
  "kind": "theorem",
  "first-tactic": "intro gâ‚ gâ‚‚ hg",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (hf : Injective f)  (e' : Î² â†’ Î³) : Injective fun g â†¦ extend f g e'",
  "args": "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (hf : Injective f)  (e' : Î² â†’ Î³)"},
 {"type": "f (ite P x (f x)) = ite (Â¬P) x (f x)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±) : f (ite P x (f x)) = ite (Â¬P) x (f x) := by rw [apply_ite f]; sorry",
  "name": "ite_not",
  "kind": "theorem",
  "first-tactic": "rw [apply_ite f]",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±) : f (ite P x (f x)) = ite (Â¬P) x (f x)",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±)"},
 {"type": "Function.Bijective (Eq.mp h)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (Eq.mp h) := by cases h; sorry",
  "name": "eq_mp_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (Eq.mp h)",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²)"},
 {"type": "Function.Bijective (Eq.mpr h)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (Eq.mpr h) := by cases h; sorry",
  "name": "eq_mpr_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (Eq.mpr h)",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²)"},
 {"type": "Function.Bijective (cast h)",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (cast h) := by cases h; sorry",
  "name": "cast_bijective",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²) : Function.Bijective (cast h)",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  (h : Î± = Î²)"},
 {"type": "cast (congr_arg (fun a â†¦ Î³ (f a)) (h a)) (C (g (f a))) = C a",
  "tactic-prompt":
  "theorem {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  {Î³ : Î² â†’ Sort v}  {f : Î± â†’ Î²}  {g : Î² â†’ Î±}      (h : Function.LeftInverse g f)  (C : âˆ€ a : Î±, Î³ (f a))  (a : Î±) : cast (congr_arg (fun a â†¦ Î³ (f a)) (h a)) (C (g (f a))) = C a := by rw [cast_eq_iff_heq]; sorry",
  "name": "Function.LeftInverse.cast_eq",
  "kind": "theorem",
  "first-tactic": "rw [cast_eq_iff_heq]",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  {Î³ : Î² â†’ Sort v}  {f : Î± â†’ Î²}  {g : Î² â†’ Î±}      (h : Function.LeftInverse g f)  (C : âˆ€ a : Î±, Î³ (f a))  (a : Î±) : cast (congr_arg (fun a â†¦ Î³ (f a)) (h a)) (C (g (f a))) = C a",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î² â†’ Î³} {Î± Î² : Sort _}  {Î³ : Î² â†’ Sort v}  {f : Î± â†’ Î²}  {g : Î² â†’ Î±}      (h : Function.LeftInverse g f)  (C : âˆ€ a : Î±, Î³ (f a))  (a : Î±)"},
 {"type": "f x = g y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y) : f x = g y := by cases hâ‚‚; sorry",
  "name": "congr_heq",
  "kind": "theorem",
  "first-tactic": "cases hâ‚‚",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y) : f x = g y",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y)"},
 {"type": "Eq True = id",
  "tactic-prompt": "theorem  : Eq True = id := by funext _; sorry",
  "name": "eq_true_eq_id",
  "kind": "theorem",
  "first-tactic": "funext _",
  "core-prompt": " : Eq True = id",
  "args": ""},
 {"type": "Xor' True = Not",
  "tactic-prompt": "theorem  : Xor' True = Not := by simp [Xor']; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' True = Not",
  "args": ""},
 {"type": "Xor' False = id",
  "tactic-prompt": "theorem  : Xor' False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": " : Xor' False = id",
  "args": ""},
 {"type": "Xor' a a = False",
  "tactic-prompt":
  "theorem (a : Prop) : Xor' a a = False := by simp [Xor']; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": "(a : Prop) : Xor' a a = False",
  "args": "(a : Prop)"},
 {"type": "Xor' (Â¬a) b â†” (a â†” b)",
  "tactic-prompt": "theorem  : Xor' (Â¬a) b â†” (a â†” b) := by by_cases a; sorry",
  "name": "xor_not_left",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt": " : Xor' (Â¬a) b â†” (a â†” b)",
  "args": ""},
 {"type": "Xor' a (Â¬b) â†” (a â†” b)",
  "tactic-prompt": "theorem  : Xor' a (Â¬b) â†” (a â†” b) := by by_cases a; sorry",
  "name": "xor_not_right",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt": " : Xor' a (Â¬b) â†” (a â†” b)",
  "args": ""},
 {"type": "Xor' (Â¬a) (Â¬b) â†” Xor' a b",
  "tactic-prompt":
  "theorem  : Xor' (Â¬a) (Â¬b) â†” Xor' a b := by simp [Xor']; sorry",
  "name": "xor_not_not",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' (Â¬a) (Â¬b) â†” Xor' a b",
  "args": ""},
 {"type": "p âˆ§ a = b â†” p âˆ§ b = a",
  "tactic-prompt":
  "theorem (a b : Î±)  (p : Prop) : p âˆ§ a = b â†” p âˆ§ b = a := by simp [eq_comm]; sorry",
  "name": "and_symm_right",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : Î±)  (p : Prop) : p âˆ§ a = b â†” p âˆ§ b = a",
  "args": "(a b : Î±)  (p : Prop)"},
 {"type": "a = b âˆ§ p â†” b = a âˆ§ p",
  "tactic-prompt":
  "theorem (a b : Î±)  (p : Prop) : a = b âˆ§ p â†” b = a âˆ§ p := by simp [eq_comm]; sorry",
  "name": "and_symm_left",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : Î±)  (p : Prop) : a = b âˆ§ p â†” b = a âˆ§ p",
  "args": "(a b : Î±)  (p : Prop)"},
 {"type": "Â¬Xor' P Q â†” (P â†” Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : Â¬Xor' P Q â†” (P â†” Q) := by simp only [not_and]; sorry",
  "name": "not_xor",
  "kind": "theorem",
  "first-tactic": "simp only [not_and]",
  "core-prompt": "(P Q : Prop) : Â¬Xor' P Q â†” (P â†” Q)",
  "args": "(P Q : Prop)"},
 {"type": "Xor' a b â†” (a â†” Â¬b)",
  "tactic-prompt":
  "theorem  : Xor' a b â†” (a â†” Â¬b) := by simp only [â† @xor_not_right a]; sorry",
  "name": "xor_iff_iff_not",
  "kind": "theorem",
  "first-tactic": "simp only [â† @xor_not_right a]",
  "core-prompt": " : Xor' a b â†” (a â†” Â¬b)",
  "args": ""},
 {"type": "Xor' a b â†” (Â¬a â†” b)",
  "tactic-prompt":
  "theorem  : Xor' a b â†” (Â¬a â†” b) := by simp only [â† @xor_not_left _ b]; sorry",
  "name": "xor_iff_not_iff'",
  "kind": "theorem",
  "first-tactic": "simp only [â† @xor_not_left _ b]",
  "core-prompt": " : Xor' a b â†” (Â¬a â†” b)",
  "args": ""},
 {"type": "HEq (@Eq.ndrec Î± a C x b e) y",
  "tactic-prompt":
  "theorem {C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec Î± a C x b e) y := by subst e; sorry",
  "name": "rec_heq_of_heq",
  "kind": "theorem",
  "first-tactic": "subst e",
  "core-prompt":
  "{C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec Î± a C x b e) y",
  "args": "{C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y)"},
 {"type": "xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚",
  "tactic-prompt":
  "theorem (hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚) : xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚ := by subst hâ‚; sorry",
  "name": "Eq.congr",
  "kind": "theorem",
  "first-tactic": "subst hâ‚",
  "core-prompt": "(hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚) : xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚",
  "args": "(hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚)"},
 {"type": "x = z â†” y = z",
  "tactic-prompt":
  "theorem {x y z : Î±}  (h : x = y) : x = z â†” y = z := by rw [h]; sorry",
  "name": "Eq.congr_left",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : Î±}  (h : x = y) : x = z â†” y = z",
  "args": "{x y z : Î±}  (h : x = y)"},
 {"type": "z = x â†” z = y",
  "tactic-prompt":
  "theorem {x y z : Î±}  (h : x = y) : z = x â†” z = y := by rw [h]; sorry",
  "name": "Eq.congr_right",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : Î±}  (h : x = y) : z = x â†” z = y",
  "args": "{x y z : Î±}  (h : x = y)"},
 {"type": "(Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)] : (Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x := by simp only [not_exists]; sorry",
  "name": "Decidable.not_exists_not",
  "kind": "theorem",
  "first-tactic": "simp only [not_exists]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)] : (Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)]"},
 {"type": "(âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±] : (âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b := by let âŸ¨aâŸ© := ha; sorry",
  "name": "forall_imp_iff_exists_imp",
  "kind": "theorem",
  "first-tactic": "let âŸ¨aâŸ© := ha",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±] : (âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±]"},
 {"type": "(âˆ€ a, Î² a â†’ True) â†” True",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _} : (âˆ€ a, Î² a â†’ True) â†” True := by simp; sorry",
  "name": "forallâ‚‚_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _} : (âˆ€ a, Î² a â†’ True) â†” True",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}"},
 {"type": "(âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _} : (âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True := by simp; sorry",
  "name": "forallâ‚ƒ_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _} : (âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}"},
 {"type": "(p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±) : (p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b := by simp only [â† @forall_eq _ p a]; sorry",
  "name": "and_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [â† @forall_eq _ p a]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±) : (p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±)"},
 {"type": "âˆƒ! a, a = a'",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a = a' := by simp only [eq_comm]; sorry",
  "name": "exists_unique_eq",
  "kind": "theorem",
  "first-tactic": "simp only [eq_comm]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a = a'",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "âˆƒ! a, a' = a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a' = a := by simp only [ExistsUnique]; sorry",
  "name": "exists_unique_eq'",
  "kind": "theorem",
  "first-tactic": "simp only [ExistsUnique]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a' = a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "(âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a) := by simp; sorry",
  "name": "forall_apply_eq_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_apply_eq_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a) := by simp; sorry",
  "name": "forall_eq_apply_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_eq_apply_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆƒ a, p a âˆ§ a' = a) â†” p a'",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : (âˆƒ a, p a âˆ§ a' = a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_right'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : (âˆƒ a, p a âˆ§ a' = a) â†” p a'",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "(âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop} : (âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚ := by simp only [@exists_comm (Îºâ‚ _)]; sorry",
  "name": "existsâ‚‚_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@exists_comm (Îºâ‚ _)]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop} : (âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop}"},
 {"type": "(âˆƒ! _ : p, q) â†” p âˆ§ q",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop} : (âˆƒ! _ : p, q) â†” p âˆ§ q := by simp; sorry",
  "name": "exists_unique_prop",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop} : (âˆƒ! _ : p, q) â†” p âˆ§ q",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop}"},
 {"type": "b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b) : b := by simp only [exists_unique_iff_exists] at hâ‚‚; sorry",
  "name": "ExistsUnique.elimâ‚‚",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at hâ‚‚",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b) : b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b)"},
 {"type": "âˆƒ! (x : _) (hx : p x), q x hx",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w) : âˆƒ! (x : _) (hx : p x), q x hx := by simp only [exists_unique_iff_exists]; sorry",
  "name": "ExistsUnique.introâ‚‚",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w) : âˆƒ! (x : _) (hx : p x), q x hx",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w)"},
 {"type": "yâ‚ = yâ‚‚",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚) : yâ‚ = yâ‚‚ := by simp only [exists_unique_iff_exists] at h; sorry",
  "name": "ExistsUnique.uniqueâ‚‚",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚) : yâ‚ = yâ‚‚",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚)"},
 {"type": "Decidable p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p := by infer_instance; sorry",
  "name": "dec",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop)"},
 {"type": "DecidablePred p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop) : DecidablePred p := by infer_instance; sorry",
  "name": "decPred",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop) : DecidablePred p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop)"},
 {"type": "DecidableRel p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop) : DecidableRel p := by infer_instance; sorry",
  "name": "decRel",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop) : DecidableRel p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop)"},
 {"type": "DecidableEq Î±",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort u) : DecidableEq Î± := by infer_instance; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort u) : DecidableEq Î±",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort u)"},
 {"type": "(âˆƒ (x : _) (_ : x = a), p x) â†” p a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±} : (âˆƒ (x : _) (_ : x = a), p x) â†” p a := by simp only [exists_prop]; sorry",
  "name": "bex_eq_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±} : (âˆƒ (x : _) (_ : x = a), p x) â†” p a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±}"},
 {"type": "(âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b := by simp; sorry",
  "name": "bex_imp",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop}"},
 {"type":
  "(âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x := by simp only [exists_prop]; sorry",
  "name": "bex_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop}"},
 {"type": "dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c := by by_cases P; sorry",
  "name": "dite_eq_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "dite P (fun _ â†¦ a) B = a â†” âˆ€ h, B h = a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ â†¦ a) B = a â†” âˆ€ h, B h = a := by by_cases P; sorry",
  "name": "dite_eq_left_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ â†¦ a) B = a â†” âˆ€ h, B h = a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "(dite P A fun _ â†¦ b) = b â†” âˆ€ h, A h = b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ â†¦ b) = b â†” âˆ€ h, A h = b := by by_cases P; sorry",
  "name": "dite_eq_right_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ â†¦ b) = b â†” âˆ€ h, A h = b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "dite P (fun _ â†¦ a) B â‰  a â†” âˆƒ h, a â‰  B h",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ â†¦ a) B â‰  a â†” âˆƒ h, a â‰  B h := by rw [Ne.def]; sorry",
  "name": "dite_ne_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Ne.def]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ â†¦ a) B â‰  a â†” âˆƒ h, a â‰  B h",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "(dite P A fun _ â†¦ b) â‰  b â†” âˆƒ h, A h â‰  b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ â†¦ b) â‰  b â†” âˆƒ h, A h â‰  b := by simp only [Ne.def]; sorry",
  "name": "dite_ne_right_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ â†¦ b) â‰  b â†” âˆƒ h, A h â‰  b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type":
  "f (dite P a b) (dite P c d) = dite P (fun h â†¦ f (a h) (c h)) fun h â†¦ f (b h) (d h)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (fun h â†¦ f (a h) (c h)) fun h â†¦ f (b h) (d h) := by by_cases h : P; sorry",
  "name": "apply_diteâ‚‚",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (fun h â†¦ f (a h) (c h)) fun h â†¦ f (b h) (d h)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²)"},
 {"type": "(dite P f g) a = dite P (fun h â†¦ f h a) fun h â†¦ g h a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±) : (dite P f g) a = dite P (fun h â†¦ f h a) fun h â†¦ g h a := by by_cases h:P; sorry",
  "name": "dite_apply",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±) : (dite P f g) a = dite P (fun h â†¦ f h a) fun h â†¦ g h a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±)"},
 {"type": "ite (P âˆ§ Q) a b = ite P (ite Q a b) b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : ite (P âˆ§ Q) a b = ite P (ite Q a b) b := by by_cases hp : P; sorry",
  "name": "ite_and",
  "kind": "theorem",
  "first-tactic": "by_cases hp : P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : ite (P âˆ§ Q) a b = ite P (ite Q a b) b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "r x y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r)  {x y : Î±}  (hr : x â‰  y â†’ r x y) : r x y := by by_cases hxy : x = y; sorry",
  "name": "Reflexive.rel_of_ne_imp",
  "kind": "theorem",
  "first-tactic": "by_cases hxy : x = y",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r)  {x y : Î±}  (hr : x â‰  y â†’ r x y) : r x y",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} (h : Reflexive r)  {x y : Î±}  (hr : x â‰  y â†’ r x y)"},
 {"type": "(Â· â†” Â·) âˆ˜r r = r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Prop â†’ Î± â†’ Prop} : (Â· â†” Â·) âˆ˜r r = r := by have : (Â· â†” Â·) = (Â· = Â·) := by funext a b; exact iff_eq_eq; sorry",
  "name": "iff_comp",
  "kind": "theorem",
  "first-tactic": "have : (Â· â†” Â·) = (Â· = Â·) := by funext a b; exact iff_eq_eq",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Prop â†’ Î± â†’ Prop} : (Â· â†” Â·) âˆ˜r r = r",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Prop â†’ Î± â†’ Prop}"},
 {"type": "r âˆ˜r (Â· â†” Â·) = r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Î± â†’ Prop â†’ Prop} : r âˆ˜r (Â· â†” Â·) = r := by have : (Â· â†” Â·) = (Â· = Â·) := by funext a b; exact iff_eq_eq; sorry",
  "name": "comp_iff",
  "kind": "theorem",
  "first-tactic": "have : (Â· â†” Â·) = (Â· = Â·) := by funext a b; exact iff_eq_eq",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Î± â†’ Prop â†’ Prop} : r âˆ˜r (Â· â†” Â·) = r",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} {r : Î± â†’ Prop â†’ Prop}"},
 {"type": "(r âˆ˜r p) âˆ˜r q = r âˆ˜r p âˆ˜r q",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} : (r âˆ˜r p) âˆ˜r q = r âˆ˜r p âˆ˜r q := by funext a d; sorry",
  "name": "comp_assoc",
  "kind": "theorem",
  "first-tactic": "funext a d",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} : (r âˆ˜r p) âˆ˜r q = r âˆ˜r p âˆ˜r q",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop}"},
 {"type": "flip (r âˆ˜r p) = flip p âˆ˜r flip r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} : flip (r âˆ˜r p) = flip p âˆ˜r flip r := by funext c a; sorry",
  "name": "flip_comp",
  "kind": "theorem",
  "first-tactic": "funext c a",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop} : flip (r âˆ˜r p) = flip p âˆ˜r flip r",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î² â†’ Prop}  {p : Î² â†’ Î³ â†’ Prop}  {q : Î³ â†’ Î´ â†’ Prop}"},
 {"type": "ReflTransGen r a c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c := by induction hbc; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "ReflTransGen r a c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c := by induction hbc; sorry",
  "name": "head",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : r a b)  (hbc : ReflTransGen r b c) : ReflTransGen r a c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "Symmetric (ReflTransGen r)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Symmetric r) : Symmetric (ReflTransGen r) := by intro x y h; sorry",
  "name": "symmetric",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Symmetric r) : Symmetric (ReflTransGen r)",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Symmetric r)"},
 {"type": "P a h",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, ReflTransGen r a b â†’ Prop}  {a : Î±}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : âˆ€ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h â†’ P a (h.head h')) : P a h := by induction h; sorry",
  "name": "head_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, ReflTransGen r a b â†’ Prop}  {a : Î±}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : âˆ€ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h â†’ P a (h.head h')) : P a h",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, ReflTransGen r a b â†’ Prop}  {a : Î±}  (h : ReflTransGen r a b)      (refl : P b refl)      (head : âˆ€ {a c} (h' : r a c) (h : ReflTransGen r c b), P c h â†’ P a (h.head h'))"},
 {"type": "P h",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, ReflTransGen r a b â†’ Prop}  {a b : Î±}      (h : ReflTransGen r a b)  (ihâ‚ : âˆ€ a, @P a a refl)  (ihâ‚‚ : âˆ€ {a b} (h : r a b), P (single h))      (ihâ‚ƒ : âˆ€ {a b c} (hâ‚ : ReflTransGen r a b) (hâ‚‚ : ReflTransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’      P (hâ‚.trans hâ‚‚)) : P h := by induction h; sorry",
  "name": "trans_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, ReflTransGen r a b â†’ Prop}  {a b : Î±}      (h : ReflTransGen r a b)  (ihâ‚ : âˆ€ a, @P a a refl)  (ihâ‚‚ : âˆ€ {a b} (h : r a b), P (single h))      (ihâ‚ƒ : âˆ€ {a b c} (hâ‚ : ReflTransGen r a b) (hâ‚‚ : ReflTransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’      P (hâ‚.trans hâ‚‚)) : P h",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, ReflTransGen r a b â†’ Prop}  {a b : Î±}      (h : ReflTransGen r a b)  (ihâ‚ : âˆ€ a, @P a a refl)  (ihâ‚‚ : âˆ€ {a b} (h : r a b), P (single h))      (ihâ‚ƒ : âˆ€ {a b c} (hâ‚ : ReflTransGen r a b) (hâ‚‚ : ReflTransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’      P (hâ‚.trans hâ‚‚))"},
 {"type": "a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : ReflTransGen r a b) : a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b := by induction h using Relation.ReflTransGen.head_induction_on; sorry",
  "name": "cases_head",
  "kind": "theorem",
  "first-tactic": "induction h using Relation.ReflTransGen.head_induction_on",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : ReflTransGen r a b) : a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : ReflTransGen r a b)"},
 {"type": "ReflTransGen r a b â†” a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : ReflTransGen r a b â†” a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b := by use cases_head; sorry",
  "name": "cases_head_iff",
  "kind": "theorem",
  "first-tactic": "use cases_head",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : ReflTransGen r a b â†” a = b âˆ¨ âˆƒ c, r a c âˆ§ ReflTransGen r c b",
  "args": "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}"},
 {"type": "ReflTransGen r b c âˆ¨ ReflTransGen r c b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c) : ReflTransGen r b c âˆ¨ ReflTransGen r c b := by induction' ab with b d _ bd IH; sorry",
  "name": "total_of_right_unique",
  "kind": "theorem",
  "first-tactic": "induction' ab with b d _ bd IH",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c) : ReflTransGen r b c âˆ¨ ReflTransGen r c b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (U : Relator.RightUnique r)  (ab : ReflTransGen r a b)      (ac : ReflTransGen r a c)"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : TransGen r a b)  (hbc : ReflTransGen r b c) : TransGen r a c := by induction hbc; sorry",
  "name": "trans_left",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : TransGen r a b)  (hbc : ReflTransGen r b c) : TransGen r a c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : TransGen r a b)  (hbc : ReflTransGen r b c)"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : r b c) : TransGen r a c := by induction hab generalizing c; sorry",
  "name": "tail'",
  "kind": "theorem",
  "first-tactic": "induction hab generalizing c",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : r b c) : TransGen r a c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : r b c)"},
 {"type": "P a h",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, TransGen r a b â†’ Prop}  {a : Î±}  (h : TransGen r a b)      (base : âˆ€ {a} (h : r a b), P a (single h))      (ih : âˆ€ {a c} (h' : r a c) (h : TransGen r c b), P c h â†’ P a (h.head h')) : P a h := by induction h; sorry",
  "name": "head_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, TransGen r a b â†’ Prop}  {a : Î±}  (h : TransGen r a b)      (base : âˆ€ {a} (h : r a b), P a (single h))      (ih : âˆ€ {a c} (h' : r a c) (h : TransGen r c b), P c h â†’ P a (h.head h')) : P a h",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ a : Î±, TransGen r a b â†’ Prop}  {a : Î±}  (h : TransGen r a b)      (base : âˆ€ {a} (h : r a b), P a (single h))      (ih : âˆ€ {a c} (h' : r a c) (h : TransGen r c b), P c h â†’ P a (h.head h'))"},
 {"type": "P h",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, TransGen r a b â†’ Prop}  {a b : Î±}  (h : TransGen r a b)      (base : âˆ€ {a b} (h : r a b), P (single h))      (ih : âˆ€ {a b c} (hâ‚ : TransGen r a b) (hâ‚‚ : TransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’ P (hâ‚.trans hâ‚‚)) : P h := by induction h; sorry",
  "name": "trans_induction_on",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, TransGen r a b â†’ Prop}  {a b : Î±}  (h : TransGen r a b)      (base : âˆ€ {a b} (h : r a b), P (single h))      (ih : âˆ€ {a b c} (hâ‚ : TransGen r a b) (hâ‚‚ : TransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’ P (hâ‚.trans hâ‚‚)) : P h",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} {P : âˆ€ {a b : Î±}, TransGen r a b â†’ Prop}  {a b : Î±}  (h : TransGen r a b)      (base : âˆ€ {a b} (h : r a b), P (single h))      (ih : âˆ€ {a b c} (hâ‚ : TransGen r a b) (hâ‚‚ : TransGen r b c), P hâ‚ â†’ P hâ‚‚ â†’ P (hâ‚.trans hâ‚‚))"},
 {"type": "TransGen r a c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : TransGen r b c) : TransGen r a c := by induction hbc; sorry",
  "name": "trans_right",
  "kind": "theorem",
  "first-tactic": "induction hbc",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : TransGen r b c) : TransGen r a c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (hab : ReflTransGen r a b)  (hbc : TransGen r b c)"},
 {"type": "TransGen r a c â†” âˆƒ b, ReflTransGen r a b âˆ§ r b c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : TransGen r a c â†” âˆƒ b, ReflTransGen r a b âˆ§ r b c := by refine' âŸ¨fun h â†¦ _, fun âŸ¨b, hab, hbcâŸ© â†¦ tail' hab hbcâŸ©; sorry",
  "name": "tail'_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h â†¦ _, fun âŸ¨b, hab, hbcâŸ© â†¦ tail' hab hbcâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : TransGen r a c â†” âˆƒ b, ReflTransGen r a b âˆ§ r b c",
  "args": "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}"},
 {"type": "TransGen r a c â†” âˆƒ b, r a b âˆ§ ReflTransGen r b c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : TransGen r a c â†” âˆƒ b, r a b âˆ§ ReflTransGen r b c := by refine' âŸ¨fun h â†¦ _, fun âŸ¨b, hab, hbcâŸ© â†¦ head' hab hbcâŸ©; sorry",
  "name": "head'_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h â†¦ _, fun âŸ¨b, hab, hbcâŸ© â†¦ head' hab hbcâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : TransGen r a c â†” âˆƒ b, r a b âˆ§ ReflTransGen r b c",
  "args": "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}"},
 {"type": "Acc (TransGen r) a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Acc r a) : Acc (TransGen r) a := by induction' h with x _ H; sorry",
  "name": "_root_.Acc.TransGen",
  "kind": "theorem",
  "first-tactic": "induction' h with x _ H",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Acc r a) : Acc (TransGen r) a",
  "args": "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} (h : Acc r a)"},
 {"type": "TransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)  (h : âˆ€ a b, r a b â†’ p (f a) (f b))      (hab : TransGen r a b) : TransGen p (f a) (f b) := by induction hab; sorry",
  "name": "TransGen.lift",
  "kind": "theorem",
  "first-tactic": "induction hab",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)  (h : âˆ€ a b, r a b â†’ p (f a) (f b))      (hab : TransGen r a b) : TransGen p (f a) (f b)",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)  (h : âˆ€ a b, r a b â†’ p (f a) (f b))      (hab : TransGen r a b)"},
 {"type": "TransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ TransGen p (f a) (f b))  (hab : TransGen r a b) : TransGen p (f a) (f b) := by simpa [transGen_idem] using hab.lift f h; sorry",
  "name": "TransGen.lift'",
  "kind": "theorem",
  "first-tactic": "simpa [transGen_idem] using hab.lift f h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ TransGen p (f a) (f b))  (hab : TransGen r a b) : TransGen p (f a) (f b)",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ TransGen p (f a) (f b))  (hab : TransGen r a b)"},
 {"type": "TransGen (swap r) a b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : TransGen r b a) : TransGen (swap r) a b := by induction' h with b h b c _ hbc ih; sorry",
  "name": "TransGen.swap",
  "kind": "theorem",
  "first-tactic": "induction' h with b h b c _ hbc ih",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : TransGen r b a) : TransGen (swap r) a b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : TransGen r b a)"},
 {"type": "ReflTransGen r a b â†” b = a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ b, Â¬r a b) : ReflTransGen r a b â†” b = a := by rw [cases_head_iff]; sorry",
  "name": "reflTransGen_iff_eq",
  "kind": "theorem",
  "first-tactic": "rw [cases_head_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ b, Â¬r a b) : ReflTransGen r a b â†” b = a",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ b, Â¬r a b)"},
 {"type": "ReflTransGen r a b â†” b = a âˆ¨ TransGen r a b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : ReflTransGen r a b â†” b = a âˆ¨ TransGen r a b := by refine' âŸ¨fun h â†¦ _, fun h â†¦ _âŸ©; sorry",
  "name": "reflTransGen_iff_eq_or_transGen",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h â†¦ _, fun h â†¦ _âŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±} : ReflTransGen r a b â†” b = a âˆ¨ TransGen r a b",
  "args": "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}"},
 {"type": "ReflTransGen p (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b) := by simpa [refl_trans_gen_idem] using hab.lift f h; sorry",
  "name": "ReflTransGen.lift'",
  "kind": "theorem",
  "first-tactic": "simpa [refl_trans_gen_idem] using hab.lift f h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b)",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {p : Î² â†’ Î² â†’ Prop}  {a b : Î±}  (f : Î± â†’ Î²)      (h : âˆ€ a b, r a b â†’ ReflTransGen p (f a) (f b))      (hab : ReflTransGen r a b)"},
 {"type": "ReflTransGen (swap r) a b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : ReflTransGen r b a) : ReflTransGen (swap r) a b := by induction' h with b c _ hbc ih; sorry",
  "name": "ReflTransGen.swap",
  "kind": "theorem",
  "first-tactic": "induction' h with b c _ hbc ih",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : ReflTransGen r b a) : ReflTransGen (swap r) a b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : ReflTransGen r b a)"},
 {"type": "Join (ReflTransGen r) b c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ a b c, r a b â†’ r a c â†’ âˆƒ d, ReflGen r b d âˆ§ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c := by induction hab; sorry",
  "name": "church_rosser",
  "kind": "theorem",
  "first-tactic": "induction hab",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ a b c, r a b â†’ r a c â†’ âˆƒ d, ReflGen r b d âˆ§ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  (h : âˆ€ a b c, r a b â†’ r a c â†’ âˆƒ d, ReflGen r b d âˆ§ ReflTransGen r c d)      (hab : ReflTransGen r a b)  (hac : ReflTransGen r a c)"},
 {"type": "r a b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r' : Î± â†’ Î± â†’ Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : âˆ€ a b, r' a b â†’ r a b)  (h' : ReflTransGen r' a b) : r a b := by induction' h' with b c _ hbc ih; sorry",
  "name": "reflTransGen_of_transitive_reflexive",
  "kind": "theorem",
  "first-tactic": "induction' h' with b c _ hbc ih",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r' : Î± â†’ Î± â†’ Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : âˆ€ a b, r' a b â†’ r a b)  (h' : ReflTransGen r' a b) : r a b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r' : Î± â†’ Î± â†’ Prop}  (hr : Reflexive r)      (ht : Transitive r)  (h : âˆ€ a b, r' a b â†’ r a b)  (h' : ReflTransGen r' a b)"},
 {"type": "EqvGen p a b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r : Î± â†’ Î± â†’ Prop}  {a b : Î±} {r p : Î± â†’ Î± â†’ Prop}  (hrp : âˆ€ a b, r a b â†’ p a b)  (h : EqvGen r a b) : EqvGen p a b := by induction h; sorry",
  "name": "EqvGen.mono",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r : Î± â†’ Î± â†’ Prop}  {a b : Î±} {r p : Î± â†’ Î± â†’ Prop}  (hrp : âˆ€ a b, r a b â†’ p a b)  (h : EqvGen r a b) : EqvGen p a b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {r : Î± â†’ Î± â†’ Prop}  {a b c d : Î±}  {r : Î± â†’ Î± â†’ Prop}  {a b : Î±} {r p : Î± â†’ Î± â†’ Prop}  (hrp : âˆ€ a b, r a b â†’ p a b)  (h : EqvGen r a b)"},
 {"type":
  "(dite p a fun hp â†¦ dite q (b hp) (c hp)) =\n      dite q (fun hq â†¦ (dite p a) fun hp â†¦ b hp hq) fun hq â†¦ (dite p a) fun hp â†¦ c hp hq",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ Î±}  {b : Â¬p â†’ q â†’ Î±}  {c : Â¬p â†’ Â¬q â†’ Î±} : (dite p a fun hp â†¦ dite q (b hp) (c hp)) =\n      dite q (fun hq â†¦ (dite p a) fun hp â†¦ b hp hq) fun hq â†¦ (dite p a) fun hp â†¦ c hp hq := by split_ifs; sorry",
  "name": "dite_dite_distrib_left",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ Î±}  {b : Â¬p â†’ q â†’ Î±}  {c : Â¬p â†’ Â¬q â†’ Î±} : (dite p a fun hp â†¦ dite q (b hp) (c hp)) =\n      dite q (fun hq â†¦ (dite p a) fun hp â†¦ b hp hq) fun hq â†¦ (dite p a) fun hp â†¦ c hp hq",
  "args":
  "{Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ Î±}  {b : Â¬p â†’ q â†’ Î±}  {c : Â¬p â†’ Â¬q â†’ Î±}"},
 {"type":
  "dite p (fun hp â†¦ dite q (a hp) (b hp)) c =\n      dite q (fun hq â†¦ dite p (fun hp â†¦ a hp hq) c) fun hq â†¦ dite p (fun hp â†¦ b hp hq) c",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ q â†’ Î±}  {b : p â†’ Â¬q â†’ Î±}  {c : Â¬p â†’ Î±} : dite p (fun hp â†¦ dite q (a hp) (b hp)) c =\n      dite q (fun hq â†¦ dite p (fun hp â†¦ a hp hq) c) fun hq â†¦ dite p (fun hp â†¦ b hp hq) c := by split_ifs; sorry",
  "name": "dite_dite_distrib_right",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ q â†’ Î±}  {b : p â†’ Â¬q â†’ Î±}  {c : Â¬p â†’ Î±} : dite p (fun hp â†¦ dite q (a hp) (b hp)) c =\n      dite q (fun hq â†¦ dite p (fun hp â†¦ a hp hq) c) fun hq â†¦ dite p (fun hp â†¦ b hp hq) c",
  "args":
  "{Î± : Sort _}  {p q r : Prop}  [Decidable p]  [Decidable q]  {a b c : Î±} {a : p â†’ q â†’ Î±}  {b : p â†’ Â¬q â†’ Î±}  {c : Â¬p â†’ Î±}"},
 {"type": "p â‰  0",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 â†’ R}  (h : IsCoprime (p 0) (p 1)) : p â‰  0 := by rintro rfl; sorry",
  "name": "IsCoprime.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 â†’ R}  (h : IsCoprime (p 0) (p 1)) : p â‰  0",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) [Nontrivial R]  {p : Fin 2 â†’ R}  (h : IsCoprime (p 0) (p 1))"},
 {"type": "x âˆ£ y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x âˆ£ y * z) : x âˆ£ y := by let âŸ¨a, b, HâŸ© := H1; sorry",
  "name": "IsCoprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let âŸ¨a, b, HâŸ© := H1",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x âˆ£ y * z) : x âˆ£ y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x z)  (H2 : x âˆ£ y * z)"},
 {"type": "x âˆ£ z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x âˆ£ y * z) : x âˆ£ z := by let âŸ¨a, b, HâŸ© := H1; sorry",
  "name": "IsCoprime.dvd_of_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let âŸ¨a, b, HâŸ© := H1",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x âˆ£ y * z) : x âˆ£ z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : x âˆ£ y * z)"},
 {"type": "IsCoprime x (y * z)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z) : IsCoprime x (y * z) := by rw [isCoprime_comm] at H1 H2âŠ¢; sorry",
  "name": "IsCoprime.mul_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at H1 H2âŠ¢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z) : IsCoprime x (y * z)",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H1 : IsCoprime x y)  (H2 : IsCoprime x z)"},
 {"type": "x * y âˆ£ z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x âˆ£ z)  (H2 : y âˆ£ z) : x * y âˆ£ z := by obtain âŸ¨a, b, hâŸ© := H; sorry",
  "name": "IsCoprime.mul_dvd",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨a, b, hâŸ© := H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x âˆ£ z)  (H2 : y âˆ£ z) : x * y âˆ£ z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x y)  (H1 : x âˆ£ z)  (H2 : y âˆ£ z)"},
 {"type": "IsCoprime y z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z) : IsCoprime y z := by rw [mul_comm] at H; sorry",
  "name": "IsCoprime.of_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z) : IsCoprime y z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime (x * y) z)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x y := by rw [isCoprime_comm] at HâŠ¢; sorry",
  "name": "IsCoprime.of_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at HâŠ¢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z))"},
 {"type": "IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x z := by rw [mul_comm] at H; sorry",
  "name": "IsCoprime.of_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at H",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z)) : IsCoprime x z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (H : IsCoprime x (y * z))"},
 {"type": "IsCoprime x (y * z) â†” IsCoprime x y âˆ§ IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) : IsCoprime x (y * z) â†” IsCoprime x y âˆ§ IsCoprime x z := by rw [isCoprime_comm]; sorry",
  "name": "IsCoprime.mul_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) : IsCoprime x (y * z) â†” IsCoprime x y âˆ§ IsCoprime x z",
  "args": "{R : Type u}  [CommSemiring R]  (x y z : R)"},
 {"type": "IsCoprime x z",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x âˆ£ y) : IsCoprime x z := by obtain âŸ¨d, rflâŸ© := hdvd; sorry",
  "name": "IsCoprime.of_isCoprime_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨d, rflâŸ© := hdvd",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x âˆ£ y) : IsCoprime x z",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime y z)  (hdvd : x âˆ£ y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y) : IsCoprime x y := by rw [mul_comm] at h; sorry",
  "name": "IsCoprime.of_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (x + z * y) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z)) : IsCoprime x y := by rw [isCoprime_comm] at hâŠ¢; sorry",
  "name": "IsCoprime.of_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm] at hâŠ¢",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + x * z))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x)) : IsCoprime x y := by rw [mul_comm] at h; sorry",
  "name": "IsCoprime.of_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (y + z * x))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_left_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (y * z + x) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_right_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime (z * y + x) y)"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y)) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_left_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (x * z + y))"},
 {"type": "IsCoprime x y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y)) : IsCoprime x y := by rw [add_comm] at h; sorry",
  "name": "IsCoprime.of_mul_add_right_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm] at h",
  "core-prompt":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y)) : IsCoprime x y",
  "args":
  "{R : Type u}  [CommSemiring R]  (x y z : R) (h : IsCoprime x (z * x + y))"},
 {"type": "IsCoprime (x + z * y) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (x + z * y) y := by rw [mul_comm]; sorry",
  "name": "add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (x + z * y) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (y + x * z)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + x * z) := by rw [isCoprime_comm]; sorry",
  "name": "add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + x * z)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (y + z * x)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + z * x) := by rw [isCoprime_comm]; sorry",
  "name": "add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [isCoprime_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (y + z * x)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (y * z + x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (y * z + x) y := by rw [add_comm]; sorry",
  "name": "mul_add_left_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (y * z + x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (z * y + x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (z * y + x) y := by rw [add_comm]; sorry",
  "name": "mul_add_right_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime (z * y + x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (x * z + y)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (x * z + y) := by rw [add_comm]; sorry",
  "name": "mul_add_left_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (x * z + y)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime x (z * x + y)",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (z * x + y) := by rw [add_comm]; sorry",
  "name": "mul_add_right_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R) : IsCoprime x (z * x + y)",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)  (z : R)"},
 {"type": "IsCoprime (-x) y",
  "tactic-prompt":
  "theorem {R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y) : IsCoprime (-x) y := by obtain âŸ¨a, b, hâŸ© := h; sorry",
  "name": "neg_left",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨a, b, hâŸ© := h",
  "core-prompt":
  "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y) : IsCoprime (-x) y",
  "args": "{R : Type u}  [CommRing R] {x y : R}  (h : IsCoprime x y)"},
 {"type": "a ^ 2 + b ^ 2 â‰  0",
  "tactic-prompt":
  "theorem {R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b) : a ^ 2 + b ^ 2 â‰  0 := by intro h'; sorry",
  "name": "sq_add_sq_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h'",
  "core-prompt":
  "{R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b) : a ^ 2 + b ^ 2 â‰  0",
  "args":
  "{R : Type _}  [LinearOrderedCommRing R]  {a b : R}  (h : IsCoprime a b)"},
 {"type": "reverse (reverse f) = f",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b) : reverse (reverse f) = f := by apply h.inv'; sorry",
  "name": "reverse_reverse",
  "kind": "theorem",
  "first-tactic": "apply h.inv'",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b) : reverse (reverse f) = f",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b)"},
 {"type": "reverse f = reverse g â†” f = g",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a âŸ¶ b) : reverse f = reverse g â†” f = g := by constructor; sorry",
  "name": "reverse_inj",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a âŸ¶ b) : reverse f = reverse g â†” f = g",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}      (f g : a âŸ¶ b)"},
 {"type": "f = reverse g â†” reverse f = g",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b)      (g : b âŸ¶ a) : f = reverse g â†” reverse f = g := by rw [â†reverse_inj]; sorry",
  "name": "eq_reverse_iff",
  "kind": "theorem",
  "first-tactic": "rw [â†reverse_inj]",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b)      (g : b âŸ¶ a) : f = reverse g â†” reverse f = g",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] [h : HasInvolutiveReverse V]  {a b : V}  (f : a âŸ¶ b)      (g : b âŸ¶ a)"},
 {"type": "(p.comp q).reverse = q.reverse.comp p.reverse",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c) : (p.comp q).reverse = q.reverse.comp p.reverse := by induction' q with _ _ _ _ h; sorry",
  "name": "Path.reverse_comp",
  "kind": "theorem",
  "first-tactic": "induction' q with _ _ _ _ h",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c) : (p.comp q).reverse = q.reverse.comp p.reverse",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [HasReverse V]  {a b c : V}  (p : Path a b)  (q : Path b c)"},
 {"type": "p.reverse.reverse = p",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b) : p.reverse.reverse = p := by induction' p with _ _ _ _ h; sorry",
  "name": "Path.reverse_reverse",
  "kind": "theorem",
  "first-tactic": "induction' p with _ _ _ _ h",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b) : p.reverse.reverse = p",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W]  [h : HasInvolutiveReverse V]  {a b : V}  (p : Path a b)"},
 {"type": "Symmetrify.of.comp (Symmetrify.lift Ï†) = Ï†",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : Prefunctor V V') : Symmetrify.of.comp (Symmetrify.lift Ï†) = Ï† := by fapply Prefunctor.ext; sorry",
  "name": "lift_spec",
  "kind": "theorem",
  "first-tactic": "fapply Prefunctor.ext",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : Prefunctor V V') : Symmetrify.of.comp (Symmetrify.lift Ï†) = Ï†",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : Prefunctor V V')"},
 {"type":
  "(Symmetrify.lift Ï†).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift Ï†).map f)",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (Ï† : Prefunctor V V')  {X Y : Symmetrify V}  (f : X âŸ¶ Y) : (Symmetrify.lift Ï†).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift Ï†).map f) := by dsimp [Symmetrify.lift]; sorry",
  "name": "lift_reverse",
  "kind": "theorem",
  "first-tactic": "dsimp [Symmetrify.lift]",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (Ï† : Prefunctor V V')  {X Y : Symmetrify V}  (f : X âŸ¶ Y) : (Symmetrify.lift Ï†).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift Ï†).map f)",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [h : HasInvolutiveReverse V']      (Ï† : Prefunctor V V')  {X Y : Symmetrify V}  (f : X âŸ¶ Y)"},
 {"type": "Î¦ = Symmetrify.lift Ï†",
  "tactic-prompt":
  "theorem (U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : V â¥¤q V')  (Î¦ : Symmetrify V â¥¤q V')  (hÎ¦ : (of â‹™q Î¦) = Ï†)      (hÎ¦inv : âˆ€ {X Y : Symmetrify V} (f : X âŸ¶ Y),       Î¦.map (Quiver.reverse f) = Quiver.reverse (Î¦.map f)) : Î¦ = Symmetrify.lift Ï† := by subst_vars; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : V â¥¤q V')  (Î¦ : Symmetrify V â¥¤q V')  (hÎ¦ : (of â‹™q Î¦) = Ï†)      (hÎ¦inv : âˆ€ {X Y : Symmetrify V} (f : X âŸ¶ Y),       Î¦.map (Quiver.reverse f) = Quiver.reverse (Î¦.map f)) : Î¦ = Symmetrify.lift Ï†",
  "args":
  "(U V W : Type _)  [Quiver.{u + 1} U]  [Quiver.{v + 1} V]  [Quiver.{w + 1} W] {V' : Type _}  [Quiver.{v' + 1} V'] [HasReverse V']  (Ï† : V â¥¤q V')  (Î¦ : Symmetrify V â¥¤q V')  (hÎ¦ : (of â‹™q Î¦) = Ï†)      (hÎ¦inv : âˆ€ {X Y : Symmetrify V} (f : X âŸ¶ Y),       Î¦.map (Quiver.reverse f) = Quiver.reverse (Î¦.map f))"},
 {"type": "e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v) : e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e := by subst_vars; sorry",
  "name": "Hom.cast_eq_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v) : e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)"},
 {"type": "(e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv')",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u âŸ¶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv') := by subst_vars; sorry",
  "name": "Hom.cast_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u âŸ¶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv')",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (e : u âŸ¶ v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'')"},
 {"type": "HEq (e.cast hu hv) e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v) : HEq (e.cast hu hv) e := by subst_vars; sorry",
  "name": "Hom.cast_heq",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v) : HEq (e.cast hu hv) e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)"},
 {"type": "e.cast hu hv = e' â†” HEq e e'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v') : e.cast hu hv = e' â†” HEq e e' := by rw [Hom.cast_eq_cast]; sorry",
  "name": "Hom.cast_eq_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [Hom.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v') : e.cast hu hv = e' â†” HEq e e'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v')"},
 {"type": "e' = e.cast hu hv â†” HEq e' e",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v') : e' = e.cast hu hv â†” HEq e' e := by rw [eq_comm]; sorry",
  "name": "Hom.eq_cast_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v') : e' = e.cast hu hv â†” HEq e' e",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (e : u âŸ¶ v)  (e' : u' âŸ¶ v')"},
 {"type": "p.cast hu hv = _root_.cast (by rw [hu, hv]) p",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : p.cast hu hv = _root_.cast (by rw [hu, hv]) p := by subst_vars; sorry",
  "name": "Path.cast_eq_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : p.cast hu hv = _root_.cast (by rw [hu, hv]) p",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)"},
 {"type": "(p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv')",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv') := by subst_vars; sorry",
  "name": "Path.cast_cast",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'') : (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv')",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' u'' v'' : U}  (p : Path u v)  (hu : u = u')  (hv : v = v')      (hu' : u' = u'')  (hv' : v' = v'')"},
 {"type": "(Path.nil : Path u u).cast hu hu = Path.nil",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil := by subst_vars; sorry",
  "name": "Path.cast_nil",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil",
  "args": "{U : Type _}  [Quiver.{u + 1} U] {u u' : U}  (hu : u = u')"},
 {"type": "HEq (p.cast hu hv) p",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : HEq (p.cast hu hv) p := by rw [Path.cast_eq_cast]; sorry",
  "name": "Path.cast_heq",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v) : HEq (p.cast hu hv) p",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)"},
 {"type": "p.cast hu hv = p' â†” HEq p p'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v') : p.cast hu hv = p' â†” HEq p p' := by rw [Path.cast_eq_cast]; sorry",
  "name": "Path.cast_eq_iff_heq",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_cast]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v') : p.cast hu hv = p' â†” HEq p p'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v u' v' : U}  (hu : u = u')  (hv : v = v')  (p : Path u v)      (p' : Path u' v')"},
 {"type": "(p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw)",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v âŸ¶ w)  (hu : u = u')  (hw : w = w') : (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw) := by subst_vars; sorry",
  "name": "Path.cast_cons",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v âŸ¶ w)  (hu : u = u')  (hw : w = w') : (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw)",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v w u' w' : U}  (p : Path u v)  (e : v âŸ¶ w)  (hu : u = u')  (hw : w = w')"},
 {"type": "p.cast rfl (obj_eq_of_cons_eq_cons h) = p'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e') : p.cast rfl (obj_eq_of_cons_eq_cons h) = p' := by rw [Path.cast_eq_iff_heq]; sorry",
  "name": "cast_eq_of_cons_eq_cons",
  "kind": "theorem",
  "first-tactic": "rw [Path.cast_eq_iff_heq]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e') : p.cast rfl (obj_eq_of_cons_eq_cons h) = p'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e')"},
 {"type": "e.cast (obj_eq_of_cons_eq_cons h) rfl = e'",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e') : e.cast (obj_eq_of_cons_eq_cons h) rfl = e' := by rw [Hom.cast_eq_iff_heq]; sorry",
  "name": "hom_cast_eq_of_cons_eq_cons",
  "kind": "theorem",
  "first-tactic": "rw [Hom.cast_eq_iff_heq]",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e') : e.cast (obj_eq_of_cons_eq_cons h) rfl = e'",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v v' w : U}  {p : Path u v}  {p' : Path u v'}  {e : v âŸ¶ w}      {e' : v' âŸ¶ w}  (h : p.cons e = p'.cons e')"},
 {"type": "p.cast (eq_of_length_zero p hzero) rfl = Path.nil",
  "tactic-prompt":
  "theorem {U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0) : p.cast (eq_of_length_zero p hzero) rfl = Path.nil := by cases p; sorry",
  "name": "eq_nil_of_length_zero",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0) : p.cast (eq_of_length_zero p hzero) rfl = Path.nil",
  "args":
  "{U : Type _}  [Quiver.{u + 1} U] {u v : U}  (p : Path u v)  (hzero : p.length = 0)"},
 {"type": "F = G",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver.{vâ‚} V]  {W : Type uâ‚‚}  [Quiver.{vâ‚‚} W]  {F G : Prefunctor V W}      (h_obj : âˆ€ X, F.obj X = G.obj X)      (h_map : âˆ€ (X Y : V) (f : X âŸ¶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by cases' F with F_obj _; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases' F with F_obj _",
  "core-prompt":
  "{V : Type u}  [Quiver.{vâ‚} V]  {W : Type uâ‚‚}  [Quiver.{vâ‚‚} W]  {F G : Prefunctor V W}      (h_obj : âˆ€ X, F.obj X = G.obj X)      (h_map : âˆ€ (X Y : V) (f : X âŸ¶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G",
  "args":
  "{V : Type u}  [Quiver.{vâ‚} V]  {W : Type uâ‚‚}  [Quiver.{vâ‚‚} W]  {F G : Prefunctor V W}      (h_obj : âˆ€ X, F.obj X = G.obj X)      (h_map : âˆ€ (X Y : V) (f : X âŸ¶ Y),       F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f)))"},
 {"type": "(of Ïƒ â‹™q lift Ïƒ Ï† Ï„ h) = Ï†",
  "tactic-prompt":
  "theorem {V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x)) : (of Ïƒ â‹™q lift Ïƒ Ï† Ï„ h) = Ï† := by fapply Prefunctor.ext; sorry",
  "name": "lift_comp",
  "kind": "theorem",
  "first-tactic": "fapply Prefunctor.ext",
  "core-prompt":
  "{V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x)) : (of Ïƒ â‹™q lift Ïƒ Ï† Ï„ h) = Ï†",
  "args":
  "{V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x))"},
 {"type": "Î¦ = lift Ïƒ Ï† Ï„ h",
  "tactic-prompt":
  "theorem {V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x)) (Î¦ : Push Ïƒ â¥¤q W')  (Î¦â‚€ : Î¦.obj = Ï„)  (Î¦comp : (of Ïƒ â‹™q Î¦) = Ï†) : Î¦ = lift Ïƒ Ï† Ï„ h := by dsimp only [of]; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "dsimp only [of]",
  "core-prompt":
  "{V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x)) (Î¦ : Push Ïƒ â¥¤q W')  (Î¦â‚€ : Î¦.obj = Ï„)  (Î¦comp : (of Ïƒ â‹™q Î¦) = Ï†) : Î¦ = lift Ïƒ Ï† Ï„ h",
  "args":
  "{V : Type _}  [Quiver V]  {W : Type _}  (Ïƒ : V â†’ W) {W' : Type _}  [Quiver W']  (Ï† : V â¥¤q W')  (Ï„ : W â†’ W')  (h : âˆ€ x, Ï†.obj x = Ï„ (Ïƒ x)) (Î¦ : Push Ïƒ â¥¤q W')  (Î¦â‚€ : Î¦.obj = Ï„)  (Î¦comp : (of Ïƒ â‹™q Î¦) = Ï†)"},
 {"type": "b = c",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : b = c := by injection h; sorry",
  "name": "obj_eq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : b = c",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "HEq p p'",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : HEq p p' := by injection h; sorry",
  "name": "heq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : HEq p p'",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "HEq e e'",
  "tactic-prompt":
  "lemma {V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : HEq e e' := by injection h; sorry",
  "name": "hom_heq_of_cons_eq_cons",
  "kind": "lemma",
  "first-tactic": "injection h",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e') : HEq e e'",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {p : Path a b}  {p' : Path a c}    {e : b âŸ¶ d}  {e' : c âŸ¶ d}  (h : p.cons e = p'.cons e')"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0) : a = b := by cases p; sorry",
  "name": "eq_of_length_zero",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0) : a = b",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} (p : Path a b)  (hzero : p.length = 0)"},
 {"type": "pâ‚.comp qâ‚ = pâ‚‚.comp qâ‚‚ â†” pâ‚ = pâ‚‚ âˆ§ qâ‚ = qâ‚‚",
  "tactic-prompt":
  "theorem {V : Type u}  [Quiver V]  {a b c d : V} {pâ‚ pâ‚‚ : Path a b}  {qâ‚ qâ‚‚ : Path b c}  (hq : qâ‚.length = qâ‚‚.length) : pâ‚.comp qâ‚ = pâ‚‚.comp qâ‚‚ â†” pâ‚ = pâ‚‚ âˆ§ qâ‚ = qâ‚‚ := by refine' âŸ¨fun h => _, by rintro âŸ¨rfl, rflâŸ©; rflâŸ©; sorry",
  "name": "comp_inj",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, by rintro âŸ¨rfl, rflâŸ©; rflâŸ©",
  "core-prompt":
  "{V : Type u}  [Quiver V]  {a b c d : V} {pâ‚ pâ‚‚ : Path a b}  {qâ‚ qâ‚‚ : Path b c}  (hq : qâ‚.length = qâ‚‚.length) : pâ‚.comp qâ‚ = pâ‚‚.comp qâ‚‚ â†” pâ‚ = pâ‚‚ âˆ§ qâ‚ = qâ‚‚",
  "args":
  "{V : Type u}  [Quiver V]  {a b c d : V} {pâ‚ pâ‚‚ : Path a b}  {qâ‚ qâ‚‚ : Path b c}  (hq : qâ‚.length = qâ‚‚.length)"},
 {"type": "decide True = true",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable True) : decide True = true := by simp; sorry",
  "name": "decide_True'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b c d : Prop} (h : Decidable True) : decide True = true",
  "args": "{a b c d : Prop} (h : Decidable True)"},
 {"type": "decide False = false",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable False) : decide False = false := by simp; sorry",
  "name": "decide_False'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{a b c d : Prop} (h : Decidable False) : decide False = false",
  "args": "{a b c d : Prop} (h : Decidable False)"},
 {"type": "t",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t := by have := if_pos hc â–¸ h; sorry",
  "name": "imp_of_if_pos",
  "kind": "theorem",
  "first-tactic": "have := if_pos hc â–¸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c)"},
 {"type": "e",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c) : e := by have := if_neg hnc â–¸ h; sorry",
  "name": "imp_of_if_neg",
  "kind": "theorem",
  "first-tactic": "have := if_neg hnc â–¸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c) : e",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c)"},
 {"type": "HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚) : HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x) := by cases h; sorry",
  "name": "let_value_heq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚) : HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚)"},
 {"type": "(let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x) := by exact h _ â–¸ rfl; sorry",
  "name": "let_body_eq",
  "kind": "theorem",
  "first-tactic": "exact h _ â–¸ rfl",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x)"},
 {"type": "(let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x) := by simp [hâ‚]; sorry",
  "name": "let_eq",
  "kind": "theorem",
  "first-tactic": "simp [hâ‚]",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x)"},
 {"type": "min a b â‰¤ a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ a := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "min_le_left",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "min a b â‰¤ b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ b := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "min_le_right",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "c â‰¤ min a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b) : c â‰¤ min a b := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "le_min",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b) : c â‰¤ min a b",
  "args":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b)"},
 {"type": "a â‰¤ max a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : a â‰¤ max a b := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "le_max_left",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : a â‰¤ max a b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "b â‰¤ max a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : b â‰¤ max a b := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "le_max_right",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : b â‰¤ max a b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "max a b â‰¤ c",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c) : max a b â‰¤ c := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "max_le",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c) : max a b â‰¤ c",
  "args":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c)"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : min (min a b) c = min a (min b c)",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a : Î±) : min a a = a := by simp [min_def]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a : Î±) : min a a = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a : Î±)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : min a b = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : min a b = b",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : max (max a b) c = max a (max b c)",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a : Î±) : max a a = a := by simp [max_def]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a : Î±) : max a a = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a : Î±)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : max a b = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : max a b = b := by rw [â†max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [â†max_comm b a]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : max a b = b",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "âˆ€ a b, min a b = if a â‰¤ b then a else b",
  "tactic-prompt":
  "def {Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, min a b = if a â‰¤ b then a else b := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, min a b = if a â‰¤ b then a else b",
  "args": "{Î± : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "âˆ€ a b, max a b = if a â‰¤ b then b else a",
  "tactic-prompt":
  "def {Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, max a b = if a â‰¤ b then b else a := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, max a b = if a â‰¤ b then b else a",
  "args": "{Î± : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "bodd (succ n) = not (bodd n)",
  "tactic-prompt":
  "theorem (n : â„•) : bodd (succ n) = not (bodd n) := by simp only [bodd]; sorry",
  "name": "bodd_succ",
  "kind": "theorem",
  "first-tactic": "simp only [bodd]",
  "core-prompt": "(n : â„•) : bodd (succ n) = not (bodd n)",
  "args": "(n : â„•)"},
 {"type": "bodd (m + n) = bxor (bodd m) (bodd n)",
  "tactic-prompt":
  "theorem (m n : â„•) : bodd (m + n) = bxor (bodd m) (bodd n) := by induction' n with n IH; sorry",
  "name": "bodd_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(m n : â„•) : bodd (m + n) = bxor (bodd m) (bodd n)",
  "args": "(m n : â„•)"},
 {"type": "bodd (m * n) = (bodd m && bodd n)",
  "tactic-prompt":
  "theorem (m n : â„•) : bodd (m * n) = (bodd m && bodd n) := by induction' n with n IH; sorry",
  "name": "bodd_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(m n : â„•) : bodd (m * n) = (bodd m && bodd n)",
  "args": "(m n : â„•)"},
 {"type": "n % 2 = cond (bodd n) 1 0",
  "tactic-prompt":
  "theorem (n : â„•) : n % 2 = cond (bodd n) 1 0 := by have := congr_arg bodd (mod_add_div n 2); sorry",
  "name": "mod_two_of_bodd",
  "kind": "theorem",
  "first-tactic": "have := congr_arg bodd (mod_add_div n 2)",
  "core-prompt": "(n : â„•) : n % 2 = cond (bodd n) 1 0",
  "args": "(n : â„•)"},
 {"type": "div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n)",
  "tactic-prompt":
  "theorem (n : â„•) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n) := by simp only [bodd]; sorry",
  "name": "div2_succ",
  "kind": "theorem",
  "first-tactic": "simp only [bodd]",
  "core-prompt":
  "(n : â„•) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n)",
  "args": "(n : â„•)"},
 {"type": "âˆ€ n, shiftr 0 n = 0",
  "tactic-prompt": "theorem  : âˆ€ n, shiftr 0 n = 0 := by intros; sorry",
  "name": "shiftr_zero",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt": " : âˆ€ n, shiftr 0 n = 0",
  "args": ""},
 {"type": "div2 n < n",
  "tactic-prompt": "lemma (h : n â‰  0) : div2 n < n := by rw [div2_val]; sorry",
  "name": "binaryRec_decreasing",
  "kind": "lemma",
  "first-tactic": "rw [div2_val]",
  "core-prompt": "(h : n â‰  0) : div2 n < n",
  "args": "(h : n â‰  0)"},
 {"type": "binaryRec z f 0 = z",
  "tactic-prompt":
  "theorem {C : Nat â†’ Sort u}  (z : C 0)  (f : âˆ€ b n, C n â†’ C (bit b n)) : binaryRec z f 0 = z := by rw [binaryRec]; sorry",
  "name": "binary_rec_zero",
  "kind": "theorem",
  "first-tactic": "rw [binaryRec]",
  "core-prompt":
  "{C : Nat â†’ Sort u}  (z : C 0)  (f : âˆ€ b n, C n â†’ C (bit b n)) : binaryRec z f 0 = z",
  "args": "{C : Nat â†’ Sort u}  (z : C 0)  (f : âˆ€ b n, C n â†’ C (bit b n))"},
 {"type":
  "(@binaryRec (fun _ => â„•) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : â„• => cond (f false true) n 0",
  "tactic-prompt":
  "theorem {f : Bool â†’ Bool â†’ Bool}  (h : f false false = false) : (@binaryRec (fun _ => â„•) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : â„• => cond (f false true) n 0 := by funext n; sorry",
  "name": "bitwise'_bit_aux",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{f : Bool â†’ Bool â†’ Bool}  (h : f false false = false) : (@binaryRec (fun _ => â„•) (cond (f true false) (bit false 0) 0) fun b n _ =>\n        bit (f false b) (cond (f false true) n 0)) =\n      fun n : â„• => cond (f false true) n 0",
  "args": "{f : Bool â†’ Bool â†’ Bool}  (h : f false false = false)"},
 {"type": "bitwise' f 0 0 = 0",
  "tactic-prompt":
  "theorem (f : Bool â†’ Bool â†’ Bool) : bitwise' f 0 0 = 0 := by rw [bitwise'_zero_left]; sorry",
  "name": "bitwise'_zero",
  "kind": "theorem",
  "first-tactic": "rw [bitwise'_zero_left]",
  "core-prompt": "(f : Bool â†’ Bool â†’ Bool) : bitwise' f 0 0 = 0",
  "args": "(f : Bool â†’ Bool â†’ Bool)"},
 {"type": "bitwise' (Function.swap f) = Function.swap (bitwise' f)",
  "tactic-prompt":
  "theorem {f : Bool â†’ Bool â†’ Bool}  (h : f false false = false) : bitwise' (Function.swap f) = Function.swap (bitwise' f) := by funext m n; sorry",
  "name": "bitwise'_swap",
  "kind": "theorem",
  "first-tactic": "funext m n",
  "core-prompt":
  "{f : Bool â†’ Bool â†’ Bool}  (h : f false false = false) : bitwise' (Function.swap f) = Function.swap (bitwise' f)",
  "args": "{f : Bool â†’ Bool â†’ Bool}  (h : f false false = false)"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) : WellFounded (lbp p) := by refine âŸ¨let âŸ¨n, pnâŸ© := H; ?_âŸ©; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine âŸ¨let âŸ¨n, pnâŸ© := H; ?_âŸ©",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) : WellFounded (lbp p)",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n)"},
 {"type":
  "âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat)"},
 {"type":
  "âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ â†’ n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ â†’ n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ â†’ n / b < b ^ e",
  "args":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "(Nat.toDigitsCore b f n []).length <= e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]; sorry",
  "name": "to_digits_core_length",
  "kind": "lemma",
  "first-tactic":
  "induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e",
  "args":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e)"},
 {"type": "0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat) : 0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat) : 0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat)"},
 {"type": "xor b b = false",
  "tactic-prompt": "theorem (b : Bool) : xor b b = false := by cases b; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b b = false",
  "args": "(b : Bool)"},
 {"type": "xor b true = not b",
  "tactic-prompt":
  "theorem (b : Bool) : xor b true = not b := by cases b; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b true = not b",
  "args": "(b : Bool)"},
 {"type": "xor b false = b",
  "tactic-prompt": "theorem (b : Bool) : xor b false = b := by cases b; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor b false = b",
  "args": "(b : Bool)"},
 {"type": "xor true b = not b",
  "tactic-prompt":
  "theorem (b : Bool) : xor true b = not b := by cases b; sorry",
  "name": "true_xor",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor true b = not b",
  "args": "(b : Bool)"},
 {"type": "xor false b = b",
  "tactic-prompt": "theorem (b : Bool) : xor false b = b := by cases b; sorry",
  "name": "false_xor",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : xor false b = b",
  "args": "(b : Bool)"},
 {"type": "Â¬true = false",
  "tactic-prompt": "theorem  : Â¬true = false := by decide; sorry",
  "name": "true_eq_false_eq_False",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Â¬true = false",
  "args": ""},
 {"type": "Â¬false = true",
  "tactic-prompt": "theorem  : Â¬false = true := by decide; sorry",
  "name": "false_eq_true_eq_False",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Â¬false = true",
  "args": ""},
 {"type": "(Â¬b = true) = (b = false)",
  "tactic-prompt":
  "theorem (b : Bool) : (Â¬b = true) = (b = false) := by simp; sorry",
  "name": "eq_false_eq_not_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : Bool) : (Â¬b = true) = (b = false)",
  "args": "(b : Bool)"},
 {"type": "(Â¬b = false) = (b = true)",
  "tactic-prompt":
  "theorem (b : Bool) : (Â¬b = false) = (b = true) := by simp; sorry",
  "name": "eq_true_eq_not_eq_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : Bool) : (Â¬b = false) = (b = true)",
  "args": "(b : Bool)"},
 {"type": "((a && b) = true) = (a = true âˆ§ b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a && b) = true) = (a = true âˆ§ b = true) := by simp; sorry",
  "name": "and_eq_true_eq_eq_true_and_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : ((a && b) = true) = (a = true âˆ§ b = true)",
  "args": "(a b : Bool)"},
 {"type": "((a || b) = true) = (a = true âˆ¨ b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a || b) = true) = (a = true âˆ¨ b = true) := by simp; sorry",
  "name": "or_eq_true_eq_eq_true_or_eq_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : ((a || b) = true) = (a = true âˆ¨ b = true)",
  "args": "(a b : Bool)"},
 {"type": "(not a = true) = (a = false)",
  "tactic-prompt":
  "theorem (a : Bool) : (not a = true) = (a = false) := by cases a; sorry",
  "name": "not_eq_true_eq_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Bool) : (not a = true) = (a = false)",
  "args": "(a : Bool)"},
 {"type": "((a && b) = false) = (a = false âˆ¨ b = false)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a && b) = false) = (a = false âˆ¨ b = false) := by cases a; sorry",
  "name": "and_eq_false_eq_eq_false_or_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : ((a && b) = false) = (a = false âˆ¨ b = false)",
  "args": "(a b : Bool)"},
 {"type": "((a || b) = false) = (a = false âˆ§ b = false)",
  "tactic-prompt":
  "theorem (a b : Bool) : ((a || b) = false) = (a = false âˆ§ b = false) := by cases a; sorry",
  "name": "or_eq_false_eq_eq_false_and_eq_false",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : ((a || b) = false) = (a = false âˆ§ b = false)",
  "args": "(a b : Bool)"},
 {"type": "(not a = false) = (a = true)",
  "tactic-prompt":
  "theorem (a : Bool) : (not a = false) = (a = true) := by cases a; sorry",
  "name": "not_eq_false_eq_eq_true",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Bool) : (not a = false) = (a = true)",
  "args": "(a : Bool)"},
 {"type": "â†‘false = False",
  "tactic-prompt": "theorem  : â†‘false = False := by simp; sorry",
  "name": "coe_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : â†‘false = False",
  "args": ""},
 {"type": "â†‘true = True",
  "tactic-prompt": "theorem  : â†‘true = True := by simp; sorry",
  "name": "coe_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : â†‘true = True",
  "args": ""},
 {"type": "(â†¥false : Prop) = False",
  "tactic-prompt": "theorem  : (â†¥false : Prop) = False := by simp; sorry",
  "name": "coe_sort_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : (â†¥false : Prop) = False",
  "args": ""},
 {"type": "(â†¥true : Prop) = True",
  "tactic-prompt": "theorem  : (â†¥true : Prop) = True := by simp; sorry",
  "name": "coe_sort_true",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : (â†¥true : Prop) = True",
  "args": ""},
 {"type": "decide p = true â†” p",
  "tactic-prompt":
  "theorem (p : Prop)  [d : Decidable p] : decide p = true â†” p := by simp; sorry",
  "name": "decide_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(p : Prop)  [d : Decidable p] : decide p = true â†” p",
  "args": "(p : Prop)  [d : Decidable p]"},
 {"type": "Â¬b â†” b = false",
  "tactic-prompt": "theorem {b : Bool} : Â¬b â†” b = false := by cases b; sorry",
  "name": "bool_iff_false",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "{b : Bool} : Â¬b â†” b = false",
  "args": "{b : Bool}"},
 {"type": "decide p = decide q",
  "tactic-prompt":
  "theorem {p q : Prop}  [Decidable p]  [Decidable q]  (h : p â†” q) : decide p = decide q := by cases h' : decide q; sorry",
  "name": "decide_congr",
  "kind": "theorem",
  "first-tactic": "cases h' : decide q",
  "core-prompt":
  "{p q : Prop}  [Decidable p]  [Decidable q]  (h : p â†” q) : decide p = decide q",
  "args": "{p q : Prop}  [Decidable p]  [Decidable q]  (h : p â†” q)"},
 {"type": "a || b â†” a âˆ¨ b",
  "tactic-prompt": "theorem (a b : Bool) : a || b â†” a âˆ¨ b := by simp; sorry",
  "name": "or_coe_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : a || b â†” a âˆ¨ b",
  "args": "(a b : Bool)"},
 {"type": "a && b â†” a âˆ§ b",
  "tactic-prompt": "theorem (a b : Bool) : a && b â†” a âˆ§ b := by simp; sorry",
  "name": "and_coe_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Bool) : a && b â†” a âˆ§ b",
  "args": "(a b : Bool)"},
 {"type": "xor a b â†” Xor' (a = true) (b = true)",
  "tactic-prompt":
  "theorem (a b : Bool) : xor a b â†” Xor' (a = true) (b = true) := by cases a; sorry",
  "name": "xor_coe_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Bool) : xor a b â†” Xor' (a = true) (b = true)",
  "args": "(a b : Bool)"},
 {"type": "((if c then a else b) = true) = if c then a = true else b = true",
  "tactic-prompt":
  "theorem (c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = true) = if c then a = true else b = true := by by_cases c; sorry",
  "name": "ite_eq_true_distrib",
  "kind": "theorem",
  "first-tactic": "by_cases c",
  "core-prompt":
  "(c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = true) = if c then a = true else b = true",
  "args": "(c : Prop)  [Decidable c]  (a b : Bool)"},
 {"type": "((if c then a else b) = false) = if c then a = false else b = false",
  "tactic-prompt":
  "theorem (c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = false) = if c then a = false else b = false := by by_cases c; sorry",
  "name": "ite_eq_false_distrib",
  "kind": "theorem",
  "first-tactic": "by_cases c",
  "core-prompt":
  "(c : Prop)  [Decidable c]  (a b : Bool) : ((if c then a else b) = false) = if c then a = false else b = false",
  "args": "(c : Prop)  [Decidable c]  (a b : Bool)"},
 {"type": "length (Â«repeatÂ»  a n) = n",
  "tactic-prompt":
  "theorem (a : Î±)  (n : â„•) : length (Â«repeatÂ»  a n) = n := by induction n; sorry",
  "name": "length_repeat",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(a : Î±)  (n : â„•) : length (Â«repeatÂ»  a n) = n",
  "args": "(a : Î±)  (n : â„•)"},
 {"type": "(Ïƒ ^ m) ((Ïƒ ^ n) x) = (Ïƒ ^ n) ((Ïƒ ^ m) x)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} {Î± : Type _}  (Ïƒ : Perm Î±)  (m n : â„¤)  {x : Î±} : (Ïƒ ^ m) ((Ïƒ ^ n) x) = (Ïƒ ^ n) ((Ïƒ ^ m) x) := by rw [â† Equiv.Perm.mul_apply]; sorry",
  "name": "zpow_apply_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† Equiv.Perm.mul_apply]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} {Î± : Type _}  (Ïƒ : Perm Î±)  (m n : â„¤)  {x : Î±} : (Ïƒ ^ m) ((Ïƒ ^ n) x) = (Ïƒ ^ n) ((Ïƒ ^ m) x)",
  "args":
  "{Î± : Type u}  {Î² : Type v} {Î± : Type _}  (Ïƒ : Perm Î±)  (m n : â„¤)  {x : Î±}"},
 {"type": "Function.Injective (sumCongrHom Î± Î²)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} {Î± Î² : Type _} : Function.Injective (sumCongrHom Î± Î²) := by rintro âŸ¨âŸ© âŸ¨âŸ© h; sorry",
  "name": "sumCongrHom_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} {Î± Î² : Type _} : Function.Injective (sumCongrHom Î± Î²)",
  "args": "{Î± : Type u}  {Î² : Type v} {Î± Î² : Type _}"},
 {"type": "Function.Injective (sigmaCongrRightHom Î²)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} {Î± : Type _}  {Î² : Î± â†’ Type _} : Function.Injective (sigmaCongrRightHom Î²) := by intro x y h; sorry",
  "name": "sigmaCongrRightHom_injective",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} {Î± : Type _}  {Î² : Î± â†’ Type _} : Function.Injective (sigmaCongrRightHom Î²)",
  "args": "{Î± : Type u}  {Î² : Type v} {Î± : Type _}  {Î² : Î± â†’ Type _}"},
 {"type": "Function.Injective (subtypeCongrHom p)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} (p : Î± â†’ Prop)  [DecidablePred p] : Function.Injective (subtypeCongrHom p) := by rintro âŸ¨âŸ© âŸ¨âŸ© h; sorry",
  "name": "subtypeCongrHom_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} (p : Î± â†’ Prop)  [DecidablePred p] : Function.Injective (subtypeCongrHom p)",
  "args": "{Î± : Type u}  {Î² : Type v} (p : Î± â†’ Prop)  [DecidablePred p]"},
 {"type": "f * swap x y = swap (f x) (f y) * f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±) : f * swap x y = swap (f x) (f y) * f := by rw [swap_mul_eq_mul_swap]; sorry",
  "name": "mul_swap_eq_swap_mul",
  "kind": "theorem",
  "first-tactic": "rw [swap_mul_eq_mul_swap]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±) : f * swap x y = swap (f x) (f y) * f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±)"},
 {"type": "swap (f x) (f y) = f * swap x y * fâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±) : swap (f x) (f y) = f * swap x y * fâ»Â¹ := by rw [mul_swap_eq_swap_mul]; sorry",
  "name": "swap_apply_apply",
  "kind": "theorem",
  "first-tactic": "rw [mul_swap_eq_swap_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±) : swap (f x) (f y) = f * swap x y * fâ»Â¹",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (f : Perm Î±)  (x y : Î±)"},
 {"type": "Equiv.swap i j * (Equiv.swap i j * Ïƒ) = Ïƒ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±) : Equiv.swap i j * (Equiv.swap i j * Ïƒ) = Ïƒ := by rw [â† mul_assoc]; sorry",
  "name": "swap_mul_self_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±) : Equiv.swap i j * (Equiv.swap i j * Ïƒ) = Ïƒ",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±)"},
 {"type": "Ïƒ * Equiv.swap i j * Equiv.swap i j = Ïƒ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±) : Ïƒ * Equiv.swap i j * Equiv.swap i j = Ïƒ := by rw [mul_assoc]; sorry",
  "name": "mul_swap_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±) : Ïƒ * Equiv.swap i j * Equiv.swap i j = Ïƒ",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [DecidableEq Î±] (i j : Î±)  (Ïƒ : Perm Î±)"},
 {"type": "eâ‚ = eâ‚‚",
  "tactic-prompt":
  "theorem {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚) : eâ‚ = eâ‚‚ := by simpa only [hâ‚.left_id]; sorry",
  "name": "one",
  "kind": "theorem",
  "first-tactic": "simpa only [hâ‚.left_id]",
  "core-prompt":
  "{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚) : eâ‚ = eâ‚‚",
  "args":
  "{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚)"},
 {"type": "mâ‚ = mâ‚‚",
  "tactic-prompt":
  "theorem {X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚) : mâ‚ = mâ‚‚ := by funext a b; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "funext a b",
  "core-prompt":
  "{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚) : mâ‚ = mâ‚‚",
  "args":
  "{X : Type u} {mâ‚ mâ‚‚ : X â†’ X â†’ X}  {eâ‚ eâ‚‚ : X} (hâ‚ : IsUnital mâ‚ eâ‚)  (hâ‚‚ : IsUnital mâ‚‚ eâ‚‚)"},
 {"type": "(a â€¢ b) â€¢ c â€¢ d = (a â€¢ c) â€¢ b â€¢ d",
  "tactic-prompt":
  "theorem {M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul Î± Î²]  [SMul Î± Î³]  [SMul Î² Î´]  [SMul Î± Î´]  [SMul Î³ Î´]      [IsScalarTower Î± Î² Î´]  [IsScalarTower Î± Î³ Î´]  [SMulCommClass Î² Î³ Î´]  (a : Î±)  (b : Î²)  (c : Î³)      (d : Î´) : (a â€¢ b) â€¢ c â€¢ d = (a â€¢ c) â€¢ b â€¢ d := by rw [smul_assoc]; sorry",
  "name": "smul_smul_smul_comm",
  "kind": "theorem",
  "first-tactic": "rw [smul_assoc]",
  "core-prompt":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul Î± Î²]  [SMul Î± Î³]  [SMul Î² Î´]  [SMul Î± Î´]  [SMul Î³ Î´]      [IsScalarTower Î± Î² Î´]  [IsScalarTower Î± Î³ Î´]  [SMulCommClass Î² Î³ Î´]  (a : Î±)  (b : Î²)  (c : Î³)      (d : Î´) : (a â€¢ b) â€¢ c â€¢ d = (a â€¢ c) â€¢ b â€¢ d",
  "args":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul Î± Î²]  [SMul Î± Î³]  [SMul Î² Î´]  [SMul Î± Î´]  [SMul Î³ Î´]      [IsScalarTower Î± Î² Î´]  [IsScalarTower Î± Î³ Î´]  [SMulCommClass Î² Î³ Î´]  (a : Î±)  (b : Î²)  (c : Î³)      (d : Î´)"},
 {"type": "ite p aâ‚ aâ‚‚ â€¢ b = ite p (aâ‚ â€¢ b) (aâ‚‚ â€¢ b)",
  "tactic-prompt":
  "theorem {M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (aâ‚ aâ‚‚ : M)  (b : Î±) : ite p aâ‚ aâ‚‚ â€¢ b = ite p (aâ‚ â€¢ b) (aâ‚‚ â€¢ b) := by split_ifs; sorry",
  "name": "ite_smul",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (aâ‚ aâ‚‚ : M)  (b : Î±) : ite p aâ‚ aâ‚‚ â€¢ b = ite p (aâ‚ â€¢ b) (aâ‚‚ â€¢ b)",
  "args":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (aâ‚ aâ‚‚ : M)  (b : Î±)"},
 {"type": "a â€¢ ite p bâ‚ bâ‚‚ = ite p (a â€¢ bâ‚) (a â€¢ bâ‚‚)",
  "tactic-prompt":
  "theorem {M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (a : M)  (bâ‚ bâ‚‚ : Î±) : a â€¢ ite p bâ‚ bâ‚‚ = ite p (a â€¢ bâ‚) (a â€¢ bâ‚‚) := by split_ifs; sorry",
  "name": "smul_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (a : M)  (bâ‚ bâ‚‚ : Î±) : a â€¢ ite p bâ‚ bâ‚‚ = ite p (a â€¢ bâ‚) (a â€¢ bâ‚‚)",
  "args":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [SMul M Î±]  (p : Prop)  [Decidable p] (a : M)  (bâ‚ bâ‚‚ : Î±)"},
 {"type": "r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y)",
  "tactic-prompt":
  "theorem {M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [MulAction M Î±]  [Mul Î±]  (r s : M)  (x y : Î±)  [IsScalarTower M Î± Î±]  [SMulCommClass M Î± Î±] : r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y) := by rw [smul_mul_assoc]; sorry",
  "name": "smul_mul_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_mul_assoc]",
  "core-prompt":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [MulAction M Î±]  [Mul Î±]  (r s : M)  (x y : Î±)  [IsScalarTower M Î± Î±]  [SMulCommClass M Î± Î±] : r â€¢ x * s â€¢ y = (r * s) â€¢ (x * y)",
  "args":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [MulAction M Î±]  [Mul Î±]  (r s : M)  (x y : Î±)  [IsScalarTower M Î± Î±]  [SMulCommClass M Î± Î±]"},
 {"type": "r â€¢ (x - y) = r â€¢ x - r â€¢ y",
  "tactic-prompt":
  "theorem {M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A) : r â€¢ (x - y) = r â€¢ x - r â€¢ y := by rw [sub_eq_add_neg]; sorry",
  "name": "smul_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A) : r â€¢ (x - y) = r â€¢ x - r â€¢ y",
  "args":
  "{M N G A B Î± Î² Î³ Î´ : Type _} [SMul M Î±]  [Monoid M]  [AddGroup A]  [DistribMulAction M A] (r : M)  (x y : A)"},
 {"type": "câ»Â¹ â€¢ c â€¢ x = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²) : câ»Â¹ â€¢ c â€¢ x = x := by rw [smul_smul]; sorry",
  "name": "inv_smul_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_smul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²) : câ»Â¹ â€¢ c â€¢ x = x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²)"},
 {"type": "c â€¢ câ»Â¹ â€¢ x = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²) : c â€¢ câ»Â¹ â€¢ x = x := by rw [smul_smul]; sorry",
  "name": "smul_inv_smul",
  "kind": "theorem",
  "first-tactic": "rw [smul_smul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²) : c â€¢ câ»Â¹ â€¢ x = x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] (c : Î±)  (x : Î²)"},
 {"type": "(c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²) : (c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹ := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "smul_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²) : (c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²)"},
 {"type": "(c â€¢ x) ^ p = c ^ p â€¢ x ^ p",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²)  (p : â„¤) : (c â€¢ x) ^ p = c ^ p â€¢ x ^ p := by cases p; sorry",
  "name": "smul_zpow",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²)  (p : â„¤) : (c â€¢ x) ^ p = c ^ p â€¢ x ^ p",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Group Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²)  (p : â„¤)"},
 {"type": "Commute (r â€¢ a) b â†” Commute a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Mul Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  {a b : Î²}      (r : Î±) : Commute (r â€¢ a) b â†” Commute a b := by rw [Commute.symm_iff]; sorry",
  "name": "Commute.smul_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Commute.symm_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Mul Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  {a b : Î²}      (r : Î±) : Commute (r â€¢ a) b â†” Commute a b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}   [Group Î±]  [MulAction Î± Î²] [Mul Î²]  [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  {a b : Î²}      (r : Î±)"},
 {"type": "IsUnit (r â€¢ (1 : Î²) - a) â†” IsUnit (1 - râ»Â¹ â€¢ a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Group Î±]  [Monoid Î²] [AddGroup Î²]  [DistribMulAction Î± Î²]  [IsScalarTower Î± Î² Î²]      [SMulCommClass Î± Î² Î²]  (r : Î±)  (a : Î²) : IsUnit (r â€¢ (1 : Î²) - a) â†” IsUnit (1 - râ»Â¹ â€¢ a) := by rw [â† is_unit_smul_iff r (1 - râ»Â¹ â€¢ a)]; sorry",
  "name": "IsUnit.smul_sub_iff_sub_inv_smul",
  "kind": "theorem",
  "first-tactic": "rw [â† is_unit_smul_iff r (1 - râ»Â¹ â€¢ a)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Group Î±]  [Monoid Î²] [AddGroup Î²]  [DistribMulAction Î± Î²]  [IsScalarTower Î± Î² Î²]      [SMulCommClass Î± Î² Î²]  (r : Î±)  (a : Î²) : IsUnit (r â€¢ (1 : Î²) - a) â†” IsUnit (1 - râ»Â¹ â€¢ a)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Group Î±]  [Monoid Î²] [AddGroup Î²]  [DistribMulAction Î± Î²]  [IsScalarTower Î± Î² Î²]      [SMulCommClass Î± Î² Î²]  (r : Î±)  (a : Î²)"},
 {"type": "a â€¢ ((0 : Î±), c) = (0, a â€¢ c)",
  "tactic-prompt":
  "theorem {M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î± : Type _}  [Monoid M]  [AddMonoid Î±]  [DistribMulAction M Î±]  (a : M)  (c : Î²) : a â€¢ ((0 : Î±), c) = (0, a â€¢ c) := by rw [Prod.smul_mk]; sorry",
  "name": "smul_zero_mk",
  "kind": "theorem",
  "first-tactic": "rw [Prod.smul_mk]",
  "core-prompt":
  "{M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î± : Type _}  [Monoid M]  [AddMonoid Î±]  [DistribMulAction M Î±]  (a : M)  (c : Î²) : a â€¢ ((0 : Î±), c) = (0, a â€¢ c)",
  "args":
  "{M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î± : Type _}  [Monoid M]  [AddMonoid Î±]  [DistribMulAction M Î±]  (a : M)  (c : Î²)"},
 {"type": "a â€¢ (b, (0 : Î²)) = (a â€¢ b, 0)",
  "tactic-prompt":
  "theorem {M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î² : Type _}  [Monoid M]  [AddMonoid Î²]  [DistribMulAction M Î²]  (a : M)  (b : Î±) : a â€¢ (b, (0 : Î²)) = (a â€¢ b, 0) := by rw [Prod.smul_mk]; sorry",
  "name": "smul_mk_zero",
  "kind": "theorem",
  "first-tactic": "rw [Prod.smul_mk]",
  "core-prompt":
  "{M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î² : Type _}  [Monoid M]  [AddMonoid Î²]  [DistribMulAction M Î²]  (a : M)  (b : Î±) : a â€¢ (b, (0 : Î²)) = (a â€¢ b, 0)",
  "args":
  "{M N P E Î± Î² : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (x : Î± Ã— Î²) {Î² : Type _}  [Monoid M]  [AddMonoid Î²]  [DistribMulAction M Î²]  (a : M)  (b : Î±)"},
 {"type": "(a â€¢ x).swap = a â€¢ x.swap",
  "tactic-prompt":
  "theorem {M N P Î± Î² Î³ : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (b : Î±)  (c : Î²)    (x : Sum Î± Î²) : (a â€¢ x).swap = a â€¢ x.swap := by cases x; sorry",
  "name": "smul_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{M N P Î± Î² Î³ : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (b : Î±)  (c : Î²)    (x : Sum Î± Î²) : (a â€¢ x).swap = a â€¢ x.swap",
  "args":
  "{M N P Î± Î² Î³ : Type _}  [SMul M Î±]  [SMul M Î²]  [SMul N Î±]  [SMul N Î²]  (a : M)  (b : Î±)  (c : Î²)    (x : Sum Î± Î²)"},
 {"type": "(c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹",
  "tactic-prompt":
  "theorem {R R' M M' : Type _}  {Î± Î² : Type _}  [GroupWithZero Î±]  [GroupWithZero Î²]  [MulActionWithZero Î± Î²] [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²) : (c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹ := by obtain rfl | hc := eq_or_ne c 0; sorry",
  "name": "smul_invâ‚€",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hc := eq_or_ne c 0",
  "core-prompt":
  "{R R' M M' : Type _}  {Î± Î² : Type _}  [GroupWithZero Î±]  [GroupWithZero Î²]  [MulActionWithZero Î± Î²] [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²) : (c â€¢ x)â»Â¹ = câ»Â¹ â€¢ xâ»Â¹",
  "args":
  "{R R' M M' : Type _}  {Î± Î² : Type _}  [GroupWithZero Î±]  [GroupWithZero Î²]  [MulActionWithZero Î± Î²] [SMulCommClass Î± Î² Î²]  [IsScalarTower Î± Î² Î²]  (c : Î±)  (x : Î²)"},
 {"type": "(n : R) = 0 â†” n = 0",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] {n : â„•} : (n : R) = 0 â†” n = 0 := by rw [â† cast_zero]; sorry",
  "name": "cast_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_zero]",
  "core-prompt":
  "[AddMonoidWithOne R]  [CharZero R] {n : â„•} : (n : R) = 0 â†” n = 0",
  "args": "[AddMonoidWithOne R]  [CharZero R] {n : â„•}"},
 {"type": "(n + 1 : R) â‰  0",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] (n : â„•) : (n + 1 : R) â‰  0 := by norm_cast; sorry",
  "name": "cast_add_one_ne_zero",
  "kind": "theorem",
  "first-tactic": "norm_cast",
  "core-prompt": "[AddMonoidWithOne R]  [CharZero R] (n : â„•) : (n + 1 : R) â‰  0",
  "args": "[AddMonoidWithOne R]  [CharZero R] (n : â„•)"},
 {"type": "(n : R) = 1 â†” n = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [CharZero R] {n : â„•} : (n : R) = 1 â†” n = 1 := by rw [â† cast_one]; sorry",
  "name": "cast_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_one]",
  "core-prompt":
  "[AddMonoidWithOne R]  [CharZero R] {n : â„•} : (n : R) = 1 â†” n = 1",
  "args": "[AddMonoidWithOne R]  [CharZero R] {n : â„•}"},
 {"type": "((Â· * a)^[n]) 1 = a ^ n",
  "tactic-prompt":
  "theorem {M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R â†’+* R)  (n : â„•)  (x y : R)  [Monoid G]  (a : G)  (n : â„•) : ((Â· * a)^[n]) 1 = a ^ n := by simp [mul_right_iterate]; sorry",
  "name": "mul_right_iterate_apply_one",
  "kind": "theorem",
  "first-tactic": "simp [mul_right_iterate]",
  "core-prompt":
  "{M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R â†’+* R)  (n : â„•)  (x y : R)  [Monoid G]  (a : G)  (n : â„•) : ((Â· * a)^[n]) 1 = a ^ n",
  "args":
  "{M : Type _}  {N : Type _}  {G : Type _}  {H : Type _} [Monoid M]  [Monoid N]  [Group G]  [Group H] [AddMonoid M]  [AddGroup G] {R : Type _}  [Ring R]  (f : R â†’+* R)  (n : â„•)  (x y : R)  [Monoid G]  (a : G)  (n : â„•)"},
 {"type": "Î± â†’â‚™+* Î±",
  "tactic-prompt":
  "def {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (Î± : Type _)  [NonUnitalNonAssocSemiring Î±] : Î± â†’â‚™+* Î± := by refine' { toFun := id.. }; sorry",
  "name": "id",
  "kind": "def",
  "first-tactic": "refine' { toFun := id.. }",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (Î± : Type _)  [NonUnitalNonAssocSemiring Î±] : Î± â†’â‚™+* Î±",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (Î± : Type _)  [NonUnitalNonAssocSemiring Î±]"},
 {"type": "g.comp (0 : Î± â†’â‚™+* Î²) = 0",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) : g.comp (0 : Î± â†’â‚™+* Î²) = 0 := by ext; sorry",
  "name": "comp_zero",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³) : g.comp (0 : Î± â†’â‚™+* Î²) = 0",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (g : Î² â†’â‚™+* Î³)"},
 {"type": "(0 : Î² â†’â‚™+* Î³).comp f = 0",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (f : Î± â†’â‚™+* Î²) : (0 : Î² â†’â‚™+* Î³).comp f = 0 := by ext; sorry",
  "name": "zero_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (f : Î± â†’â‚™+* Î²) : (0 : Î² â†’â‚™+* Î³).comp f = 0",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (f : Î± â†’â‚™+* Î²)"},
 {"type": "(f.toMonoidWithZeroHom : Î± â†’ Î²) = f",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  (f : Î± â†’+* Î²) : (f.toMonoidWithZeroHom : Î± â†’ Î²) = f := by rfl; sorry",
  "name": "toMonoidWithZeroHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  (f : Î± â†’+* Î²) : (f.toMonoidWithZeroHom : Î± â†’ Î²) = f",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  (f : Î± â†’+* Î²)"},
 {"type": "f (ite p 0 1) = ite p 0 1",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 0 1) = ite p 0 1 := by split_ifs with h; sorry",
  "name": "map_ite_zero_one",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 0 1) = ite p 0 1",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p]"},
 {"type": "f (ite p 1 0) = ite p 1 0",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 1 0) = ite p 1 0 := by split_ifs with h; sorry",
  "name": "map_ite_one_zero",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p] : f (ite p 1 0) = ite p 1 0",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)  {F : Type _}  [RingHomClass F Î± Î²]  (f : F)  (p : Prop)  [Decidable p]"},
 {"type": "(0 : Î²) = 1 â†” f 1 = 0",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) : (0 : Î²) = 1 â†” f 1 = 0 := by rw [map_one]; sorry",
  "name": "codomain_trivial_iff_map_one_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [map_one]",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) : (0 : Î²) = 1 â†” f 1 = 0",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²)"},
 {"type": "Î± â†’+* Î±",
  "tactic-prompt":
  "def {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (Î± : Type _)  [NonAssocSemiring Î±] : Î± â†’+* Î± := by refine' { toFun := _root_.id.. }; sorry",
  "name": "id",
  "kind": "def",
  "first-tactic": "refine' { toFun := _root_.id.. }",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (Î± : Type _)  [NonAssocSemiring Î±] : Î± â†’+* Î±",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) (Î± : Type _)  [NonAssocSemiring Î±]"},
 {"type": "IsDomain Î²",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) [Ring Î±]  [IsDomain Î±]  [Ring Î²]  (f : Î² â†’+* Î±)      (hf : Injective f) : IsDomain Î² := by haveI := pullback_nonzero f f.map_zero f.map_one; sorry",
  "name": "Function.Injective.isDomain",
  "kind": "theorem",
  "first-tactic": "haveI := pullback_nonzero f f.map_zero f.map_one",
  "core-prompt":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) [Ring Î±]  [IsDomain Î±]  [Ring Î²]  (f : Î² â†’+* Î±)      (hf : Injective f) : IsDomain Î²",
  "args":
  "{F Î± Î² Î³ : Type _} [NonUnitalNonAssocSemiring Î±]  [NonUnitalNonAssocSemiring Î²] (g : Î² â†’â‚™+* Î³)  (f : Î± â†’â‚™+* Î²) [Ring Î±]  [IsDomain Î±]  [Ring Î²]  (f : Î² â†’+* Î±)      (hf : Injective f)"},
 {"type": "Group (MulAut M)",
  "tactic-prompt":
  "instance {A : Type _}  {M : Type _}  {G : Type _} : Group (MulAut M) := by refine'\n            { mul := fun g h => MulEquiv.trans h g\n              one := MulEquiv.refl M\n              inv := MulEquiv.symm\n              div := fun g h => MulEquiv.trans h.symm g\n              npow := @npowRec _ âŸ¨MulEquiv.refl MâŸ© âŸ¨fun g h => MulEquiv.trans h gâŸ©\n              zpow := @zpowRec _ âŸ¨MulEquiv.refl MâŸ© âŸ¨fun g h => MulEquiv.trans h gâŸ© âŸ¨MulEquiv.symmâŸ©\n              .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine'\n            { mul := fun g h => MulEquiv.trans h g\n              one := MulEquiv.refl M\n              inv := MulEquiv.symm\n              div := fun g h => MulEquiv.trans h.symm g\n              npow := @npowRec _ âŸ¨MulEquiv.refl MâŸ© âŸ¨fun g h => MulEquiv.trans h gâŸ©\n              zpow := @zpowRec _ âŸ¨MulEquiv.refl MâŸ© âŸ¨fun g h => MulEquiv.trans h gâŸ© âŸ¨MulEquiv.symmâŸ©\n              .. }",
  "core-prompt": "{A : Type _}  {M : Type _}  {G : Type _} : Group (MulAut M)",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "MulAut M â†’* Equiv.Perm M",
  "tactic-prompt":
  "def {A : Type _}  {M : Type _}  {G : Type _} : MulAut M â†’* Equiv.Perm M := by refine' { toFun := MulEquiv.toEquiv, ..}; sorry",
  "name": "toPerm",
  "kind": "def",
  "first-tactic": "refine' { toFun := MulEquiv.toEquiv, ..}",
  "core-prompt":
  "{A : Type _}  {M : Type _}  {G : Type _} : MulAut M â†’* Equiv.Perm M",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "Group (AddAut A)",
  "tactic-prompt":
  "instance {A : Type _}  {M : Type _}  {G : Type _} : Group (AddAut A) := by refine'\n            { mul := fun g h => AddEquiv.trans h g\n              one := AddEquiv.refl A\n              inv := AddEquiv.symm\n              div := fun g h => AddEquiv.trans h.symm g\n              npow := @npowRec _ âŸ¨AddEquiv.refl AâŸ© âŸ¨fun g h => AddEquiv.trans h gâŸ©\n              zpow := @zpowRec _ âŸ¨AddEquiv.refl AâŸ© âŸ¨fun g h => AddEquiv.trans h gâŸ© âŸ¨AddEquiv.symmâŸ©\n              .. }; sorry",
  "name": "group",
  "kind": "instance",
  "first-tactic":
  "refine'\n            { mul := fun g h => AddEquiv.trans h g\n              one := AddEquiv.refl A\n              inv := AddEquiv.symm\n              div := fun g h => AddEquiv.trans h.symm g\n              npow := @npowRec _ âŸ¨AddEquiv.refl AâŸ© âŸ¨fun g h => AddEquiv.trans h gâŸ©\n              zpow := @zpowRec _ âŸ¨AddEquiv.refl AâŸ© âŸ¨fun g h => AddEquiv.trans h gâŸ© âŸ¨AddEquiv.symmâŸ©\n              .. }",
  "core-prompt": "{A : Type _}  {M : Type _}  {G : Type _} : Group (AddAut A)",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "AddAut A â†’* Equiv.Perm A",
  "tactic-prompt":
  "def {A : Type _}  {M : Type _}  {G : Type _} : AddAut A â†’* Equiv.Perm A := by refine' { toFun := AddEquiv.toEquiv, .. }; sorry",
  "name": "toPerm",
  "kind": "def",
  "first-tactic": "refine' { toFun := AddEquiv.toEquiv, .. }",
  "core-prompt":
  "{A : Type _}  {M : Type _}  {G : Type _} : AddAut A â†’* Equiv.Perm A",
  "args": "{A : Type _}  {M : Type _}  {G : Type _}"},
 {"type": "SemiconjBy (f a) (f x) (f y)",
  "tactic-prompt":
  "theorem {F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F) : SemiconjBy (f a) (f x) (f y) := by simpa only [SemiconjBy]; sorry",
  "name": "SemiconjBy.map",
  "kind": "theorem",
  "first-tactic": "simpa only [SemiconjBy]",
  "core-prompt":
  "{F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F) : SemiconjBy (f a) (f x) (f y)",
  "args":
  "{F M N : Type _}  [Mul M]  [Mul N]  {a x y : M} [MulHomClass F M N]  (h : SemiconjBy a x y)  (f : F)"},
 {"type": "map (MonoidHom.id M) = MonoidHom.id MË£",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] : map (MonoidHom.id M) = MonoidHom.id MË£ := by ext; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] : map (MonoidHom.id M) = MonoidHom.id MË£",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]"},
 {"type": "a /â‚š u = a / u",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid Î±] (a : Î±)  (u : Î±Ë£) : a /â‚š u = a / u := by rw [div_eq_mul_inv]; sorry",
  "name": "_root_.divp_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid Î±] (a : Î±)  (u : Î±Ë£) : a /â‚š u = a / u",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P]  [DivisionMonoid Î±] (a : Î±)  (u : Î±Ë£)"},
 {"type": "IsUnit (f x)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x) : IsUnit (f x) := by rcases h with âŸ¨y, rflâŸ©; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨y, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x) : IsUnit (f x)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  (f : F)  {x : M}  (h : IsUnit x)"},
 {"type": "IsUnit x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x)) : IsUnit x := by simpa only [hfg x] using h.map g; sorry",
  "name": "of_leftInverse",
  "kind": "theorem",
  "first-tactic": "simpa only [hfg x] using h.map g",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x)) : IsUnit x",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [Monoid M]  [Monoid N] [MonoidHomClass F M N]  [MonoidHomClass G N M]  {f : F}  {x : M}  (g : G)    (hfg : Function.LeftInverse g f)  (h : IsUnit (f x))"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : a / a = 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±) : a / b * b = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±) : a * b / b = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)  (a : Î±)"},
 {"type": "a * (1 / a) = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : a * (1 / a) = 1 := by simp [h]; sorry",
  "name": "mul_one_div_cancel",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : a * (1 / a) = 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a)"},
 {"type": "1 / a * a = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : 1 / a * a = 1 := by simp [h]; sorry",
  "name": "one_div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : 1 / a * a = 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a)"},
 {"type": "IsUnit aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : IsUnit aâ»Â¹ := by rcases h with âŸ¨u, huâŸ©; sorry",
  "name": "inv",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨u, huâŸ©",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a) : IsUnit aâ»Â¹",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit a)"},
 {"type": "IsUnit (a / b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (ha : IsUnit a)  (hb : IsUnit b) : IsUnit (a / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (ha : IsUnit a)  (hb : IsUnit b) : IsUnit (a / b)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "a / c = b / c â†” a = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c) : a / c = b / c â†” a = b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c) : a / c = b / c â†” a = b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c)"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b) : a / b = c â†” a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b) : a / b = c â†” a = c * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)"},
 {"type": "a = b / c â†” a * c = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c) : a = b / c â†” a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c) : a = b / c â†” a * c = b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c)"},
 {"type": "b / (a * b) = 1 / a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b) : b / (a * b) = 1 / a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b) : b / (a * b) = 1 / a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit b)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c)  (a b : Î±) : a * c / (b * c) = a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_right",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c)  (a b : Î±) : a * c / (b * c) = a / b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : IsUnit c)  (a b : Î±)"},
 {"type": "a * b * (1 / b) = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (a : Î±)  (h : IsUnit b) : a * b * (1 / b) = a := by simp [h]; sorry",
  "name": "mul_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (a : Î±)  (h : IsUnit b) : a * b * (1 / b) = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (a : Î±)  (h : IsUnit b)"},
 {"type": "a / (a * b) = 1 / b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a / (a * b) = 1 / b := by rw [mul_comm]; sorry",
  "name": "div_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a / (a * b) = 1 / b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±)"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a * b / a = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a * b / a = b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a * (b / a) = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±) : a * (b / a) = b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)  (b : Î±)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit c)  (a b : Î±) : c * a / (c * b) = a / b := by rw [mul_comm c]; sorry",
  "name": "mul_div_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit c)  (a b : Î±) : c * a / (c * b) = a / b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit c)  (a b : Î±)"},
 {"type": "a * d = c * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d)    (a c : Î±)  (h : a / b = c / d) : a * d = c * b := by rw [â† mul_one a]; sorry",
  "name": "mul_eq_mul_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_one a]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d)    (a c : Î±)  (h : a / b = c / d) : a * d = c * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d)    (a c : Î±)  (h : a / b = c / d)"},
 {"type": "a / b = c / d â†” a * d = c * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d) : a / b = c / d â†” a * d = c * b := by rw [â† (hb.mul hd).mul_left_inj]; sorry",
  "name": "div_eq_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† (hb.mul hd).mul_left_inj]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d) : a / b = c / d â†” a * d = c * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (hb : IsUnit b)  (hd : IsUnit d)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a) : a / (a / b) = b := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a) : a / (a / b) = b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {P : Type w}  [Monoid M]  [Monoid N]  [Monoid P] {F G Î± M N : Type _}  [DivisionCommMonoid Î±]  {a b c d : Î±} (h : IsUnit a)"},
 {"type": "f a * f b = 1",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1) : f a * f b = 1 := by rw [â† map_mul]; sorry",
  "name": "map_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [â† map_mul]",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1) : f a * f b = 1",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [MonoidHomClass F M N]  (f : F)  {a b : M}  (h : a * b = 1)"},
 {"type": "f (a / b) = f a / f b",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : âˆ€ a, f aâ»Â¹ = (f a)â»Â¹)  (a b : G) : f (a / b) = f a / f b := by rw [div_eq_mul_inv]; sorry",
  "name": "map_div'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : âˆ€ a, f aâ»Â¹ = (f a)â»Â¹)  (a b : G) : f (a / b) = f a / f b",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [DivInvMonoid G]  [DivInvMonoid H]  [MonoidHomClass F G H]    (f : F)  (hf : âˆ€ a, f aâ»Â¹ = (f a)â»Â¹)  (a b : G)"},
 {"type": "f (a * bâ»Â¹) = f a * (f b)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G) : f (a * bâ»Â¹) = f a * (f b)â»Â¹ := by rw [map_mul]; sorry",
  "name": "map_mul_inv",
  "kind": "theorem",
  "first-tactic": "rw [map_mul]",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G) : f (a * bâ»Â¹) = f a * (f b)â»Â¹",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulOneClass M]  [MulOneClass N] [Group G]  [DivisionMonoid H]  [MonoidHomClass F G H]  (f : F)  (a b : G)"},
 {"type": "f.comp (1 : OneHom M N) = 1",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P) : f.comp (1 : OneHom M N) = 1 := by ext; sorry",
  "name": "OneHom.comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P) : f.comp (1 : OneHom M N) = 1",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [One M]  [One N]  [One P]  (f : OneHom N P)"},
 {"type": "g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N â†’â‚™* P)  (fâ‚ fâ‚‚ : M â†’â‚™* N) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N â†’â‚™* P)  (fâ‚ fâ‚‚ : M â†’â‚™* N) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Mul M]  [CommSemigroup N]  [CommSemigroup P]  (g : N â†’â‚™* P)  (fâ‚ fâ‚‚ : M â†’â‚™* N)"},
 {"type": "f.comp (1 : M â†’* N) = 1",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N â†’* P) : f.comp (1 : M â†’* N) = 1 := by ext; sorry",
  "name": "comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N â†’* P) : f.comp (1 : M â†’* N) = 1",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [MulOneClass N]  [MulOneClass P]  (f : N â†’* P)"},
 {"type": "g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N â†’* P)  (fâ‚ fâ‚‚ : M â†’* N) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N â†’* P)  (fâ‚ fâ‚‚ : M â†’* N) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [MulOneClass M]  [CommMonoid N]  [CommMonoid P]  (g : N â†’* P)  (fâ‚ fâ‚‚ : M â†’* N)"},
 {"type": "f (g * hâ»Â¹) = f g * (f h)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group Î±]  [DivisionMonoid Î²]  (f : Î± â†’* Î²)  (g h : Î±) : f (g * hâ»Â¹) = f g * (f h)â»Â¹ := by simp; sorry",
  "name": "map_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group Î±]  [DivisionMonoid Î²]  (f : Î± â†’* Î²)  (g h : Î±) : f (g * hâ»Â¹) = f g * (f h)â»Â¹",
  "args":
  "{Î± Î² M N P : Type _}  -- monoids {G : Type _}  {H : Type _}  -- groups {F : Type _}  -- homs  [MulZeroOneClass M]  [MulZeroOneClass N] (A : Type _)  [AddZeroClass A] [Group G]  [CommGroup H] [Group Î±]  [DivisionMonoid Î²]  (f : Î± â†’* Î²)  (g h : Î±)"},
 {"type": "mulLeftEmbedding g = mulRightEmbedding g",
  "tactic-prompt":
  "theorem {R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G) : mulLeftEmbedding g = mulRightEmbedding g := by ext; sorry",
  "name": "mul_left_embedding_eq_mul_right_embedding",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G) : mulLeftEmbedding g = mulRightEmbedding g",
  "args": "{R : Type _}  {G : Type _}  [CancelCommMonoid G]  (g : G)"},
 {"type": "IsRightRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a)) : IsRightRegular b := by refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a)); sorry",
  "name": "IsRightRegular.of_mul",
  "kind": "theorem",
  "first-tactic": "refine' fun x y xy => ab (_ : x * (b * a) = y * (b * a))",
  "core-prompt":
  "{R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a)) : IsRightRegular b",
  "args":
  "{R : Type _}  [Semigroup R]  {a b : R} (ab : IsRightRegular (b * a))"},
 {"type": "IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [Semigroup R]  {a b : R} : IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b := by refine' âŸ¨_, _âŸ©; sorry",
  "name": "isRegular_mul_and_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, _âŸ©",
  "core-prompt":
  "{R : Type _}  [Semigroup R]  {a b : R} : IsRegular (a * b) âˆ§ IsRegular (b * a) â†” IsRegular a âˆ§ IsRegular b",
  "args": "{R : Type _}  [Semigroup R]  {a b : R}"},
 {"type": "Â¬IsLeftRegular (0 : R) â†” Nontrivial R",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} : Â¬IsLeftRegular (0 : R) â†” Nontrivial R := by rw [nontrivial_iff]; sorry",
  "name": "not_isLeftRegular_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} : Â¬IsLeftRegular (0 : R) â†” Nontrivial R",
  "args": "{R : Type _}  [MulZeroClass R]  {a b : R}"},
 {"type": "Â¬IsRightRegular (0 : R) â†” Nontrivial R",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} : Â¬IsRightRegular (0 : R) â†” Nontrivial R := by rw [nontrivial_iff]; sorry",
  "name": "not_isRightRegular_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} : Â¬IsRightRegular (0 : R) â†” Nontrivial R",
  "args": "{R : Type _}  [MulZeroClass R]  {a b : R}"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a) : a â‰  0 := by rintro rfl; sorry",
  "name": "IsLeftRegular.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a) : a â‰  0",
  "args":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (la : IsLeftRegular a)"},
 {"type": "a â‰  0",
  "tactic-prompt":
  "theorem {R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a) : a â‰  0 := by rintro rfl; sorry",
  "name": "IsRightRegular.ne_zero",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a) : a â‰  0",
  "args":
  "{R : Type _}  [MulZeroClass R]  {a b : R} [Nontrivial R]  (ra : IsRightRegular a)"},
 {"type": "IsRegular (a * b) â†” IsRegular a âˆ§ IsRegular b",
  "tactic-prompt":
  "theorem {R : Type _}  [CommSemigroup R]  {a b : R} : IsRegular (a * b) â†” IsRegular a âˆ§ IsRegular b := by refine' Iff.trans _ isRegular_mul_and_mul_iff; sorry",
  "name": "isRegular_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ isRegular_mul_and_mul_iff",
  "core-prompt":
  "{R : Type _}  [CommSemigroup R]  {a b : R} : IsRegular (a * b) â†” IsRegular a âˆ§ IsRegular b",
  "args": "{R : Type _}  [CommSemigroup R]  {a b : R}"},
 {"type": "IsRegular a",
  "tactic-prompt":
  "theorem {R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a) : IsRegular a := by rcases ua with âŸ¨a, rflâŸ©; sorry",
  "name": "IsUnit.isRegular",
  "kind": "theorem",
  "first-tactic": "rcases ua with âŸ¨a, rflâŸ©",
  "core-prompt":
  "{R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a) : IsRegular a",
  "args": "{R : Type _}  [Monoid R]  {a b : R} (ua : IsUnit a)"},
 {"type": "IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b)) : IsSMulRegular M b := by rw [â† smul_eq_mul] at ab; sorry",
  "name": "of_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† smul_eq_mul] at ab",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b)) : IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]  (ab : IsSMulRegular M (a * b))"},
 {"type":
  "IsSMulRegular M (a * b) âˆ§ IsSMulRegular M (b * a) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M] : IsSMulRegular M (a * b) âˆ§ IsSMulRegular M (b * a) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b := by refine' âŸ¨_, _âŸ©; sorry",
  "name": "mul_and_mul_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, _âŸ©",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M] : IsSMulRegular M (a * b) âˆ§ IsSMulRegular M (b * a) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [SMul R M]  [SMul R S]  [SMul S M]  [IsScalarTower R S M] [Mul R]  [IsScalarTower R R M]"},
 {"type": "IsSMulRegular M (a ^ n)",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : â„•)  (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n) := by induction' n with n hn; sorry",
  "name": "pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n hn",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : â„•)  (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n)",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (n : â„•)  (ra : IsSMulRegular M a)"},
 {"type": "IsSMulRegular M (a ^ n) â†” IsSMulRegular M a",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : â„•}  (n0 : 0 < n) : IsSMulRegular M (a ^ n) â†” IsSMulRegular M a := by refine' âŸ¨_, pow nâŸ©; sorry",
  "name": "pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, pow nâŸ©",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : â„•}  (n0 : 0 < n) : IsSMulRegular M (a ^ n) â†” IsSMulRegular M a",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] {n : â„•}  (n0 : 0 < n)"},
 {"type": "Â¬IsSMulRegular M (0 : R) â†” Nontrivial M",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M] : Â¬IsSMulRegular M (0 : R) â†” Nontrivial M := by rw [nontrivial_iff]; sorry",
  "name": "not_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [nontrivial_iff]",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M] : Â¬IsSMulRegular M (0 : R) â†” Nontrivial M",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [MonoidWithZero R]  [MonoidWithZero S]  [Zero M]  [MulActionWithZero R M]    [MulActionWithZero R S]  [MulActionWithZero S M]  [IsScalarTower R S M]"},
 {"type": "IsSMulRegular M (a * b) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M] : IsSMulRegular M (a * b) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b := by rw [â† mul_and_mul_iff]; sorry",
  "name": "mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_and_mul_iff]",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M] : IsSMulRegular M (a * b) â†” IsSMulRegular M a âˆ§ IsSMulRegular M b",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [CommSemigroup R]  [SMul R M]  [IsScalarTower R R M]"},
 {"type": "IsSMulRegular R g",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G) : IsSMulRegular R g := by intro x y h; sorry",
  "name": "isSMulRegular_of_group",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G) : IsSMulRegular R g",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  {G : Type _}  [Group G] [MulAction G R]  (g : G)"},
 {"type": "IsSMulRegular M a",
  "tactic-prompt":
  "theorem {R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a) : IsSMulRegular M a := by rcases ua with âŸ¨a, rflâŸ©; sorry",
  "name": "IsUnit.isSMulRegular",
  "kind": "theorem",
  "first-tactic": "rcases ua with âŸ¨a, rflâŸ©",
  "core-prompt":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a) : IsSMulRegular M a",
  "args":
  "{R S : Type _}  (M : Type _)  {a b : R}  {s : S}  [Monoid R]  [MulAction R M] (ua : IsUnit a)"},
 {"type": "(a + b + c) * d = a * d + b * d + c * d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R) : (a + b + c) * d = a * d + b * d + c * d := by simp [right_distrib]; sorry",
  "name": "distrib_three_right",
  "kind": "theorem",
  "first-tactic": "simp [right_distrib]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R) : (a + b + c) * d = a * d + b * d + c * d",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Mul R]  [Add R]  [RightDistribClass R]  (a b c d : R)"},
 {"type": "(a + 1) * b = a * b + b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±) : (a + 1) * b = a * b + b := by rw [add_mul]; sorry",
  "name": "add_one_mul",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±) : (a + 1) * b = a * b + b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±)"},
 {"type": "a * (b + 1) = a * b + a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±) : a * (b + 1) = a * b + a := by rw [mul_add]; sorry",
  "name": "mul_add_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±) : a * (b + 1) = a * b + a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±)"},
 {"type": "(1 + a) * b = b + a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±) : (1 + a) * b = b + a * b := by rw [add_mul]; sorry",
  "name": "one_add_mul",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±) : (1 + a) * b = b + a * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [RightDistribClass Î±]  (a b : Î±)"},
 {"type": "a * (1 + b) = a + a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±) : a * (1 + b) = a + a * b := by rw [mul_add]; sorry",
  "name": "mul_one_add",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±) : a * (1 + b) = a + a * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Add Î±]  [MulOneClass Î±] [LeftDistribClass Î±]  (a b : Î±)"},
 {"type": "ite P (a * b) 0 = ite P a 0 * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±) : ite P (a * b) 0 = ite P a 0 * b := by by_cases h : P; sorry",
  "name": "ite_mul_zero_left",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±) : ite P (a * b) 0 = ite P a 0 * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±)"},
 {"type": "ite P (a * b) 0 = a * ite P b 0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±) : ite P (a * b) 0 = a * ite P b 0 := by by_cases h : P; sorry",
  "name": "ite_mul_zero_right",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±) : ite P (a * b) 0 = a * ite P b 0",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P : Prop)  [Decidable P]  (a b : Î±)"},
 {"type": "ite (P âˆ§ Q) (a * b) 0 = ite P a 0 * ite Q b 0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : Î±) : ite (P âˆ§ Q) (a * b) 0 = ite P a 0 * ite Q b 0 := by simp only [â† ite_and]; sorry",
  "name": "ite_and_mul_zero",
  "kind": "theorem",
  "first-tactic": "simp only [â† ite_and]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : Î±) : ite (P âˆ§ Q) (a * b) 0 = ite P a 0 * ite Q b 0",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} {Î± : Type _}  [MulZeroClass Î±]  (P Q : Prop)  [Decidable P]  [Decidable Q]      (a b : Î±)"},
 {"type": "(a + b) * (a + b) = a * a + 2 * a * b + b * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [CommSemiring Î±]  {a b c : Î±} (a b : Î±) : (a + b) * (a + b) = a * a + 2 * a * b + b * b := by simp only [two_mul]; sorry",
  "name": "add_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "simp only [two_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [CommSemiring Î±]  {a b c : Î±} (a b : Î±) : (a + b) * (a + b) = a * a + 2 * a * b + b * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [CommSemiring Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±) : -a * -b = a * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±) : -a * b = a * -b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [Mul Î±]  [HasDistribNeg Î±] (a b : Î±)"},
 {"type": "-a = -1 * a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : -a = -1 * a := by simp; sorry",
  "name": "neg_eq_neg_one_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : -a = -1 * a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : a * -1 = -a := by simp; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : a * -1 = -a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±)"},
 {"type": "-1 * a = -a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : -1 * a = -a := by simp; sorry",
  "name": "neg_one_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±) : -1 * a = -a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}   [MulOneClass Î±]  [HasDistribNeg Î±] (a : Î±)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±) : a * (b - c) = a * b - a * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_left_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±) : a * (b - c) = a * b - a * c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±) : (a - b) * c = a * c - b * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_right_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±) : (a - b) * c = a * c - b * c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing Î±] (a b c : Î±)"},
 {"type": "(a - 1) * b = a * b - b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : (a - 1) * b = a * b - b := by rw [sub_mul]; sorry",
  "name": "sub_one_mul",
  "kind": "theorem",
  "first-tactic": "rw [sub_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : (a - 1) * b = a * b - b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±)"},
 {"type": "a * (b - 1) = a * b - a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : a * (b - 1) = a * b - a := by rw [mul_sub]; sorry",
  "name": "mul_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : a * (b - 1) = a * b - a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±)"},
 {"type": "(1 - a) * b = b - a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : (1 - a) * b = b - a * b := by rw [sub_mul]; sorry",
  "name": "one_sub_mul",
  "kind": "theorem",
  "first-tactic": "rw [sub_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : (1 - a) * b = b - a * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±)"},
 {"type": "a * (1 - b) = a - a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : a * (1 - b) = a - a * b := by rw [mul_sub]; sorry",
  "name": "mul_one_sub",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±) : a * (1 - b) = a - a * b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonAssocRing Î±] (a b : Î±)"},
 {"type": "IsIdempotentElem (p * q)",
  "tactic-prompt":
  "theorem {M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p q : S}  (h : Commute p q)  (hâ‚ : IsIdempotentElem p)      (hâ‚‚ : IsIdempotentElem q) : IsIdempotentElem (p * q) := by rw [IsIdempotentElem]; sorry",
  "name": "mul_of_commute",
  "kind": "theorem",
  "first-tactic": "rw [IsIdempotentElem]",
  "core-prompt":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p q : S}  (h : Commute p q)  (hâ‚ : IsIdempotentElem p)      (hâ‚‚ : IsIdempotentElem q) : IsIdempotentElem (p * q)",
  "args":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p q : S}  (h : Commute p q)  (hâ‚ : IsIdempotentElem p)      (hâ‚‚ : IsIdempotentElem q)"},
 {"type": "IsIdempotentElem (1 - p)",
  "tactic-prompt":
  "theorem {M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : R}  (h : IsIdempotentElem p) : IsIdempotentElem (1 - p) := by rw [IsIdempotentElem]; sorry",
  "name": "one_sub",
  "kind": "theorem",
  "first-tactic": "rw [IsIdempotentElem]",
  "core-prompt":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : R}  (h : IsIdempotentElem p) : IsIdempotentElem (1 - p)",
  "args":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : R}  (h : IsIdempotentElem p)"},
 {"type": "IsIdempotentElem p â†” p = 0 âˆ¨ p = 1",
  "tactic-prompt":
  "theorem {M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : Gâ‚€} : IsIdempotentElem p â†” p = 0 âˆ¨ p = 1 := by refine'\n    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>\n      h.elim (fun hp => hp.symm â–¸ zero) fun hp => hp.symm â–¸ one; sorry",
  "name": "iff_eq_zero_or_one",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    Iff.intro (fun h => or_iff_not_imp_left.mpr fun hp => _) fun h =>\n      h.elim (fun hp => hp.symm â–¸ zero) fun hp => hp.symm â–¸ one",
  "core-prompt":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : Gâ‚€} : IsIdempotentElem p â†” p = 0 âˆ¨ p = 1",
  "args":
  "{M N S Mâ‚€ Mâ‚ R G Gâ‚€ : Type _} [Mul M]  [Monoid N]  [Semigroup S]  [MulZeroClass Mâ‚€]  [MulOneClass Mâ‚]  [NonAssocRing R]    [Group G]  [CancelMonoidWithZero Gâ‚€] {p : Gâ‚€}"},
 {"type": "SemiconjBy a (x + x') (y + y')",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x + x') (y + y') := by simp only [SemiconjBy]; sorry",
  "name": "add_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x + x') (y + y')",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a x y x' y' : R}  (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a + b) x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a + b) x y := by simp only [SemiconjBy]; sorry",
  "name": "add_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a + b) x y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Distrib R]  {a b x y : R}  (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a (-x) (-y)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy a (-x) (-y) := by simp only [SemiconjBy]; sorry",
  "name": "neg_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy a (-x) (-y)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy (-a) x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy (-a) x y := by simp only [SemiconjBy]; sorry",
  "name": "neg_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y) : SemiconjBy (-a) x y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Mul R]  [HasDistribNeg R]  {a x y : R} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy a (x - x') (y - y')",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x - x') (y - y') := by simpa only [sub_eq_add_neg] using h.add_right h'.neg_right; sorry",
  "name": "sub_right",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg] using h.add_right h'.neg_right",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x - x') (y - y')",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a - b) x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a - b) x y := by simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left; sorry",
  "name": "sub_left",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg] using ha.add_left hb.neg_left",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y) : SemiconjBy (a - b) x y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [NonUnitalNonAssocRing R]  {a b x y x' y' : R} (ha : SemiconjBy a x y)  (hb : SemiconjBy b x y)"},
 {"type": "a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : a âˆ£ -b) : a âˆ£ b := by let t := dvd_neg_of_dvd h; sorry",
  "name": "dvd_of_dvd_neg",
  "kind": "theorem",
  "first-tactic": "let t := dvd_neg_of_dvd h",
  "core-prompt":
  "{Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : a âˆ£ -b) : a âˆ£ b",
  "args":
  "{Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : a âˆ£ -b)"},
 {"type": "a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : -a âˆ£ b) : a âˆ£ b := by let t := neg_dvd_of_dvd h; sorry",
  "name": "dvd_of_neg_dvd",
  "kind": "theorem",
  "first-tactic": "let t := neg_dvd_of_dvd h",
  "core-prompt":
  "{Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : -a âˆ£ b) : a âˆ£ b",
  "args":
  "{Î± Î² : Type _}  [Semigroup Î±]  [HasDistribNeg Î±]  {a b c : Î±} (h : -a âˆ£ b)"},
 {"type": "a âˆ£ b - c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (hâ‚ : a âˆ£ b)  (hâ‚‚ : a âˆ£ c) : a âˆ£ b - c := by rw [sub_eq_add_neg]; sorry",
  "name": "dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (hâ‚ : a âˆ£ b)  (hâ‚‚ : a âˆ£ c) : a âˆ£ b - c",
  "args":
  "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (hâ‚ : a âˆ£ b)  (hâ‚‚ : a âˆ£ c)"},
 {"type": "a âˆ£ c â†” a âˆ£ b + c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (h : a âˆ£ b) : a âˆ£ c â†” a âˆ£ b + c := by rw [add_comm]; sorry",
  "name": "dvd_add_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (h : a âˆ£ b) : a âˆ£ c â†” a âˆ£ b + c",
  "args": "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} (h : a âˆ£ b)"},
 {"type": "a âˆ£ b â†” a âˆ£ c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} {a b c : Î±}  (h : a âˆ£ b - c) : a âˆ£ b â†” a âˆ£ c := by constructor; sorry",
  "name": "dvd_iff_dvd_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} {a b c : Î±}  (h : a âˆ£ b - c) : a âˆ£ b â†” a âˆ£ c",
  "args":
  "{Î± Î² : Type _}  [NonUnitalRing Î±]  {a b c : Î±} {a b c : Î±}  (h : a âˆ£ b - c)"},
 {"type": "k âˆ£ a * x - b * y",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [NonUnitalCommRing Î±]  {a b c : Î±} {k a b x y : Î±}  (hab : k âˆ£ a - b)  (hxy : k âˆ£ x - y) : k âˆ£ a * x - b * y := by convert dvd_add (hxy.mul_left a) (hab.mul_right y); sorry",
  "name": "dvd_mul_sub_mul",
  "kind": "theorem",
  "first-tactic": "convert dvd_add (hxy.mul_left a) (hab.mul_right y)",
  "core-prompt":
  "{Î± Î² : Type _}  [NonUnitalCommRing Î±]  {a b c : Î±} {k a b x y : Î±}  (hab : k âˆ£ a - b)  (hxy : k âˆ£ x - y) : k âˆ£ a * x - b * y",
  "args":
  "{Î± Î² : Type _}  [NonUnitalCommRing Î±]  {a b c : Î±} {k a b x y : Î±}  (hab : k âˆ£ a - b)  (hxy : k âˆ£ x - y)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a + b) * (a - b) := by rw [add_mul]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [add_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a + b) * (a - b)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b)"},
 {"type": "a * a - b * b = (a - b) * (a + b)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a - b) * (a + b) := by rw [mul_add]; sorry",
  "name": "mul_self_sub_mul_self_eq'",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b) : a * a - b * b = (a - b) * (a + b)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  {a b : R}  (h : Commute a b)"},
 {"type": "a * a = b * b â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b) : a * a = b * b â†” a = b âˆ¨ a = -b := by rw [â† sub_eq_zero]; sorry",
  "name": "mul_self_eq_mul_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† sub_eq_zero]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b) : a * a = b * b â†” a = b âˆ¨ a = -b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonUnitalNonAssocRing R]  [NoZeroDivisors R]  {a b : R}      (h : Commute a b)"},
 {"type": "a * a - 1 = (a + 1) * (a - 1)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  (a : R) : a * a - 1 = (a + 1) * (a - 1) := by rw [â† (Commute.one_right a).mul_self_sub_mul_self_eq]; sorry",
  "name": "mul_self_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [â† (Commute.one_right a).mul_self_sub_mul_self_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  (a : R) : a * a - 1 = (a + 1) * (a - 1)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  (a : R)"},
 {"type": "a * a = 1 â†” a = 1 âˆ¨ a = -1",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R} : a * a = 1 â†” a = 1 âˆ¨ a = -1 := by rw [â† (Commute.one_right a).mul_self_eq_mul_self_iff]; sorry",
  "name": "mul_self_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† (Commute.one_right a).mul_self_eq_mul_self_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R} : a * a = 1 â†” a = 1 âˆ¨ a = -1",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [NonAssocRing R]  [NoZeroDivisors R]  {a : R}"},
 {"type": "uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : RË£) : uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1 := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "inv_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : RË£) : uâ»Â¹ = u â†” u = 1 âˆ¨ u = -1",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [Ring R]  [NoZeroDivisors R]  (u : RË£)"},
 {"type": "(-a)â»Â¹ = -aâ»Â¹",
  "tactic-prompt":
  "theorem [Group Î±]  [HasDistribNeg Î±] (a : Î±) : (-a)â»Â¹ = -aâ»Â¹ := by rw [eq_comm]; sorry",
  "name": "inv_neg'",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "[Group Î±]  [HasDistribNeg Î±] (a : Î±) : (-a)â»Â¹ = -aâ»Â¹",
  "args": "[Group Î±]  [HasDistribNeg Î±] (a : Î±)"},
 {"type": "âˆƒ y : Î±, y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c",
  "tactic-prompt":
  "theorem [NonUnitalCommRing Î±]  {a b c : Î±} {b c x : Î±}  (h : x * x - b * x + c = 0) : âˆƒ y : Î±, y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c := by have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).trans (by simp [mul_sub]; sorry",
  "name": "Vieta_formula_quadratic",
  "kind": "theorem",
  "first-tactic":
  "have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).trans (by simp [mul_sub]",
  "core-prompt":
  "[NonUnitalCommRing Î±]  {a b c : Î±} {b c x : Î±}  (h : x * x - b * x + c = 0) : âˆƒ y : Î±, y * y - b * y + c = 0 âˆ§ x + y = b âˆ§ x * y = c",
  "args":
  "[NonUnitalCommRing Î±]  {a b c : Î±} {b c x : Î±}  (h : x * x - b * x + c = 0)"},
 {"type": "-(a /â‚š u) = -a /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Monoid Î±]  [HasDistribNeg Î±]  {a b : Î±} (a : Î±)  (u : Î±Ë£) : -(a /â‚š u) = -a /â‚š u := by simp only [divp]; sorry",
  "name": "neg_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Monoid Î±]  [HasDistribNeg Î±]  {a b : Î±} (a : Î±)  (u : Î±Ë£) : -(a /â‚š u) = -a /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Monoid Î±]  [HasDistribNeg Î±]  {a b : Î±} (a : Î±)  (u : Î±Ë£)"},
 {"type": "a /â‚š u + b /â‚š u = (a + b) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u + b /â‚š u = (a + b) /â‚š u := by simp only [divp]; sorry",
  "name": "divp_add_divp_same",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u + b /â‚š u = (a + b) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a /â‚š u - b /â‚š u = (a - b) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u - b /â‚š u = (a - b) /â‚š u := by rw [sub_eq_add_neg]; sorry",
  "name": "divp_sub_divp_same",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u - b /â‚š u = (a - b) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a + b /â‚š u = (a * u + b) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a + b /â‚š u = (a * u + b) /â‚š u := by simp only [divp]; sorry",
  "name": "add_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a + b /â‚š u = (a * u + b) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a - b /â‚š u = (a * u - b) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a - b /â‚š u = (a * u - b) /â‚š u := by simp only [divp]; sorry",
  "name": "sub_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a - b /â‚š u = (a * u - b) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a /â‚š u + b = (a + b * u) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u + b = (a + b * u) /â‚š u := by simp only [divp]; sorry",
  "name": "divp_add",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u + b = (a + b * u) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a /â‚š u - b = (a - b * u) /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u - b = (a - b * u) /â‚š u := by simp only [divp]; sorry",
  "name": "divp_sub",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£) : a /â‚š u - b = (a - b * u) /â‚š u",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x}  [Ring Î±]  {a b : Î±} (a b : Î±)  (u : Î±Ë£)"},
 {"type": "a /â‚š uâ‚ + b /â‚š uâ‚‚ = (a * uâ‚‚ + uâ‚ * b) /â‚š (uâ‚ * uâ‚‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : a /â‚š uâ‚ + b /â‚š uâ‚‚ = (a * uâ‚‚ + uâ‚ * b) /â‚š (uâ‚ * uâ‚‚) := by simp only [divp]; sorry",
  "name": "divp_add_divp",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : a /â‚š uâ‚ + b /â‚š uâ‚‚ = (a * uâ‚‚ + uâ‚ * b) /â‚š (uâ‚ * uâ‚‚)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£)"},
 {"type": "a /â‚š uâ‚ - b /â‚š uâ‚‚ = (a * uâ‚‚ - uâ‚ * b) /â‚š (uâ‚ * uâ‚‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : a /â‚š uâ‚ - b /â‚š uâ‚‚ = (a * uâ‚‚ - uâ‚ * b) /â‚š (uâ‚ * uâ‚‚) := by simp only [sub_eq_add_neg]; sorry",
  "name": "divp_sub_divp",
  "kind": "theorem",
  "first-tactic": "simp only [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : a /â‚š uâ‚ - b /â‚š uâ‚‚ = (a * uâ‚‚ - uâ‚ * b) /â‚š (uâ‚ * uâ‚‚)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {R : Type x} [CommRing Î±]  (a b : Î±)  (uâ‚ uâ‚‚ : Î±Ë£)"},
 {"type": "IsLeftRegular k",
  "tactic-prompt":
  "theorem {Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, k * x = 0 â†’ x = 0) : IsLeftRegular k := by refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _); sorry",
  "name": "isLeftRegular_of_non_zero_divisor",
  "kind": "theorem",
  "first-tactic":
  "refine' fun x y (h' : k * x = k * y) => sub_eq_zero.mp (h _ _)",
  "core-prompt":
  "{Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, k * x = 0 â†’ x = 0) : IsLeftRegular k",
  "args":
  "{Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, k * x = 0 â†’ x = 0)"},
 {"type": "IsRightRegular k",
  "tactic-prompt":
  "theorem {Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, x * k = 0 â†’ x = 0) : IsRightRegular k := by refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _); sorry",
  "name": "isRightRegular_of_non_zero_divisor",
  "kind": "theorem",
  "first-tactic":
  "refine' fun x y (h' : x * k = y * k) => sub_eq_zero.mp (h _ _)",
  "core-prompt":
  "{Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, x * k = 0 â†’ x = 0) : IsRightRegular k",
  "args":
  "{Î± : Type _} [NonUnitalNonAssocRing Î±]  (k : Î±)      (h : âˆ€ x : Î±, x * k = 0 â†’ x = 0)"},
 {"type": "âˆ€ x : R, x â‰  0 â†’ âˆƒ! y : R, x * y = 1",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R) : âˆ€ x : R, x â‰  0 â†’ âˆƒ! y : R, x * y = 1 := by intro x hx; sorry",
  "name": "uniq_inv_of_is_field",
  "kind": "theorem",
  "first-tactic": "intro x hx",
  "core-prompt":
  "{Î± Î² K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R) : âˆ€ x : R, x â‰  0 â†’ âˆƒ! y : R, x * y = 1",
  "args": "{Î± Î² K : Type _}  (R : Type u)  [Ring R]  (hf : IsField R)"},
 {"type": "(a + b) / c = a / c + b / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±) : (a + b) / c = a / c + b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "add_div",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±) : (a + b) / c = a / c + b / c",
  "args": "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "(b + a) / b = 1 + a / b",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0) : (b + a) / b = 1 + a / b := by rw [â† div_self h]; sorry",
  "name": "same_add_div",
  "kind": "theorem",
  "first-tactic": "rw [â† div_self h]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0) : (b + a) / b = 1 + a / b",
  "args": "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0)"},
 {"type": "(a + b) / b = a / b + 1",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0) : (a + b) / b = a / b + 1 := by rw [â† div_self h]; sorry",
  "name": "div_add_same",
  "kind": "theorem",
  "first-tactic": "rw [â† div_self h]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0) : (a + b) / b = a / b + 1",
  "args": "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (h : b â‰  0)"},
 {"type": "1 / a * (a + b) * (1 / b) = 1 / a + 1 / b",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b := by rw [mul_add]; sorry",
  "name": "one_div_mul_add_mul_one_div_eq_one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [mul_add]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b",
  "args":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "b + a / c = (b * c + a) / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0) : b + a / c = (b * c + a) / c := by rw [add_div]; sorry",
  "name": "add_div'",
  "kind": "theorem",
  "first-tactic": "rw [add_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0) : b + a / c = (b * c + a) / c",
  "args":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0)"},
 {"type": "a / c + b = (a + b * c) / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0) : a / c + b = (a + b * c) / c := by rwa [add_comm]; sorry",
  "name": "div_add'",
  "kind": "theorem",
  "first-tactic": "rwa [add_comm]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0) : a / c + b = (a + b * c) / c",
  "args":
  "{Î± Î² K : Type _}  [DivisionSemiring Î±]  {a b c : Î±} (a b c : Î±)  (hc : c â‰  0)"},
 {"type": "-b / a = -(b / a)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -b / a = -(b / a) := by rw [neg_eq_neg_one_mul]; sorry",
  "name": "neg_div",
  "kind": "theorem",
  "first-tactic": "rw [neg_eq_neg_one_mul]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -b / a = -(b / a)",
  "args":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-(b / a) = -b / a",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -(b / a) = -b / a := by simp [neg_div]; sorry",
  "name": "neg_div'",
  "kind": "theorem",
  "first-tactic": "simp [neg_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -(b / a) = -b / a",
  "args":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-a / -b = a / b",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -a / -b = a / b := by rw [div_neg_eq_neg_div]; sorry",
  "name": "neg_div_neg_eq",
  "kind": "theorem",
  "first-tactic": "rw [div_neg_eq_neg_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K) : -a / -b = a / b",
  "args":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a b : K)"},
 {"type": "-aâ»Â¹ = (-a)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : -aâ»Â¹ = (-a)â»Â¹ := by rw [inv_eq_one_div]; sorry",
  "name": "neg_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : -aâ»Â¹ = (-a)â»Â¹",
  "args": "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K}"},
 {"type": "a / -b = -(a / b)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K) : a / -b = -(a / b) := by rw [â† div_neg_eq_neg_div]; sorry",
  "name": "div_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† div_neg_eq_neg_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K) : a / -b = -(a / b)",
  "args":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} (a : K)"},
 {"type": "(-a)â»Â¹ = -aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : (-a)â»Â¹ = -aâ»Â¹ := by rw [neg_inv]; sorry",
  "name": "inv_neg",
  "kind": "theorem",
  "first-tactic": "rw [neg_inv]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K} : (-a)â»Â¹ = -aâ»Â¹",
  "args": "{Î± Î² K : Type _}  [DivisionMonoid K]  [HasDistribNeg K]  {a b : K}"},
 {"type": "a / -a = -1",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0) : a / -a = -1 := by rw [div_neg_eq_neg_div]; sorry",
  "name": "div_neg_self",
  "kind": "theorem",
  "first-tactic": "rw [div_neg_eq_neg_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0) : a / -a = -1",
  "args": "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0)"},
 {"type": "-a / a = -1",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0) : -a / a = -1 := by rw [neg_div]; sorry",
  "name": "neg_div_self",
  "kind": "theorem",
  "first-tactic": "rw [neg_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0) : -a / a = -1",
  "args": "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a : K}  (h : a â‰  0)"},
 {"type": "a / c - b / c = (a - b) / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (a b c : K) : a / c - b / c = (a - b) / c := by rw [sub_eq_add_neg]; sorry",
  "name": "div_sub_div_same",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (a b c : K) : a / c - b / c = (a - b) / c",
  "args": "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (a b c : K)"},
 {"type": "(b - a) / b = 1 - a / b",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0) : (b - a) / b = 1 - a / b := by simpa only [â† @div_self _ _ b h] using (div_sub_div_same b a b).symm; sorry",
  "name": "same_sub_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [â† @div_self _ _ b h] using (div_sub_div_same b a b).symm",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0) : (b - a) / b = 1 - a / b",
  "args":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0)"},
 {"type": "(a - b) / b = a / b - 1",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0) : (a - b) / b = a / b - 1 := by simpa only [â† @div_self _ _ b h] using (div_sub_div_same a b b).symm; sorry",
  "name": "div_sub_same",
  "kind": "theorem",
  "first-tactic":
  "simpa only [â† @div_self _ _ b h] using (div_sub_div_same a b b).symm",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0) : (a - b) / b = a / b - 1",
  "args":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (h : b â‰  0)"},
 {"type": "aâ»Â¹ - bâ»Â¹ = aâ»Â¹ * (b - a) * bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ - bâ»Â¹ = aâ»Â¹ * (b - a) * bâ»Â¹ := by rw [mul_sub]; sorry",
  "name": "inv_sub_inv'",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ - bâ»Â¹ = aâ»Â¹ * (b - a) * bâ»Â¹",
  "args":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} {a b : K}  (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "1 / a * (b - a) * (1 / b) = 1 / a - 1 / b",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a * (b - a) * (1 / b) = 1 / a - 1 / b := by rw [mul_sub_left_distrib (1 / a)]; sorry",
  "name": "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [mul_sub_left_distrib (1 / a)]",
  "core-prompt":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a * (b - a) * (1 / b) = 1 / a - 1 / b",
  "args":
  "{Î± Î² K : Type _}  [DivisionRing K]  {a b : K} (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "a / b + c / d = (a * d + b * c) / (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (a : Î±)  (c : Î±)  (hb : b â‰  0)  (hd : d â‰  0) : a / b + c / d = (a * d + b * c) / (b * d) := by rw [â† mul_div_mul_right _ b hd]; sorry",
  "name": "div_add_div",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_mul_right _ b hd]",
  "core-prompt":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (a : Î±)  (c : Î±)  (hb : b â‰  0)  (hd : d â‰  0) : a / b + c / d = (a * d + b * c) / (b * d)",
  "args":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (a : Î±)  (c : Î±)  (hb : b â‰  0)  (hd : d â‰  0)"},
 {"type": "1 / a + 1 / b = (a + b) / (a * b)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a + 1 / b = (a + b) / (a * b) := by rw [div_add_div _ _ ha hb]; sorry",
  "name": "one_div_add_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_add_div _ _ ha hb]",
  "core-prompt":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0) : 1 / a + 1 / b = (a + b) / (a * b)",
  "args":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "aâ»Â¹ + bâ»Â¹ = (a + b) / (a * b)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ + bâ»Â¹ = (a + b) / (a * b) := by rw [inv_eq_one_div]; sorry",
  "name": "inv_add_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ + bâ»Â¹ = (a + b) / (a * b)",
  "args":
  "{Î± Î² K : Type _}  [Semifield Î±]  {a b c d : Î±} (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "a / b - c / d = (a * d - b * c) / (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b â‰  0)  (hd : d â‰  0) : a / b - c / d = (a * d - b * c) / (b * d) := by simp [sub_eq_add_neg]; sorry",
  "name": "div_sub_div",
  "kind": "theorem",
  "first-tactic": "simp [sub_eq_add_neg]",
  "core-prompt":
  "{Î± Î² K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b â‰  0)  (hd : d â‰  0) : a / b - c / d = (a * d - b * c) / (b * d)",
  "args":
  "{Î± Î² K : Type _}  [Field K] (a : K)  {b : K}  (c : K)  {d : K}  (hb : b â‰  0)  (hd : d â‰  0)"},
 {"type": "aâ»Â¹ - bâ»Â¹ = (b - a) / (a * b)",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Field K] {a b : K}  (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ - bâ»Â¹ = (b - a) / (a * b) := by rw [inv_eq_one_div]; sorry",
  "name": "inv_sub_inv",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î± Î² K : Type _}  [Field K] {a b : K}  (ha : a â‰  0)  (hb : b â‰  0) : aâ»Â¹ - bâ»Â¹ = (b - a) / (a * b)",
  "args": "{Î± Î² K : Type _}  [Field K] {a b : K}  (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "b - a / c = (b * c - a) / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0) : b - a / c = (b * c - a) / c := by simpa using div_sub_div b a one_ne_zero hc; sorry",
  "name": "sub_div'",
  "kind": "theorem",
  "first-tactic": "simpa using div_sub_div b a one_ne_zero hc",
  "core-prompt":
  "{Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0) : b - a / c = (b * c - a) / c",
  "args": "{Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0)"},
 {"type": "a / c - b = (a - c * b) / c",
  "tactic-prompt":
  "theorem {Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0) : a / c - b = (a - c * b) / c := by simpa using div_sub_div a b hc one_ne_zero; sorry",
  "name": "div_sub'",
  "kind": "theorem",
  "first-tactic": "simpa using div_sub_div a b hc one_ne_zero",
  "core-prompt":
  "{Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0) : a / c - b = (a - c * b) / c",
  "args": "{Î± Î² K : Type _}  [Field K] (a b c : K)  (hc : c â‰  0)"},
 {"type": "(a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„•}  {a b : Î±} : (a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹ := by induction' i with i hi; sorry",
  "name": "conj_pow",
  "kind": "theorem",
  "first-tactic": "induction' i with i hi",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„•}  {a b : Î±} : (a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹",
  "args": "{Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„•}  {a b : Î±}"},
 {"type": "(a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„¤}  {a b : Î±} : (a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹ := by induction' i; sorry",
  "name": "conj_zpow",
  "kind": "theorem",
  "first-tactic": "induction' i",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„¤}  {a b : Î±} : (a * b * aâ»Â¹) ^ i = a * b ^ i * aâ»Â¹",
  "args": "{Î± : Type u}  {Î² : Type v}  [Group Î±] {i : â„¤}  {a b : Î±}"},
 {"type": "Function.Surjective (ConjClasses.map f)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Monoid Î±]  [Monoid Î²] {f : Î± â†’* Î²}  (hf : Function.Surjective f) : Function.Surjective (ConjClasses.map f) := by intro b; sorry",
  "name": "map_surjective",
  "kind": "theorem",
  "first-tactic": "intro b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Monoid Î±]  [Monoid Î²] {f : Î± â†’* Î²}  (hf : Function.Surjective f) : Function.Surjective (ConjClasses.map f)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Monoid Î±]  [Monoid Î²] {f : Î± â†’* Î²}  (hf : Function.Surjective f)"},
 {"type": "a âˆˆ carrier b â†” ConjClasses.mk a = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v} [Monoid Î±] {a : Î±}  {b : ConjClasses Î±} : a âˆˆ carrier b â†” ConjClasses.mk a = b := by revert b; sorry",
  "name": "mem_carrier_iff_mk_eq",
  "kind": "theorem",
  "first-tactic": "revert b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v} [Monoid Î±] {a : Î±}  {b : ConjClasses Î±} : a âˆˆ carrier b â†” ConjClasses.mk a = b",
  "args": "{Î± : Type u}  {Î² : Type v} [Monoid Î±] {a : Î±}  {b : ConjClasses Î±}"},
 {"type": "âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚",
  "tactic-prompt":
  "theorem {G : Type _} {M : Type u} : âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚ := by rintro @âŸ¨âŸ¨oneâ‚âŸ©, âŸ¨mulâ‚âŸ©, one_mulâ‚, mul_oneâ‚âŸ© @âŸ¨âŸ¨oneâ‚‚âŸ©, âŸ¨mulâ‚‚âŸ©, one_mulâ‚‚, mul_oneâ‚‚âŸ© âŸ¨rflâŸ©; sorry",
  "name": "MulOneClass.ext",
  "kind": "theorem",
  "first-tactic":
  "rintro @âŸ¨âŸ¨oneâ‚âŸ©, âŸ¨mulâ‚âŸ©, one_mulâ‚, mul_oneâ‚âŸ© @âŸ¨âŸ¨oneâ‚‚âŸ©, âŸ¨mulâ‚‚âŸ©, one_mulâ‚‚, mul_oneâ‚‚âŸ© âŸ¨rflâŸ©",
  "core-prompt":
  "{G : Type _} {M : Type u} : âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚",
  "args": "{G : Type _} {M : Type u}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [â† one_mul c]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† one_mul c]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹",
  "tactic-prompt":
  "theorem {G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : â„•) : a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹ := by rw [â† zpow_ofNat]; sorry",
  "name": "zpow_negSucc",
  "kind": "theorem",
  "first-tactic": "rw [â† zpow_ofNat]",
  "core-prompt":
  "{G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : â„•) : a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹",
  "args": "{G : Type _}  [DivInvMonoid G]  {a b : G} (a : G)  (n : â„•)"},
 {"type": "a * aâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a : G) : a * aâ»Â¹ = 1 := by rw [â† mul_left_inv aâ»Â¹]; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_left_inv aâ»Â¹]",
  "core-prompt": "{G : Type _}  [Group G]  {a b c : G} (a : G) : a * aâ»Â¹ = 1",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a : G)"},
 {"type": "aâ»Â¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : aâ»Â¹ * (a * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : aâ»Â¹ * (a * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * (aâ»Â¹ * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (aâ»Â¹ * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (aâ»Â¹ * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b * bâ»Â¹ = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * bâ»Â¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * bâ»Â¹ = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * bâ»Â¹ * b = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * bâ»Â¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * bâ»Â¹ * b = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "Function.Injective (@Group.toDivInvMonoid G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G) := by rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "Group.toDivInvMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt":
  "{G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G)",
  "args": "{G : Type _} {G : Type _}"},
 {"type": "Function.Injective (@CommGroup.toGroup G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G) := by rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "CommGroup.toGroup_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt":
  "{G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G)",
  "args": "{G : Type _} {G : Type u}"},
 {"type": "SemiconjBy a (x * x') (y * y')",
  "tactic-prompt":
  "theorem [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y') := by unfold SemiconjBy; sorry",
  "name": "mul_right",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')",
  "args":
  "[Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a * b) x z",
  "tactic-prompt":
  "theorem [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by unfold SemiconjBy; sorry",
  "name": "mul_left",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z",
  "args":
  "[Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a 1 1",
  "tactic-prompt":
  "theorem [MulOneClass M] (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy]; sorry",
  "name": "one_right",
  "kind": "theorem",
  "first-tactic": "rw [SemiconjBy]",
  "core-prompt": "[MulOneClass M] (a : M) : SemiconjBy a 1 1",
  "args": "[MulOneClass M] (a : M)"},
 {"type": "SemiconjBy a (x ^ n) (y ^ n)",
  "tactic-prompt":
  "theorem [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•) : SemiconjBy a (x ^ n) (y ^ n) := by induction' n with n ih; sorry",
  "name": "pow_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "[Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•) : SemiconjBy a (x ^ n) (y ^ n)",
  "args": "[Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•)"},
 {"type": "SemiconjBy a x (a * x * aâ»Â¹)",
  "tactic-prompt":
  "theorem [Group G]  {a x y : G} (a x : G) : SemiconjBy a x (a * x * aâ»Â¹) := by unfold SemiconjBy; sorry",
  "name": "conj_mk",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Group G]  {a x y : G} (a x : G) : SemiconjBy a x (a * x * aâ»Â¹)",
  "args": "[Group G]  {a x y : G} (a x : G)"},
 {"type": "SemiconjBy (â†‘u) x (u * x * â†‘uâ»Â¹)",
  "tactic-prompt":
  "theorem [Monoid M]  (u : MË£)  (x : M) : SemiconjBy (â†‘u) x (u * x * â†‘uâ»Â¹) := by unfold SemiconjBy; sorry",
  "name": "Units.mk_semiconjBy",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "[Monoid M]  (u : MË£)  (x : M) : SemiconjBy (â†‘u) x (u * x * â†‘uâ»Â¹)",
  "args": "[Monoid M]  (u : MË£)  (x : M)"},
 {"type":
  "Pairwise fun i j => âˆ€ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)",
  "tactic-prompt":
  "theorem {Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i] : Pairwise fun i j => âˆ€ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y) := by intro i j hij x y; sorry",
  "name": "Pi.mulSingle_commute",
  "kind": "theorem",
  "first-tactic": "intro i j hij x y",
  "core-prompt":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i] : Pairwise fun i j => âˆ€ (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)",
  "args":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i]"},
 {"type": "Commute (mulSingle i (x i)) (mulSingle j (x j))",
  "tactic-prompt":
  "theorem {Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i]  (x : âˆ€ i, f i)  (i j : I) : Commute (mulSingle i (x i)) (mulSingle j (x j)) := by obtain rfl | hij := Decidable.eq_or_ne i j; sorry",
  "name": "Pi.mulSingle_apply_commute",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hij := Decidable.eq_or_ne i j",
  "core-prompt":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i]  (x : âˆ€ i, f i)  (i j : I) : Commute (mulSingle i (x i)) (mulSingle j (x j))",
  "args":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, MulOneClass <| f i]  (x : âˆ€ i, f i)  (i j : I)"},
 {"type": "Function.update g i x = g / mulSingle i (g i) * mulSingle i x",
  "tactic-prompt":
  "theorem {Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, Group <| f i]  (g : âˆ€ i : I, f i)  (x : f i) : Function.update g i x = g / mulSingle i (g i) * mulSingle i x := by ext j; sorry",
  "name": "Pi.update_eq_div_mul_mulSingle",
  "kind": "theorem",
  "first-tactic": "ext j",
  "core-prompt":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, Group <| f i]  (g : âˆ€ i : I, f i)  (x : f i) : Function.update g i x = g / mulSingle i (g i) * mulSingle i x",
  "args":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, Group <| f i]  (g : âˆ€ i : I, f i)  (x : f i)"},
 {"type":
  "(mulSingle k u : I â†’ M) * mulSingle l v = mulSingle m u * mulSingle n v â†”\n      k = m âˆ§ l = n âˆ¨ u = v âˆ§ k = n âˆ§ l = m âˆ¨ u * v = 1 âˆ§ k = l âˆ§ m = n",
  "tactic-prompt":
  "theorem {Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u â‰  1)  (hv : v â‰  1) : (mulSingle k u : I â†’ M) * mulSingle l v = mulSingle m u * mulSingle n v â†”\n      k = m âˆ§ l = n âˆ¨ u = v âˆ§ k = n âˆ§ l = m âˆ¨ u * v = 1 âˆ§ k = l âˆ§ m = n := by refine' âŸ¨fun h => _, _âŸ©; sorry",
  "name": "Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, _âŸ©",
  "core-prompt":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u â‰  1)  (hv : v â‰  1) : (mulSingle k u : I â†’ M) * mulSingle l v = mulSingle m u * mulSingle n v â†”\n      k = m âˆ§ l = n âˆ¨ u = v âˆ§ k = n âˆ§ l = m âˆ¨ u * v = 1 âˆ§ k = l âˆ§ m = n",
  "args":
  "{Î¹ Î± : Type _} {I : Type u}  -- The indexing type {f : I â†’ Type v}  -- The family of types already equipped with instances (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] {M : Type _}  [CommMonoid M]      {k l m n : I}  {u v : M}  (hu : u â‰  1)  (hv : v â‰  1)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b := by simp only [mul_assoc]; sorry",
  "name": "right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b",
  "args":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S)"},
 {"type": "aâ»Â¹ * b * a = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : aâ»Â¹ * b * a = b := by rw [h.inv_left.eq]; sorry",
  "name": "inv_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [h.inv_left.eq]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : aâ»Â¹ * b * a = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "aâ»Â¹ * (b * a) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : aâ»Â¹ * (b * a) = b := by rw [â† mul_assoc]; sorry",
  "name": "inv_mul_cancel_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : aâ»Â¹ * (b * a) = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "a * b * aâ»Â¹ = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * b * aâ»Â¹ = b := by rw [h.eq]; sorry",
  "name": "mul_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [h.eq]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * b * aâ»Â¹ = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "a * (b * aâ»Â¹) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * (b * aâ»Â¹) = b := by rw [â† mul_assoc]; sorry",
  "name": "mul_inv_cancel_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b : G} (h : Commute a b) : a * (b * aâ»Â¹) = b",
  "args": "{G : Type _}  [Group G]  {a b : G} (h : Commute a b)"},
 {"type": "(x * Â·) âˆ˜ (y * Â·) = (x * y * Â·)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (x * Â·) âˆ˜ (y * Â·) = (x * y * Â·) := by ext z; sorry",
  "name": "comp_mul_left",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (x * Â·) âˆ˜ (y * Â·) = (x * y * Â·)",
  "args": "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±)"},
 {"type": "(Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x))",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x)) := by ext z; sorry",
  "name": "comp_mul_right",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x))",
  "args": "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±)"},
 {"type": "ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by by_cases h:P; sorry",
  "name": "ite_mul_one",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by by_cases h:P; sorry",
  "name": "ite_one_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "a = 1 â†” b = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 â†” b = 1 := by constructor; sorry",
  "name": "eq_one_iff_eq_one_of_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 â†” b = 1",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1)"},
 {"type": "a * b * (c * d) = a * c * (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d)",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G)"},
 {"type": "a * b * c = b * c * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "a * (b * c) = b * (c * a)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a)",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "bit1 (a + b) = bit1 a + bit0 b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M) : bit1 (a + b) = bit1 a + bit0 b := by rw [add_comm]; sorry",
  "name": "bit1_add'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M) : bit1 (a + b) = bit1 a + bit0 b",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [AddCommSemigroup M] [One M]  (a b : M)"},
 {"type": "bit1 (0 : M) = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M] : bit1 (0 : M) = 1 := by rw [bit1]; sorry",
  "name": "bit1_zero",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M] : bit1 (0 : M) = 1",
  "args": "{Î± Î² G : Type _}  {M : Type u}  [AddMonoid M]  {a b c : M} [One M]"},
 {"type": "b = aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = bâ»Â¹) : b = aâ»Â¹ := by simp [h]; sorry",
  "name": "eq_inv_of_eq_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = bâ»Â¹) : b = aâ»Â¹",
  "args": "{Î± Î² G : Type _}  [InvolutiveInv G]  {a b : G} (h : a = bâ»Â¹)"},
 {"type": "xâ»Â¹ = 1 / x",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : xâ»Â¹ = 1 / x := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : xâ»Â¹ = 1 / x",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G)"},
 {"type": "x * (1 / y) = x / y",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G)"},
 {"type": "a * b / c = a * (b / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c)",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a * (b / c) = a * b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc]; sorry",
  "name": "mul_div",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a / b = a * (1 / b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b)",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G)"},
 {"type": "a / 1 = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a := by simp [div_eq_mul_inv]; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt": "{Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a",
  "args": "{Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G)"},
 {"type": "bâ»Â¹ = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : bâ»Â¹ = a := by rw [â† inv_eq_of_mul_eq_one_right h]; sorry",
  "name": "inv_eq_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_eq_of_mul_eq_one_right h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : bâ»Â¹ = a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_left h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1) : b = 1 / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_right",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_right h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : b = 1 / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1)"},
 {"type": "1 / a * (1 / b) = 1 / (b * a)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / a * (1 / b) = 1 / (b * a) := by simp; sorry",
  "name": "one_div_mul_one_div_rev",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / a * (1 / b) = 1 / (b * a)",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "aâ»Â¹ / b = (b * a)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : aâ»Â¹ / b = (b * a)â»Â¹ := by simp; sorry",
  "name": "inv_div_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : aâ»Â¹ / b = (b * a)â»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "(a / b)â»Â¹ = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : (a / b)â»Â¹ = b / a := by simp; sorry",
  "name": "inv_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : (a / b)â»Â¹ = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "1 / (a / b) = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (a / b) = b / a := by simp; sorry",
  "name": "one_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (a / b) = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "1 / (1 / a) = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (1 / a) = a := by simp; sorry",
  "name": "one_div_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (1 / a) = a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b) : a = b := by rw [â† one_div_one_div a]; sorry",
  "name": "eq_of_one_div_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [â† one_div_one_div a]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b) : a = b",
  "args":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b)"},
 {"type": "a / (b / c) = a * c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b / c) = a * c / b := by simp; sorry",
  "name": "div_div_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b / c) = a * c / b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a / bâ»Â¹ = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / bâ»Â¹ = a * b := by simp; sorry",
  "name": "div_inv_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / bâ»Â¹ = a * b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a / (b * c) = a / c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b * c) = a / c / b := by simp only [mul_assoc]; sorry",
  "name": "div_mul_eq_div_div_swap",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b * c) = a / c / b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "(a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹ := by simp; sorry",
  "name": "mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹ := by simp; sorry",
  "name": "inv_div'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b = bâ»Â¹ * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b = bâ»Â¹ * a := by simp; sorry",
  "name": "div_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b = bâ»Â¹ * a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "aâ»Â¹ * b = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ * b = b / a := by simp; sorry",
  "name": "inv_mul_eq_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ * b = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(a * b)â»Â¹ = aâ»Â¹ / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ / b := by simp; sorry",
  "name": "inv_mul'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "aâ»Â¹ / bâ»Â¹ = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ / bâ»Â¹ = b / a := by simp; sorry",
  "name": "inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ / bâ»Â¹ = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b := by simp; sorry",
  "name": "inv_inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "1 / a * (1 / b) = 1 / (a * b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : 1 / a * (1 / b) = 1 / (a * b) := by simp; sorry",
  "name": "one_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : 1 / a * (1 / b) = 1 / (a * b)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / c = a / c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / c / b := by simp; sorry",
  "name": "div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / c / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / c = a / (b * c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / (b * c) := by simp; sorry",
  "name": "div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / (b * c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a / (b / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a / (b / c) := by simp; sorry",
  "name": "div_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a / (b / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * (b / c) = b * (a / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * (b / c) = b * (a / c) := by simp; sorry",
  "name": "mul_div_left_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * (b / c) = b * (a / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / c = a / c * b := by simp; sorry",
  "name": "mul_div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / c = a / c * b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / (b * c) = a / b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b / c := by simp; sorry",
  "name": "div_mul_eq_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b / c",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a * c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * c / b := by simp; sorry",
  "name": "div_mul_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * c / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a * (c / b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * (c / b) := by simp; sorry",
  "name": "mul_comm_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * (c / b)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = c / b * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = c / b * a := by simp; sorry",
  "name": "div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = c / b * a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / (b * c) = a / b * (1 / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b * (1 / c) := by simp; sorry",
  "name": "div_mul_eq_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b * (1 / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / (c / d) = a * d / (b * c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a * d / (b * c) := by simp; sorry",
  "name": "div_div_div_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a * d / (b * c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / (c / d) = a / c / (b / d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a / c / (b / d) := by simp; sorry",
  "name": "div_div_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a / c / (b / d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * (c / d) = a * c / (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * (c / d) = a * c / (b * d) := by simp; sorry",
  "name": "div_mul_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * (c / d) = a * c / (b * d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / (c * d) = a / c * (b / d) := by simp; sorry",
  "name": "mul_div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / (c * d) = a / c * (b / d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b = bâ»Â¹ â†” a = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = bâ»Â¹ â†” a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_inv_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = bâ»Â¹ â†” a = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b * câ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * câ»Â¹ := by simp [h.symm]; sorry",
  "name": "eq_mul_inv_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * câ»Â¹",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a = bâ»Â¹ * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = bâ»Â¹ * c := by simp [h.symm]; sorry",
  "name": "eq_inv_mul_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = bâ»Â¹ * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c)"},
 {"type": "aâ»Â¹ * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : aâ»Â¹ * b = c := by simp [h]; sorry",
  "name": "inv_mul_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : aâ»Â¹ * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c)"},
 {"type": "a * bâ»Â¹ = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * bâ»Â¹ = c := by simp [h]; sorry",
  "name": "mul_inv_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * bâ»Â¹ = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_mul_inv_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_inv_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c) : a * b = c := by rw [h]; sorry",
  "name": "mul_eq_of_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹)"},
 {"type": "a * b = 1 â†” aâ»Â¹ = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * b = 1 â†” aâ»Â¹ = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * b = 1 â†” aâ»Â¹ = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a * bâ»Â¹ = 1 â†” a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * bâ»Â¹ = 1 â†” a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_inv_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * bâ»Â¹ = 1 â†” a = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "aâ»Â¹ * b = 1 â†” a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : aâ»Â¹ * b = 1 â†” a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "inv_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : aâ»Â¹ * b = 1 â†” a = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a â†¦ a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a â†¦ a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a â†¦ a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a â†¦ b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a â†¦ b / a := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_right_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a â†¦ b / a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b := by rw [div_mul_eq_div_div_swap]; sorry",
  "name": "mul_div_mul_right_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_div_swap]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c := by simp [â† h]; sorry",
  "name": "eq_div_of_mul_eq'",
  "kind": "theorem",
  "first-tactic": "simp [â† h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c := by simp [h]; sorry",
  "name": "div_eq_of_eq_mul''",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c := by simp [â† h]; sorry",
  "name": "eq_mul_of_div_eq",
  "kind": "theorem",
  "first-tactic": "simp [â† h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b)"},
 {"type": "b / a = c / a â†” b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : b / a = c / a â†” b = c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : b / a = c / a â†” b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * (b / c) = a / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c := by rw [â† mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b := by rw [â† inv_div c b]; sorry",
  "name": "div_div_div_cancel_right'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div c b]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = a â†” b = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = a â†” b = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = a â†” b = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b / c â†” a * c = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a = b / c â†” a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff_mul_eq'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a = b / c â†” a * c = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = c â†” a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = c â†” a = c * b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b â†” c = d",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b â†” c = d := by rw [â† div_eq_one]; sorry",
  "name": "eq_iff_eq_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [â† div_eq_one]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b â†” c = d",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d)"},
 {"type": "âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1) : âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1 := by cases' n with n n; sorry",
  "name": "exists_npow_eq_one_of_zpow_eq_one",
  "kind": "theorem",
  "first-tactic": "cases' n with n n",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1) : âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1",
  "args":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c := by rw [h]; sorry",
  "name": "div_eq_of_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c",
  "args":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_left_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c := by simp [h.symm]; sorry",
  "name": "eq_div_of_mul_eq''",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_div_eq'",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div'",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b; sorry",
  "name": "div_div_self'",
  "kind": "theorem",
  "first-tactic": "simpa using mul_inv_cancel_left a b",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / b = c / b * (a / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]; sorry",
  "name": "div_eq_div_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [mul_left_comm c]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c)",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b / a = bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = bâ»Â¹ := by simp; sorry",
  "name": "div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a = b / c â†” c * a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c â†” c * a = b := by rw [eq_div_iff_mul_eq']; sorry",
  "name": "eq_div_iff_mul_eq''",
  "kind": "theorem",
  "first-tactic": "rw [eq_div_iff_mul_eq']",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c â†” c * a = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c â†” a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c â†” a = b * c := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_iff_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c â†” a = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b := by rw [div_eq_inv_mul]; sorry",
  "name": "mul_div_cancel'''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_inv_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b := by rw [â† mul_div_assoc]; sorry",
  "name": "mul_div_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / (a * b) = bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = bâ»Â¹ := by rw [â† inv_div]; sorry",
  "name": "div_mul_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b * aâ»Â¹) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * aâ»Â¹) = b := by rw [â† div_eq_mul_inv]; sorry",
  "name": "mul_mul_inv_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [â† div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * aâ»Â¹) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * c * (b / c) = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc]; sorry",
  "name": "mul_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c * (b * c) = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm]; sorry",
  "name": "div_mul_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b * (c / a) = c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm]; sorry",
  "name": "div_mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a * b / (a / c) = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c := by rw [â† div_mul]; sorry",
  "name": "mul_div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [â† div_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "c / a / (c / b) = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a := by rw [â† inv_div b c]; sorry",
  "name": "div_div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div b c]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = c / d â†” a * d = c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a * d = c * b := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a * d = c * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c / d â†” a / c = b / d",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a / c = b / d := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a / c = b / d",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "(a : Î±) = 1 â†” a = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±Ë£} : (a : Î±) = 1 â†” a = 1 := by rw [â† Units.val_one]; sorry",
  "name": "val_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [â† Units.val_one]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±Ë£} : (a : Î±) = 1 â†” a = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±Ë£}"},
 {"type": "â†‘uâ»Â¹ * a = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a) : â†‘uâ»Â¹ * a = 1 := by rw [â† h]; sorry",
  "name": "inv_mul_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a) : â†‘uâ»Â¹ * a = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a)"},
 {"type": "a * â†‘uâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a) : a * â†‘uâ»Â¹ = 1 := by rw [â† h]; sorry",
  "name": "mul_inv_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a) : a * â†‘uâ»Â¹ = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}  (h : â†‘u = a)"},
 {"type": "(a : Î±) * (â†‘aâ»Â¹ * b) = b",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±) : (a : Î±) * (â†‘aâ»Â¹ * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±) : (a : Î±) * (â†‘aâ»Â¹ * b) = b",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±)"},
 {"type": "(â†‘aâ»Â¹ : Î±) * (a * b) = b",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±) : (â†‘aâ»Â¹ : Î±) * (a * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±) : (â†‘aâ»Â¹ : Î±) * (a * b) = b",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±Ë£)  (b : Î±)"},
 {"type": "a * b * â†‘bâ»Â¹ = a",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£) : a * b * â†‘bâ»Â¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£) : a * b * â†‘bâ»Â¹ = a",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£)"},
 {"type": "a * â†‘bâ»Â¹ * b = a",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£) : a * â†‘bâ»Â¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£) : a * â†‘bâ»Â¹ * b = a",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} (a : Î±)  (b : Î±Ë£)"},
 {"type": "a * u = 1 â†” a = â†‘uâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±} : a * u = 1 â†” a = â†‘uâ»Â¹ := by rw [â† mul_inv_eq_one]; sorry",
  "name": "mul_eq_one_iff_eq_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_inv_eq_one]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±} : a * u = 1 â†” a = â†‘uâ»Â¹",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}"},
 {"type": "â†‘u * a = 1 â†” â†‘uâ»Â¹ = a",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±} : â†‘u * a = 1 â†” â†‘uâ»Â¹ = a := by rw [â† inv_mul_eq_one]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_mul_eq_one]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±} : â†‘u * a = 1 â†” â†‘uâ»Â¹ = a",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£} {a : Î±}"},
 {"type": "x /â‚š uâ‚ /â‚š uâ‚‚ = x /â‚š (uâ‚‚ * uâ‚)",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (x : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : x /â‚š uâ‚ /â‚š uâ‚‚ = x /â‚š (uâ‚‚ * uâ‚) := by simp only [divp]; sorry",
  "name": "divp_divp_eq_divp_mul",
  "kind": "theorem",
  "first-tactic": "simp only [divp]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (x : Î±)  (uâ‚ uâ‚‚ : Î±Ë£) : x /â‚š uâ‚ /â‚š uâ‚‚ = x /â‚š (uâ‚‚ * uâ‚)",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (x : Î±)  (uâ‚ uâ‚‚ : Î±Ë£)"},
 {"type": "x = y /â‚š u â†” x * u = y",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} {x : Î±}  {u : Î±Ë£}  {y : Î±} : x = y /â‚š u â†” x * u = y := by rw [eq_comm]; sorry",
  "name": "eq_divp_iff_mul_eq",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} {x : Î±}  {u : Î±Ë£}  {y : Î±} : x = y /â‚š u â†” x * u = y",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} {x : Î±}  {u : Î±Ë£}  {y : Î±}"},
 {"type": "â†‘uâ»Â¹ = 1 /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£) : â†‘uâ»Â¹ = 1 /â‚š u := by rw [one_divp]; sorry",
  "name": "inv_eq_one_divp",
  "kind": "theorem",
  "first-tactic": "rw [one_divp]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£) : â†‘uâ»Â¹ = 1 /â‚š u",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£)"},
 {"type": "((1 / u : Î±Ë£) : Î±) = 1 /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£) : ((1 / u : Î±Ë£) : Î±) = 1 /â‚š u := by rw [one_div]; sorry",
  "name": "inv_eq_one_divp'",
  "kind": "theorem",
  "first-tactic": "rw [one_div]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£) : ((1 / u : Î±Ë£) : Î±) = 1 /â‚š u",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (u : Î±Ë£)"},
 {"type": "â†‘(uâ‚ / uâ‚‚) = â†‘uâ‚ /â‚š uâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (uâ‚ uâ‚‚ : Î±Ë£) : â†‘(uâ‚ / uâ‚‚) = â†‘uâ‚ /â‚š uâ‚‚ := by rw [divp]; sorry",
  "name": "val_div_eq_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (uâ‚ uâ‚‚ : Î±Ë£) : â†‘(uâ‚ / uâ‚‚) = â†‘uâ‚ /â‚š uâ‚‚",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [Monoid Î±]  {a b c : Î±} (uâ‚ uâ‚‚ : Î±Ë£)"},
 {"type": "x /â‚š u * y = x * y /â‚š u",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (u : Î±Ë£) : x /â‚š u * y = x * y /â‚š u := by rw [divp]; sorry",
  "name": "divp_mul_eq_mul_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (u : Î±Ë£) : x /â‚š u * y = x * y /â‚š u",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (u : Î±Ë£)"},
 {"type": "x /â‚š ux = y /â‚š uy â†” x * uy = y * ux",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] {x y : Î±}  {ux uy : Î±Ë£} : x /â‚š ux = y /â‚š uy â†” x * uy = y * ux := by rw [divp_eq_iff_mul_eq]; sorry",
  "name": "divp_eq_divp_iff",
  "kind": "theorem",
  "first-tactic": "rw [divp_eq_iff_mul_eq]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] {x y : Î±}  {ux uy : Î±Ë£} : x /â‚š ux = y /â‚š uy â†” x * uy = y * ux",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] {x y : Î±}  {ux uy : Î±Ë£}"},
 {"type": "x /â‚š ux * (y /â‚š uy) = x * y /â‚š (ux * uy)",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (ux uy : Î±Ë£) : x /â‚š ux * (y /â‚š uy) = x * y /â‚š (ux * uy) := by rw [divp_mul_eq_mul_divp]; sorry",
  "name": "divp_mul_divp",
  "kind": "theorem",
  "first-tactic": "rw [divp_mul_eq_mul_divp]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (ux uy : Î±Ë£) : x /â‚š ux * (y /â‚š uy) = x * y /â‚š (ux * uy)",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  [CommMonoid Î±] (x y : Î±)  (ux uy : Î±Ë£)"},
 {"type": "âˆƒ b, a * b = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : âˆƒ b, a * b = 1 := by rcases h with âŸ¨âŸ¨a, b, hab, _âŸ©, rflâŸ©; sorry",
  "name": "IsUnit.exists_right_inv",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨âŸ¨a, b, hab, _âŸ©, rflâŸ©",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : âˆƒ b, a * b = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a)"},
 {"type": "âˆƒ b, b * a = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : âˆƒ b, b * a = 1 := by rcases h with âŸ¨âŸ¨a, b, _, hbaâŸ©, rflâŸ©; sorry",
  "name": "IsUnit.exists_left_inv",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨âŸ¨a, b, _, hbaâŸ©, rflâŸ©",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a) : âˆƒ b, b * a = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {a : M}  (h : IsUnit a)"},
 {"type": "IsUnit a â†” âˆƒ b, b * a = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M} : IsUnit a â†” âˆƒ b, b * a = 1 := by rw [isUnit_iff_exists_inv]; sorry",
  "name": "isUnit_iff_exists_inv'",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff_exists_inv]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M} : IsUnit a â†” âˆƒ b, b * a = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [CommMonoid M]  {a : M}"},
 {"type": "IsUnit x â†’ IsUnit y â†’ IsUnit (x * y)",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M} : IsUnit x â†’ IsUnit y â†’ IsUnit (x * y) := by rintro âŸ¨x, rflâŸ© âŸ¨y, rflâŸ©; sorry",
  "name": "IsUnit.mul",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨x, rflâŸ© âŸ¨y, rflâŸ©",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M} : IsUnit x â†’ IsUnit y â†’ IsUnit (x * y)",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [Monoid M]  {x y : M}"},
 {"type": "a * â†‘h.unitâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a) : a * â†‘h.unitâ»Â¹ = 1 := by rw [â†h.unit.mul_inv]; sorry",
  "name": "mul_val_inv",
  "kind": "theorem",
  "first-tactic": "rw [â†h.unit.mul_inv]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a) : a * â†‘h.unitâ»Â¹ = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _}  [Monoid M]  {a b c : M} (h : IsUnit a)"},
 {"type": "IsUnit a â†’ aâ»Â¹ * a = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a â†’ aâ»Â¹ * a = 1 := by rintro âŸ¨u, rflâŸ©; sorry",
  "name": "inv_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a â†’ aâ»Â¹ * a = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M}"},
 {"type": "IsUnit a â†’ a * aâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a â†’ a * aâ»Â¹ = 1 := by rintro âŸ¨u, rflâŸ©; sorry",
  "name": "mul_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M} : IsUnit a â†’ a * aâ»Â¹ = 1",
  "args":
  "{Î± : Type u} [Monoid Î±]  -- Porting note: unclear whether this should be a `CoeHead` or `CoeTail` (a b c : Î±Ë£)  {u : Î±Ë£}  {M : Type _}  {N : Type _} [DivisionMonoid M]  {a : M}"},
 {"type": "a * 0 = 0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {Î± : Type u}  [Mul Î±]  (a : WithZero Î±) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {Î± : Type u}  [Mul Î±]  (a : WithZero Î±) : a * 0 = 0",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {Î± : Type u}  [Mul Î±]  (a : WithZero Î±)"},
 {"type": "map (MulHom.id Î±) = MonoidHom.id (WithOne Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Mul Î±]  [MulOneClass Î²] (f : Î± â†’â‚™* Î²)  [Mul Î±]  [Mul Î²]  [Mul Î³] : map (MulHom.id Î±) = MonoidHom.id (WithOne Î±) := by ext x; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Mul Î±]  [MulOneClass Î²] (f : Î± â†’â‚™* Î²)  [Mul Î±]  [Mul Î²]  [Mul Î³] : map (MulHom.id Î±) = MonoidHom.id (WithOne Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  [Mul Î±]  [MulOneClass Î²] (f : Î± â†’â‚™* Î²)  [Mul Î±]  [Mul Î²]  [Mul Î³]"},
 {"type": "((1 : M), bâ‚) * (1, bâ‚‚) = (1, bâ‚ * bâ‚‚)",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (bâ‚ bâ‚‚ : N) : ((1 : M), bâ‚) * (1, bâ‚‚) = (1, bâ‚ * bâ‚‚) := by rw [mk_mul_mk]; sorry",
  "name": "one_mk_mul_one_mk",
  "kind": "theorem",
  "first-tactic": "rw [mk_mul_mk]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (bâ‚ bâ‚‚ : N) : ((1 : M), bâ‚) * (1, bâ‚‚) = (1, bâ‚ * bâ‚‚)",
  "args":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Monoid M]  [Mul N]  (bâ‚ bâ‚‚ : N)"},
 {"type": "(aâ‚, (1 : N)) * (aâ‚‚, 1) = (aâ‚ * aâ‚‚, 1)",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (aâ‚ aâ‚‚ : M) : (aâ‚, (1 : N)) * (aâ‚‚, 1) = (aâ‚ * aâ‚‚, 1) := by rw [mk_mul_mk]; sorry",
  "name": "mk_one_mul_mk_one",
  "kind": "theorem",
  "first-tactic": "rw [mk_mul_mk]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (aâ‚ aâ‚‚ : M) : (aâ‚, (1 : N)) * (aâ‚‚, 1) = (aâ‚ * aâ‚‚, 1)",
  "args":
  "{A : Type _}  {B : Type _}  {G : Type _}  {H : Type _}  {M : Type _}  {N : Type _}  {P : Type _} [Mul M]  [Monoid N]  (aâ‚ aâ‚‚ : M)"},
 {"type": "Function.Injective (@CommMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CommMonoid.toMonoid M) := by rintro âŸ¨âŸ© âŸ¨âŸ© h; sorry",
  "name": "CommMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© h",
  "core-prompt": "{M : Type u} : Function.Injective (@CommMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@LeftCancelMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@LeftCancelMonoid.toMonoid M) := by rintro @âŸ¨@âŸ¨âŸ©âŸ© @âŸ¨@âŸ¨âŸ©âŸ© h; sorry",
  "name": "LeftCancelMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @âŸ¨@âŸ¨âŸ©âŸ© @âŸ¨@âŸ¨âŸ©âŸ© h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@LeftCancelMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@RightCancelMonoid.toMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@RightCancelMonoid.toMonoid M) := by rintro @âŸ¨@âŸ¨âŸ©âŸ© @âŸ¨@âŸ¨âŸ©âŸ© h; sorry",
  "name": "RightCancelMonoid.toMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @âŸ¨@âŸ¨âŸ©âŸ© @âŸ¨@âŸ¨âŸ©âŸ© h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@RightCancelMonoid.toMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@CancelMonoid.toLeftCancelMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CancelMonoid.toLeftCancelMonoid M) := by rintro âŸ¨âŸ© âŸ¨âŸ© h; sorry",
  "name": "CancelMonoid.toLeftCancelMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@CancelMonoid.toLeftCancelMonoid M)",
  "args": "{M : Type u}"},
 {"type": "Function.Injective (@CancelCommMonoid.toCommMonoid M)",
  "tactic-prompt":
  "theorem {M : Type u} : Function.Injective (@CancelCommMonoid.toCommMonoid M) := by rintro @âŸ¨@âŸ¨@âŸ¨âŸ©âŸ©âŸ© @âŸ¨@âŸ¨@âŸ¨âŸ©âŸ©âŸ© h; sorry",
  "name": "CancelCommMonoid.toCommMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro @âŸ¨@âŸ¨@âŸ¨âŸ©âŸ©âŸ© @âŸ¨@âŸ¨@âŸ¨âŸ©âŸ©âŸ© h",
  "core-prompt":
  "{M : Type u} : Function.Injective (@CancelCommMonoid.toCommMonoid M)",
  "args": "{M : Type u}"},
 {"type": "op (x / y) = (op y)â»Â¹ * op x",
  "tactic-prompt":
  "theorem (Î± : Type u) [DivInvMonoid Î±]  (x y : Î±) : op (x / y) = (op y)â»Â¹ * op x := by simp [div_eq_mul_inv]; sorry",
  "name": "op_div",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt":
  "(Î± : Type u) [DivInvMonoid Î±]  (x y : Î±) : op (x / y) = (op y)â»Â¹ * op x",
  "args": "(Î± : Type u) [DivInvMonoid Î±]  (x y : Î±)"},
 {"type": "SemiconjBy (op a) (op y) (op x) â†” SemiconjBy a x y",
  "tactic-prompt":
  "theorem (Î± : Type u) [Mul Î±]  {a x y : Î±} : SemiconjBy (op a) (op y) (op x) â†” SemiconjBy a x y := by simp only [SemiconjBy]; sorry",
  "name": "semiconjBy_op",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "(Î± : Type u) [Mul Î±]  {a x y : Î±} : SemiconjBy (op a) (op y) (op x) â†” SemiconjBy a x y",
  "args": "(Î± : Type u) [Mul Î±]  {a x y : Î±}"},
 {"type": "SemiconjBy (unop a) (unop y) (unop x) â†” SemiconjBy a x y",
  "tactic-prompt":
  "theorem (Î± : Type u) [Mul Î±]  {a x y : Î±áµáµ’áµ–} : SemiconjBy (unop a) (unop y) (unop x) â†” SemiconjBy a x y := by conv_rhs => rw [â† op_unop a]; sorry",
  "name": "semiconjBy_unop",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [â† op_unop a]",
  "core-prompt":
  "(Î± : Type u) [Mul Î±]  {a x y : Î±áµáµ’áµ–} : SemiconjBy (unop a) (unop y) (unop x) â†” SemiconjBy a x y",
  "args": "(Î± : Type u) [Mul Î±]  {a x y : Î±áµáµ’áµ–}"},
 {"type": "Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r := by refine âŸ¨fun h a b c bc â†¦ ?_, fun h a b c bc â†¦ ?_âŸ©; sorry",
  "name": "Group.covariant_iff_contravariant",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h a b c bc â†¦ ?_, fun h a b c bc â†¦ ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r",
  "args": "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N]"},
 {"type": "Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r := by refine âŸ¨fun h a b c bc â†¦ ?_, fun h a b c bc â†¦ ?_âŸ©; sorry",
  "name": "Group.covariant_swap_iff_contravariant_swap",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h a b c bc â†¦ ?_, fun h a b c bc â†¦ ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r",
  "args": "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N]"},
 {"type": "Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·) := by intro h a b c bc; sorry",
  "name": "covariant_le_of_covariant_lt",
  "kind": "theorem",
  "first-tactic": "intro h a b c bc",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·)",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N]"},
 {"type": "Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·) := by refine fun h a b c bc â†¦ lt_iff_le_and_ne.mpr âŸ¨h a bc.le, ?_âŸ©; sorry",
  "name": "contravariant_lt_of_contravariant_le",
  "kind": "theorem",
  "first-tactic":
  "refine fun h a b c bc â†¦ lt_iff_le_and_ne.mpr âŸ¨h a bc.le, ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·)",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N]"},
 {"type": "Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r := by rw [flip_mul]; sorry",
  "name": "covariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N]"},
 {"type": "Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r := by rw [flip_mul]; sorry",
  "name": "contravariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N]"},
 {"type": "p âˆ£ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {p : Î±}  (hp : Prime p) (hp : Prime p)  {a : Î±}  {n : â„•}  (h : p âˆ£ a ^ n) : p âˆ£ a := by induction' n with n ih; sorry",
  "name": "dvd_of_dvd_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {p : Î±}  (hp : Prime p) (hp : Prime p)  {a : Î±}  {n : â„•}  (h : p âˆ£ a ^ n) : p âˆ£ a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {p : Î±}  (hp : Prime p) (hp : Prime p)  {a : Î±}  {n : â„•}  (h : p âˆ£ a ^ n)"},
 {"type": "a âˆ£ p * b â†’ p âˆ£ a âˆ¨ a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p : Î±}  (hp : Prime p)      {a b : Î±} : a âˆ£ p * b â†’ p âˆ£ a âˆ¨ a âˆ£ b := by rintro âŸ¨c, hcâŸ©; sorry",
  "name": "Prime.left_dvd_or_dvd_right_of_dvd_mul",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨c, hcâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p : Î±}  (hp : Prime p)      {a b : Î±} : a âˆ£ p * b â†’ p âˆ£ a âˆ¨ a âˆ£ b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p : Î±}  (hp : Prime p)      {a b : Î±}"},
 {"type": "p ^ n âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ a)  (h' : p ^ n âˆ£ a * b) : p ^ n âˆ£ b := by induction' n with n ih; sorry",
  "name": "Prime.pow_dvd_of_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ a)  (h' : p ^ n âˆ£ a * b) : p ^ n âˆ£ b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ a)  (h' : p ^ n âˆ£ a * b)"},
 {"type": "p ^ n âˆ£ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ b)  (h' : p ^ n âˆ£ a * b) : p ^ n âˆ£ a := by rw [mul_comm] at h'; sorry",
  "name": "Prime.pow_dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at h'",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ b)  (h' : p ^ n âˆ£ a * b) : p ^ n âˆ£ a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}  (hp : Prime p)      (n : â„•)  (h : Â¬p âˆ£ b)  (h' : p ^ n âˆ£ a * b)"},
 {"type": "p âˆ£ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}      {n : â„•}  (hp : Prime p)  (hpow : p ^ n.succ âˆ£ a ^ n.succ * b ^ n)  (hb : Â¬p ^ 2 âˆ£ b) : p âˆ£ a := by cases' hp.dvd_or_dvd ((dvd_pow_self p (Nat.succ_ne_zero n)).trans hpow) with H hbdiv; sorry",
  "name": "Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd",
  "kind": "theorem",
  "first-tactic":
  "cases' hp.dvd_or_dvd ((dvd_pow_self p (Nat.succ_ne_zero n)).trans hpow) with H hbdiv",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}      {n : â„•}  (hp : Prime p)  (hpow : p ^ n.succ âˆ£ a ^ n.succ * b ^ n)  (hb : Â¬p ^ 2 âˆ£ b) : p âˆ£ a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [CancelCommMonoidWithZero Î±]  {p a b : Î±}      {n : â„•}  (hp : Prime p)  (hpow : p ^ n.succ âˆ£ a ^ n.succ * b ^ n)  (hb : Â¬p ^ 2 âˆ£ b)"},
 {"type": "p ^ (i + 1) âˆ£ x âˆ¨ p âˆ£ y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± : Type _}  [CancelCommMonoidWithZero Î±]  {p x y : Î±}  (h : Prime p)      {i : â„•}  (hxy : p ^ (i + 1) âˆ£ x * y) : p ^ (i + 1) âˆ£ x âˆ¨ p âˆ£ y := by rw [or_iff_not_imp_right]; sorry",
  "name": "prime_pow_succ_dvd_mul",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± : Type _}  [CancelCommMonoidWithZero Î±]  {p x y : Î±}  (h : Prime p)      {i : â„•}  (hxy : p ^ (i + 1) âˆ£ x * y) : p ^ (i + 1) âˆ£ x âˆ¨ p âˆ£ y",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± : Type _}  [CancelCommMonoidWithZero Î±]  {p x y : Î±}  (h : Prime p)      {i : â„•}  (hxy : p ^ (i + 1) âˆ£ x * y)"},
 {"type": "Â¬Irreducible (1 : Î±)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±] : Â¬Irreducible (1 : Î±) := by simp [irreducible_iff]; sorry",
  "name": "not_irreducible_one",
  "kind": "theorem",
  "first-tactic": "simp [irreducible_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±] : Â¬Irreducible (1 : Î±)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±]"},
 {"type": "p âˆ£ q â†’ q âˆ£ p",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±]  {p q : Î±}  (hp : Irreducible p)  (hq : Irreducible q) : p âˆ£ q â†’ q âˆ£ p := by rintro âŸ¨q', rflâŸ©; sorry",
  "name": "Irreducible.dvd_symm",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨q', rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±]  {p q : Î±}  (hp : Irreducible p)  (hq : Irreducible q) : p âˆ£ q â†’ q âˆ£ p",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} [Monoid Î±]  {p q : Î±}  (hp : Irreducible p)  (hq : Irreducible q)"},
 {"type": "Irreducible (â†‘a * b) â†” Irreducible b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±) : Irreducible (â†‘a * b) â†” Irreducible b := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_units_mul",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±) : Irreducible (â†‘a * b) â†” Irreducible b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±)"},
 {"type": "Irreducible (b * â†‘a) â†” Irreducible b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±) : Irreducible (b * â†‘a) â†” Irreducible b := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_mul_units",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±) : Irreducible (b * â†‘a) â†” Irreducible b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] (a : Î±Ë£)  (b : Î±)"},
 {"type":
  "Irreducible (a * b) â†” Irreducible a âˆ§ IsUnit b âˆ¨ Irreducible b âˆ§ IsUnit a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] {a b : Î±} : Irreducible (a * b) â†” Irreducible a âˆ§ IsUnit b âˆ¨ Irreducible b âˆ§ IsUnit a := by constructor; sorry",
  "name": "irreducible_mul_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] {a b : Î±} : Irreducible (a * b) â†” Irreducible a âˆ§ IsUnit b âˆ¨ Irreducible b âˆ§ IsUnit a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±] {a b : Î±}"},
 {"type": "Â¬IsSquare a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a : Î±} (ha : Irreducible a) : Â¬IsSquare a := by rintro âŸ¨b, rflâŸ©; sorry",
  "name": "Irreducible.not_square",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨b, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a : Î±} (ha : Irreducible a) : Â¬IsSquare a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a : Î±} (ha : Irreducible a)"},
 {"type": "Associated (u * a) a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  (a u : Î²)  (hu : IsUnit u) : Associated (u * a) a := by rw [mul_comm]; sorry",
  "name": "associated_unit_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  (a u : Î²)  (hu : IsUnit u) : Associated (u * a) a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  (a u : Î²)  (hu : IsUnit u)"},
 {"type": "Associated (u * a) b â†” Associated a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  {u a b : Î²}  (hu : IsUnit u) : Associated (u * a) b â†” Associated a b := by rw [mul_comm]; sorry",
  "name": "associated_isUnit_mul_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  {u a b : Î²}  (hu : IsUnit u) : Associated (u * a) b â†” Associated a b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î² : Type _}  [CommMonoid Î²]  {u a b : Î²}  (hu : IsUnit u)"},
 {"type": "(Associated : Î± â†’ Î± â†’ Prop) = Eq",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£] : (Associated : Î± â†’ Î± â†’ Prop) = Eq := by ext; sorry",
  "name": "associated_eq_eq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£] : (Associated : Î± â†’ Î± â†’ Prop) = Eq",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£]"},
 {"type": "p âˆ£ q â†” p = q",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique MË£]  {p q : M}      (pp : Prime p)  (qp : Prime q) : p âˆ£ q â†” p = q := by rw [pp.dvd_prime_iff_associated qp]; sorry",
  "name": "prime_dvd_prime_iff_eq",
  "kind": "theorem",
  "first-tactic": "rw [pp.dvd_prime_iff_associated qp]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique MË£]  {p q : M}      (pp : Prime p)  (qp : Prime q) : p âˆ£ q â†” p = q",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [Monoid Î±]  [Unique Î±Ë£] {M : Type _}  [CancelCommMonoidWithZero M]  [Unique MË£]  {p q : M}      (pp : Prime p)  (qp : Prime q)"},
 {"type": "pâ‚ = pâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚) : pâ‚ = pâ‚‚ := by rw [â† associated_iff_eq] at hâŠ¢; sorry",
  "name": "eq_of_prime_pow_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† associated_iff_eq] at hâŠ¢",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚) : pâ‚ = pâ‚‚",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚)"},
 {"type": "pâ‚ = pâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚) : pâ‚ = pâ‚‚ := by rw [â† associated_iff_eq] at hâŠ¢; sorry",
  "name": "eq_of_prime_pow_eq'",
  "kind": "theorem",
  "first-tactic": "rw [â† associated_iff_eq] at hâŠ¢",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚) : pâ‚ = pâ‚‚",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  {R : Type _}  [CancelCommMonoidWithZero R]  [Unique RË£]  {pâ‚ pâ‚‚ : R}  {kâ‚ kâ‚‚ : â„•} (hpâ‚ : Prime pâ‚)  (hpâ‚‚ : Prime pâ‚‚)  (hkâ‚ : 0 < kâ‚‚)      (h : pâ‚ ^ kâ‚ = pâ‚‚ ^ kâ‚‚)"},
 {"type": "Associates.mk (a ^ n) = Associates.mk a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (a : Î±)  (n : â„•) : Associates.mk (a ^ n) = Associates.mk a ^ n := by induction n; sorry",
  "name": "mk_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (a : Î±)  (n : â„•) : Associates.mk (a ^ n) = Associates.mk a ^ n",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (a : Î±)  (n : â„•)"},
 {"type": "(u : Associates Î±) = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (u : (Associates Î±)Ë£) : (u : Associates Î±) = 1 := by simp; sorry",
  "name": "coe_unit_eq_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (u : (Associates Î±)Ë£) : (u : Associates Î±) = 1",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] (u : (Associates Î±)Ë£)"},
 {"type": "IsUnit a â†” a = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] {a : Associates Î±} : IsUnit a â†” a = âŠ¥ := by rw [Associates.isUnit_iff_eq_one]; sorry",
  "name": "isUnit_iff_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [Associates.isUnit_iff_eq_one]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] {a : Associates Î±} : IsUnit a â†” a = âŠ¥",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±] {a : Associates Î±}"},
 {"type": "a â‰¤ b * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a b : Associates Î±} : a â‰¤ b * a := by rw [mul_comm]; sorry",
  "name": "le_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a b : Associates Î±} : a â‰¤ b * a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoid Î±]  {a b : Associates Î±}"},
 {"type": "Prime (Associates.mk p) â†” Prime p",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (p : Î±) : Prime (Associates.mk p) â†” Prime p := by rw [Prime]; sorry",
  "name": "prime_mk",
  "kind": "theorem",
  "first-tactic": "rw [Prime]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (p : Î±) : Prime (Associates.mk p) â†” Prime p",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (p : Î±)"},
 {"type": "Irreducible (Associates.mk a) â†” Irreducible a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (a : Î±) : Irreducible (Associates.mk a) â†” Irreducible a := by simp only [irreducible_iff]; sorry",
  "name": "irreducible_mk",
  "kind": "theorem",
  "first-tactic": "simp only [irreducible_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (a : Î±) : Irreducible (Associates.mk a) â†” Irreducible a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] (a : Î±)"},
 {"type": "DvdNotUnit (Associates.mk a) (Associates.mk b) â†” DvdNotUnit a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Î±} : DvdNotUnit (Associates.mk a) (Associates.mk b) â†” DvdNotUnit a b := by rw [DvdNotUnit]; sorry",
  "name": "mk_dvdNotUnit_mk_iff",
  "kind": "theorem",
  "first-tactic": "rw [DvdNotUnit]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Î±} : DvdNotUnit (Associates.mk a) (Associates.mk b) â†” DvdNotUnit a b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Î±}"},
 {"type": "DvdNotUnit a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Associates Î±}  (hlt : a < b) : DvdNotUnit a b := by constructor; sorry",
  "name": "dvdNotUnit_of_lt",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Associates Î±}  (hlt : a < b) : DvdNotUnit a b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] {a b : Associates Î±}  (hlt : a < b)"},
 {"type":
  "(âˆ€ a : Î±, Irreducible a â†” Prime a) â†” âˆ€ a : Associates Î±, Irreducible a â†” Prime a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] : (âˆ€ a : Î±, Irreducible a â†” Prime a) â†” âˆ€ a : Associates Î±, Irreducible a â†” Prime a := by simp_rw [forall_associated]; sorry",
  "name": "irreducible_iff_prime_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [forall_associated]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±] : (âˆ€ a : Î±, Irreducible a â†” Prime a) â†” âˆ€ a : Associates Î±, Irreducible a â†” Prime a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]"},
 {"type": "âˆ€ a b c : Associates Î±, a â‰  0 â†’ a * b = a * c â†’ b = c",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±] : âˆ€ a b c : Associates Î±, a â‰  0 â†’ a * b = a * c â†’ b = c := by rintro âŸ¨aâŸ© âŸ¨bâŸ© âŸ¨câŸ© ha h; sorry",
  "name": "eq_of_mul_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨aâŸ© âŸ¨bâŸ© âŸ¨câŸ© ha h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±] : âˆ€ a b c : Associates Î±, a â‰  0 â†’ a * b = a * c â†’ b = c",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]"},
 {"type": "p â‰¤ 1 â†” p = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±] {p : Associates Î±} : p â‰¤ 1 â†” p = 1 := by rw [â† Associates.bot_eq_one]; sorry",
  "name": "le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† Associates.bot_eq_one]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±] {p : Associates Î±} : p â‰¤ 1 â†” p = 1",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±] {p : Associates Î±}"},
 {"type": "IsUnit p",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}      (h : DvdNotUnit p q)  (hq : Irreducible q) : IsUnit p := by obtain âŸ¨_, x, hx, hx'âŸ© := h; sorry",
  "name": "DvdNotUnit.isUnit_of_irreducible_right",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨_, x, hx, hx'âŸ© := h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}      (h : DvdNotUnit p q)  (hq : Irreducible q) : IsUnit p",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}      (h : DvdNotUnit p q)  (hq : Irreducible q)"},
 {"type": "Â¬IsUnit q",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}  (hp : DvdNotUnit p q) : Â¬IsUnit q := by obtain âŸ¨-, x, hx, rflâŸ© := hp; sorry",
  "name": "DvdNotUnit.not_unit",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨-, x, hx, rflâŸ© := hp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}  (hp : DvdNotUnit p q) : Â¬IsUnit q",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  {p q : Î±}  (hp : DvdNotUnit p q)"},
 {"type": "DvdNotUnit p r",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  [Nontrivial Î±]  {p q r : Î±}      (h : DvdNotUnit p q)  (h' : Associated q r) : DvdNotUnit p r := by obtain âŸ¨u, rflâŸ© := Associated.symm h'; sorry",
  "name": "dvdNotUnit_of_dvdNotUnit_associated",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨u, rflâŸ© := Associated.symm h'",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  [Nontrivial Î±]  {p q r : Î±}      (h : DvdNotUnit p q)  (h' : Associated q r) : DvdNotUnit p r",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CommMonoidWithZero Î±]  [Nontrivial Î±]  {p q r : Î±}      (h : DvdNotUnit p q)  (h' : Associated q r)"},
 {"type": "IsUnit b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p b : Î±}  (h : Associated (p * b) p)      (hp : p â‰  0) : IsUnit b := by cases' h with a ha; sorry",
  "name": "isUnit_of_associated_mul",
  "kind": "theorem",
  "first-tactic": "cases' h with a ha",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p b : Î±}  (h : Associated (p * b) p)      (hp : p â‰  0) : IsUnit b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p b : Î±}  (h : Associated (p * b) p)      (hp : p â‰  0)"},
 {"type": "Â¬Associated p q",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q) : Â¬Associated p q := by rintro âŸ¨a, rflâŸ©; sorry",
  "name": "DvdNotUnit.not_associated",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q) : Â¬Associated p q",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q)"},
 {"type": "p â‰  q",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q) : p â‰  q := by by_contra hcontra; sorry",
  "name": "DvdNotUnit.ne",
  "kind": "theorem",
  "first-tactic": "by_contra hcontra",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q) : p â‰  q",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (h : DvdNotUnit p q)"},
 {"type": "Function.Injective fun n : â„• => q ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {q : Î±}  (hq : Â¬IsUnit q)      (hq' : q â‰  0) : Function.Injective fun n : â„• => q ^ n := by refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne âŸ¨pow_ne_zero n hq', q ^ (m - n), _, _âŸ©; sorry",
  "name": "pow_injective_of_not_unit",
  "kind": "theorem",
  "first-tactic":
  "refine' injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne âŸ¨pow_ne_zero n hq', q ^ (m - n), _, _âŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {q : Î±}  (hq : Â¬IsUnit q)      (hq' : q â‰  0) : Function.Injective fun n : â„• => q ^ n",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {q : Î±}  (hq : Â¬IsUnit q)      (hq' : q â‰  0)"},
 {"type": "q âˆ£ p ^ n â†” âˆƒ i â‰¤ n, Associated q (p ^ i)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (hp : Prime p)  (n : â„•) : q âˆ£ p ^ n â†” âˆƒ i â‰¤ n, Associated q (p ^ i) := by induction' n with n ih generalizing q; sorry",
  "name": "dvd_prime_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih generalizing q",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (hp : Prime p)  (n : â„•) : q âˆ£ p ^ n â†” âˆƒ i â‰¤ n, Associated q (p ^ i)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _}  [CancelCommMonoidWithZero Î±]  {p q : Î±}  (hp : Prime p)  (n : â„•)"},
 {"type": "Â¬NeZero n â†” n = 0",
  "tactic-prompt":
  "theorem {R : Type _}  [Zero R]  {n : R} : Â¬NeZero n â†” n = 0 := by simp [neZero_iff]; sorry",
  "name": "not_neZero",
  "kind": "theorem",
  "first-tactic": "simp [neZero_iff]",
  "core-prompt": "{R : Type _}  [Zero R]  {n : R} : Â¬NeZero n â†” n = 0",
  "args": "{R : Type _}  [Zero R]  {n : R}"},
 {"type": "(0 : M) ^ n = if n = 0 then 1 else 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] (n : â„•) : (0 : M) ^ n = if n = 0 then 1 else 0 := by split_ifs with h; sorry",
  "name": "zero_pow_eq",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] (n : â„•) : (0 : M) ^ n = if n = 0 then 1 else 0",
  "args": "{R S M : Type _}  [MonoidWithZero M] (n : â„•)"},
 {"type": "x ^ m = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : â„•}  (hn : n â‰¤ m)  (hx : x ^ n = 0) : x ^ m = 0 := by rw [â† tsub_add_cancel_of_le hn]; sorry",
  "name": "pow_eq_zero_of_le",
  "kind": "theorem",
  "first-tactic": "rw [â† tsub_add_cancel_of_le hn]",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : â„•}  (hn : n â‰¤ m)  (hx : x ^ n = 0) : x ^ m = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] {x : M}  {n m : â„•}  (hn : n â‰¤ m)  (hx : x ^ n = 0)"},
 {"type": "x = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : â„•}  (H : x ^ n = 0) : x = 0 := by induction' n with n ih; sorry",
  "name": "pow_eq_zero",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : â„•}  (H : x ^ n = 0) : x = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {x : M}  {n : â„•}  (H : x ^ n = 0)"},
 {"type": "a ^ n = 0 â†” a = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : â„•}  (hn : 0 < n) : a ^ n = 0 â†” a = 0 := by refine' âŸ¨pow_eq_zero, _âŸ©; sorry",
  "name": "pow_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨pow_eq_zero, _âŸ©",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : â„•}  (hn : 0 < n) : a ^ n = 0 â†” a = 0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  {a : M}  {n : â„•}  (hn : 0 < n)"},
 {"type": "a ^ n = 0 â†” a = 0 âˆ§ n â‰  0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : â„•} : a ^ n = 0 â†” a = 0 âˆ§ n â‰  0 := by cases (zero_le n).eq_or_gt; sorry",
  "name": "pow_eq_zero_iff'",
  "kind": "theorem",
  "first-tactic": "cases (zero_le n).eq_or_gt",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : â„•} : a ^ n = 0 â†” a = 0 âˆ§ n â‰  0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] [NoZeroDivisors M]  [Nontrivial M]  {a : M}  {n : â„•}"},
 {"type": "a ^ n â‰  0 â†’ a â‰  0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] {a : M}  {n : â„•}  (hn : n â‰  0) : a ^ n â‰  0 â†’ a â‰  0 := by contrapose!; sorry",
  "name": "ne_zero_pow",
  "kind": "theorem",
  "first-tactic": "contrapose!",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] {a : M}  {n : â„•}  (hn : n â‰  0) : a ^ n â‰  0 â†’ a â‰  0",
  "args":
  "{R S M : Type _}  [MonoidWithZero M] {a : M}  {n : â„•}  (hn : n â‰  0)"},
 {"type": "(0 : M) ^ n = 0 â†” 0 < n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : â„•} : (0 : M) ^ n = 0 â†” 0 < n := by constructor; sorry",
  "name": "zero_pow_eq_zero",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : â„•} : (0 : M) ^ n = 0 â†” 0 < n",
  "args": "{R S M : Type _}  [MonoidWithZero M] [Nontrivial M]  {n : â„•}"},
 {"type": "x ^ n âˆ£ x ^ m â†” n â‰¤ m",
  "tactic-prompt":
  "theorem {R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : â„•}  (h0 : x â‰  0)      (h1 : Â¬IsUnit x) : x ^ n âˆ£ x ^ m â†” n â‰¤ m := by constructor; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : â„•}  (h0 : x â‰  0)      (h1 : Â¬IsUnit x) : x ^ n âˆ£ x ^ m â†” n â‰¤ m",
  "args":
  "{R S M : Type _} [CancelCommMonoidWithZero R]  {x : R}  {n m : â„•}  (h0 : x â‰  0)      (h1 : Â¬IsUnit x)"},
 {"type": "c ^ min n m âˆ£ a + b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Semiring R]  [Semiring S] {n m : â„•}  {a b c : R}  (ha : c ^ n âˆ£ a)  (hb : c ^ m âˆ£ b) : c ^ min n m âˆ£ a + b := by replace ha := (pow_dvd_pow c (min_le_left n m)).trans ha; sorry",
  "name": "min_pow_dvd_add",
  "kind": "theorem",
  "first-tactic": "replace ha := (pow_dvd_pow c (min_le_left n m)).trans ha",
  "core-prompt":
  "{R S M : Type _}  [Semiring R]  [Semiring S] {n m : â„•}  {a b c : R}  (ha : c ^ n âˆ£ a)  (hb : c ^ m âˆ£ b) : c ^ min n m âˆ£ a + b",
  "args":
  "{R S M : Type _}  [Semiring R]  [Semiring S] {n m : â„•}  {a b c : R}  (ha : c ^ n âˆ£ a)  (hb : c ^ m âˆ£ b)"},
 {"type": "(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2 := by simp only [sq]; sorry",
  "name": "add_sq",
  "kind": "theorem",
  "first-tactic": "simp only [sq]",
  "core-prompt":
  "{R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2",
  "args": "{R S M : Type _}  [CommSemiring R] (a b : R)"},
 {"type": "(a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b := by rw [add_sq]; sorry",
  "name": "add_sq'",
  "kind": "theorem",
  "first-tactic": "rw [add_sq]",
  "core-prompt":
  "{R S M : Type _}  [CommSemiring R] (a b : R) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b",
  "args": "{R S M : Type _}  [CommSemiring R] (a b : R)"},
 {"type": "(-a) ^ bit0 n = a ^ bit0 n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•) : (-a) ^ bit0 n = a ^ bit0 n := by rw [pow_bit0']; sorry",
  "name": "neg_pow_bit0",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0']",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•) : (-a) ^ bit0 n = a ^ bit0 n",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•)"},
 {"type": "(-a) ^ bit1 n = -a ^ bit1 n",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•) : (-a) ^ bit1 n = -a ^ bit1 n := by simp only [bit1]; sorry",
  "name": "neg_pow_bit1",
  "kind": "theorem",
  "first-tactic": "simp only [bit1]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•) : (-a) ^ bit1 n = -a ^ bit1 n",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  (a : R)  (n : â„•)"},
 {"type": "(-a) ^ 2 = a ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2 := by simp [sq]; sorry",
  "name": "neg_sq",
  "kind": "theorem",
  "first-tactic": "simp [sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R) : (-a) ^ 2 = a ^ 2",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] (a : R)"},
 {"type": "(-1 : R) ^ 2 = 1",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R] : (-1 : R) ^ 2 = 1 := by simp [neg_sq]; sorry",
  "name": "neg_one_sq",
  "kind": "theorem",
  "first-tactic": "simp [neg_sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R] : (-1 : R) ^ 2 = 1",
  "args": "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]"},
 {"type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by rw [sq]; sorry",
  "name": "Commute.sq_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} (h : Commute a b)"},
 {"type": "(-1) ^ n * r = 0 â†” r = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R} : (-1) ^ n * r = 0 â†” r = 0 := by rcases neg_one_pow_eq_or R n with h | h; sorry",
  "name": "neg_one_pow_mul_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rcases neg_one_pow_eq_or R n with h | h",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R} : (-1) ^ n * r = 0 â†” r = 0",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R}"},
 {"type": "r * (-1) ^ n = 0 â†” r = 0",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R} : r * (-1) ^ n = 0 â†” r = 0 := by rcases neg_one_pow_eq_or R n with h | h; sorry",
  "name": "mul_neg_one_pow_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rcases neg_one_pow_eq_or R n with h | h",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R} : r * (-1) ^ n = 0 â†” r = 0",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} {n : â„•}  {r : R}"},
 {"type": "a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b) : a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b := by rw [â† sub_eq_zero]; sorry",
  "name": "Commute.sq_eq_sq_iff_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† sub_eq_zero]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b) : a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] (h : Commute a b)"},
 {"type": "a ^ 2 = 1 â†” a = 1 âˆ¨ a = -1",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] : a ^ 2 = 1 â†” a = 1 âˆ¨ a = -1 := by rw [â† (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg]; sorry",
  "name": "sq_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† (Commute.one_right a).sq_eq_sq_iff_eq_or_eq_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R] : a ^ 2 = 1 â†” a = 1 âˆ¨ a = -1",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [Ring R]  {a b : R} [NoZeroDivisors R]"},
 {"type": "(a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2 := by rw [sub_eq_add_neg]; sorry",
  "name": "sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R)"},
 {"type": "(a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b := by rw [sub_eq_add_neg]; sorry",
  "name": "sub_sq'",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R) : (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] (a b : R)"},
 {"type": "a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : RË£} : a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b := by simp_rw [ext_iff]; sorry",
  "name": "sq_eq_sq_iff_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : RË£} : a ^ 2 = b ^ 2 â†” a = b âˆ¨ a = -b",
  "args":
  "{R S M : Type _}  [Monoid R]  [HasDistribNeg R]  [CommRing R] [NoZeroDivisors R]  {a b : R} {a b : RË£}"},
 {"type": "(a ^ if P then b else c) = if P then a ^ b else a ^ c",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a : M)  (b c : â„•) : (a ^ if P then b else c) = if P then a ^ b else a ^ c := by split_ifs; sorry",
  "name": "pow_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a : M)  (b c : â„•) : (a ^ if P then b else c) = if P then a ^ b else a ^ c",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a : M)  (b c : â„•)"},
 {"type": "(if P then a else b) ^ c = if P then a ^ c else b ^ c",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a b : M)  (c : â„•) : (if P then a else b) ^ c = if P then a ^ c else b ^ c := by split_ifs; sorry",
  "name": "ite_pow",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a b : M)  (c : â„•) : (if P then a else b) ^ c = if P then a ^ c else b ^ c",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Pow M â„•] (P : Prop)  [Decidable P]  (a b : M)  (c : â„•)"},
 {"type": "n â€¢ (0 : A) = 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•) : n â€¢ (0 : A) = 0 := by induction' n with n ih; sorry",
  "name": "nsmul_zero",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•) : n â€¢ (0 : A) = 0",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•)"},
 {"type": "1 â€¢ a = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A) : 1 â€¢ a = a := by rw [succ_nsmul]; sorry",
  "name": "one_nsmul",
  "kind": "theorem",
  "first-tactic": "rw [succ_nsmul]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A) : 1 â€¢ a = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A)"},
 {"type": "(m + n) â€¢ a = m â€¢ a + n â€¢ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A)  (m n : â„•) : (m + n) â€¢ a = m â€¢ a + n â€¢ a := by induction m; sorry",
  "name": "add_nsmul",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A)  (m n : â„•) : (m + n) â€¢ a = m â€¢ a + n â€¢ a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : A)  (m n : â„•)"},
 {"type": "(1 : M) ^ n = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•) : (1 : M) ^ n = 1 := by induction' n with n ih; sorry",
  "name": "one_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•) : (1 : M) ^ n = 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (n : â„•)"},
 {"type": "a ^ 1 = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 1 = a := by rw [pow_succ]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 1 = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 2 = a * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 2 = a * a := by rw [pow_succ]; sorry",
  "name": "pow_two",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 2 = a * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 3 = a * a * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * a * a := by rw [pow_succ']; sorry",
  "name": "pow_three'",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ']",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * a * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ 3 = a * (a * a)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * (a * a) := by rw [pow_succ]; sorry",
  "name": "pow_three",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M) : a ^ 3 = a * (a * a)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m + n) = a ^ m * a ^ n := by induction' n with n ih; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m + n) = a ^ m * a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•)"},
 {"type": "a ^ (m * n) = (a ^ m) ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ m) ^ n := by induction' n with n ih; sorry",
  "name": "pow_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ m) ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•)"},
 {"type": "a ^ (m * n) = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ n) ^ m := by rw [Nat.mul_comm]; sorry",
  "name": "pow_mul'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ n) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•)"},
 {"type": "(a * b) ^ n = a ^ n * b ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : â„•) : (a * b) ^ n = a ^ n * b ^ n := by induction' n with n ih; sorry",
  "name": "Commute.mul_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : â„•) : (a * b) ^ n = a ^ n * b ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (h : Commute a b)  (n : â„•)"},
 {"type": "(a ^ if P then 1 else 0) = if P then a else 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M) : (a ^ if P then 1 else 0) = if P then a else 1 := by simp; sorry",
  "name": "pow_boole",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M) : (a ^ if P then 1 else 0) = if P then a else 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (P : Prop)  [Decidable P]  (a : M)"},
 {"type": "(a ^ m) ^ n = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : (a ^ m) ^ n = (a ^ n) ^ m := by rw [â† pow_mul]; sorry",
  "name": "pow_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_mul]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•) : (a ^ m) ^ n = (a ^ n) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  (m n : â„•)"},
 {"type": "a ^ m * a ^ (n - m) = a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n) : a ^ m * a ^ (n - m) = a ^ n := by rw [â† pow_add]; sorry",
  "name": "pow_mul_pow_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_add]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n) : a ^ m * a ^ (n - m) = a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n)"},
 {"type": "a ^ (n - m) * a ^ m = a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n) : a ^ (n - m) * a ^ m = a ^ n := by rw [â† pow_add]; sorry",
  "name": "pow_sub_mul_pow",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_add]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n) : a ^ (n - m) * a ^ m = a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] (a : M)  {m n : â„•}  (h : m â‰¤ n)"},
 {"type": "x ^ m = x ^ (m % n)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : â„•)  {n : â„•}  (h : x ^ n = 1) : x ^ m = x ^ (m % n) := by have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n    congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm; sorry",
  "name": "pow_eq_pow_mod",
  "kind": "theorem",
  "first-tactic":
  "have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n    congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : â„•)  {n : â„•}  (h : x ^ n = 1) : x ^ m = x ^ (m % n)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {M : Type _}  [Monoid M]  {x : M}  (m : â„•)  {n : â„•}  (h : x ^ n = 1)"},
 {"type": "a ^ bit1 n = a ^ n * a ^ n * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit1 n = a ^ n * a ^ n * a := by rw [bit1]; sorry",
  "name": "pow_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit1 n = a ^ n * a ^ n * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•)"},
 {"type": "a ^ bit0 n = (a * a) ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit0 n = (a * a) ^ n := by rw [pow_bit0]; sorry",
  "name": "pow_bit0'",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit0 n = (a * a) ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•)"},
 {"type": "a ^ bit1 n = (a * a) ^ n * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit1 n = (a * a) ^ n * a := by rw [bit1]; sorry",
  "name": "pow_bit1'",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•) : a ^ bit1 n = (a * a) ^ n * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A]  (a : M)  (n : â„•)"},
 {"type": "a ^ n * b ^ n = 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (n : â„•)  (h : a * b = 1) : a ^ n * b ^ n = 1 := by induction' n with n hn; sorry",
  "name": "pow_mul_pow_eq_one",
  "kind": "theorem",
  "first-tactic": "induction' n with n hn",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (n : â„•)  (h : a * b = 1) : a ^ n * b ^ n = 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [AddMonoid A] {a b : M}  (n : â„•)  (h : a * b = 1)"},
 {"type": "a ^ (1 : â„¤) = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G) : a ^ (1 : â„¤) = a := by convert pow_one a using 1; sorry",
  "name": "zpow_one",
  "kind": "theorem",
  "first-tactic": "convert pow_one a using 1",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G) : a ^ (1 : â„¤) = a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G)"},
 {"type": "a ^ (2 : â„¤) = a * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G) : a ^ (2 : â„¤) = a * a := by convert pow_two a using 1; sorry",
  "name": "zpow_two",
  "kind": "theorem",
  "first-tactic": "convert pow_two a using 1",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G) : a ^ (2 : â„¤) = a * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivInvMonoid G] (a : G)"},
 {"type": "(a * b) ^ (-1 : â„¤) = b ^ (-1 : â„¤) * a ^ (-1 : â„¤)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a b : Î±) : (a * b) ^ (-1 : â„¤) = b ^ (-1 : â„¤) * a ^ (-1 : â„¤) := by simp only [zpow_neg]; sorry",
  "name": "mul_zpow_neg_one",
  "kind": "theorem",
  "first-tactic": "simp only [zpow_neg]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a b : Î±) : (a * b) ^ (-1 : â„¤) = b ^ (-1 : â„¤) * a ^ (-1 : â„¤)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a b : Î±)"},
 {"type": "aâ»Â¹ ^ n = a ^ (-n)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤) : aâ»Â¹ ^ n = a ^ (-n) := by rw [inv_zpow]; sorry",
  "name": "inv_zpow'",
  "kind": "theorem",
  "first-tactic": "rw [inv_zpow]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤) : aâ»Â¹ ^ n = a ^ (-n)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤)"},
 {"type": "(1 / a) ^ n = 1 / a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„•) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div]; sorry",
  "name": "one_div_pow",
  "kind": "theorem",
  "first-tactic": "simp only [one_div]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„•) : (1 / a) ^ n = 1 / a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„•)"},
 {"type": "(1 / a) ^ n = 1 / a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤) : (1 / a) ^ n = 1 / a ^ n := by simp only [one_div]; sorry",
  "name": "one_div_zpow",
  "kind": "theorem",
  "first-tactic": "simp only [one_div]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤) : (1 / a) ^ n = 1 / a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  {a b : Î±} (a : Î±)  (n : â„¤)"},
 {"type": "(a / b) ^ n = a ^ n / b ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„•) : (a / b) ^ n = a ^ n / b ^ n := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_pow",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„•) : (a / b) ^ n = a ^ n / b ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„•)"},
 {"type": "(a / b) ^ n = a ^ n / b ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„¤) : (a / b) ^ n = a ^ n / b ^ n := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_zpow",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„¤) : (a / b) ^ n = a ^ n / b ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionCommMonoid Î±] (a b : Î±)  (n : â„¤)"},
 {"type": "aâ»Â¹ ^ (m - n) = (a ^ m)â»Â¹ * a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : â„•}  (h : n â‰¤ m) : aâ»Â¹ ^ (m - n) = (a ^ m)â»Â¹ * a ^ n := by rw [pow_sub aâ»Â¹ h]; sorry",
  "name": "inv_pow_sub",
  "kind": "theorem",
  "first-tactic": "rw [pow_sub aâ»Â¹ h]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : â„•}  (h : n â‰¤ m) : aâ»Â¹ ^ (m - n) = (a ^ m)â»Â¹ * a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  [Group H]  [AddGroup A]  [AddGroup B] (a : G)  {m n : â„•}  (h : n â‰¤ m)"},
 {"type":
  "(xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2 := by ring; sorry",
  "name": "sq_add_sq_mul_sq_add_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2) = (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type":
  "(xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) =\n    (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) =\n    (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2 := by ring; sorry",
  "name": "sq_add_mul_sq_mul_sq_add_mul_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + n * xâ‚‚ ^ 2) * (yâ‚ ^ 2 + n * yâ‚‚ ^ 2) =\n    (xâ‚ * yâ‚ - n * xâ‚‚ * yâ‚‚) ^ 2 + n * (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type": "a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2) := by ring; sorry",
  "name": "pow_four_add_four_mul_pow_four",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type":
  "a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2) := by ring; sorry",
  "name": "pow_four_add_four_mul_pow_four'",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type":
  "(xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) =\n      (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 +\n          (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 +\n        (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) =\n      (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 +\n          (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 +\n        (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2 := by ring; sorry",
  "name": "sum_four_sq_mul_sum_four_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2) * (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2) =\n      (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„) ^ 2 + (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ) ^ 2 +\n          (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚) ^ 2 +\n        (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type":
  "(xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) *\n      (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) =\n    (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 +\n      (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 +\n      (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 +\n      (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 +\n      (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 +\n      (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 +\n      (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 +\n      (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2",
  "tactic-prompt":
  "theorem {R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) *\n      (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) =\n    (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 +\n      (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 +\n      (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 +\n      (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 +\n      (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 +\n      (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 +\n      (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 +\n      (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2 := by ring; sorry",
  "name": "sum_eight_sq_mul_sum_eight_sq",
  "kind": "theorem",
  "first-tactic": "ring",
  "core-prompt":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R} : (xâ‚ ^ 2 + xâ‚‚ ^ 2 + xâ‚ƒ ^ 2 + xâ‚„ ^ 2 + xâ‚… ^ 2 + xâ‚† ^ 2 + xâ‚‡ ^ 2 + xâ‚ˆ ^ 2) *\n      (yâ‚ ^ 2 + yâ‚‚ ^ 2 + yâ‚ƒ ^ 2 + yâ‚„ ^ 2 + yâ‚… ^ 2 + yâ‚† ^ 2 + yâ‚‡ ^ 2 + yâ‚ˆ ^ 2) =\n    (xâ‚ * yâ‚ - xâ‚‚ * yâ‚‚ - xâ‚ƒ * yâ‚ƒ - xâ‚„ * yâ‚„ - xâ‚… * yâ‚… - xâ‚† * yâ‚† - xâ‚‡ * yâ‚‡ - xâ‚ˆ * yâ‚ˆ) ^ 2 +\n      (xâ‚ * yâ‚‚ + xâ‚‚ * yâ‚ + xâ‚ƒ * yâ‚„ - xâ‚„ * yâ‚ƒ + xâ‚… * yâ‚† - xâ‚† * yâ‚… - xâ‚‡ * yâ‚ˆ + xâ‚ˆ * yâ‚‡) ^ 2 +\n      (xâ‚ * yâ‚ƒ - xâ‚‚ * yâ‚„ + xâ‚ƒ * yâ‚ + xâ‚„ * yâ‚‚ + xâ‚… * yâ‚‡ + xâ‚† * yâ‚ˆ - xâ‚‡ * yâ‚… - xâ‚ˆ * yâ‚†) ^ 2 +\n      (xâ‚ * yâ‚„ + xâ‚‚ * yâ‚ƒ - xâ‚ƒ * yâ‚‚ + xâ‚„ * yâ‚ + xâ‚… * yâ‚ˆ - xâ‚† * yâ‚‡ + xâ‚‡ * yâ‚† - xâ‚ˆ * yâ‚…) ^ 2 +\n      (xâ‚ * yâ‚… - xâ‚‚ * yâ‚† - xâ‚ƒ * yâ‚‡ - xâ‚„ * yâ‚ˆ + xâ‚… * yâ‚ + xâ‚† * yâ‚‚ + xâ‚‡ * yâ‚ƒ + xâ‚ˆ * yâ‚„) ^ 2 +\n      (xâ‚ * yâ‚† + xâ‚‚ * yâ‚… - xâ‚ƒ * yâ‚ˆ + xâ‚„ * yâ‚‡ - xâ‚… * yâ‚‚ + xâ‚† * yâ‚ - xâ‚‡ * yâ‚„ + xâ‚ˆ * yâ‚ƒ) ^ 2 +\n      (xâ‚ * yâ‚‡ + xâ‚‚ * yâ‚ˆ + xâ‚ƒ * yâ‚… - xâ‚„ * yâ‚† - xâ‚… * yâ‚ƒ + xâ‚† * yâ‚„ + xâ‚‡ * yâ‚ - xâ‚ˆ * yâ‚‚) ^ 2 +\n      (xâ‚ * yâ‚ˆ - xâ‚‚ * yâ‚‡ + xâ‚ƒ * yâ‚† + xâ‚„ * yâ‚… - xâ‚… * yâ‚„ - xâ‚† * yâ‚ƒ + xâ‚‡ * yâ‚‚ + xâ‚ˆ * yâ‚) ^ 2",
  "args":
  "{R : Type _}  [CommRing R]  {a b xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… xâ‚† xâ‚‡ xâ‚ˆ yâ‚ yâ‚‚ yâ‚ƒ yâ‚„ yâ‚… yâ‚† yâ‚‡ yâ‚ˆ n : R}"},
 {"type": "âˆ€ n : â„•, n â€¢ (1 : A) = n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [AddMonoidWithOne A] : âˆ€ n : â„•, n â€¢ (1 : A) = n := by let f : â„• â†’+ A :=\n  { toFun := fun n â†¦ n â€¢ (1 : A),\n    map_zero' := by simp [zero_nsmul],\n    map_add' := by simp [add_nsmul] }; sorry",
  "name": "nsmul_one",
  "kind": "theorem",
  "first-tactic":
  "let f : â„• â†’+ A :=\n  { toFun := fun n â†¦ n â€¢ (1 : A),\n    map_zero' := by simp [zero_nsmul],\n    map_add' := by simp [add_nsmul] }",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [AddMonoidWithOne A] : âˆ€ n : â„•, n â€¢ (1 : A) = n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [AddMonoidWithOne A]"},
 {"type": "(k â€¢ x) ^ p = k ^ p â€¢ x ^ p",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : â„•) : (k â€¢ x) ^ p = k ^ p â€¢ x ^ p := by induction' p with p IH; sorry",
  "name": "smul_pow",
  "kind": "theorem",
  "first-tactic": "induction' p with p IH",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : â„•) : (k â€¢ x) ^ p = k ^ p â€¢ x ^ p",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulAction M N]  [IsScalarTower M N N]  [SMulCommClass M N N]  (k : M)  (x : N)      (p : â„•)"},
 {"type": "x â€¢ m ^ n = (x â€¢ m) ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : â„•) : x â€¢ m ^ n = (x â€¢ m) ^ n := by induction' n with n ih; sorry",
  "name": "smul_pow'",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : â„•) : x â€¢ m ^ n = (x â€¢ m) ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Monoid M]  [Monoid N]  [AddMonoid A]  [AddMonoid B] [MulDistribMulAction M N]  (x : M)  (m : N)  (n : â„•)"},
 {"type": "n â€¢ (1 : A) = n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroupWithOne A]  (n : â„¤) : n â€¢ (1 : A) = n := by cases n; sorry",
  "name": "zsmul_one",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroupWithOne A]  (n : â„¤) : n â€¢ (1 : A) = n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroupWithOne A]  (n : â„¤)"},
 {"type": "a ^ (m * n) = (a ^ n) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : Î±)  (m n : â„¤) : a ^ (m * n) = (a ^ n) ^ m := by rw [mul_comm]; sorry",
  "name": "zpow_mul'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : Î±)  (m n : â„¤) : a ^ (m * n) = (a ^ n) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed. (a : Î±)  (m n : â„¤)"},
 {"type": "(-x) ^ bit0 n = x ^ bit0 n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg Î±]  (x : Î±)  (n : â„¤) : (-x) ^ bit0 n = x ^ bit0 n := by rw [zpow_bit0']; sorry",
  "name": "zpow_bit0_neg",
  "kind": "theorem",
  "first-tactic": "rw [zpow_bit0']",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg Î±]  (x : Î±)  (n : â„¤) : (-x) ^ bit0 n = x ^ bit0 n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [DivisionMonoid Î±]  -- Note that `mul_zsmul` and `zpow_mul` have the primes swapped -- when additivised since their argument order, -- and therefore the more \"natural\" choice of lemma, is reversed.  [HasDistribNeg Î±]  (x : Î±)  (n : â„¤)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤) : a ^ (m + n) = a ^ m * a ^ n := by induction' n using Int.induction_on with n ihn n ihn; sorry",
  "name": "zpow_add",
  "kind": "theorem",
  "first-tactic": "induction' n using Int.induction_on with n ihn n ihn",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤) : a ^ (m + n) = a ^ m * a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤)"},
 {"type": "b * b ^ m = b ^ (m + 1)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤) : b * b ^ m = b ^ (m + 1) := by conv_lhs =>\n    congr\n    rw [â† zpow_one b]; sorry",
  "name": "mul_self_zpow",
  "kind": "theorem",
  "first-tactic": "conv_lhs =>\n    congr\n    rw [â† zpow_one b]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤) : b * b ^ m = b ^ (m + 1)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤)"},
 {"type": "b ^ m * b = b ^ (m + 1)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤) : b ^ m * b = b ^ (m + 1) := by conv_lhs =>\n    congr\n    Â· skip\n    rw [â† zpow_one b]; sorry",
  "name": "mul_zpow_self",
  "kind": "theorem",
  "first-tactic": "conv_lhs =>\n    congr\n    Â· skip\n    rw [â† zpow_one b]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤) : b ^ m * b = b ^ (m + 1)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (b : G)  (m : â„¤)"},
 {"type": "a ^ (m - n) = a ^ m * (a ^ n)â»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤) : a ^ (m - n) = a ^ m * (a ^ n)â»Â¹ := by rw [sub_eq_add_neg]; sorry",
  "name": "zpow_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤) : a ^ (m - n) = a ^ m * (a ^ n)â»Â¹",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (m n : â„¤)"},
 {"type": "a ^ (1 + i) = a * a ^ i",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (i : â„¤) : a ^ (1 + i) = a * a ^ i := by rw [zpow_add]; sorry",
  "name": "zpow_one_add",
  "kind": "theorem",
  "first-tactic": "rw [zpow_add]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (i : â„¤) : a ^ (1 + i) = a * a ^ i",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G] (a : G)  (i : â„¤)"},
 {"type": "a ^ bit1 n = a ^ n * a ^ n * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  (a : G)  (n : â„¤) : a ^ bit1 n = a ^ n * a ^ n * a := by rw [bit1]; sorry",
  "name": "zpow_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  (a : G)  (n : â„¤) : a ^ bit1 n = a ^ n * a ^ n * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [Group G]  (a : G)  (n : â„¤)"},
 {"type": "1 < a ^ k",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [OrderedCommGroup Î±]  {m n : â„¤}  {a b : Î±} (ha : 1 < a)  {k : â„¤}  (hk : (0 : â„¤) < k) : 1 < a ^ k := by obtain âŸ¨n, hnâŸ© := Int.eq_ofNat_of_zero_le hk.le; sorry",
  "name": "one_lt_zpow'",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨n, hnâŸ© := Int.eq_ofNat_of_zero_le hk.le",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [OrderedCommGroup Î±]  {m n : â„¤}  {a b : Î±} (ha : 1 < a)  {k : â„¤}  (hk : (0 : â„¤) < k) : 1 < a ^ k",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [OrderedCommGroup Î±]  {m n : â„¤}  {a b : Î±} (ha : 1 < a)  {k : â„¤}  (hk : (0 : â„¤) < k)"},
 {"type": "Function.Injective ((Â· ^ n) : Î± â†’ Î±)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedCommGroup Î±]  {n : â„¤}  {a b : Î±} (hn : n â‰  0) : Function.Injective ((Â· ^ n) : Î± â†’ Î±) := by rcases hn.symm.lt_or_lt with (h | h); sorry",
  "name": "zpow_left_injective",
  "kind": "theorem",
  "first-tactic": "rcases hn.symm.lt_or_lt with (h | h)",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedCommGroup Î±]  {n : â„¤}  {a b : Î±} (hn : n â‰  0) : Function.Injective ((Â· ^ n) : Î± â†’ Î±)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedCommGroup Î±]  {n : â„¤}  {a b : Î±} (hn : n â‰  0)"},
 {"type": "|n â€¢ a| = n â€¢ |a|",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„•)  (a : Î±) : |n â€¢ a| = n â€¢ |a| := by cases' le_total a 0 with hneg hpos; sorry",
  "name": "abs_nsmul",
  "kind": "theorem",
  "first-tactic": "cases' le_total a 0 with hneg hpos",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„•)  (a : Î±) : |n â€¢ a| = n â€¢ |a|",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„•)  (a : Î±)"},
 {"type": "|n â€¢ a| = |n| â€¢ |a|",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„¤)  (a : Î±) : |n â€¢ a| = |n| â€¢ |a| := by obtain n0 | n0 := le_total 0 n; sorry",
  "name": "abs_zsmul",
  "kind": "theorem",
  "first-tactic": "obtain n0 | n0 := le_total 0 n",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„¤)  (a : Î±) : |n â€¢ a| = |n| â€¢ |a|",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (n : â„¤)  (a : Î±)"},
 {"type": "|a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (hle : a â‰¤ b) : |a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0 := by obtain a0 | a0 := le_or_lt 0 a; sorry",
  "name": "abs_add_eq_add_abs_le",
  "kind": "theorem",
  "first-tactic": "obtain a0 | a0 := le_or_lt 0 a",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (hle : a â‰¤ b) : |a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (hle : a â‰¤ b)"},
 {"type": "|a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (a b : Î±) : |a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0 := by obtain ab | ab := le_total a b; sorry",
  "name": "abs_add_eq_add_abs_iff",
  "kind": "theorem",
  "first-tactic": "obtain ab | ab := le_total a b",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (a b : Î±) : |a + b| = |a| + |b| â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedAddCommGroup Î±]  {a b : Î±} (a b : Î±)"},
 {"type": "n â€¢ a = n * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [NonAssocSemiring R]  (n : â„•)  (a : R) : n â€¢ a = n * a := by rw [nsmul_eq_mul']; sorry",
  "name": "nsmul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [nsmul_eq_mul']",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [NonAssocSemiring R]  (n : â„•)  (a : R) : n â€¢ a = n * a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [NonAssocSemiring R]  (n : â„•)  (a : R)"},
 {"type": "(â†‘(n ^ m) : R) = (â†‘n : R) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Semiring R]  (n m : â„•) : (â†‘(n ^ m) : R) = (â†‘n : R) ^ m := by induction' m with m ih; sorry",
  "name": "Nat.cast_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Semiring R]  (n m : â„•) : (â†‘(n ^ m) : R) = (â†‘n : R) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Semiring R]  (n m : â„•)"},
 {"type": "((n ^ m : â„•) : â„¤) = (n : â„¤) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n m : â„•) : ((n ^ m : â„•) : â„¤) = (n : â„¤) ^ m := by induction' m with m _; sorry",
  "name": "Int.coe_nat_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m _",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n m : â„•) : ((n ^ m : â„•) : â„¤) = (n : â„¤) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n m : â„•)"},
 {"type": "bit0 n * r = (2 : â„¤) â€¢ (n * r)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R} : bit0 n * r = (2 : â„¤) â€¢ (n * r) := by dsimp [bit0]; sorry",
  "name": "bit0_mul",
  "kind": "theorem",
  "first-tactic": "dsimp [bit0]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R} : bit0 n * r = (2 : â„¤) â€¢ (n * r)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R}"},
 {"type": "r * bit0 n = (2 : â„¤) â€¢ (r * n)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R} : r * bit0 n = (2 : â„¤) â€¢ (r * n) := by dsimp [bit0]; sorry",
  "name": "mul_bit0",
  "kind": "theorem",
  "first-tactic": "dsimp [bit0]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R} : r * bit0 n = (2 : â„¤) â€¢ (r * n)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonUnitalNonAssocRing R]  {n r : R}"},
 {"type": "bit1 n * r = (2 : â„¤) â€¢ (n * r) + r",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R} : bit1 n * r = (2 : â„¤) â€¢ (n * r) + r := by dsimp [bit1]; sorry",
  "name": "bit1_mul",
  "kind": "theorem",
  "first-tactic": "dsimp [bit1]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R} : bit1 n * r = (2 : â„¤) â€¢ (n * r) + r",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R}"},
 {"type": "r * bit1 n = (2 : â„¤) â€¢ (r * n) + r",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R} : r * bit1 n = (2 : â„¤) â€¢ (r * n) + r := by dsimp [bit1]; sorry",
  "name": "mul_bit1",
  "kind": "theorem",
  "first-tactic": "dsimp [bit1]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R} : r * bit1 n = (2 : â„¤) â€¢ (r * n) + r",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [NonAssocRing R]  {n r : R}"},
 {"type": "n â€¢ a = a * n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (a : R)  (n : â„¤) : n â€¢ a = a * n := by rw [zsmul_eq_mul]; sorry",
  "name": "zsmul_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [zsmul_eq_mul]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (a : R)  (n : â„¤) : n â€¢ a = a * n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (a : R)  (n : â„¤)"},
 {"type": "a â€¢ b = a * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a b : â„¤) : a â€¢ b = a * b := by simp; sorry",
  "name": "zsmul_int_int",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a b : â„¤) : a â€¢ b = a * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a b : â„¤)"},
 {"type": "n â€¢ (1 : â„¤) = n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n : â„¤) : n â€¢ (1 : â„¤) = n := by simp; sorry",
  "name": "zsmul_int_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n : â„¤) : n â€¢ (1 : â„¤) = n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (n : â„¤)"},
 {"type": "(â†‘(n ^ m) : R) = (â†‘n : R) ^ m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (n : â„¤)  (m : â„•) : (â†‘(n ^ m) : R) = (â†‘n : R) ^ m := by induction' m with m ih; sorry",
  "name": "Int.cast_pow",
  "kind": "theorem",
  "first-tactic": "induction' m with m ih",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (n : â„¤)  (m : â„•) : (â†‘(n ^ m) : R) = (â†‘n : R) ^ m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  (n : â„¤)  (m : â„•)"},
 {"type": "(-1 : R) ^ n = (-1) ^ (n % 2)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  {n : â„•} : (-1 : R) ^ n = (-1) ^ (n % 2) := by rw [â† Nat.mod_add_div n 2]; sorry",
  "name": "neg_one_pow_eq_pow_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.mod_add_div n 2]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  {n : â„•} : (-1 : R) ^ n = (-1) ^ (n % 2)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Ring R]  {n : â„•}"},
 {"type": "a ^ j â‰¤ a ^ i",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [StrictOrderedSemiring R]  {a : R} (h : 0 â‰¤ a)  (ha : a â‰¤ 1)  {i j : â„•}  (hij : i â‰¤ j) : a ^ j â‰¤ a ^ i := by let âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_le hij; sorry",
  "name": "pow_le_pow_of_le_one",
  "kind": "theorem",
  "first-tactic": "let âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_le hij",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [StrictOrderedSemiring R]  {a : R} (h : 0 â‰¤ a)  (ha : a â‰¤ 1)  {i j : â„•}  (hij : i â‰¤ j) : a ^ j â‰¤ a ^ i",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [StrictOrderedSemiring R]  {a : R} (h : 0 â‰¤ a)  (ha : a â‰¤ 1)  {i j : â„•}  (hij : i â‰¤ j)"},
 {"type": "C = 0 âˆ¨ 0 < C âˆ§ 0 â‰¤ r",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedSemiring R] {C r : R}  (h : âˆ€ n : â„•, 0 â‰¤ C * r ^ n) : C = 0 âˆ¨ 0 < C âˆ§ 0 â‰¤ r := by have : 0 â‰¤ C := by simpa only [pow_zero]; sorry",
  "name": "sign_cases_of_C_mul_pow_nonneg",
  "kind": "theorem",
  "first-tactic": "have : 0 â‰¤ C := by simpa only [pow_zero]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedSemiring R] {C r : R}  (h : âˆ€ n : â„•, 0 â‰¤ C * r ^ n) : C = 0 âˆ¨ 0 < C âˆ§ 0 â‰¤ r",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedSemiring R] {C r : R}  (h : âˆ€ n : â„•, 0 â‰¤ C * r ^ n)"},
 {"type": "a ^ bit1 n â‰¤ 0 â†” a â‰¤ 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•} : a ^ bit1 n â‰¤ 0 â†” a â‰¤ 0 := by simp only [le_iff_lt_or_eq]; sorry",
  "name": "pow_bit1_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "simp only [le_iff_lt_or_eq]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•} : a ^ bit1 n â‰¤ 0 â†” a â‰¤ 0",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•}"},
 {"type": "StrictMono fun a : R => a ^ bit1 n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•}  (n : â„•) : StrictMono fun a : R => a ^ bit1 n := by intro a b hab; sorry",
  "name": "strictMono_pow_bit1",
  "kind": "theorem",
  "first-tactic": "intro a b hab",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•}  (n : â„•) : StrictMono fun a : R => a ^ bit1 n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•}  (n : â„•)"},
 {"type": "1 + (n : R) * (a - 1) â‰¤ a ^ n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•} (H : -1 â‰¤ a)  (n : â„•) : 1 + (n : R) * (a - 1) â‰¤ a ^ n := by have : -2 â‰¤ a - 1 := by\n    rwa [â† one_add_one_eq_two]; sorry",
  "name": "one_add_mul_sub_le_pow",
  "kind": "theorem",
  "first-tactic": "have : -2 â‰¤ a - 1 := by\n    rwa [â† one_add_one_eq_two]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•} (H : -1 â‰¤ a)  (n : â„•) : 1 + (n : R) * (a - 1) â‰¤ a ^ n",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚}  [LinearOrderedRing R]  {a : R}  {n : â„•} (H : -1 â‰¤ a)  (n : â„•)"},
 {"type": "â†‘(x.natAbs ^ 2) = x ^ 2",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤) : â†‘(x.natAbs ^ 2) = x ^ 2 := by rw [sq]; sorry",
  "name": "natAbs_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤) : â†‘(x.natAbs ^ 2) = x ^ 2",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤)"},
 {"type": "(x.natAbs: â„¤) ^ 2 = x ^ 2",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤) : (x.natAbs: â„¤) ^ 2 = x ^ 2 := by have l : (x.natAbs: â„¤) ^ 2 = â†‘(x.natAbs ^ 2) := by simp; sorry",
  "name": "natAbs_sq'",
  "kind": "theorem",
  "first-tactic": "have l : (x.natAbs: â„¤) ^ 2 = â†‘(x.natAbs ^ 2) := by simp",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤) : (x.natAbs: â„¤) ^ 2 = x ^ 2",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (x : â„¤)"},
 {"type": "(Int.natAbs a : â„¤) â‰¤ a ^ 2",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a : â„¤) : (Int.natAbs a : â„¤) â‰¤ a ^ 2 := by rw [â† Int.natAbs_sq a]; sorry",
  "name": "natAbs_le_self_sq",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.natAbs_sq a]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a : â„¤) : (Int.natAbs a : â„¤) â‰¤ a ^ 2",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} (a : â„¤)"},
 {"type": "Function.Injective ((Â· ^ Â·) x : â„• â†’ â„¤)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} {x : â„¤}  (h : 1 < x.natAbs) : Function.Injective ((Â· ^ Â·) x : â„• â†’ â„¤) := by suffices Function.Injective (natAbs âˆ˜ ((Â· ^ Â·) x : â„• â†’ â„¤)) by\n    exact Function.Injective.of_comp this; sorry",
  "name": "pow_right_injective",
  "kind": "theorem",
  "first-tactic":
  "suffices Function.Injective (natAbs âˆ˜ ((Â· ^ Â·) x : â„• â†’ â„¤)) by\n    exact Function.Injective.of_comp this",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} {x : â„¤}  (h : 1 < x.natAbs) : Function.Injective ((Â· ^ Â·) x : â„• â†’ â„¤)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} {x : â„¤}  (h : 1 < x.natAbs)"},
 {"type": "f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  (f : Multiplicative â„• â†’* M)  (n : Multiplicative â„•) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n) := by rw [â† powersHom_symm_apply]; sorry",
  "name": "MonoidHom.apply_mnat",
  "kind": "theorem",
  "first-tactic": "rw [â† powersHom_symm_apply]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  (f : Multiplicative â„• â†’* M)  (n : Multiplicative â„•) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  (f : Multiplicative â„• â†’* M)  (n : Multiplicative â„•)"},
 {"type": "f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Group M]  (f : Multiplicative â„¤ â†’* M)  (n : Multiplicative â„¤) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n) := by rw [â† zpowersHom_symm_apply]; sorry",
  "name": "MonoidHom.apply_mint",
  "kind": "theorem",
  "first-tactic": "rw [â† zpowersHom_symm_apply]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Group M]  (f : Multiplicative â„¤ â†’* M)  (n : Multiplicative â„¤) : f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Group M]  (f : Multiplicative â„¤ â†’* M)  (n : Multiplicative â„¤)"},
 {"type": "f n = n â€¢ f 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddMonoid M]  (f : â„• â†’+ M)  (n : â„•) : f n = n â€¢ f 1 := by rw [â† multiplesHom_symm_apply]; sorry",
  "name": "AddMonoidHom.apply_nat",
  "kind": "theorem",
  "first-tactic": "rw [â† multiplesHom_symm_apply]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddMonoid M]  (f : â„• â†’+ M)  (n : â„•) : f n = n â€¢ f 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddMonoid M]  (f : â„• â†’+ M)  (n : â„•)"},
 {"type": "f n = n â€¢ f 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroup M]  (f : â„¤ â†’+ M)  (n : â„¤) : f n = n â€¢ f 1 := by rw [â† zmultiplesHom_symm_apply]; sorry",
  "name": "AddMonoidHom.apply_int",
  "kind": "theorem",
  "first-tactic": "rw [â† zmultiplesHom_symm_apply]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroup M]  (f : â„¤ â†’+ M)  (n : â„¤) : f n = n â€¢ f 1",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [AddGroup M]  (f : â„¤ â†’+ M)  (n : â„¤)"},
 {"type": "Commute (m : R) a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute (m : R) a := by rw [â† mul_one (m : R)]; sorry",
  "name": "cast_int_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_one (m : R)]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute (m : R) a",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}"},
 {"type": "Commute a m",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute a m := by rw [â† mul_one (m : R)]; sorry",
  "name": "cast_int_right",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_one (m : R)]",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R} : Commute a m",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}"},
 {"type": "toAdd (a ^ b) = toAdd a * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„•)  (b : â„•) : toAdd (a ^ b) = toAdd a * b := by induction' b with b ihs; sorry",
  "name": "Nat.to_add_pow",
  "kind": "theorem",
  "first-tactic": "induction' b with b ihs",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„•)  (b : â„•) : toAdd (a ^ b) = toAdd a * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„•)  (b : â„•)"},
 {"type": "toAdd (a ^ b) = toAdd a * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„¤)  (b : â„•) : toAdd (a ^ b) = toAdd a * b := by induction b; sorry",
  "name": "Int.to_add_pow",
  "kind": "theorem",
  "first-tactic": "induction b",
  "core-prompt":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„¤)  (b : â„•) : toAdd (a ^ b) = toAdd a * b",
  "args":
  "{Î± : Type _}  {M : Type u}  {N : Type v}  {G : Type w}  {H : Type x}  {A : Type y}  {B : Type z}    {R : Type uâ‚}  {S : Type uâ‚‚} [Monoid M]  [Group G]  [Ring R] {a b x y x' y' : R} [Monoid M]  [Group G]  [Ring R] {a b : R}  (a : Multiplicative â„¤)  (b : â„•)"},
 {"type": "1 < a ^ k",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : â„•}  (hk : k â‰  0) : 1 < a ^ k := by rcases Nat.exists_eq_succ_of_ne_zero hk with âŸ¨l, rflâŸ©; sorry",
  "name": "one_lt_pow'",
  "kind": "theorem",
  "first-tactic": "rcases Nat.exists_eq_succ_of_ne_zero hk with âŸ¨l, rflâŸ©",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : â„•}  (hk : k â‰  0) : 1 < a ^ k",
  "args":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. {a : M}  (ha : 1 < a)  {k : â„•}  (hk : k â‰  0)"},
 {"type": "a ^ n < a ^ m",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (Â· * Â·) (Â· < Â·)]  {a : M}  {n m : â„•}  (ha : 1 < a)      (h : n < m) : a ^ n < a ^ m := by rcases Nat.le.dest h with âŸ¨k, rflâŸ©; sorry",
  "name": "pow_lt_pow'",
  "kind": "theorem",
  "first-tactic": "rcases Nat.le.dest h with âŸ¨k, rflâŸ©",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (Â· * Â·) (Â· < Â·)]  {a : M}  {n m : â„•}  (ha : 1 < a)      (h : n < m) : a ^ n < a ^ m",
  "args":
  "{A G M R : Type _}  [Monoid M]  [Preorder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  {x : M}  -- Porting note: removed `mono` attribute, not implemented yet. [CovariantClass M M (Â· * Â·) (Â· < Â·)]  {a : M}  {n m : â„•}  (ha : 1 < a)      (h : n < m)"},
 {"type": "x ^ n = 1 â†” x = 1",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)] {x : M}  {n : â„•}  (hn : n â‰  0) : x ^ n = 1 â†” x = 1 := by simp only [le_antisymm_iff]; sorry",
  "name": "pow_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "simp only [le_antisymm_iff]",
  "core-prompt":
  "{A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)] {x : M}  {n : â„•}  (hn : n â‰  0) : x ^ n = 1 â†” x = 1",
  "args":
  "{A G M R : Type _}  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)] {x : M}  {n : â„•}  (hn : n â‰  0)"},
 {"type": "1 â‰¤ x ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (Â· * Â·) (Â· â‰¤ Â·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 â‰¤ x)  {n : â„¤}  (hn : 0 â‰¤ n) : 1 â‰¤ x ^ n := by let n' := n.natAbs; sorry",
  "name": "one_le_zpow",
  "kind": "theorem",
  "first-tactic": "let n' := n.natAbs",
  "core-prompt":
  "{A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (Â· * Â·) (Â· â‰¤ Â·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 â‰¤ x)  {n : â„¤}  (hn : 0 â‰¤ n) : 1 â‰¤ x ^ n",
  "args":
  "{A G M R : Type _}  [DivInvMonoid G]  [Preorder G]  [CovariantClass G G (Â· * Â·) (Â· â‰¤ Â·)]  -- porting note: expanded for missing lift {x : G}  (H : 1 â‰¤ x)  {n : â„¤}  (hn : 0 â‰¤ n)"},
 {"type": "x ^ n + y ^ n â‰¤ (x + y) ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} (hx : 0 â‰¤ x)  (hy : 0 â‰¤ y)  (hn : n â‰  0) : x ^ n + y ^ n â‰¤ (x + y) ^ n := by rcases Nat.exists_eq_succ_of_ne_zero hn with âŸ¨k, rflâŸ©; sorry",
  "name": "pow_add_pow_le",
  "kind": "theorem",
  "first-tactic": "rcases Nat.exists_eq_succ_of_ne_zero hn with âŸ¨k, rflâŸ©",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} (hx : 0 â‰¤ x)  (hy : 0 â‰¤ y)  (hn : n â‰  0) : x ^ n + y ^ n â‰¤ (x + y) ^ n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} (hx : 0 â‰¤ x)  (hy : 0 â‰¤ y)  (hn : n â‰  0)"},
 {"type": "âˆ€ i : â„•, a ^ i â‰¤ b ^ i",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} {a b : R}  (ha : 0 â‰¤ a)  (hab : a â‰¤ b) : âˆ€ i : â„•, a ^ i â‰¤ b ^ i := by intro i; sorry",
  "name": "pow_le_pow_of_le_left",
  "kind": "theorem",
  "first-tactic": "intro i",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} {a b : R}  (ha : 0 â‰¤ a)  (hab : a â‰¤ b) : âˆ€ i : â„•, a ^ i â‰¤ b ^ i",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [OrderedSemiring R]  {a x y : R}  {n m : â„•} {a b : R}  (ha : 0 â‰¤ a)  (hab : a â‰¤ b)"},
 {"type": "0 < a ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : â„•} (ha : 0 < a) : 0 < a ^ 2 := by rw [sq]; sorry",
  "name": "sq_pos_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : â„•} (ha : 0 < a) : 0 < a ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedSemiring R]  {a x y : R}  {n m : â„•} (ha : 0 < a)"},
 {"type": "0 < a ^ bit0 n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•) : 0 < a ^ bit0 n := by rw [pow_bit0']; sorry",
  "name": "pow_bit0_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0']",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•) : 0 < a ^ bit0 n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•)"},
 {"type": "a ^ bit1 n < 0",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•) : a ^ bit1 n < 0 := by rw [bit1]; sorry",
  "name": "pow_bit1_neg",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•) : a ^ bit1 n < 0",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [StrictOrderedRing R]  {a : R} (ha : a < 0)  (n : â„•)"},
 {"type": "a ^ n â‰¤ 1 â†” a â‰¤ 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0) : a ^ n â‰¤ 1 â†” a â‰¤ 1 := by refine' âŸ¨_, pow_le_one n haâŸ©; sorry",
  "name": "pow_le_one_iff_of_nonneg",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, pow_le_one n haâŸ©",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0) : a ^ n â‰¤ 1 â†” a â‰¤ 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0)"},
 {"type": "1 â‰¤ a ^ n â†” 1 â‰¤ a",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0) : 1 â‰¤ a ^ n â†” 1 â‰¤ a := by refine' âŸ¨_, fun h => one_le_pow_of_one_le h nâŸ©; sorry",
  "name": "one_le_pow_iff_of_nonneg",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, fun h => one_le_pow_of_one_le h nâŸ©",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0) : 1 â‰¤ a ^ n â†” 1 â‰¤ a",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} {a : R}  (ha : 0 â‰¤ a)  {n : â„•}  (hn : n â‰  0)"},
 {"type": "a * a < b * b â†’ a < b",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 â‰¤ b) : a * a < b * b â†’ a < b := by simp_rw [â† sq]; sorry",
  "name": "lt_of_mul_self_lt_mul_self",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† sq]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 â‰¤ b) : a * a < b * b â†’ a < b",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedSemiring R]  {a b : R} (hb : 0 â‰¤ b)"},
 {"type": "|(-1 : R) ^ n| = 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : â„•) : |(-1 : R) ^ n| = 1 := by rw [â† pow_abs]; sorry",
  "name": "abs_neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_abs]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : â„•) : |(-1 : R) ^ n| = 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] (n : â„•)"},
 {"type": "0 â‰¤ a ^ bit0 n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : â„•) : 0 â‰¤ a ^ bit0 n := by rw [pow_bit0]; sorry",
  "name": "pow_bit0_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [pow_bit0]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : â„•) : 0 â‰¤ a ^ bit0 n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  (n : â„•)"},
 {"type": "0 < a ^ bit0 n â†” a â‰  0",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : â„•}  (hn : n â‰  0) : 0 < a ^ bit0 n â†” a â‰  0 := by refine' âŸ¨fun h => _, fun h => pow_bit0_pos h nâŸ©; sorry",
  "name": "pow_bit0_pos_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => pow_bit0_pos h nâŸ©",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : â„•}  (hn : n â‰  0) : 0 < a ^ bit0 n â†” a â‰  0",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R]  (a : R)  {n : â„•}  (hn : n â‰  0)"},
 {"type": "|x| ^ 2 = x ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x| ^ 2 = x ^ 2 := by simpa only [sq] using abs_mul_abs_self x; sorry",
  "name": "sq_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [sq] using abs_mul_abs_self x",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x| ^ 2 = x ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "|x ^ 2| = x ^ 2",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x ^ 2| = x ^ 2 := by simpa only [sq] using abs_mul_self x; sorry",
  "name": "abs_sq",
  "kind": "theorem",
  "first-tactic": "simpa only [sq] using abs_mul_self x",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : |x ^ 2| = x ^ 2",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "x ^ 2 < y ^ 2 â†” |x| < |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 < y ^ 2 â†” |x| < |y| := by simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).lt_iff_lt (abs_nonneg x) (abs_nonneg y); sorry",
  "name": "sq_lt_sq",
  "kind": "theorem",
  "first-tactic":
  "simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).lt_iff_lt (abs_nonneg x) (abs_nonneg y)",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 < y ^ 2 â†” |x| < |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}"},
 {"type": "x ^ 2 â‰¤ y ^ 2 â†” |x| â‰¤ |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 â‰¤ y ^ 2 â†” |x| â‰¤ |y| := by simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).le_iff_le (abs_nonneg x) (abs_nonneg y); sorry",
  "name": "sq_le_sq",
  "kind": "theorem",
  "first-tactic":
  "simpa only [sq_abs] using\n    (@strictMonoOn_pow R _ _ two_pos).le_iff_le (abs_nonneg x) (abs_nonneg y)",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} : x ^ 2 â‰¤ y ^ 2 â†” |x| â‰¤ |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}"},
 {"type": "|x| < y",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 â‰¤ y) : |x| < y := by rwa [â† abs_of_nonneg hy]; sorry",
  "name": "abs_lt_of_sq_lt_sq",
  "kind": "theorem",
  "first-tactic": "rwa [â† abs_of_nonneg hy]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 â‰¤ y) : |x| < y",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 < y ^ 2)  (hy : 0 â‰¤ y)"},
 {"type": "|x| â‰¤ y",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 â‰¤ y ^ 2)  (hy : 0 â‰¤ y) : |x| â‰¤ y := by rwa [â† abs_of_nonneg hy]; sorry",
  "name": "abs_le_of_sq_le_sq",
  "kind": "theorem",
  "first-tactic": "rwa [â† abs_of_nonneg hy]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 â‰¤ y ^ 2)  (hy : 0 â‰¤ y) : |x| â‰¤ y",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (h : x ^ 2 â‰¤ y ^ 2)  (hy : 0 â‰¤ y)"},
 {"type": "x ^ 2 = y ^ 2 â†” |x| = |y|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R) : x ^ 2 = y ^ 2 â†” |x| = |y| := by simp only [le_antisymm_iff]; sorry",
  "name": "sq_eq_sq_iff_abs_eq_abs",
  "kind": "theorem",
  "first-tactic": "simp only [le_antisymm_iff]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R) : x ^ 2 = y ^ 2 â†” |x| = |y|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x y : R)"},
 {"type": "x ^ 2 â‰¤ 1 â†” |x| â‰¤ 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 â‰¤ 1 â†” |x| â‰¤ 1 := by simpa only [one_pow]; sorry",
  "name": "sq_le_one_iff_abs_le_one",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 â‰¤ 1 â†” |x| â‰¤ 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "x ^ 2 < 1 â†” |x| < 1",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 < 1 â†” |x| < 1 := by simpa only [one_pow]; sorry",
  "name": "sq_lt_one_iff_abs_lt_one",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : x ^ 2 < 1 â†” |x| < 1",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "1 â‰¤ x ^ 2 â†” 1 â‰¤ |x|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 â‰¤ x ^ 2 â†” 1 â‰¤ |x| := by simpa only [one_pow]; sorry",
  "name": "one_le_sq_iff_one_le_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 â‰¤ x ^ 2 â†” 1 â‰¤ |x|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "1 < x ^ 2 â†” 1 < |x|",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 < x ^ 2 â†” 1 < |x| := by simpa only [one_pow]; sorry",
  "name": "one_lt_sq_iff_one_lt_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [one_pow]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R) : 1 < x ^ 2 â†” 1 < |x|",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} (x : R)"},
 {"type": "0 < a ^ n â†” 0 < a",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : â„•} (hn : 0 < n) : 0 < a ^ n â†” 0 < a := by simp_rw [zero_lt_iff]; sorry",
  "name": "pow_pos_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [zero_lt_iff]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : â„•} (hn : 0 < n) : 0 < a ^ n â†” 0 < a",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommMonoidWithZero M]  [NoZeroDivisors M]  {a : M}  {n : â„•} (hn : 0 < n)"},
 {"type": "a ^ n < a ^ n.succ",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a) : a ^ n < a ^ n.succ := by rw [â† one_mul (a ^ n)]; sorry",
  "name": "pow_lt_pow_succ",
  "kind": "theorem",
  "first-tactic": "rw [â† one_mul (a ^ n)]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a) : a ^ n < a ^ n.succ",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a)"},
 {"type": "a ^ m < a ^ n",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a)  (hmn : m < n) : a ^ m < a ^ n := by induction' hmn with n _ ih; sorry",
  "name": "pow_lt_powâ‚€",
  "kind": "theorem",
  "first-tactic": "induction' hmn with n _ ih",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a)  (hmn : m < n) : a ^ m < a ^ n",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R}  [LinearOrderedCommGroupWithZero M]  {a : M}  {m n : â„•} (ha : 1 < a)  (hmn : m < n)"},
 {"type": "f (-x) = f x",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x : R) : f (-x) = f x := by rw [â† neg_one_mul]; sorry",
  "name": "map_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† neg_one_mul]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x : R) : f (-x) = f x",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x : R)"},
 {"type": "f (x - y) = f (y - x)",
  "tactic-prompt":
  "theorem {A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x y : R) : f (x - y) = f (y - x) := by rw [â† map_neg]; sorry",
  "name": "map_sub_swap",
  "kind": "theorem",
  "first-tactic": "rw [â† map_neg]",
  "core-prompt":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x y : R) : f (x - y) = f (y - x)",
  "args":
  "{A G M R : Type _} [CanonicallyOrderedCommSemiring R]  [LinearOrderedRing R] {x y : R} [Ring R]  [Monoid M]  [LinearOrder M]  [CovariantClass M M (Â· * Â·) (Â· â‰¤ Â·)]  (f : R â†’* M) (x y : R)"},
 {"type": "â…Ÿ a * (a * b) = b",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a] : â…Ÿ a * (a * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "invOf_mul_self_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a] : â…Ÿ a * (a * b) = b",
  "args": "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a]"},
 {"type": "a * (â…Ÿ a * b) = b",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a] : a * (â…Ÿ a * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "mul_invOf_self_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a] : a * (â…Ÿ a * b) = b",
  "args": "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible a]"},
 {"type": "a * â…Ÿ b * b = a",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b] : a * â…Ÿ b * b = a := by simp [mul_assoc]; sorry",
  "name": "mul_invOf_mul_self_cancel",
  "kind": "theorem",
  "first-tactic": "simp [mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b] : a * â…Ÿ b * b = a",
  "args": "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b]"},
 {"type": "a * b * â…Ÿ b = a",
  "tactic-prompt":
  "theorem {Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b] : a * b * â…Ÿ b = a := by simp [mul_assoc]; sorry",
  "name": "mul_mul_invOf_self_cancel",
  "kind": "theorem",
  "first-tactic": "simp [mul_assoc]",
  "core-prompt":
  "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b] : a * b * â…Ÿ b = a",
  "args": "{Î± : Type u} [Monoid Î±]  (a b : Î±)  [Invertible b]"},
 {"type": "â…Ÿ a = â…Ÿ b",
  "tactic-prompt":
  "theorem {Î± : Type u} {Î± : Type u}  [Monoid Î±]  (a b : Î±)  [Invertible a]  [Invertible b]      (h : a = b) : â…Ÿ a = â…Ÿ b := by apply invOf_eq_right_inv; sorry",
  "name": "invertible_unique",
  "kind": "theorem",
  "first-tactic": "apply invOf_eq_right_inv",
  "core-prompt":
  "{Î± : Type u} {Î± : Type u}  [Monoid Î±]  (a b : Î±)  [Invertible a]  [Invertible b]      (h : a = b) : â…Ÿ a = â…Ÿ b",
  "args":
  "{Î± : Type u} {Î± : Type u}  [Monoid Î±]  (a b : Î±)  [Invertible a]  [Invertible b]      (h : a = b)"},
 {"type": "(â…Ÿ 2 : Î±) + (â…Ÿ 2 : Î±) = 1",
  "tactic-prompt":
  "theorem {Î± : Type u} [NonAssocSemiring Î±]  [Invertible (2 : Î±)] : (â…Ÿ 2 : Î±) + (â…Ÿ 2 : Î±) = 1 := by rw [â† two_mul]; sorry",
  "name": "invOf_two_add_invOf_two",
  "kind": "theorem",
  "first-tactic": "rw [â† two_mul]",
  "core-prompt":
  "{Î± : Type u} [NonAssocSemiring Î±]  [Invertible (2 : Î±)] : (â…Ÿ 2 : Î±) + (â…Ÿ 2 : Î±) = 1",
  "args": "{Î± : Type u} [NonAssocSemiring Î±]  [Invertible (2 : Î±)]"},
 {"type": "op x = op y â†” x = y",
  "tactic-prompt": "theorem {x y : Î±} : op x = op y â†” x = y := by simp; sorry",
  "name": "op_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{x y : Î±} : op x = op y â†” x = y",
  "args": "{x y : Î±}"},
 {"type": "a - âŠ¤ = 0",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Sub Î±]  [Zero Î±] {a : WithTop Î±} : a - âŠ¤ = 0 := by cases a; sorry",
  "name": "sub_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± Î² : Type _}  [Sub Î±]  [Zero Î±] {a : WithTop Î±} : a - âŠ¤ = 0",
  "args": "{Î± Î² : Type _}  [Sub Î±]  [Zero Î±] {a : WithTop Î±}"},
 {"type": "OrderedSub (WithTop Î±)",
  "tactic-prompt":
  "instance {Î± Î² : Type _} [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±] : OrderedSub (WithTop Î±) := by constructor; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² : Type _} [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±] : OrderedSub (WithTop Î±)",
  "args":
  "{Î± Î² : Type _} [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]"},
 {"type": "a - b â‰¤ c â†” a â‰¤ b + c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ c â†” a â‰¤ b + c := by rw [tsub_le_iff_right]; sorry",
  "name": "tsub_le_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ c â†” a â‰¤ b + c",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - b â‰¤ c â†” a - c â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ c â†” a - c â‰¤ b := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_le_iff_tsub_le",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ c â†” a - c â‰¤ b",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a + b - c â‰¤ a + (b - c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - c â‰¤ a + (b - c) := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_le_assoc",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - c â‰¤ a + (b - c)",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + b - c â‰¤ a - c + b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - c â‰¤ a - c + b := by rw [add_comm]; sorry",
  "name": "add_tsub_le_tsub_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - c â‰¤ a - c + b",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + b â‰¤ a + c + (b - c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b â‰¤ a + c + (b - c) := by rw [add_assoc]; sorry",
  "name": "add_le_add_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_assoc]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b â‰¤ a + c + (b - c)",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + b â‰¤ a - c + (b + c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b â‰¤ a - c + (b + c) := by rw [add_comm a]; sorry",
  "name": "le_tsub_add_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b â‰¤ a - c + (b + c)",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a - c â‰¤ a - b + (b - c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a - c â‰¤ a - b + (b - c) := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_le_tsub_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a - c â‰¤ a - b + (b - c)",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "c - a - (c - b) â‰¤ b - a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : c - a - (c - b) â‰¤ b - a := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_tsub_tsub_le_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : c - a - (c - b) â‰¤ b - a",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + b - (c + d) â‰¤ a - c + (b - d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - (c + d) â‰¤ a - c + (b - d) := by rw [add_comm c]; sorry",
  "name": "add_tsub_add_le_tsub_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm c]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - (c + d) â‰¤ a - c + (b - d)",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + b - (a + c) â‰¤ b - c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - (a + c) â‰¤ b - c := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_add_le_tsub_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + b - (a + c) â‰¤ b - c",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a + c - (b + c) â‰¤ a - b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + c - (b + c) â‰¤ a - b := by rw [tsub_le_iff_left]; sorry",
  "name": "add_tsub_add_le_tsub_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] : a + c - (b + c) â‰¤ a - b",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]"},
 {"type": "a â‰¤ a + b - b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b) : a â‰¤ a + b - b := by rw [add_comm]; sorry",
  "name": "le_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b) : a â‰¤ a + b - b",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)"},
 {"type": "a - b â‰¤ 0 â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Preorder Î±] [AddCommMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ 0 â†” a â‰¤ b := by rw [tsub_le_iff_left]; sorry",
  "name": "tsub_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_left]",
  "core-prompt":
  "{Î± Î² : Type _}   [Preorder Î±] [AddCommMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b â‰¤ 0 â†” a â‰¤ b",
  "args":
  "{Î± Î² : Type _}   [Preorder Î±] [AddCommMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "b - a - c = b - (a + c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (b a c : Î±) : b - a - c = b - (a + c) := by apply le_antisymm; sorry",
  "name": "tsub_tsub",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (b a c : Î±) : b - a - c = b - (a + c)",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (b a c : Î±)"},
 {"type": "a - (b + c) = a - c - b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b c : Î±) : a - (b + c) = a - c - b := by rw [add_comm]; sorry",
  "name": "tsub_add_eq_tsub_tsub_swap",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b c : Î±) : a - (b + c) = a - c - b",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a - b - c = a - c - b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b - c = a - c - b := by rw [â†tsub_add_eq_tsub_tsub]; sorry",
  "name": "tsub_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [â†tsub_add_eq_tsub_tsub]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b - c = a - c - b",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : a - b < c) : a < b + c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_add_of_tsub_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : a - b < c) : a < b + c",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : a - b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : a - c < b) : a < b + c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_add_of_tsub_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : a - c < b) : a < b + c",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : a - c < b)"},
 {"type": "a + c - (b + c) = a - b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a c b : Î±) : a + c - (b + c) = a - b := by refine' add_tsub_add_le_tsub_right.antisymm (tsub_le_iff_right.2 <| le_of_add_le_add_right _); sorry",
  "name": "add_tsub_add_eq_tsub_right",
  "kind": "theorem",
  "first-tactic":
  "refine' add_tsub_add_le_tsub_right.antisymm (tsub_le_iff_right.2 <| le_of_add_le_add_right _)",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a c b : Î±) : a + c - (b + c) = a - b",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a c b : Î±)"},
 {"type": "a + b - (a + c) = b - c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a b c : Î±) : a + b - (a + c) = b - c := by rw [add_comm a b]; sorry",
  "name": "add_tsub_add_eq_tsub_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a b]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a b c : Î±) : a + b - (a + c) = b - c",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  [AddCommSemigroup Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)] (a b c : Î±)"},
 {"type": "a + (b - a) = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b) : a + (b - a) = b := by refine' le_antisymm _ le_add_tsub; sorry",
  "name": "add_tsub_cancel_of_le",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ le_add_tsub",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b) : a + (b - a) = b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b)"},
 {"type": "b - a + a = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b) : b - a + a = b := by rw [add_comm]; sorry",
  "name": "tsub_add_cancel_of_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b) : b - a + a = b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : a â‰¤ b)"},
 {"type": "a - c â‰¤ b - c â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b) : a - c â‰¤ b - c â†” a â‰¤ b := by rw [tsub_le_iff_right]; sorry",
  "name": "tsub_le_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b) : a - c â‰¤ b - c â†” a â‰¤ b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b)"},
 {"type": "a - c = b - c â†” a = b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h1 : c â‰¤ a)  (h2 : c â‰¤ b) : a - c = b - c â†” a = b := by simp_rw [le_antisymm_iff]; sorry",
  "name": "tsub_left_inj",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_antisymm_iff]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h1 : c â‰¤ a)  (h2 : c â‰¤ b) : a - c = b - c â†” a = b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h1 : c â‰¤ a)  (h2 : c â‰¤ b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b)  (h2 : a - c < b - c) : a < b := by refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _; sorry",
  "name": "lt_of_tsub_lt_tsub_right_of_le",
  "kind": "theorem",
  "first-tactic": "refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b)  (h2 : a - c < b - c) : a < b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b)  (h2 : a - c < b - c)"},
 {"type": "a - b + (b - c) = a - c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : b â‰¤ a)  (hcb : c â‰¤ b) : a - b + (b - c) = a - c := by convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2; sorry",
  "name": "tsub_add_tsub_cancel",
  "kind": "theorem",
  "first-tactic":
  "convert tsub_add_cancel_of_le (tsub_le_tsub_right hab c) using 2",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : b â‰¤ a)  (hcb : c â‰¤ b) : a - b + (b - c) = a - c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : b â‰¤ a)  (hcb : c â‰¤ b)"},
 {"type": "a - c - (b - c) = a - b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b) : a - c - (b - c) = a - b := by rw [tsub_tsub]; sorry",
  "name": "tsub_tsub_tsub_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [tsub_tsub]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b) : a - c - (b - c) = a - b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (h : c â‰¤ b)"},
 {"type": "a - b = c â†” a = c + b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a) : a - b = c â†” a = c + b := by rw [eq_comm]; sorry",
  "name": "tsub_eq_iff_eq_add_of_le",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a) : a - b = c â†” a = c + b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b)  (a : Î±) : a + b - c = a + (b - c) := by conv_lhs => rw [â† add_tsub_cancel_of_le h]; sorry",
  "name": "add_tsub_assoc_of_le",
  "kind": "theorem",
  "first-tactic": "conv_lhs => rw [â† add_tsub_cancel_of_le h]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b)  (a : Î±) : a + b - c = a + (b - c)",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b)  (a : Î±)"},
 {"type": "a - b + c = a + c - b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a) : a - b + c = a + c - b := by rw [add_comm a]; sorry",
  "name": "tsub_add_eq_add_tsub",
  "kind": "theorem",
  "first-tactic": "rw [add_comm a]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a) : a - b + c = a + c - b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (h : b â‰¤ a)"},
 {"type": "a - b + (c - d) = a + c - (b + d)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b â‰¤ a)  (hdc : d â‰¤ c) : a - b + (c - d) = a + c - (b + d) := by rw [hb.tsub_add_eq_add_tsub hba]; sorry",
  "name": "tsub_add_tsub_comm",
  "kind": "theorem",
  "first-tactic": "rw [hb.tsub_add_eq_add_tsub hba]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b â‰¤ a)  (hdc : d â‰¤ c) : a - b + (c - d) = a + c - (b + d)",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hd : AddLECancellable d)      (hba : b â‰¤ a)  (hdc : d â‰¤ c)"},
 {"type": "b â‰¤ c - a â†” b + a â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (h : a â‰¤ c) : b â‰¤ c - a â†” b + a â‰¤ c := by rw [add_comm]; sorry",
  "name": "le_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (h : a â‰¤ c) : b â‰¤ c - a â†” b + a â‰¤ c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (h : a â‰¤ c)"},
 {"type": "a - b < c â†” a < b + c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a) : a - b < c â†” a < b + c := by refine' âŸ¨hb.lt_add_of_tsub_lt_left, _âŸ©; sorry",
  "name": "tsub_lt_iff_left",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨hb.lt_add_of_tsub_lt_left, _âŸ©",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a) : a - b < c â†” a < b + c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a)"},
 {"type": "a - b < c â†” a < c + b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a) : a - b < c â†” a < c + b := by rw [add_comm]; sorry",
  "name": "tsub_lt_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a) : a - b < c â†” a < c + b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hba : b â‰¤ a)"},
 {"type": "a - b < c â†” a - c < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a) : a - b < c â†” a - c < b := by rw [hb.tsub_lt_iff_left hâ‚]; sorry",
  "name": "tsub_lt_iff_tsub_lt",
  "kind": "theorem",
  "first-tactic": "rw [hb.tsub_lt_iff_left hâ‚]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a) : a - b < c â†” a - c < b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hb : AddLECancellable b)  (hc : AddLECancellable c)      (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a)"},
 {"type": "a â‰¤ b - c â†” c â‰¤ b - a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (hâ‚ : a â‰¤ b)  (hâ‚‚ : c â‰¤ b) : a â‰¤ b - c â†” c â‰¤ b - a := by rw [ha.le_tsub_iff_left hâ‚]; sorry",
  "name": "le_tsub_iff_le_tsub",
  "kind": "theorem",
  "first-tactic": "rw [ha.le_tsub_iff_left hâ‚]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (hâ‚ : a â‰¤ b)  (hâ‚‚ : c â‰¤ b) : a â‰¤ b - c â†” c â‰¤ b - a",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (hâ‚ : a â‰¤ b)  (hâ‚‚ : c â‰¤ b)"},
 {"type": "a < b - c â†” a + c < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b) : a < b - c â†” a + c < b := by refine' âŸ¨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_rightâŸ©; sorry",
  "name": "lt_tsub_iff_right_of_le",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun h' => (add_le_of_le_tsub_right_of_le h h'.le).lt_of_ne _, hc.lt_tsub_of_add_lt_rightâŸ©",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b) : a < b - c â†” a + c < b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b)"},
 {"type": "a < b - c â†” c + a < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b) : a < b - c â†” c + a < b := by rw [add_comm]; sorry",
  "name": "lt_tsub_iff_left_of_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b) : a < b - c â†” c + a < b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ b)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a)      (hâ‚ƒ : a - b = a - c) : b = c := by rw [â† hab.inj]; sorry",
  "name": "tsub_inj_right",
  "kind": "theorem",
  "first-tactic": "rw [â† hab.inj]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a)      (hâ‚ƒ : a - b = a - c) : b = c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (hâ‚ : b â‰¤ a)  (hâ‚‚ : c â‰¤ a)      (hâ‚ƒ : a - b = a - c)"},
 {"type": "c < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [ContravariantClass Î± Î± (Â· + Â·) (Â· < Â·)]      (hb : AddLECancellable b)  (hca : c â‰¤ a)  (h : a - b < a - c) : c < b := by conv_lhs at h => rw [â† tsub_add_cancel_of_le hca]; sorry",
  "name": "lt_of_tsub_lt_tsub_left_of_le",
  "kind": "theorem",
  "first-tactic": "conv_lhs at h => rw [â† tsub_add_cancel_of_le hca]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [ContravariantClass Î± Î± (Â· + Â·) (Â· < Â·)]      (hb : AddLECancellable b)  (hca : c â‰¤ a)  (h : a - b < a - c) : c < b",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [ContravariantClass Î± Î± (Â· + Â·) (Â· < Â·)]      (hb : AddLECancellable b)  (hca : c â‰¤ a)  (h : a - b < a - c)"},
 {"type": "a - c < b - c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a)  (h2 : a < b) : a - c < b - c := by apply hc.lt_tsub_of_add_lt_left; sorry",
  "name": "tsub_lt_tsub_right_of_le",
  "kind": "theorem",
  "first-tactic": "apply hc.lt_tsub_of_add_lt_left",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a)  (h2 : a < b) : a - c < b - c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a)  (h2 : a < b)"},
 {"type": "a - c - (a - b) = b - c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (h : b â‰¤ a) : a - c - (a - b) = b - c := by rw [tsub_right_comm]; sorry",
  "name": "tsub_tsub_tsub_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [tsub_right_comm]",
  "core-prompt":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (h : b â‰¤ a) : a - c - (a - b) = b - c",
  "args":
  "{Î± : Type _}  [AddCommSemigroup Î±]  [PartialOrder Î±]  [ExistsAddOfLE Î±]    [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hab : AddLECancellable (a - b))  (h : b â‰¤ a)"},
 {"type": "b - a + a = b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : b - a + a = b â†” a â‰¤ b := by rw [add_comm]; sorry",
  "name": "tsub_add_cancel_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : b - a + a = b â†” a â‰¤ b",
  "args":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - b = 0 â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b = 0 â†” a â‰¤ b := by rw [â† nonpos_iff_eq_zero]; sorry",
  "name": "tsub_eq_zero_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [â† nonpos_iff_eq_zero]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b = 0 â†” a â‰¤ b",
  "args":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "0 < a - b â†” Â¬a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : 0 < a - b â†” Â¬a â‰¤ b := by rw [pos_iff_ne_zero]; sorry",
  "name": "tsub_pos_iff_not_le",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : 0 < a - b â†” Â¬a â‰¤ b",
  "args":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - b â‰¤ a - c â†” c â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c â‰¤ a) : a - b â‰¤ a - c â†” c â‰¤ b := by refine' âŸ¨_, fun h => tsub_le_tsub_left h aâŸ©; sorry",
  "name": "tsub_le_tsub_iff_left",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, fun h => tsub_le_tsub_left h aâŸ©",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c â‰¤ a) : a - b â‰¤ a - c â†” c â‰¤ b",
  "args":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hc : AddLECancellable c)      (h : c â‰¤ a)"},
 {"type": "a - b = a - c â†” b = c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b â‰¤ a)  (hca : c â‰¤ a) : a - b = a - c â†” b = c := by simp_rw [le_antisymm_iff]; sorry",
  "name": "tsub_right_inj",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_antisymm_iff]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b â‰¤ a)  (hca : c â‰¤ a) : a - b = a - c â†” b = c",
  "args":
  "{Î± : Type _}  [CanonicallyOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hb : AddLECancellable b)      (hc : AddLECancellable c)  (hba : b â‰¤ a)  (hca : c â‰¤ a)"},
 {"type": "0 < a - b â†” b < a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : 0 < a - b â†” b < a := by rw [tsub_pos_iff_not_le]; sorry",
  "name": "tsub_pos_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [tsub_pos_iff_not_le]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : 0 < a - b â†” b < a",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - b = a - min a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b : Î±) : a - b = a - min a b := by cases' le_total a b with h h; sorry",
  "name": "tsub_eq_tsub_min",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b : Î±) : a - b = a - min a b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (a b : Î±)"},
 {"type": "a - c < b - c â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a) : a - c < b - c â†” a < b := by rw [hc.lt_tsub_iff_left]; sorry",
  "name": "tsub_lt_tsub_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [hc.lt_tsub_iff_left]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a) : a - c < b - c â†” a < b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (hc : AddLECancellable c)  (h : c â‰¤ a)"},
 {"type": "a - b < a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hâ‚ : 0 < a)  (hâ‚‚ : 0 < b) : a - b < a := by refine' tsub_le_self.lt_of_ne fun h => _; sorry",
  "name": "tsub_lt_self",
  "kind": "theorem",
  "first-tactic": "refine' tsub_le_self.lt_of_ne fun h => _",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hâ‚ : 0 < a)  (hâ‚‚ : 0 < b) : a - b < a",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)  (hâ‚ : 0 < a)  (hâ‚‚ : 0 < b)"},
 {"type": "a - b < a â†” 0 < a âˆ§ 0 < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a) : a - b < a â†” 0 < a âˆ§ 0 < b := by refine'\n    âŸ¨fun h => âŸ¨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _âŸ©, fun h => ha.tsub_lt_self h.1 h.2âŸ©; sorry",
  "name": "tsub_lt_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun h => âŸ¨(zero_le _).trans_lt h, (zero_le b).lt_of_ne _âŸ©, fun h => ha.tsub_lt_self h.1 h.2âŸ©",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a) : a - b < a â†” 0 < a âˆ§ 0 < b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} (ha : AddLECancellable a)"},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b + b = max a b := by cases' le_total a b with h h; sorry",
  "name": "tsub_add_eq_max",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b + b = max a b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a + (b - a) = max a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a + (b - a) = max a b := by rw [add_comm]; sorry",
  "name": "add_tsub_eq_max",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a + (b - a) = max a b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - min a b = a - b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - min a b = a - b := by cases' le_total a b with h h; sorry",
  "name": "tsub_min",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with h h",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - min a b = a - b",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "a - b + min a b = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b + min a b = a := by rw [â† tsub_min]; sorry",
  "name": "tsub_add_min",
  "kind": "theorem",
  "first-tactic": "rw [â† tsub_min]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} : a - b + min a b = a",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±}"},
 {"type": "f a - f b â‰¤ f (a - b)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [Preorder Î²]  [Add Î²]  [Sub Î²]  [OrderedSub Î²]  (f : AddHom Î± Î²)      (hf : Monotone f)  (a b : Î±) : f a - f b â‰¤ f (a - b) := by rw [tsub_le_iff_right]; sorry",
  "name": "AddHom.le_map_tsub",
  "kind": "theorem",
  "first-tactic": "rw [tsub_le_iff_right]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [Preorder Î²]  [Add Î²]  [Sub Î²]  [OrderedSub Î²]  (f : AddHom Î± Î²)      (hf : Monotone f)  (a b : Î±) : f a - f b â‰¤ f (a - b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} [Preorder Î²]  [Add Î²]  [Sub Î²]  [OrderedSub Î²]  (f : AddHom Î± Î²)      (hf : Monotone f)  (a b : Î±)"},
 {"type": "a * c - b * c â‰¤ (a - b) * c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : R} : a * c - b * c â‰¤ (a - b) * c := by simpa only [mul_comm _ c] using le_mul_tsub; sorry",
  "name": "le_tsub_mul",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_comm _ c] using le_mul_tsub",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : R} : a * c - b * c â‰¤ (a - b) * c",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  [Add Î±]  [Sub Î±]  [OrderedSub Î±]  {a b c d : Î±} {R : Type _}  [CommSemiring R]  [Preorder R]  [Sub R]  [OrderedSub R]      [CovariantClass R R (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : R}"},
 {"type": "e (a - b) = e a - e b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M â‰ƒo N)      (h_add : âˆ€ a b, e (a + b) = e a + e b)  (a b : M) : e (a - b) = e a - e b := by let e_add : M â‰ƒ+ N := { e with map_add' := h_add }; sorry",
  "name": "OrderIso.map_tsub",
  "kind": "theorem",
  "first-tactic": "let e_add : M â‰ƒ+ N := { e with map_add' := h_add }",
  "core-prompt":
  "{Î± Î² : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M â‰ƒo N)      (h_add : âˆ€ a b, e (a + b) = e a + e b)  (a b : M) : e (a - b) = e a - e b",
  "args":
  "{Î± Î² : Type _} {M N : Type _}  [Preorder M]  [Add M]  [Sub M]  [OrderedSub M]      [PartialOrder N]  [Add N]  [Sub N]  [OrderedSub N]  (e : M â‰ƒo N)      (h_add : âˆ€ a b, e (a + b) = e a + e b)  (a b : M)"},
 {"type": "0 â‰¤ f a",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : 0 â‰¤ a) : 0 â‰¤ f a := by rw [â† map_zero f]; sorry",
  "name": "map_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [â† map_zero f]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : 0 â‰¤ a) : 0 â‰¤ f a",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : 0 â‰¤ a)"},
 {"type": "f a â‰¤ 0",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : a â‰¤ 0) : f a â‰¤ 0 := by rw [â† map_zero f]; sorry",
  "name": "map_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [â† map_zero f]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : a â‰¤ 0) : f a â‰¤ 0",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommMonoid Î±]  [OrderedAddCommMonoid Î²]  [OrderAddMonoidHomClass F Î± Î²]  (f : F)    {a : Î±} (ha : a â‰¤ 0)"},
 {"type": "StrictMono (f : Î± â†’ Î²) â†” âˆ€ a, 0 < a â†’ 0 < f a",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommGroup Î±]  [OrderedAddCommMonoid Î²]  [AddMonoidHomClass F Î± Î²]  (f : F) [CovariantClass Î² Î² (Â· + Â·) (Â· < Â·)] : StrictMono (f : Î± â†’ Î²) â†” âˆ€ a, 0 < a â†’ 0 < f a := by refine âŸ¨fun h a => ?_, fun h a b hl => ?_âŸ©; sorry",
  "name": "strictMono_iff_map_pos",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h a => ?_, fun h a b hl => ?_âŸ©",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommGroup Î±]  [OrderedAddCommMonoid Î²]  [AddMonoidHomClass F Î± Î²]  (f : F) [CovariantClass Î² Î² (Â· + Â·) (Â· < Â·)] : StrictMono (f : Î± â†’ Î²) â†” âˆ€ a, 0 < a â†’ 0 < f a",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedAddCommGroup Î±]  [OrderedAddCommMonoid Î²]  [AddMonoidHomClass F Î± Î²]  (f : F) [CovariantClass Î² Î² (Â· + Â·) (Â· < Â·)]"},
 {"type": "f.comp (1 : Î± â†’*o Î²) = 1",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´]  [MulOneClass Î±]  [MulOneClass Î²]    [MulOneClass Î³]  [MulOneClass Î´]  {f g : Î± â†’*o Î²} (f : Î² â†’*o Î³) : f.comp (1 : Î± â†’*o Î²) = 1 := by ext; sorry",
  "name": "comp_one",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´]  [MulOneClass Î±]  [MulOneClass Î²]    [MulOneClass Î³]  [MulOneClass Î´]  {f g : Î± â†’*o Î²} (f : Î² â†’*o Î³) : f.comp (1 : Î± â†’*o Î²) = 1",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´]  [MulOneClass Î±]  [MulOneClass Î²]    [MulOneClass Î³]  [MulOneClass Î´]  {f g : Î± â†’*o Î²} (f : Î² â†’*o Î³)"},
 {"type": "g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedCommMonoid Î±]  [OrderedCommMonoid Î²]  [OrderedCommMonoid Î³] (g : Î² â†’*o Î³)  (fâ‚ fâ‚‚ : Î± â†’*o Î²) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚ := by ext; sorry",
  "name": "comp_mul",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedCommMonoid Î±]  [OrderedCommMonoid Î²]  [OrderedCommMonoid Î³] (g : Î² â†’*o Î³)  (fâ‚ fâ‚‚ : Î± â†’*o Î²) : g.comp (fâ‚ * fâ‚‚) = g.comp fâ‚ * g.comp fâ‚‚",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  [OrderedCommMonoid Î±]  [OrderedCommMonoid Î²]  [OrderedCommMonoid Î³] (g : Î² â†’*o Î³)  (fâ‚ fâ‚‚ : Î± â†’*o Î²)"},
 {"type": "f.toMonoidHom = f",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : OrderedCommMonoid Î±}  {hÎ² : OrderedCommMonoid Î²} (f : Î± â†’*o Î²) : f.toMonoidHom = f := by ext; sorry",
  "name": "toMonoidHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : OrderedCommMonoid Î±}  {hÎ² : OrderedCommMonoid Î²} (f : Î± â†’*o Î²) : f.toMonoidHom = f",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : OrderedCommMonoid Î±}  {hÎ² : OrderedCommMonoid Î²} (f : Î± â†’*o Î²)"},
 {"type": "f.toMonoidWithZeroHom = f",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : Preorder Î±}  {hÎ±' : MulZeroOneClass Î±}  {hÎ² : Preorder Î²}  {hÎ²' : MulZeroOneClass Î²} (f : Î± â†’*â‚€o Î²) : f.toMonoidWithZeroHom = f := by ext; sorry",
  "name": "toMonoidWithZeroHom_eq_coe",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : Preorder Î±}  {hÎ±' : MulZeroOneClass Î±}  {hÎ² : Preorder Î²}  {hÎ²' : MulZeroOneClass Î²} (f : Î± â†’*â‚€o Î²) : f.toMonoidWithZeroHom = f",
  "args":
  "{F Î± Î² Î³ Î´ : Type _}    [Preorder Î±]  [Preorder Î²]  [MulZeroOneClass Î±]  [MulZeroOneClass Î²]  {hÎ± : Preorder Î±}  {hÎ±' : MulZeroOneClass Î±}  {hÎ² : Preorder Î²}  {hÎ²' : MulZeroOneClass Î²} (f : Î± â†’*â‚€o Î²)"},
 {"type": "f a â‰¤ f b * f (a / b)",
  "tactic-prompt":
  "theorem {Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b : Î±) : f a â‰¤ f b * f (a / b) := by simpa only [mul_comm]; sorry",
  "name": "le_map_mul_map_div",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_comm]",
  "core-prompt":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b : Î±) : f a â‰¤ f b * f (a / b)",
  "args":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b : Î±)"},
 {"type": "f a â‰¤ f b + f (a / b)",
  "tactic-prompt":
  "theorem {Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]  (f : F)      (a b : Î±) : f a â‰¤ f b + f (a / b) := by simpa only [add_comm]; sorry",
  "name": "le_map_add_map_div",
  "kind": "theorem",
  "first-tactic": "simpa only [add_comm]",
  "core-prompt":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]  (f : F)      (a b : Î±) : f a â‰¤ f b + f (a / b)",
  "args":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]  (f : F)      (a b : Î±)"},
 {"type": "f (a / c) â‰¤ f (a / b) * f (b / c)",
  "tactic-prompt":
  "theorem {Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b c : Î±) : f (a / c) â‰¤ f (a / b) * f (b / c) := by simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c); sorry",
  "name": "le_map_div_mul_map_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_mul_div_cancel'] using map_mul_le_mul f (a / b) (b / c)",
  "core-prompt":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b c : Î±) : f (a / c) â‰¤ f (a / b) * f (b / c)",
  "args":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [CommSemigroup Î²]  [LE Î²]  [SubMultiplicativeHomClass F Î± Î²]      (f : F)  (a b c : Î±)"},
 {"type": "f (a / c) â‰¤ f (a / b) + f (b / c)",
  "tactic-prompt":
  "theorem {Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]      (f : F)  (a b c : Î±) : f (a / c) â‰¤ f (a / b) + f (b / c) := by simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c); sorry",
  "name": "le_map_div_add_map_div",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_mul_div_cancel'] using map_mul_le_add f (a / b) (b / c)",
  "core-prompt":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]      (f : F)  (a b c : Î±) : f (a / c) â‰¤ f (a / b) + f (b / c)",
  "args":
  "{Î¹ F Î± Î² Î³ Î´ : Type _} [Group Î±]  [AddCommSemigroup Î²]  [LE Î²]  [MulLEAddHomClass F Î± Î²]      (f : F)  (a b c : Î±)"},
 {"type": "0 < bit1 a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  (h : 0 < a) : 0 < bit1 a := by nontriviality; sorry",
  "name": "bit1_pos'",
  "kind": "theorem",
  "first-tactic": "nontriviality",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  (h : 0 < a) : 0 < bit1 a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  (h : 0 < a)"},
 {"type": "c * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0) : c * a â‰¤ c * b := by simpa only [neg_mul]; sorry",
  "name": "mul_le_mul_of_nonpos_left",
  "kind": "theorem",
  "first-tactic": "simpa only [neg_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0) : c * a â‰¤ c * b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0)"},
 {"type": "a * c â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0) : a * c â‰¤ b * c := by simpa only [mul_neg]; sorry",
  "name": "mul_le_mul_of_nonpos_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0) : a * c â‰¤ b * c",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : b â‰¤ a)  (hc : c â‰¤ 0)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b := by simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [OrderedRing Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (ha : a â‰¤ 0)  (hb : b â‰¤ 0)"},
 {"type": "a < c â†’ b < d â†’ 0 â‰¤ a â†’ 0 â‰¤ b â†’ a * b < c * d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : a < c â†’ b < d â†’ 0 â‰¤ a â†’ 0 â‰¤ b â†’ a * b < c * d := by classical\n  exact Decidable.mul_lt_mul''; sorry",
  "name": "mul_lt_mul''",
  "kind": "theorem",
  "first-tactic": "classical\n  exact Decidable.mul_lt_mul''",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : a < c â†’ b < d â†’ 0 â‰¤ a â†’ 0 â‰¤ b â†’ a * b < c * d",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "a < b * a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < b * a := by convert mul_lt_mul_of_pos_right hm hn; sorry",
  "name": "lt_mul_left",
  "kind": "theorem",
  "first-tactic": "convert mul_lt_mul_of_pos_right hm hn",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < b * a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b)"},
 {"type": "a < a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < a * b := by convert mul_lt_mul_of_pos_left hm hn; sorry",
  "name": "lt_mul_right",
  "kind": "theorem",
  "first-tactic": "convert mul_lt_mul_of_pos_left hm hn",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b) : a < a * b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hn : 0 < a)  (hm : 1 < b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : c * a < c * b := by simpa only [neg_mul]; sorry",
  "name": "mul_lt_mul_of_neg_left",
  "kind": "theorem",
  "first-tactic": "simpa only [neg_mul]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : c * a < c * b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : a * c < b * c := by simpa only [mul_neg]; sorry",
  "name": "mul_lt_mul_of_neg_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0) : a * c < b * c",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] (h : b < a)  (hc : c < 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] {a b : Î±}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by simpa only [zero_mul] using mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_neg_right ha hb",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] {a b : Î±}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [StrictOrderedRing Î±]  {a b c : Î±}  -- see Note [lower instance priority] {a b : Î±}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hab : 0 â‰¤ a * b) : 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0 := by refine' Decidable.or_iff_not_and_not.2 _; sorry",
  "name": "nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg",
  "kind": "theorem",
  "first-tactic": "refine' Decidable.or_iff_not_and_not.2 _",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hab : 0 â‰¤ a * b) : 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (hab : 0 â‰¤ a * b)"},
 {"type": "0 â‰¤ c * b â†” 0 â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c) : 0 â‰¤ c * b â†” 0 â‰¤ b := by simpa using (mul_le_mul_left h : c * 0 â‰¤ c * b â†” 0 â‰¤ b); sorry",
  "name": "zero_le_mul_left",
  "kind": "theorem",
  "first-tactic": "simpa using (mul_le_mul_left h : c * 0 â‰¤ c * b â†” 0 â‰¤ b)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c) : 0 â‰¤ c * b â†” 0 â‰¤ b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c)"},
 {"type": "0 â‰¤ b * c â†” 0 â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c) : 0 â‰¤ b * c â†” 0 â‰¤ b := by simpa using (mul_le_mul_right h : 0 * c â‰¤ b * c â†” 0 â‰¤ b); sorry",
  "name": "zero_le_mul_right",
  "kind": "theorem",
  "first-tactic": "simpa using (mul_le_mul_right h : 0 * c â‰¤ b * c â†” 0 â‰¤ b)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c) : 0 â‰¤ b * c â†” 0 â‰¤ b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] (h : 0 < c)"},
 {"type": "bit0 a â‰¤ bit0 b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : bit0 a â‰¤ bit0 b â†” a â‰¤ b := by rw [bit0]; sorry",
  "name": "bit0_le_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : bit0 a â‰¤ bit0 b â†” a â‰¤ b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "bit0 a < bit0 b â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : bit0 a < bit0 b â†” a < b := by rw [bit0]; sorry",
  "name": "bit0_lt_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : bit0 a < bit0 b â†” a < b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "(1 : Î±) â‰¤ bit1 a â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (1 : Î±) â‰¤ bit1 a â†” 0 â‰¤ a := by rw [bit1]; sorry",
  "name": "one_le_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (1 : Î±) â‰¤ bit1 a â†” 0 â‰¤ a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "(1 : Î±) < bit1 a â†” 0 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (1 : Î±) < bit1 a â†” 0 < a := by rw [bit1]; sorry",
  "name": "one_lt_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (1 : Î±) < bit1 a â†” 0 < a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "(0 : Î±) â‰¤ bit0 a â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (0 : Î±) â‰¤ bit0 a â†” 0 â‰¤ a := by rw [bit0]; sorry",
  "name": "zero_le_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (0 : Î±) â‰¤ bit0 a â†” 0 â‰¤ a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "(0 : Î±) < bit0 a â†” 0 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (0 : Î±) < bit0 a â†” 0 < a := by rw [bit0]; sorry",
  "name": "zero_lt_bit0",
  "kind": "theorem",
  "first-tactic": "rw [bit0]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority] : (0 : Î±) < bit0 a â†” 0 < a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]"},
 {"type": "a * b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : a * b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b := by rw [â† neg_pos]; sorry",
  "name": "mul_neg_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† neg_pos]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : a * b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a := by iterate 3 rw [mul_nonneg_iff]; sorry",
  "name": "mul_nonneg_of_three",
  "kind": "theorem",
  "first-tactic": "iterate 3 rw [mul_nonneg_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} (a b c : Î±) : 0 â‰¤ a * b âˆ¨ 0 â‰¤ b * c âˆ¨ 0 â‰¤ c * a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "a * b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : a * b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b := by rw [â† neg_nonneg]; sorry",
  "name": "mul_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† neg_nonneg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : a * b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "-a â‰¤ a â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : -a â‰¤ a â†” 0 â‰¤ a := by simp [neg_le_iff_add_nonneg]; sorry",
  "name": "neg_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [neg_le_iff_add_nonneg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : -a â‰¤ a â†” 0 â‰¤ a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "-a < a â†” 0 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : -a < a â†” 0 < a := by simp [neg_lt_iff_pos_add]; sorry",
  "name": "neg_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [neg_lt_iff_pos_add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} : -a < a â†” 0 < a",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "0 < a * a â†” a â‰  0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {a : Î±} : 0 < a * a â†” a â‰  0 := by constructor; sorry",
  "name": "mul_self_pos",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {a : Î±} : 0 < a * a â†” a â‰  0",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {a : Î±}"},
 {"type": "x * x + y * y = 0 â†” x = 0 âˆ§ y = 0",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 := by rw [add_eq_zero_iff']; sorry",
  "name": "mul_self_add_mul_self_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [add_eq_zero_iff']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [OrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedSemiring Î±]  {a b c d : Î±}  -- see Note [lower instance priority]  [LinearOrderedRing Î±]  {a b c : Î±} {x y : Î±}"},
 {"type": "a * d + b * c â‰¤ a * c + b * d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a â‰¤ b)  (hcd : c â‰¤ d) : a * d + b * c â‰¤ a * c + b * d := by obtain âŸ¨b, rflâŸ© := exists_add_of_le hab; sorry",
  "name": "mul_add_mul_le_mul_add_mul",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨b, rflâŸ© := exists_add_of_le hab",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a â‰¤ b)  (hcd : c â‰¤ d) : a * d + b * c â‰¤ a * c + b * d",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a â‰¤ b)  (hcd : c â‰¤ d)"},
 {"type": "a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b â‰¤ a)  (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d := by rw [add_comm (a â€¢ d)]; sorry",
  "name": "mul_add_mul_le_mul_add_mul'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm (a â€¢ d)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b â‰¤ a)  (hdc : d â‰¤ c) : a â€¢ d + b â€¢ c â‰¤ a â€¢ c + b â€¢ d",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b â‰¤ a)  (hdc : d â‰¤ c)"},
 {"type": "a * d + b * c < a * c + b * d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a < b)  (hcd : c < d) : a * d + b * c < a * c + b * d := by obtain âŸ¨b, rflâŸ© := exists_add_of_le hab.le; sorry",
  "name": "mul_add_mul_lt_mul_add_mul",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨b, rflâŸ© := exists_add_of_le hab.le",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a < b)  (hcd : c < d) : a * d + b * c < a * c + b * d",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hab : a < b)  (hcd : c < d)"},
 {"type": "a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b < a)  (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d := by rw [add_comm (a â€¢ d)]; sorry",
  "name": "mul_add_mul_lt_mul_add_mul'",
  "kind": "theorem",
  "first-tactic": "rw [add_comm (a â€¢ d)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b < a)  (hdc : d < c) : a â€¢ d + b â€¢ c < a â€¢ c + b â€¢ d",
  "args":
  "{Î± : Type u}  {Î² : Type _}  [StrictOrderedSemiring Î±]  {a b c d : Î±}  [ExistsAddOfLE Î±] (hba : b < a)  (hdc : d < c)"},
 {"type": "0 < a * b â†” 0 < a âˆ§ 0 < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority] : 0 < a * b â†” 0 < a âˆ§ 0 < b := by simp only [pos_iff_ne_zero]; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "simp only [pos_iff_ne_zero]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority] : 0 < a * b â†” 0 < a âˆ§ 0 < b",
  "args":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c := by cases' total_of (Â· â‰¤ Â·) b c with hbc hcb; sorry",
  "name": "mul_tsub",
  "kind": "theorem",
  "first-tactic": "cases' total_of (Â· â‰¤ Â·) b c with hbc hcb",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c",
  "args":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (a * c))"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c := by simp only [mul_comm _ c] at *; sorry",
  "name": "tsub_mul",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm _ c] at *",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c",
  "args":
  "{Î± : Type u}  {Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  {a b : Î±}  -- see Note [lower instance priority]  [CanonicallyOrderedCommSemiring Î±]  {a b c : Î±} [Sub Î±]  [OrderedSub Î±] [IsTotal Î± (Â· â‰¤ Â·)] (h : AddLECancellable (b * c))"},
 {"type": "|a * b| = |a| * |b|",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a b : Î±) : |a * b| = |a| * |b| := by rw [abs_eq (mul_nonneg (abs_nonneg a) (abs_nonneg b))]; sorry",
  "name": "abs_mul",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq (mul_nonneg (abs_nonneg a) (abs_nonneg b))]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a b : Î±) : |a * b| = |a| * |b|",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "|a * a| = a * a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : |a * a| = a * a := by rw [abs_mul]; sorry",
  "name": "abs_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [abs_mul]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : |a * a| = a * a",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±)"},
 {"type": "|a| = a â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = a â†” 0 â‰¤ a := by simp [abs_eq_max_neg]; sorry",
  "name": "abs_eq_self",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = a â†” 0 â‰¤ a",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a| = -a â†” a â‰¤ 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = -a â†” a â‰¤ 0 := by simp [abs_eq_max_neg]; sorry",
  "name": "abs_eq_neg_self",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = -a â†” a â‰¤ 0",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : |a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0 := by by_cases h : 0 â‰¤ a; sorry",
  "name": "abs_cases",
  "kind": "theorem",
  "first-tactic": "by_cases h : 0 â‰¤ a",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : |a| = a âˆ§ 0 â‰¤ a âˆ¨ |a| = -a âˆ§ a < 0",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±)"},
 {"type": "max a 0 + max (-a) 0 = |a|",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : max a 0 + max (-a) 0 = |a| := by symm; sorry",
  "name": "max_zero_add_max_neg_zero_eq_abs_self",
  "kind": "theorem",
  "first-tactic": "symm",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±) : max a 0 + max (-a) 0 = |a|",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} (a : Î±)"},
 {"type": "|a| = |b| â†” a * a = b * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = |b| â†” a * a = b * b := by rw [â† abs_mul_abs_self]; sorry",
  "name": "abs_eq_iff_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_mul_abs_self]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| = |b| â†” a * a = b * b",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a| < |b| â†” a * a < b * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| < |b| â†” a * a < b * b := by rw [â† abs_mul_abs_self]; sorry",
  "name": "abs_lt_iff_mul_self_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_mul_abs_self]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| < |b| â†” a * a < b * b",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a| â‰¤ |b| â†” a * a â‰¤ b * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| â‰¤ |b| â†” a * a â‰¤ b * b := by rw [â† abs_mul_abs_self]; sorry",
  "name": "abs_le_iff_mul_self_le",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_mul_abs_self]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| â‰¤ |b| â†” a * a â‰¤ b * b",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a| â‰¤ 1 â†” a * a â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| â‰¤ 1 â†” a * a â‰¤ 1 := by simpa only [abs_one]; sorry",
  "name": "abs_le_one_iff_mul_self_le_one",
  "kind": "theorem",
  "first-tactic": "simpa only [abs_one]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±} : |a| â‰¤ 1 â†” a * a â‰¤ 1",
  "args": "{Î± : Type _}  [LinearOrderedRing Î±]  {a b c : Î±}"},
 {"type": "|a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedCommRing Î±]  {a b c d : Î±} (a b : Î±) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b := by rw [abs_mul_abs_self]; sorry",
  "name": "abs_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [abs_mul_abs_self]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedCommRing Î±]  {a b c d : Î±} (a b : Î±) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b",
  "args": "{Î± : Type _}  [LinearOrderedCommRing Î±]  {a b c d : Î±} (a b : Î±)"},
 {"type": "|a| âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±) : |a| âˆ£ b â†” a âˆ£ b := by cases' abs_choice a with h h; sorry",
  "name": "abs_dvd",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice a with h h",
  "core-prompt":
  "{Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±) : |a| âˆ£ b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±)"},
 {"type": "a âˆ£ |b| â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±) : a âˆ£ |b| â†” a âˆ£ b := by cases' abs_choice b with h h; sorry",
  "name": "dvd_abs",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice b with h h",
  "core-prompt":
  "{Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±) : a âˆ£ |b| â†” a âˆ£ b",
  "args": "{Î± : Type _}  [Ring Î±]  [LinearOrder Î±]  {a b : Î±} (a b : Î±)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "Left.mul_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "0 < c * b â†” 0 < b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  [PosMulReflectLT Î±]  (h : 0 < c) : 0 < c * b â†” 0 < b := by rw [â†mul_zero c]; sorry",
  "name": "zero_lt_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [â†mul_zero c]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  [PosMulReflectLT Î±]  (h : 0 < c) : 0 < c * b â†” 0 < b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulStrictMono Î±]  [PosMulReflectLT Î±]  (h : 0 < c)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "Right.mul_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 < b * c â†” 0 < b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  [MulPosReflectLT Î±]  (h : 0 < c) : 0 < b * c â†” 0 < b := by rw [â†zero_mul c]; sorry",
  "name": "zero_lt_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [â†zero_mul c]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  [MulPosReflectLT Î±]  (h : 0 < c) : 0 < b * c â†” 0 < b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosStrictMono Î±]  [MulPosReflectLT Î±]  (h : 0 < c)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "Left.mul_nonneg",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0 := by simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (hb : b â‰¤ 0)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "Right.mul_nonneg",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0 := by simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [Preorder Î±] [MulPosMono Î±]  (ha : a â‰¤ 0)  (hb : 0 â‰¤ b)"},
 {"type": "a * c = b * d â†” a = b âˆ§ c = d",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (a0 : 0 < a)  (d0 : 0 < d) : a * c = b * d â†” a = b âˆ§ c = d := by refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©; sorry",
  "name": "mul_eq_mul_iff_eq_and_eq_of_pos",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (a0 : 0 < a)  (d0 : 0 < d) : a * c = b * d â†” a = b âˆ§ c = d",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (a0 : 0 < a)  (d0 : 0 < d)"},
 {"type": "a * c = b * d â†” a = b âˆ§ c = d",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (b0 : 0 < b)  (c0 : 0 < c) : a * c = b * d â†” a = b âˆ§ c = d := by refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©; sorry",
  "name": "mul_eq_mul_iff_eq_and_eq_of_pos'",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (b0 : 0 < b)  (c0 : 0 < c) : a * c = b * d â†” a = b âˆ§ c = d",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [PartialOrder Î±] [PosMulStrictMono Î±]  [MulPosStrictMono Î±]  [PosMulMonoRev Î±]      [MulPosMonoRev Î±]  (hac : a â‰¤ b)  (hbd : c â‰¤ d)  (b0 : 0 < b)  (c0 : 0 < c)"},
 {"type": "0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [LinearOrder Î±] [PosMulMono Î±]  [MulPosMono Î±]  (hab : 0 < a * b) : 0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0 := by rcases lt_trichotomy a 0 with (ha | rfl | ha); sorry",
  "name": "pos_and_pos_or_neg_and_neg_of_mul_pos",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy a 0 with (ha | rfl | ha)",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [LinearOrder Î±] [PosMulMono Î±]  [MulPosMono Î±]  (hab : 0 < a * b) : 0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulZeroClass Î±]  [LinearOrder Î±] [PosMulMono Î±]  [MulPosMono Î±]  (hab : 0 < a * b)"},
 {"type": "a * b â‰¤ b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : a â‰¤ 1) : a * b â‰¤ b := by simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb; sorry",
  "name": "mul_le_of_le_one_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : a â‰¤ 1) : a * b â‰¤ b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : a â‰¤ 1)"},
 {"type": "b â‰¤ a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : 1 â‰¤ a) : b â‰¤ a * b := by simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb; sorry",
  "name": "le_mul_of_one_le_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : 1 â‰¤ a) : b â‰¤ a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosMono Î±]  (hb : 0 â‰¤ b)  (h : 1 â‰¤ a)"},
 {"type": "a * b â‰¤ a",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : b â‰¤ 1) : a * b â‰¤ a := by simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha; sorry",
  "name": "mul_le_of_le_one_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : b â‰¤ 1) : a * b â‰¤ a",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : b â‰¤ 1)"},
 {"type": "a â‰¤ a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : 1 â‰¤ b) : a â‰¤ a * b := by simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha; sorry",
  "name": "le_mul_of_one_le_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : 1 â‰¤ b) : a â‰¤ a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulMono Î±]  (ha : 0 â‰¤ a)  (h : 1 â‰¤ b)"},
 {"type": "a * b < b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : a < 1) : a * b < b := by simpa only [one_mul] using mul_lt_mul_of_pos_right h hb; sorry",
  "name": "mul_lt_of_lt_one_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : a < 1) : a * b < b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : a < 1)"},
 {"type": "b < a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : 1 < a) : b < a * b := by simpa only [one_mul] using mul_lt_mul_of_pos_right h hb; sorry",
  "name": "lt_mul_of_one_lt_left",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : 1 < a) : b < a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [MulPosStrictMono Î±]  (hb : 0 < b)  (h : 1 < a)"},
 {"type": "a * b < a",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : b < 1) : a * b < a := by simpa only [mul_one] using mul_lt_mul_of_pos_left h ha; sorry",
  "name": "mul_lt_of_lt_one_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : b < 1) : a * b < a",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : b < 1)"},
 {"type": "a < a * b",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : 1 < b) : a < a * b := by simpa only [mul_one] using mul_lt_mul_of_pos_left h ha; sorry",
  "name": "lt_mul_of_one_lt_right",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : 1 < b) : a < a * b",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [Preorder Î±] [PosMulStrictMono Î±]  (ha : 0 < a)  (h : 1 < b)"},
 {"type": "âˆƒ b : Î±, b * b â‰¤ a",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [LinearOrder Î±]  -- YaÃ«l: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 â‰¤ a` as `exists_square_le` [PosMulStrictMono Î±]  (a0 : 0 < a) : âˆƒ b : Î±, b * b â‰¤ a := by obtain ha | ha := lt_or_le a 1; sorry",
  "name": "exists_square_le'",
  "kind": "theorem",
  "first-tactic": "obtain ha | ha := lt_or_le a 1",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [LinearOrder Î±]  -- YaÃ«l: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 â‰¤ a` as `exists_square_le` [PosMulStrictMono Î±]  (a0 : 0 < a) : âˆƒ b : Î±, b * b â‰¤ a",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [MulOneClass Î±]  [Zero Î±]  [LinearOrder Î±]  -- YaÃ«l: What's the point of this lemma? If we have `0 * 0 = 0`, then we can just take `b = 0`. -- proven with `a0 : 0 â‰¤ a` as `exists_square_le` [PosMulStrictMono Î±]  (a0 : 0 < a)"},
 {"type": "PosMulStrictMono Î± â†” MulPosStrictMono Î±",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulStrictMono Î± â†” MulPosStrictMono Î± := by simp only [PosMulStrictMono]; sorry",
  "name": "posMulStrictMono_iff_mulPosStrictMono",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulStrictMono]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulStrictMono Î± â†” MulPosStrictMono Î±",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±]"},
 {"type": "PosMulReflectLT Î± â†” MulPosReflectLT Î±",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulReflectLT Î± â†” MulPosReflectLT Î± := by simp only [PosMulReflectLT]; sorry",
  "name": "posMulReflectLT_iff_mulPosReflectLT",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulReflectLT]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulReflectLT Î± â†” MulPosReflectLT Î±",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±]"},
 {"type": "PosMulMono Î± â†” MulPosMono Î±",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulMono Î± â†” MulPosMono Î± := by simp only [PosMulMono]; sorry",
  "name": "posMulMono_iff_mulPosMono",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulMono]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulMono Î± â†” MulPosMono Î±",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±]"},
 {"type": "PosMulMonoRev Î± â†” MulPosMonoRev Î±",
  "tactic-prompt":
  "theorem (Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulMonoRev Î± â†” MulPosMonoRev Î± := by simp only [PosMulMonoRev]; sorry",
  "name": "posMulMonoRev_iff_mulPosMonoRev",
  "kind": "theorem",
  "first-tactic": "simp only [PosMulMonoRev]",
  "core-prompt":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±] : PosMulMonoRev Î± â†” MulPosMonoRev Î±",
  "args":
  "(Î± : Type _)  -- mathport name: Â«exprÎ±â‰¥0Â» /- Notations for nonnegative and positive elements https:// leanprover.zulipchat.com/#narrow/stream/113488-general/topic/notation.20for.20positive.20elements -/  [CommSemigroup Î±]  [Zero Î±]  [Preorder Î±]"},
 {"type": "0 â‰¤ aâ»Â¹ â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : 0 â‰¤ aâ»Â¹ â†” 0 â‰¤ a := by simp only [le_iff_eq_or_lt]; sorry",
  "name": "inv_nonneg",
  "kind": "theorem",
  "first-tactic": "simp only [le_iff_eq_or_lt]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : 0 â‰¤ aâ»Â¹ â†” 0 â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "aâ»Â¹ < 0 â†” a < 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ < 0 â†” a < 0 := by simp only [â† not_le]; sorry",
  "name": "inv_lt_zero",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_le]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ < 0 â†” a < 0",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "aâ»Â¹ â‰¤ 0 â†” a â‰¤ 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ â‰¤ 0 â†” a â‰¤ 0 := by simp only [â† not_lt]; sorry",
  "name": "inv_nonpos",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_lt]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ â‰¤ 0 â†” a â‰¤ 0",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "0 < a / b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 0 < a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_pos",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 0 < a / b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "0 â‰¤ a / b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a / b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "a / b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a / b â‰¤ 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a / b â‰¤ 0",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : a â‰¤ 0)  (hb : 0 â‰¤ b)"},
 {"type": "a / b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a / b â‰¤ 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a / b â‰¤ 0",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : b â‰¤ 0)"},
 {"type": "a â‰¤ b / c â†” c * a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : a â‰¤ b / c â†” c * a â‰¤ b := by rw [mul_comm]; sorry",
  "name": "le_div_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : a â‰¤ b / c â†” c * a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)"},
 {"type": "a / b â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b â‰¤ c â†” a â‰¤ b * c := by rw [mul_comm]; sorry",
  "name": "div_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b)"},
 {"type": "a < b / c â†” c * a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : a < b / c â†” c * a < b := by rw [mul_comm]; sorry",
  "name": "lt_div_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : a < b / c â†” c * a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)"},
 {"type": "b / c < a â†” b < c * a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : b / c < a â†” b < c * a := by rw [mul_comm]; sorry",
  "name": "div_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c) : b / c < a â†” b < c * a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)"},
 {"type": "bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c := by rw [inv_eq_one_div]; sorry",
  "name": "inv_mul_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "bâ»Â¹ * a â‰¤ c â†” a â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a â‰¤ c â†” a â‰¤ c * b := by rw [inv_mul_le_iff h]; sorry",
  "name": "inv_mul_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_le_iff h]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a â‰¤ c â†” a â‰¤ c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c := by rw [mul_comm]; sorry",
  "name": "mul_inv_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "a * bâ»Â¹ â‰¤ c â†” a â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ â‰¤ c â†” a â‰¤ c * b := by rw [mul_comm]; sorry",
  "name": "mul_inv_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ â‰¤ c â†” a â‰¤ c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "bâ»Â¹ * a < c â†” a < b * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a < c â†” a < b * c := by rw [inv_eq_one_div]; sorry",
  "name": "inv_mul_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a < c â†” a < b * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "bâ»Â¹ * a < c â†” a < c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a < c â†” a < c * b := by rw [inv_mul_lt_iff h]; sorry",
  "name": "inv_mul_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_lt_iff h]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : bâ»Â¹ * a < c â†” a < c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "a * bâ»Â¹ < c â†” a < b * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ < c â†” a < b * c := by rw [mul_comm]; sorry",
  "name": "mul_inv_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ < c â†” a < b * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "a * bâ»Â¹ < c â†” a < c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ < c â†” a < c * b := by rw [mul_comm]; sorry",
  "name": "mul_inv_lt_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b) : a * bâ»Â¹ < c â†” a < c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < b)"},
 {"type": "aâ»Â¹ â‰¤ b â†” 1 â‰¤ b * a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ â‰¤ b â†” 1 â‰¤ b * a := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_le_iff_one_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ â‰¤ b â†” 1 â‰¤ b * a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)"},
 {"type": "aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_le_iff_one_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ â‰¤ b â†” 1 â‰¤ a * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)"},
 {"type": "aâ»Â¹ < b â†” 1 < b * a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ < b â†” 1 < b * a := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_lt_iff_one_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ < b â†” 1 < b * a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)"},
 {"type": "aâ»Â¹ < b â†” 1 < a * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ < b â†” 1 < a * b := by rw [inv_eq_one_div]; sorry",
  "name": "inv_pos_lt_iff_one_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a) : aâ»Â¹ < b â†” 1 < a * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)"},
 {"type": "a / b â‰¤ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 â‰¤ b)  (hc : 0 â‰¤ c)  (h : a â‰¤ c * b) : a / b â‰¤ c := by rcases eq_or_lt_of_le hb with (rfl | hb'); sorry",
  "name": "div_le_of_nonneg_of_le_mul",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_lt_of_le hb with (rfl | hb')",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 â‰¤ b)  (hc : 0 â‰¤ c)  (h : a â‰¤ c * b) : a / b â‰¤ c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 â‰¤ b)  (hc : 0 â‰¤ c)  (h : a â‰¤ c * b)"},
 {"type": "bâ»Â¹ â‰¤ aâ»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b) : bâ»Â¹ â‰¤ aâ»Â¹ := by rwa [â† one_div a]; sorry",
  "name": "inv_le_inv_of_le",
  "kind": "theorem",
  "first-tactic": "rwa [â† one_div a]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b) : bâ»Â¹ â‰¤ aâ»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b)"},
 {"type": "aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a := by rw [â† one_div]; sorry",
  "name": "inv_le_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a := by rw [â† inv_le_inv hb (inv_pos.2 ha)]; sorry",
  "name": "inv_le",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_le_inv hb (inv_pos.2 ha)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹ := by rw [â† inv_le_inv (inv_pos.2 hb) ha]; sorry",
  "name": "le_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_le_inv (inv_pos.2 hb) ha]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "aâ»Â¹ < 1",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 < a) : aâ»Â¹ < 1 := by rwa [inv_lt (zero_lt_one.trans ha) zero_lt_one]; sorry",
  "name": "inv_lt_one",
  "kind": "theorem",
  "first-tactic": "rwa [inv_lt (zero_lt_one.trans ha) zero_lt_one]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 < a) : aâ»Â¹ < 1",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 < a)"},
 {"type": "1 < aâ»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a < 1) : 1 < aâ»Â¹ := by rwa [lt_inv (@zero_lt_one Î± _ _ _ _ _) hâ‚]; sorry",
  "name": "one_lt_inv",
  "kind": "theorem",
  "first-tactic": "rwa [lt_inv (@zero_lt_one Î± _ _ _ _ _) hâ‚]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a < 1) : 1 < aâ»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a < 1)"},
 {"type": "aâ»Â¹ â‰¤ 1",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 â‰¤ a) : aâ»Â¹ â‰¤ 1 := by rwa [inv_le (zero_lt_one.trans_le ha) zero_lt_one]; sorry",
  "name": "inv_le_one",
  "kind": "theorem",
  "first-tactic": "rwa [inv_le (zero_lt_one.trans_le ha) zero_lt_one]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 â‰¤ a) : aâ»Â¹ â‰¤ 1",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 1 â‰¤ a)"},
 {"type": "1 â‰¤ aâ»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a â‰¤ 1) : 1 â‰¤ aâ»Â¹ := by rwa [le_inv (@zero_lt_one Î± _ _ _ _ _) hâ‚]; sorry",
  "name": "one_le_inv",
  "kind": "theorem",
  "first-tactic": "rwa [le_inv (@zero_lt_one Î± _ _ _ _ _) hâ‚]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a â‰¤ 1) : 1 â‰¤ aâ»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hâ‚ : 0 < a)  (hâ‚‚ : a â‰¤ 1)"},
 {"type": "aâ»Â¹ < 1 â†” a â‰¤ 0 âˆ¨ 1 < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ < 1 â†” a â‰¤ 0 âˆ¨ 1 < a := by cases' le_or_lt a 0 with ha ha; sorry",
  "name": "inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a 0 with ha ha",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ < 1 â†” a â‰¤ 0 âˆ¨ 1 < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "aâ»Â¹ â‰¤ 1 â†” a â‰¤ 0 âˆ¨ 1 â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ â‰¤ 1 â†” a â‰¤ 0 âˆ¨ 1 â‰¤ a := by rcases em (a = 1) with (rfl | ha); sorry",
  "name": "inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases em (a = 1) with (rfl | ha)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : aâ»Â¹ â‰¤ 1 â†” a â‰¤ 0 âˆ¨ 1 â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "a / c â‰¤ b / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (h : a â‰¤ b) : a / c â‰¤ b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_le_div_of_le",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (h : a â‰¤ b) : a / c â‰¤ b / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (h : a â‰¤ b)"},
 {"type": "a / b â‰¤ a / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hc : 0 < c)  (h : c â‰¤ b) : a / b â‰¤ a / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_of_le_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hc : 0 < c)  (h : c â‰¤ b) : a / b â‰¤ a / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hc : 0 < c)  (h : c â‰¤ b)"},
 {"type": "a / c < b / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)  (h : a < b) : a / c < b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_lt_div_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)  (h : a < b) : a / c < b / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 < c)  (h : a < b)"},
 {"type": "a / b < a / c â†” c < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c) : a / b < a / c â†” c < b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_lt_div_left",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c) : a / b < a / c â†” c < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)  (hc : 0 < c)"},
 {"type": "a / b < c / d â†” a * d < c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d) : a / b < c / d â†” a * d < c * b := by rw [lt_div_iff d0]; sorry",
  "name": "div_lt_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff d0]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d) : a / b < c / d â†” a * d < c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a / b â‰¤ c / d â†” a * d â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d) : a / b â‰¤ c / d â†” a * d â‰¤ c * b := by rw [le_div_iff d0]; sorry",
  "name": "div_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff d0]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d) : a / b â‰¤ c / d â†” a * d â‰¤ c * b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a / b â‰¤ c / d",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (hac : a â‰¤ c)  (hd : 0 < d)  (hbd : d â‰¤ b) : a / b â‰¤ c / d := by rw [div_le_div_iff (hd.trans_le hbd) hd]; sorry",
  "name": "div_le_div",
  "kind": "theorem",
  "first-tactic": "rw [div_le_div_iff (hd.trans_le hbd) hd]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (hac : a â‰¤ c)  (hd : 0 < d)  (hbd : d â‰¤ b) : a / b â‰¤ c / d",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hc : 0 â‰¤ c)  (hac : a â‰¤ c)  (hd : 0 < d)  (hbd : d â‰¤ b)"},
 {"type": "a / b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 1 â‰¤ b) : a / b â‰¤ a := by simpa only [div_one] using div_le_div_of_le_left ha zero_lt_one hb; sorry",
  "name": "div_le_self",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_one] using div_le_div_of_le_left ha zero_lt_one hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 1 â‰¤ b) : a / b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hb : 1 â‰¤ b)"},
 {"type": "a / b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 1 < b) : a / b < a := by simpa only [div_one] using div_lt_div_of_lt_left ha zero_lt_one hb; sorry",
  "name": "div_lt_self",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_one] using div_lt_div_of_lt_left ha zero_lt_one hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 1 < b) : a / b < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 1 < b)"},
 {"type": "a â‰¤ a / b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hbâ‚€ : 0 < b)  (hbâ‚ : b â‰¤ 1) : a â‰¤ a / b := by simpa only [div_one] using div_le_div_of_le_left ha hbâ‚€ hbâ‚; sorry",
  "name": "le_div_self",
  "kind": "theorem",
  "first-tactic": "simpa only [div_one] using div_le_div_of_le_left ha hbâ‚€ hbâ‚",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hbâ‚€ : 0 < b)  (hbâ‚ : b â‰¤ 1) : a â‰¤ a / b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 â‰¤ a)  (hbâ‚€ : 0 < b)  (hbâ‚ : b â‰¤ 1)"},
 {"type": "1 â‰¤ a / b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : 1 â‰¤ a / b â†” b â‰¤ a := by rw [le_div_iff hb]; sorry",
  "name": "one_le_div",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : 1 â‰¤ a / b â†” b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b)"},
 {"type": "a / b â‰¤ 1 â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b â‰¤ 1 â†” a â‰¤ b := by rw [div_le_iff hb]; sorry",
  "name": "div_le_one",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b â‰¤ 1 â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b)"},
 {"type": "1 < a / b â†” b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : 1 < a / b â†” b < a := by rw [lt_div_iff hb]; sorry",
  "name": "one_lt_div",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : 1 < a / b â†” b < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b)"},
 {"type": "a / b < 1 â†” a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b < 1 â†” a < b := by rw [div_lt_iff hb]; sorry",
  "name": "div_lt_one",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b) : a / b < 1 â†” a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (hb : 0 < b)"},
 {"type": "1 / a â‰¤ b â†” 1 / b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 1 / a â‰¤ b â†” 1 / b â‰¤ a := by simpa using inv_le ha hb; sorry",
  "name": "one_div_le",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 1 / a â‰¤ b â†” 1 / b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "1 / a < b â†” 1 / b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 1 / a < b â†” 1 / b < a := by simpa using inv_lt ha hb; sorry",
  "name": "one_div_lt",
  "kind": "theorem",
  "first-tactic": "simpa using inv_lt ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : 1 / a < b â†” 1 / b < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a â‰¤ 1 / b â†” b â‰¤ 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a â‰¤ 1 / b â†” b â‰¤ 1 / a := by simpa using le_inv ha hb; sorry",
  "name": "le_one_div",
  "kind": "theorem",
  "first-tactic": "simpa using le_inv ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a â‰¤ 1 / b â†” b â‰¤ 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < 1 / b â†” b < 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a < 1 / b â†” b < 1 / a := by simpa using lt_inv ha hb; sorry",
  "name": "lt_one_div",
  "kind": "theorem",
  "first-tactic": "simpa using lt_inv ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b) : a < 1 / b â†” b < 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "1 / b â‰¤ 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b) : 1 / b â‰¤ 1 / a := by simpa using inv_le_inv_of_le ha h; sorry",
  "name": "one_div_le_one_div_of_le",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le_inv_of_le ha h",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b) : 1 / b â‰¤ 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a â‰¤ b)"},
 {"type": "1 / b < 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a < b) : 1 / b < 1 / a := by rwa [lt_div_iff' ha]; sorry",
  "name": "one_div_lt_one_div_of_lt",
  "kind": "theorem",
  "first-tactic": "rwa [lt_div_iff' ha]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a < b) : 1 / b < 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha : 0 < a)  (h : a < b)"},
 {"type": "1 < 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a < 1) : 1 < 1 / a := by rwa [lt_one_div (@zero_lt_one Î± _ _ _ _ _) h1]; sorry",
  "name": "one_lt_one_div",
  "kind": "theorem",
  "first-tactic": "rwa [lt_one_div (@zero_lt_one Î± _ _ _ _ _) h1]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a < 1) : 1 < 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a < 1)"},
 {"type": "1 â‰¤ 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a â‰¤ 1) : 1 â‰¤ 1 / a := by rwa [le_one_div (@zero_lt_one Î± _ _ _ _ _) h1]; sorry",
  "name": "one_le_one_div",
  "kind": "theorem",
  "first-tactic": "rwa [le_one_div (@zero_lt_one Î± _ _ _ _ _) h1]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a â‰¤ 1) : 1 â‰¤ 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h1 : 0 < a)  (h2 : a â‰¤ 1)"},
 {"type": "a / 2 + a / 2 = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±) : a / 2 + a / 2 = a := by rw [div_add_div_same]; sorry",
  "name": "add_halves",
  "kind": "theorem",
  "first-tactic": "rw [div_add_div_same]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±) : a / 2 + a / 2 = a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±)"},
 {"type": "(a + a) / 2 = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±) : (a + a) / 2 = a := by rw [â† mul_two]; sorry",
  "name": "add_self_div_two",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_two]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±) : (a + a) / 2 = a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a : Î±)"},
 {"type": "a / 2 < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < a) : a / 2 < a := by rw [div_lt_iff (zero_lt_two' Î±)]; sorry",
  "name": "div_two_lt_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff (zero_lt_two' Î±)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < a) : a / 2 < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : 0 < a)"},
 {"type": "a / 2 â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha_nonneg : 0 â‰¤ a) : a / 2 â‰¤ a := by by_cases h0 : a = 0; sorry",
  "name": "half_le_self",
  "kind": "theorem",
  "first-tactic": "by_cases h0 : a = 0",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha_nonneg : 0 â‰¤ a) : a / 2 â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (ha_nonneg : 0 â‰¤ a)"},
 {"type": "a < (a + b) / 2 â†” a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : a < (a + b) / 2 â†” a < b := by simp [lt_div_iff]; sorry",
  "name": "left_lt_add_div_two",
  "kind": "theorem",
  "first-tactic": "simp [lt_div_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : a < (a + b) / 2 â†” a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "(a + b) / 2 < b â†” a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : (a + b) / 2 < b â†” a < b := by simp [div_lt_iff]; sorry",
  "name": "add_div_two_lt_right",
  "kind": "theorem",
  "first-tactic": "simp [div_lt_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} : (a + b) / 2 < b â†” a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤}"},
 {"type": "b * a â‰¤ d * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a * (b / c) â‰¤ d)  (hc : 0 < c) : b * a â‰¤ d * c := by rw [â† mul_div_assoc] at h; sorry",
  "name": "mul_le_mul_of_mul_div_le",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc] at h",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a * (b / c) â‰¤ d)  (hc : 0 < c) : b * a â‰¤ d * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a * (b / c) â‰¤ d)  (hc : 0 < c)"},
 {"type": "a / (b * e) â‰¤ c / (d * e)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a / b â‰¤ c / d)  (he : 0 â‰¤ e) : a / (b * e) â‰¤ c / (d * e) := by rw [div_mul_eq_div_mul_one_div]; sorry",
  "name": "div_mul_le_div_mul_of_div_le_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_mul_one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a / b â‰¤ c / d)  (he : 0 â‰¤ e) : a / (b * e) â‰¤ c / (d * e)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (h : a / b â‰¤ c / d)  (he : 0 â‰¤ e)"},
 {"type": "âˆƒ c : Î±, 0 < c âˆ§ b * c < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {a : Î±}  (h : 0 < a)  (b : Î±) : âˆƒ c : Î±, 0 < c âˆ§ b * c < a := by have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (Or.inr zero_lt_one)); sorry",
  "name": "exists_pos_mul_lt",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < a / max (b + 1) 1 := div_pos h (lt_max_iff.2 (Or.inr zero_lt_one))",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {a : Î±}  (h : 0 < a)  (b : Î±) : âˆƒ c : Î±, 0 < c âˆ§ b * c < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {a : Î±}  (h : 0 < a)  (b : Î±)"},
 {"type": "Monotone fun x => f x / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : Monotone f)  {c : Î±}      (hc : 0 â‰¤ c) : Monotone fun x => f x / c := by haveI := @LinearOrder.decidable_le Î± _; sorry",
  "name": "Monotone.div_const",
  "kind": "theorem",
  "first-tactic": "haveI := @LinearOrder.decidable_le Î± _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : Monotone f)  {c : Î±}      (hc : 0 â‰¤ c) : Monotone fun x => f x / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : Monotone f)  {c : Î±}      (hc : 0 â‰¤ c)"},
 {"type": "StrictMono fun x => f x / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : StrictMono f)  {c : Î±}      (hc : 0 < c) : StrictMono fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc); sorry",
  "name": "StrictMono.div_const",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using hf.mul_const (inv_pos.2 hc)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : StrictMono f)  {c : Î±}      (hc : 0 < c) : StrictMono fun x => f x / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {Î² : Type _}  [Preorder Î²]  {f : Î² â†’ Î±}  (hf : StrictMono f)  {c : Î±}      (hc : 0 < c)"},
 {"type": "1 / a ^ n â‰¤ 1 / a ^ m",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n) : 1 / a ^ n â‰¤ 1 / a ^ m := by refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn); sorry",
  "name": "one_div_pow_le_one_div_pow_of_le",
  "kind": "theorem",
  "first-tactic": "refine' (one_div_le_one_div _ _).mpr (pow_le_pow a1 mn)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n) : 1 / a ^ n â‰¤ 1 / a ^ m",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n)"},
 {"type": "1 / a ^ n < 1 / a ^ m",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n) : 1 / a ^ n < 1 / a ^ m := by refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn); sorry",
  "name": "one_div_pow_lt_one_div_pow_of_lt",
  "kind": "theorem",
  "first-tactic": "refine' (one_div_lt_one_div _ _).mpr (pow_lt_pow a1 mn)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n) : 1 / a ^ n < 1 / a ^ m",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n)"},
 {"type": "(a ^ n)â»Â¹ â‰¤ (a ^ m)â»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n) : (a ^ n)â»Â¹ â‰¤ (a ^ m)â»Â¹ := by convert one_div_pow_le_one_div_pow_of_le a1 mn; sorry",
  "name": "inv_pow_le_inv_pow_of_le",
  "kind": "theorem",
  "first-tactic": "convert one_div_pow_le_one_div_pow_of_le a1 mn",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n) : (a ^ n)â»Â¹ â‰¤ (a ^ m)â»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 â‰¤ a)  {m n : â„•}  (mn : m â‰¤ n)"},
 {"type": "(a ^ n)â»Â¹ < (a ^ m)â»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n) : (a ^ n)â»Â¹ < (a ^ m)â»Â¹ := by convert one_div_pow_lt_one_div_pow_of_lt a1 mn; sorry",
  "name": "inv_pow_lt_inv_pow_of_lt",
  "kind": "theorem",
  "first-tactic": "convert one_div_pow_lt_one_div_pow_of_lt a1 mn",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n) : (a ^ n)â»Â¹ < (a ^ m)â»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} (a1 : 1 < a)  {m n : â„•}  (mn : m < n)"},
 {"type": "IsGLB ((fun b => a * b) '' s) (a * b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b) : IsGLB ((fun b => a * b) '' s) (a * b) := by rcases lt_or_eq_of_le ha with (ha | rfl); sorry",
  "name": "IsGLB.mul_left",
  "kind": "theorem",
  "first-tactic": "rcases lt_or_eq_of_le ha with (ha | rfl)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b) : IsGLB ((fun b => a * b) '' s) (a * b)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b)"},
 {"type": "IsGLB ((fun b => b * a) '' s) (b * a)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b) : IsGLB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha; sorry",
  "name": "IsGLB.mul_right",
  "kind": "theorem",
  "first-tactic": "simpa [mul_comm] using hs.mul_left ha",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b) : IsGLB ((fun b => b * a) '' s) (b * a)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedSemifield Î±]  {a b c d e : Î±}  {m n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsGLB s b)"},
 {"type": "0 < a / b â†” 0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 < a / b â†” 0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0 := by simp only [division_def]; sorry",
  "name": "div_pos_iff",
  "kind": "theorem",
  "first-tactic": "simp only [division_def]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 < a / b â†” 0 < a âˆ§ 0 < b âˆ¨ a < 0 âˆ§ b < 0",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "a / b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b := by simp [division_def]; sorry",
  "name": "div_neg_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b < 0 â†” 0 < a âˆ§ b < 0 âˆ¨ a < 0 âˆ§ 0 < b",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "0 â‰¤ a / b â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 â‰¤ a / b â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0 := by simp [division_def]; sorry",
  "name": "div_nonneg_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 â‰¤ a / b â†” 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ¨ a â‰¤ 0 âˆ§ b â‰¤ 0",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "a / b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b := by simp [division_def]; sorry",
  "name": "div_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "simp [division_def]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b â‰¤ 0 â†” 0 â‰¤ a âˆ§ b â‰¤ 0 âˆ¨ a â‰¤ 0 âˆ§ 0 â‰¤ b",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "b / c â‰¤ a â†” c * a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : b / c â‰¤ a â†” c * a â‰¤ b := by rw [mul_comm]; sorry",
  "name": "div_le_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : b / c â‰¤ a â†” c * a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)"},
 {"type": "a â‰¤ b / c â†” b â‰¤ a * c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a â‰¤ b / c â†” b â‰¤ a * c := by rw [â† neg_neg c]; sorry",
  "name": "le_div_iff_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† neg_neg c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a â‰¤ b / c â†” b â‰¤ a * c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)"},
 {"type": "a â‰¤ b / c â†” b â‰¤ c * a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a â‰¤ b / c â†” b â‰¤ c * a := by rw [mul_comm]; sorry",
  "name": "le_div_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a â‰¤ b / c â†” b â‰¤ c * a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)"},
 {"type": "b / c < a â†” c * a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : b / c < a â†” c * a < b := by rw [mul_comm]; sorry",
  "name": "div_lt_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : b / c < a â†” c * a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)"},
 {"type": "a < b / c â†” b < c * a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a < b / c â†” b < c * a := by rw [mul_comm]; sorry",
  "name": "lt_div_iff_of_neg'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0) : a < b / c â†” b < c * a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)"},
 {"type": "aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a := by rw [â† one_div]; sorry",
  "name": "inv_le_inv_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† one_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a := by rw [â† inv_le_inv_of_neg hb (inv_lt_zero.2 ha)]; sorry",
  "name": "inv_le_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_le_inv_of_neg hb (inv_lt_zero.2 ha)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : aâ»Â¹ â‰¤ b â†” bâ»Â¹ â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹ := by rw [â† inv_le_inv_of_neg (inv_lt_zero.2 hb) ha]; sorry",
  "name": "le_inv_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_le_inv_of_neg (inv_lt_zero.2 hb) ha]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a â‰¤ bâ»Â¹ â†” b â‰¤ aâ»Â¹",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a / c â‰¤ b / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰¤ 0)  (h : b â‰¤ a) : a / c â‰¤ b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_le_div_of_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰¤ 0)  (h : b â‰¤ a) : a / c â‰¤ b / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰¤ 0)  (h : b â‰¤ a)"},
 {"type": "a / c < b / c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)  (h : b < a) : a / c < b / c := by rw [div_eq_mul_one_div a c]; sorry",
  "name": "div_lt_div_of_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_one_div a c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)  (h : b < a) : a / c < b / c",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c < 0)  (h : b < a)"},
 {"type": "1 â‰¤ a / b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : 1 â‰¤ a / b â†” a â‰¤ b := by rw [le_div_iff_of_neg hb]; sorry",
  "name": "one_le_div_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_of_neg hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : 1 â‰¤ a / b â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)"},
 {"type": "a / b â‰¤ 1 â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : a / b â‰¤ 1 â†” b â‰¤ a := by rw [div_le_iff_of_neg hb]; sorry",
  "name": "div_le_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff_of_neg hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : a / b â‰¤ 1 â†” b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)"},
 {"type": "1 < a / b â†” a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : 1 < a / b â†” a < b := by rw [lt_div_iff_of_neg hb]; sorry",
  "name": "one_lt_div_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff_of_neg hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : 1 < a / b â†” a < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)"},
 {"type": "a / b < 1 â†” b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : a / b < 1 â†” b < a := by rw [div_lt_iff_of_neg hb]; sorry",
  "name": "div_lt_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_of_neg hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0) : a / b < 1 â†” b < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)"},
 {"type": "1 / a â‰¤ b â†” 1 / b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a â‰¤ b â†” 1 / b â‰¤ a := by simpa using inv_le_of_neg ha hb; sorry",
  "name": "one_div_le_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using inv_le_of_neg ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a â‰¤ b â†” 1 / b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "1 / a < b â†” 1 / b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a < b â†” 1 / b < a := by simpa using inv_lt_of_neg ha hb; sorry",
  "name": "one_div_lt_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using inv_lt_of_neg ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a < b â†” 1 / b < a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a â‰¤ 1 / b â†” b â‰¤ 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a â‰¤ 1 / b â†” b â‰¤ 1 / a := by simpa using le_inv_of_neg ha hb; sorry",
  "name": "le_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using le_inv_of_neg ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a â‰¤ 1 / b â†” b â‰¤ 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a < 1 / b â†” b < 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a < 1 / b â†” b < 1 / a := by simpa using lt_inv_of_neg ha hb; sorry",
  "name": "lt_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa using lt_inv_of_neg ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : a < 1 / b â†” b < 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "1 < a / b â†” 0 < b âˆ§ b < a âˆ¨ b < 0 âˆ§ a < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 1 < a / b â†” 0 < b âˆ§ b < a âˆ¨ b < 0 âˆ§ a < b := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "one_lt_div_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 1 < a / b â†” 0 < b âˆ§ b < a âˆ¨ b < 0 âˆ§ a < b",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "1 â‰¤ a / b â†” 0 < b âˆ§ b â‰¤ a âˆ¨ b < 0 âˆ§ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 1 â‰¤ a / b â†” 0 < b âˆ§ b â‰¤ a âˆ¨ b < 0 âˆ§ a â‰¤ b := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "one_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 1 â‰¤ a / b â†” 0 < b âˆ§ b â‰¤ a âˆ¨ b < 0 âˆ§ a â‰¤ b",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "a / b < 1 â†” 0 < b âˆ§ a < b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b < a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b < 1 â†” 0 < b âˆ§ a < b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b < a := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "div_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b < 1 â†” 0 < b âˆ§ a < b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b < a",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "a / b â‰¤ 1 â†” 0 < b âˆ§ a â‰¤ b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b â‰¤ 1 â†” 0 < b âˆ§ a â‰¤ b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b â‰¤ a := by rcases lt_trichotomy b 0 with (hb | rfl | hb); sorry",
  "name": "div_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : a / b â‰¤ 1 â†” 0 < b âˆ§ a â‰¤ b âˆ¨ b = 0 âˆ¨ b < 0 âˆ§ b â‰¤ a",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "1 / b â‰¤ 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a â‰¤ b) : 1 / b â‰¤ 1 / a := by rwa [div_le_iff_of_neg' hb]; sorry",
  "name": "one_div_le_one_div_of_neg_of_le",
  "kind": "theorem",
  "first-tactic": "rwa [div_le_iff_of_neg' hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a â‰¤ b) : 1 / b â‰¤ 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a â‰¤ b)"},
 {"type": "1 / b < 1 / a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a < b) : 1 / b < 1 / a := by rwa [div_lt_iff_of_neg' hb]; sorry",
  "name": "one_div_lt_one_div_of_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "rwa [div_lt_iff_of_neg' hb]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a < b) : 1 / b < 1 / a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hb : b < 0)  (h : a < b)"},
 {"type": "1 / a â‰¤ 1 / b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a â‰¤ 1 / b â†” b â‰¤ a := by simpa [one_div] using inv_le_inv_of_neg ha hb; sorry",
  "name": "one_div_le_one_div_of_neg",
  "kind": "theorem",
  "first-tactic": "simpa [one_div] using inv_le_inv_of_neg ha hb",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0) : 1 / a â‰¤ 1 / b â†” b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (ha : a < 0)  (hb : b < 0)"},
 {"type": "a - a / 2 = a / 2",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : a - a / 2 = a / 2 := by suffices a / 2 + a / 2 - a / 2 = a / 2 by rwa [add_halves] at this; sorry",
  "name": "sub_self_div_two",
  "kind": "theorem",
  "first-tactic":
  "suffices a / 2 + a / 2 - a / 2 = a / 2 by rwa [add_halves] at this",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : a - a / 2 = a / 2",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±)"},
 {"type": "a / 2 - a = -(a / 2)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : a / 2 - a = -(a / 2) := by suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this; sorry",
  "name": "div_two_sub_self",
  "kind": "theorem",
  "first-tactic":
  "suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : a / 2 - a = -(a / 2)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±)"},
 {"type": "a + (b - a) / 2 < b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : a < b) : a + (b - a) / 2 < b := by rwa [â† div_sub_div_same]; sorry",
  "name": "add_sub_div_two_lt",
  "kind": "theorem",
  "first-tactic": "rwa [â† div_sub_div_same]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : a < b) : a + (b - a) / 2 < b",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : a < b)"},
 {"type": "(1 - 1 / a)â»Â¹ â‰¤ 2",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2 := by refine' (inv_le_inv_of_le (inv_pos.2 <| zero_lt_two' Î±) _).trans_eq (inv_inv (2 : Î±)); sorry",
  "name": "sub_one_div_inv_le_two",
  "kind": "theorem",
  "first-tactic":
  "refine' (inv_le_inv_of_le (inv_pos.2 <| zero_lt_two' Î±) _).trans_eq (inv_inv (2 : Î±))",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a2 : 2 â‰¤ a) : (1 - 1 / a)â»Â¹ â‰¤ 2",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a2 : 2 â‰¤ a)"},
 {"type": "IsLUB ((fun b => a * b) '' s) (a * b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b) : IsLUB ((fun b => a * b) '' s) (a * b) := by rcases lt_or_eq_of_le ha with (ha | rfl); sorry",
  "name": "IsLUB.mul_left",
  "kind": "theorem",
  "first-tactic": "rcases lt_or_eq_of_le ha with (ha | rfl)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b) : IsLUB ((fun b => a * b) '' s) (a * b)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b)"},
 {"type": "IsLUB ((fun b => b * a) '' s) (b * a)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b) : IsLUB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha; sorry",
  "name": "IsLUB.mul_right",
  "kind": "theorem",
  "first-tactic": "simpa [mul_comm] using hs.mul_left ha",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b) : IsLUB ((fun b => b * a) '' s) (b * a)",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} {s : Set Î±}  (ha : 0 â‰¤ a)  (hs : IsLUB s b)"},
 {"type": "(a * d - b * c) / (c * d) < 0 â†” a / c < b / d",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†” a / c < b / d := by rw [mul_comm b c]; sorry",
  "name": "mul_sub_mul_div_mul_neg_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0) : (a * d - b * c) / (c * d) < 0 â†” a / c < b / d",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0)"},
 {"type": "(a * d - b * c) / (c * d) â‰¤ 0 â†” a / c â‰¤ b / d",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†” a / c â‰¤ b / d := by rw [mul_comm b c]; sorry",
  "name": "mul_sub_mul_div_mul_nonpos_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0) : (a * d - b * c) / (c * d) â‰¤ 0 â†” a / c â‰¤ b / d",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (hc : c â‰  0)  (hd : d â‰  0)"},
 {"type": "b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : âˆ€ Îµ > 0, b - Îµ â‰¤ a) : b â‰¤ a := by contrapose! h; sorry",
  "name": "le_of_forall_sub_le",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : âˆ€ Îµ > 0, b - Îµ â‰¤ a) : b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (h : âˆ€ Îµ > 0, b - Îµ â‰¤ a)"},
 {"type": "|1 / a| = 1 / |a|",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : |1 / a| = 1 / |a| := by rw [abs_div]; sorry",
  "name": "abs_one_div",
  "kind": "theorem",
  "first-tactic": "rw [abs_div]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±) : |1 / a| = 1 / |a|",
  "args":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} (a : Î±)"},
 {"type": "0 â‰¤ a ^ (-2 : â„¤)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 â‰¤ a ^ (-2 : â„¤) := by simp only [inv_nonneg]; sorry",
  "name": "pow_minus_two_nonneg",
  "kind": "theorem",
  "first-tactic": "simp only [inv_nonneg]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤} : 0 â‰¤ a ^ (-2 : â„¤)",
  "args": "{Î¹ Î± Î² : Type _}  [LinearOrderedField Î±]  {a b c d : Î±}  {n : â„¤}"},
 {"type": "(a - b) / c = a / c - b / c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CanonicallyLinearOrderedSemifield Î±]  [Sub Î±]  [OrderedSub Î±] (a b c : Î±) : (a - b) / c = a / c - b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "tsub_div",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  [CanonicallyLinearOrderedSemifield Î±]  [Sub Î±]  [OrderedSub Î±] (a b c : Î±) : (a - b) / c = a / c - b / c",
  "args":
  "{Î± : Type _}  [CanonicallyLinearOrderedSemifield Î±]  [Sub Î±]  [OrderedSub Î±] (a b c : Î±)"},
 {"type": "aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a := by rw [â† mul_le_mul_iff_left a]; sorry",
  "name": "Left.inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1 := by rw [â† mul_le_mul_iff_left a]; sorry",
  "name": "Left.one_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "b â‰¤ aâ»Â¹ * c â†” a * b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : b â‰¤ aâ»Â¹ * c â†” a * b â‰¤ c := by rw [â† mul_le_mul_iff_left a]; sorry",
  "name": "le_inv_mul_iff_mul_le",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : b â‰¤ aâ»Â¹ * c â†” a * b â‰¤ c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c := by rw [â† mul_le_mul_iff_left b]; sorry",
  "name": "inv_mul_le_iff_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : bâ»Â¹ * a â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "1 â‰¤ bâ»Â¹ * a â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ bâ»Â¹ * a â†” b â‰¤ a := by rw [â† mul_le_mul_iff_left b]; sorry",
  "name": "le_inv_mul_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ bâ»Â¹ * a â†” b â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "1 < aâ»Â¹ â†” a < 1",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1 := by rw [â† mul_lt_mul_iff_left a]; sorry",
  "name": "Left.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "aâ»Â¹ < 1 â†” 1 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : aâ»Â¹ < 1 â†” 1 < a := by rw [â† mul_lt_mul_iff_left a]; sorry",
  "name": "Left.inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : aâ»Â¹ < 1 â†” 1 < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "b < aâ»Â¹ * c â†” a * b < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : b < aâ»Â¹ * c â†” a * b < c := by rw [â† mul_lt_mul_iff_left a]; sorry",
  "name": "lt_inv_mul_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : b < aâ»Â¹ * c â†” a * b < c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "bâ»Â¹ * a < c â†” a < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : bâ»Â¹ * a < c â†” a < b * c := by rw [â† mul_lt_mul_iff_left b]; sorry",
  "name": "inv_mul_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : bâ»Â¹ * a < c â†” a < b * c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "1 < bâ»Â¹ * a â†” b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < bâ»Â¹ * a â†” b < a := by rw [â† mul_lt_mul_iff_left b]; sorry",
  "name": "lt_inv_mul_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < bâ»Â¹ * a â†” b < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a := by rw [â† mul_le_mul_iff_right a]; sorry",
  "name": "Right.inv_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±}"},
 {"type": "1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1 := by rw [â† mul_le_mul_iff_right a]; sorry",
  "name": "Right.one_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±}"},
 {"type": "1 â‰¤ a * bâ»Â¹ â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : 1 â‰¤ a * bâ»Â¹ â†” b â‰¤ a := by rw [â† mul_le_mul_iff_right b]; sorry",
  "name": "le_mul_inv_iff_le",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} : 1 â‰¤ a * bâ»Â¹ â†” b â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±}"},
 {"type": "aâ»Â¹ < 1 â†” 1 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : aâ»Â¹ < 1 â†” 1 < a := by rw [â† mul_lt_mul_iff_right a]; sorry",
  "name": "Right.inv_lt_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : aâ»Â¹ < 1 â†” 1 < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "1 < aâ»Â¹ â†” a < 1",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1 := by rw [â† mul_lt_mul_iff_right a]; sorry",
  "name": "Right.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "a * bâ»Â¹ < c â†” a < c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : a * bâ»Â¹ < c â†” a < c * b := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "mul_inv_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : a * bâ»Â¹ < c â†” a < c * b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "a * bâ»Â¹ < 1 â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : a * bâ»Â¹ < 1 â†” a < b := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "inv_mul_lt_one_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : a * bâ»Â¹ < 1 â†” a < b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "1 < a * bâ»Â¹ â†” b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : 1 < a * bâ»Â¹ â†” b < a := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "lt_mul_inv_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±} : 1 < a * bâ»Â¹ â†” b < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a := by rw [â† mul_le_mul_iff_left a]; sorry",
  "name": "inv_le_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} : aâ»Â¹ â‰¤ bâ»Â¹ â†” b â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ â‰¤ dâ»Â¹ * c â†” d * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} : a * bâ»Â¹ â‰¤ dâ»Â¹ * c â†” d * a â‰¤ c * b := by rw [â† mul_le_mul_iff_left d]; sorry",
  "name": "mul_inv_le_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_left d]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} : a * bâ»Â¹ â‰¤ dâ»Â¹ * c â†” d * a â‰¤ c * b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}"},
 {"type": "a / b â‰¤ a â†” 1 â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a / b â‰¤ a â†” 1 â‰¤ b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a / b â‰¤ a â†” 1 â‰¤ b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±}"},
 {"type": "a â‰¤ a / b â†” b â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a â‰¤ a / b â†” b â‰¤ 1 := by simp only [div_eq_mul_inv]; sorry",
  "name": "le_div_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a â‰¤ a / b â†” b â‰¤ 1",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±}"},
 {"type": "aâ»Â¹ < bâ»Â¹ â†” b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : aâ»Â¹ < bâ»Â¹ â†” b < a := by rw [â† mul_lt_mul_iff_left a]; sorry",
  "name": "inv_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left a]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : aâ»Â¹ < bâ»Â¹ â†” b < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±}"},
 {"type": "aâ»Â¹ < b â†” bâ»Â¹ < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : aâ»Â¹ < b â†” bâ»Â¹ < a := by rw [â† inv_lt_inv_iff]; sorry",
  "name": "inv_lt'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_lt_inv_iff]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : aâ»Â¹ < b â†” bâ»Â¹ < a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±}"},
 {"type": "a < bâ»Â¹ â†” b < aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : a < bâ»Â¹ â†” b < aâ»Â¹ := by rw [â† inv_lt_inv_iff]; sorry",
  "name": "lt_inv'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_lt_inv_iff]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : a < bâ»Â¹ â†” b < aâ»Â¹",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ < dâ»Â¹ * c â†” d * a < c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : a * bâ»Â¹ < dâ»Â¹ * c â†” d * a < c * b := by rw [â† mul_lt_mul_iff_left d]; sorry",
  "name": "mul_inv_lt_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left d]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} : a * bâ»Â¹ < dâ»Â¹ * c â†” d * a < c * b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±}"},
 {"type": "a / b < a â†” 1 < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a / b < a â†” 1 < b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±} : a / b < a â†” 1 < b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c d : Î±} (a : Î±)  {b : Î±}"},
 {"type": "câ»Â¹ * a â‰¤ b â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : câ»Â¹ * a â‰¤ b â†” a â‰¤ b * c := by rw [inv_mul_le_iff_le_mul]; sorry",
  "name": "inv_mul_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_le_iff_le_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : câ»Â¹ * a â‰¤ b â†” a â‰¤ b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c := by rw [â† inv_mul_le_iff_le_mul]; sorry",
  "name": "mul_inv_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_mul_le_iff_le_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a * bâ»Â¹ â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ â‰¤ c * dâ»Â¹ â†” a * d â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a * bâ»Â¹ â‰¤ c * dâ»Â¹ â†” a * d â‰¤ c * b := by rw [mul_comm c]; sorry",
  "name": "mul_inv_le_mul_inv_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a * bâ»Â¹ â‰¤ c * dâ»Â¹ â†” a * d â‰¤ c * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "câ»Â¹ * a < b â†” a < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : câ»Â¹ * a < b â†” a < b * c := by rw [inv_mul_lt_iff_lt_mul]; sorry",
  "name": "inv_mul_lt_iff_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_mul_lt_iff_lt_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : câ»Â¹ * a < b â†” a < b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ < c â†” a < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a * bâ»Â¹ < c â†” a < b * c := by rw [â† inv_mul_lt_iff_lt_mul]; sorry",
  "name": "mul_inv_lt_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_mul_lt_iff_lt_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a * bâ»Â¹ < c â†” a < b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a * bâ»Â¹ < c * dâ»Â¹ â†” a * d < c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a * bâ»Â¹ < c * dâ»Â¹ â†” a * d < c * b := by rw [mul_comm c]; sorry",
  "name": "mul_inv_lt_mul_inv_iff'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm c]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a * bâ»Â¹ < c * dâ»Â¹ â†” a * d < c * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / c â‰¤ b / c â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (c : Î±) : a / c â‰¤ b / c â†” a â‰¤ b := by simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _; sorry",
  "name": "div_le_div_iff_right",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_le_mul_iff_right _",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (c : Î±) : a / c â‰¤ b / c â†” a â‰¤ b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (c : Î±)"},
 {"type": "1 â‰¤ a / b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ a / b â†” b â‰¤ a := by rw [â† mul_le_mul_iff_right b]; sorry",
  "name": "one_le_div'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : 1 â‰¤ a / b â†” b â‰¤ a",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a / b â‰¤ 1 â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ 1 â†” a â‰¤ b := by rw [â† mul_le_mul_iff_right b]; sorry",
  "name": "div_le_one'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ 1 â†” a â‰¤ b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a â‰¤ c / b â†” a * b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a â‰¤ c / b â†” a * b â‰¤ c := by rw [â† mul_le_mul_iff_right b]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a â‰¤ c / b â†” a * b â‰¤ c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a / c â‰¤ b â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / c â‰¤ b â†” a â‰¤ b * c := by rw [â† mul_le_mul_iff_right c]; sorry",
  "name": "div_le_iff_le_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_le_mul_iff_right c]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / c â‰¤ b â†” a â‰¤ b * c",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a / b â‰¤ a / c â†” c â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : a / b â‰¤ a / c â†” c â‰¤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : a / b â‰¤ a / c â†” c â‰¤ b",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±)"},
 {"type": "a / b â‰¤ c / d â†” a * d â‰¤ c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ c / d â†” a * d â‰¤ c * b := by simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'; sorry",
  "name": "div_le_div_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_inv_le_mul_inv_iff'",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ c / d â†” a * d â‰¤ c * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "b â‰¤ c / a â†” a * b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : b â‰¤ c / a â†” a * b â‰¤ c := by rw [le_div_iff_mul_le]; sorry",
  "name": "le_div_iff_mul_le'",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_mul_le]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : b â‰¤ c / a â†” a * b â‰¤ c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a / b â‰¤ c â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ c â†” a â‰¤ b * c := by rw [div_le_iff_le_mul]; sorry",
  "name": "div_le_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_le_iff_le_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : a / b â‰¤ c â†” a â‰¤ b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "aâ»Â¹ â‰¤ b / c â†” c â‰¤ a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : aâ»Â¹ â‰¤ b / c â†” c â‰¤ a * b := by rw [inv_le_div_iff_le_mul]; sorry",
  "name": "inv_le_div_iff_le_mul'",
  "kind": "theorem",
  "first-tactic": "rw [inv_le_div_iff_le_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} : aâ»Â¹ â‰¤ b / c â†” c â‰¤ a * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±}"},
 {"type": "a / d â‰¤ b / c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} (hab : a â‰¤ b)  (hcd : c â‰¤ d) : a / d â‰¤ b / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} (hab : a â‰¤ b)  (hcd : c â‰¤ d) : a / d â‰¤ b / c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c d : Î±} (hab : a â‰¤ b)  (hcd : c â‰¤ d)"},
 {"type": "a / c < b / c â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} (c : Î±) : a / c < b / c â†” a < b := by simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _; sorry",
  "name": "div_lt_div_iff_right",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_lt_mul_iff_right _",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} (c : Î±) : a / c < b / c â†” a < b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} (c : Î±)"},
 {"type": "1 < a / b â†” b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : 1 < a / b â†” b < a := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "one_lt_div'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : 1 < a / b â†” b < a",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / b < 1 â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a / b < 1 â†” a < b := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "div_lt_one'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a / b < 1 â†” a < b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a < c / b â†” a * b < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a < c / b â†” a * b < c := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "lt_div_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a < c / b â†” a * b < c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / c < b â†” a < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a / c < b â†” a < b * c := by rw [â† mul_lt_mul_iff_right c]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right c]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±} : a / c < b â†” a < b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / b < a / c â†” c < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±} (a : Î±) : a / b < a / c â†” c < b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_lt_div_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±} (a : Î±) : a / b < a / c â†” c < b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±} (a : Î±)"},
 {"type": "aâ»Â¹ < b / c â†” c < a * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±} : aâ»Â¹ < b / c â†” c < a * b := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_lt_div_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±} : aâ»Â¹ < b / c â†” c < a * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]    {a b c : Î±}"},
 {"type": "a / b < c / d â†” a * d < c * b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a / b < c / d â†” a * d < c * b := by simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'; sorry",
  "name": "div_lt_div_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using mul_inv_lt_mul_inv_iff'",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a / b < c / d â†” a * d < c * b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "b < c / a â†” a * b < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : b < c / a â†” a * b < c := by rw [lt_div_iff_mul_lt]; sorry",
  "name": "lt_div_iff_mul_lt'",
  "kind": "theorem",
  "first-tactic": "rw [lt_div_iff_mul_lt]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : b < c / a â†” a * b < c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / b < c â†” a < b * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a / b < c â†” a < b * c := by rw [div_lt_iff_lt_mul]; sorry",
  "name": "div_lt_iff_lt_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_lt_mul]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} : a / b < c â†” a < b * c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±}"},
 {"type": "a / d < b / c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} (hab : a < b)  (hcd : c < d) : a / d < b / c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_lt_div''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} (hab : a < b)  (hcd : c < d) : a / d < b / c",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [CommGroup Î±]  [Preorder Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c d : Î±} (hab : a < b)  (hcd : c < d)"},
 {"type": "cmp (a / b) 1 = cmp a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  (a b : Î±) : cmp (a / b) 1 = cmp a b := by rw [â† cmp_mul_right' _ _ b]; sorry",
  "name": "cmp_div_one'",
  "kind": "theorem",
  "first-tactic": "rw [â† cmp_mul_right' _ _ b]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  (a b : Î±) : cmp (a / b) 1 = cmp a b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  (a b : Î±)"},
 {"type": "a / b â‰¤ aâ»Â¹ * b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)] : a / b â‰¤ aâ»Â¹ * b â†” a â‰¤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_inv_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)] : a / b â‰¤ aâ»Â¹ * b â†” a â‰¤ b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]"},
 {"type": "a / b â‰¤ b / a â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} {Î± : Type _}  [CommGroup Î±]  [LinearOrder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b : Î±} : a / b â‰¤ b / a â†” a â‰¤ b := by rw [div_eq_mul_inv b]; sorry",
  "name": "div_le_div_flip",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv b]",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} {Î± : Type _}  [CommGroup Î±]  [LinearOrder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b : Î±} : a / b â‰¤ b / a â†” a â‰¤ b",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [Group Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b c : Î±} {Î± : Type _}  [CommGroup Î±]  [LinearOrder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  {a b : Î±}"},
 {"type": "âˆƒ a : Î±, 1 < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CommGroup Î±]  [LinearOrderedCommGroup Î±]  {a b c : Î±} [Nontrivial Î±] : âˆƒ a : Î±, 1 < a := by obtain âŸ¨y, hyâŸ© := Decidable.exists_ne (1 : Î±); sorry",
  "name": "exists_one_lt'",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨y, hyâŸ© := Decidable.exists_ne (1 : Î±)",
  "core-prompt":
  "{Î± : Type u}  [CommGroup Î±]  [LinearOrderedCommGroup Î±]  {a b c : Î±} [Nontrivial Î±] : âˆƒ a : Î±, 1 < a",
  "args":
  "{Î± : Type u}  [CommGroup Î±]  [LinearOrderedCommGroup Î±]  {a b c : Î±} [Nontrivial Î±]"},
 {"type": "|(-a)| = |a|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] (a : Î±) : |(-a)| = |a| := by rw [abs_eq_max_neg]; sorry",
  "name": "abs_neg",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_max_neg]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] (a : Î±) : |(-a)| = |a|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] (a : Î±)"},
 {"type": "a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±}  (h : |a| = b) : a = b âˆ¨ a = -b := by simpa only [â† h]; sorry",
  "name": "eq_or_eq_neg_of_abs_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [â† h]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±}  (h : |a| = b) : a = b âˆ¨ a = -b",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±}  (h : |a| = b)"},
 {"type": "|a| = |b| â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±} : |a| = |b| â†” a = b âˆ¨ a = -b := by refine' âŸ¨fun h => _, fun h => _âŸ©; sorry",
  "name": "abs_eq_abs",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => _âŸ©",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±} : |a| = |b| â†” a = b âˆ¨ a = -b",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] {a b : Î±}"},
 {"type": "|a| â‰¤ |b|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (ha : 0 â‰¤ a)  (hab : a â‰¤ b) : |a| â‰¤ |b| := by rwa [abs_of_nonneg ha]; sorry",
  "name": "abs_le_abs_of_nonneg",
  "kind": "theorem",
  "first-tactic": "rwa [abs_of_nonneg ha]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (ha : 0 â‰¤ a)  (hab : a â‰¤ b) : |a| â‰¤ |b|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (ha : 0 â‰¤ a)  (hab : a â‰¤ b)"},
 {"type": "0 < |a| â†” a â‰  0",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} : 0 < |a| â†” a â‰  0 := by rcases lt_trichotomy a 0 with (ha | rfl | ha); sorry",
  "name": "abs_pos",
  "kind": "theorem",
  "first-tactic": "rcases lt_trichotomy a 0 with (ha | rfl | ha)",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} : 0 < |a| â†” a â‰  0",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±}"},
 {"type": "-|a| â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : -|a| â‰¤ a := by cases' le_total 0 a with h h; sorry",
  "name": "neg_abs_le_self",
  "kind": "theorem",
  "first-tactic": "cases' le_total 0 a with h h",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : -|a| â‰¤ a",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±)"},
 {"type": "0 â‰¤ a + |a|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : 0 â‰¤ a + |a| := by rw [â† add_right_neg a]; sorry",
  "name": "add_abs_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [â† add_right_neg a]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : 0 â‰¤ a + |a|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±)"},
 {"type": "-|a| â‰¤ -a",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : -|a| â‰¤ -a := by simpa using neg_abs_le_self (-a); sorry",
  "name": "neg_abs_le_neg",
  "kind": "theorem",
  "first-tactic": "simpa using neg_abs_le_self (-a)",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±) : -|a| â‰¤ -a",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} (a : Î±)"},
 {"type": "|a| â‰¤ |b|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (ha : a â‰¤ 0)  (hab : b â‰¤ a) : |a| â‰¤ |b| := by rw [abs_of_nonpos ha]; sorry",
  "name": "abs_le_abs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [abs_of_nonpos ha]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (ha : a â‰¤ 0)  (hab : b â‰¤ a) : |a| â‰¤ |b|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (ha : a â‰¤ 0)  (hab : b â‰¤ a)"},
 {"type": "max a b - min a b = |a - b|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±) : max a b - min a b = |a - b| := by cases' le_total a b with ab ba; sorry",
  "name": "max_sub_min_eq_abs'",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with ab ba",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±) : max a b - min a b = |a - b|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±)"},
 {"type": "max a b - min a b = |b - a|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±) : max a b - min a b = |b - a| := by rw [abs_sub_comm]; sorry",
  "name": "max_sub_min_eq_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_sub_comm]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±) : max a b - min a b = |b - a|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [AddGroup Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {a b c : Î±} [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)] (a b : Î±)"},
 {"type": "|a| â‰¤ b â†” -b â‰¤ a âˆ§ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a| â‰¤ b â†” -b â‰¤ a âˆ§ a â‰¤ b := by rw [abs_le']; sorry",
  "name": "abs_le",
  "kind": "theorem",
  "first-tactic": "rw [abs_le']",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a| â‰¤ b â†” -b â‰¤ a âˆ§ a â‰¤ b",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`."},
 {"type": "a â‰¤ |b| â†” b â‰¤ -a âˆ¨ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : a â‰¤ |b| â†” b â‰¤ -a âˆ¨ a â‰¤ b := by rw [le_abs]; sorry",
  "name": "le_abs'",
  "kind": "theorem",
  "first-tactic": "rw [le_abs]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : a â‰¤ |b| â†” b â‰¤ -a âˆ¨ a â‰¤ b",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`."},
 {"type": "|a| â‰¤ |b| + |b + a|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±) : |a| â‰¤ |b| + |b + a| := by simpa using abs_add (-b) (b + a); sorry",
  "name": "abs_add'",
  "kind": "theorem",
  "first-tactic": "simpa using abs_add (-b) (b + a)",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±) : |a| â‰¤ |b| + |b + a|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±)"},
 {"type": "|a - b| â‰¤ |a| + |b|",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±) : |a - b| â‰¤ |a| + |b| := by rw [sub_eq_add_neg]; sorry",
  "name": "abs_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±) : |a - b| â‰¤ |a| + |b|",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (a b : Î±)"},
 {"type": "|a - b| â‰¤ c â†” a - b â‰¤ c âˆ§ b - a â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a - b| â‰¤ c â†” a - b â‰¤ c âˆ§ b - a â‰¤ c := by rw [abs_le]; sorry",
  "name": "abs_sub_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [abs_le]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a - b| â‰¤ c â†” a - b â‰¤ c âˆ§ b - a â‰¤ c",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`."},
 {"type": "|a - b| < c â†” a - b < c âˆ§ b - a < c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a - b| < c â†” a - b < c âˆ§ b - a < c := by rw [@abs_lt Î±]; sorry",
  "name": "abs_sub_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [@abs_lt Î±]",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. : |a - b| < c â†” a - b < c âˆ§ b - a < c",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`."},
 {"type": "|a| = b â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (hb : 0 â‰¤ b) : |a| = b â†” a = b âˆ¨ a = -b := by refine' âŸ¨eq_or_eq_neg_of_abs_eq, _âŸ©; sorry",
  "name": "abs_eq",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨eq_or_eq_neg_of_abs_eq, _âŸ©",
  "core-prompt":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (hb : 0 â‰¤ b) : |a| = b â†” a = b âˆ¨ a = -b",
  "args":
  "{Î± : Type _}   [Neg Î±]  [LinearOrder Î±]  {a b : Î±}  [LinearOrderedAddCommGroup Î±]  {a b c d : Î±}  -- Porting note: -- Lean can perfectly well find this instance, -- but in the rewrites below it is going looking for it without having fixed `Î±`. (hb : 0 â‰¤ b)"},
 {"type": "max a 1 / max aâ»Â¹ 1 = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Group Î±]  [LinearOrder Î±]  [CovariantClass Î± Î± (. * .) (. â‰¤ .)] (a : Î±) : max a 1 / max aâ»Â¹ 1 = a := by rcases le_total a 1 with (h | h); sorry",
  "name": "max_one_div_max_inv_one_eq_self",
  "kind": "theorem",
  "first-tactic": "rcases le_total a 1 with (h | h)",
  "core-prompt":
  "{Î± : Type _}  [Group Î±]  [LinearOrder Î±]  [CovariantClass Î± Î± (. * .) (. â‰¤ .)] (a : Î±) : max a 1 / max aâ»Â¹ 1 = a",
  "args":
  "{Î± : Type _}  [Group Î±]  [LinearOrder Î±]  [CovariantClass Î± Î± (. * .) (. â‰¤ .)] (a : Î±)"},
 {"type": "min (a / c) (b / c) = min a b / c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : min (a / c) (b / c) = min a b / c := by simpa only [div_eq_mul_inv] using min_mul_mul_right a b câ»Â¹; sorry",
  "name": "min_div_div_right'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using min_mul_mul_right a b câ»Â¹",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : min (a / c) (b / c) = min a b / c",
  "args": "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "max (a / c) (b / c) = max a b / c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : max (a / c) (b / c) = max a b / c := by simpa only [div_eq_mul_inv] using max_mul_mul_right a b câ»Â¹; sorry",
  "name": "max_div_div_right'",
  "kind": "theorem",
  "first-tactic": "simpa only [div_eq_mul_inv] using max_mul_mul_right a b câ»Â¹",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : max (a / c) (b / c) = max a b / c",
  "args": "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "min (a / b) (a / c) = a / max b c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : min (a / b) (a / c) = a / max b c := by simp only [div_eq_mul_inv]; sorry",
  "name": "min_div_div_left'",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : min (a / b) (a / c) = a / max b c",
  "args": "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "max (a / b) (a / c) = a / min b c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : max (a / b) (a / c) = a / min b c := by simp only [div_eq_mul_inv]; sorry",
  "name": "max_div_div_left'",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±) : max (a / b) (a / c) = a / min b c",
  "args": "{Î± : Type _}  [LinearOrderedCommGroup Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "max a b - max c d â‰¤ max (a - c) (b - d)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : max a b - max c d â‰¤ max (a - c) (b - d) := by simp only [sub_le_iff_le_add]; sorry",
  "name": "max_sub_max_le_max",
  "kind": "theorem",
  "first-tactic": "simp only [sub_le_iff_le_add]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : max a b - max c d â‰¤ max (a - c) (b - d)",
  "args":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±)"},
 {"type": "|max a b - max c d| â‰¤ max (|a - c|) (|b - d|)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : |max a b - max c d| â‰¤ max (|a - c|) (|b - d|) := by refine' abs_sub_le_iff.2 âŸ¨_, _âŸ©; sorry",
  "name": "abs_max_sub_max_le_max",
  "kind": "theorem",
  "first-tactic": "refine' abs_sub_le_iff.2 âŸ¨_, _âŸ©",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : |max a b - max c d| â‰¤ max (|a - c|) (|b - d|)",
  "args":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±)"},
 {"type": "|min a b - min c d| â‰¤ max (|a - c|) (|b - d|)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : |min a b - min c d| â‰¤ max (|a - c|) (|b - d|) := by simpa only [max_neg_neg]; sorry",
  "name": "abs_min_sub_min_le_max",
  "kind": "theorem",
  "first-tactic": "simpa only [max_neg_neg]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±) : |min a b - min c d| â‰¤ max (|a - c|) (|b - d|)",
  "args":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c d : Î±)"},
 {"type": "|max a c - max b c| â‰¤ |a - b|",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c : Î±) : |max a c - max b c| â‰¤ |a - b| := by simpa only [sub_self]; sorry",
  "name": "abs_max_sub_max_le_abs",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_self]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c : Î±) : |max a c - max b c| â‰¤ |a - b|",
  "args":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±]  {a b c : Î±} (a b c : Î±)"},
 {"type": "(OrderIso.mulRight a).symm = OrderIso.mulRight aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (a : Î±) : (OrderIso.mulRight a).symm = OrderIso.mulRight aâ»Â¹ := by ext x; sorry",
  "name": "OrderIso.mulRight_symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (a : Î±) : (OrderIso.mulRight a).symm = OrderIso.mulRight aâ»Â¹",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±} (a : Î±)"},
 {"type": "(OrderIso.mulLeft a).symm = OrderIso.mulLeft aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] (a : Î±) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft aâ»Â¹ := by ext x; sorry",
  "name": "OrderIso.mulLeft_symm",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] (a : Î±) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft aâ»Â¹",
  "args":
  "{Î± : Type u}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]    {a b c d : Î±}  [Group Î±]  [LE Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] (a : Î±)"},
 {"type": "abv (a - c) â‰¤ abv (a - b) + abv (b - c)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R) : abv (a - c) â‰¤ abv (a - b) + abv (b - c) := by simpa [sub_eq_add_neg]; sorry",
  "name": "sub_le",
  "kind": "theorem",
  "first-tactic": "simpa [sub_eq_add_neg]",
  "core-prompt":
  "{R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R) : abv (a - c) â‰¤ abv (a - b) + abv (b - c)",
  "args":
  "{R S : Type _}  [Ring R]  [OrderedSemiring S]  (abv : AbsoluteValue R S) (a b c : R)"},
 {"type": "abv (-a) = abv a",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R) : abv (-a) = abv a := by by_cases ha : a = 0; sorry",
  "name": "map_neg",
  "kind": "theorem",
  "first-tactic": "by_cases ha : a = 0",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R) : abv (-a) = abv a",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a : R)"},
 {"type": "abv (a - b) = abv (b - a)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R) : abv (a - b) = abv (b - a) := by rw [â† neg_sub]; sorry",
  "name": "map_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† neg_sub]",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R) : abv (a - b) = abv (b - a)",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {R S : Type _}  [Ring R]  [OrderedCommRing S]  (abv : AbsoluteValue R S) [NoZeroDivisors S] (a b : R)"},
 {"type": "abv (a - c) â‰¤ abv (a - b) + abv (b - c)",
  "tactic-prompt":
  "theorem {R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R â†’ S)  [IsAbsoluteValue abv] (a b c : R) : abv (a - c) â‰¤ abv (a - b) + abv (b - c) := by simpa [sub_eq_add_neg]; sorry",
  "name": "abv_sub_le",
  "kind": "theorem",
  "first-tactic": "simpa [sub_eq_add_neg]",
  "core-prompt":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R â†’ S)  [IsAbsoluteValue abv] (a b c : R) : abv (a - c) â‰¤ abv (a - b) + abv (b - c)",
  "args":
  "{R S : Type _}  [Semiring R]  [OrderedRing S]  (abv : AbsoluteValue R S) [IsDomain S]  [Nontrivial R]  {S : Type _}  [OrderedRing S]  {R : Type _}  [Ring R]  (abv : R â†’ S)  [IsAbsoluteValue abv] (a b c : R)"},
 {"type": "0 â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±}  [LinearOrderedCommMonoidWithZero Î±]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/ : 0 â‰¤ a := by simpa only [mul_zero]; sorry",
  "name": "zero_le'",
  "kind": "theorem",
  "first-tactic": "simpa only [mul_zero]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±}  [LinearOrderedCommMonoidWithZero Î±]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/ : 0 â‰¤ a",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±}  [LinearOrderedCommMonoidWithZero Î±]  /- The following facts are true more generally in a (linearly) ordered commutative monoid. -/"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : c â‰  0)  (hab : a * c â‰¤ b * c) : a â‰¤ b := by simpa only [mul_inv_cancel_rightâ‚€ h] using mul_le_mul_right' hab câ»Â¹; sorry",
  "name": "le_of_le_mul_right",
  "kind": "theorem",
  "first-tactic":
  "simpa only [mul_inv_cancel_rightâ‚€ h] using mul_le_mul_right' hab câ»Â¹",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : c â‰  0)  (hab : a * c â‰¤ b * c) : a â‰¤ b",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : c â‰  0)  (hab : a * c â‰¤ b * c)"},
 {"type": "a * câ»Â¹ â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hab : a â‰¤ b * c) : a * câ»Â¹ â‰¤ b := by by_cases h : c = 0; sorry",
  "name": "mul_inv_le_of_le_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h : c = 0",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hab : a â‰¤ b * c) : a * câ»Â¹ â‰¤ b",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hab : a â‰¤ b * c)"},
 {"type": "x * zâ»Â¹ < y",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z) : x * zâ»Â¹ < y := by contrapose! h; sorry",
  "name": "mul_inv_lt_of_lt_mulâ‚€",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z) : x * zâ»Â¹ < y",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z)"},
 {"type": "yâ»Â¹ * x < z",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z) : yâ»Â¹ * x < z := by rw [mul_comm] at *; sorry",
  "name": "inv_mul_lt_of_lt_mulâ‚€",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at *",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z) : yâ»Â¹ * x < z",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : x < y * z)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (c : Î±)  (h : a < b)  (hc : c â‰  0) : a * c < b * c := by contrapose! h; sorry",
  "name": "mul_lt_rightâ‚€",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (c : Î±)  (h : a < b)  (hc : c â‰  0) : a * c < b * c",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (c : Î±)  (h : a < b)  (hc : c â‰  0)"},
 {"type": "b < d",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c â‰¤ a) : b < d := by have ha : a â‰  0 := ne_of_gt (lt_of_lt_of_le hc hh); sorry",
  "name": "lt_of_mul_lt_mul_of_leâ‚€",
  "kind": "theorem",
  "first-tactic": "have ha : a â‰  0 := ne_of_gt (lt_of_lt_of_le hc hh)",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c â‰¤ a) : b < d",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (h : a * b < c * d)  (hc : 0 < c)  (hh : c â‰¤ a)"},
 {"type": "a * b â‰¤ a * c â†” b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0) : a * b â‰¤ a * c â†” b â‰¤ c := by simp only [mul_comm a]; sorry",
  "name": "mul_le_mul_leftâ‚€",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm a]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0) : a * b â‰¤ a * c â†” b â‰¤ c",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0)"},
 {"type": "a / c â‰¤ b / c â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a / c â‰¤ b / c â†” a â‰¤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_div_rightâ‚€",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a / c â‰¤ b / c â†” a â‰¤ b",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0)"},
 {"type": "a / b â‰¤ a / c â†” c â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0)  (hb : b â‰  0)  (hc : c â‰  0) : a / b â‰¤ a / c â†” c â‰¤ b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_le_div_leftâ‚€",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0)  (hb : b â‰  0)  (hc : c â‰  0) : a / b â‰¤ a / c â†” c â‰¤ b",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (ha : a â‰  0)  (hb : b â‰  0)  (hc : c â‰  0)"},
 {"type": "a â‰¤ b / c â†” a * c â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a â‰¤ b / c â†” a * c â‰¤ b := by rw [div_eq_mul_inv]; sorry",
  "name": "le_div_iffâ‚€",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a â‰¤ b / c â†” a * c â‰¤ b",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0)"},
 {"type": "a / c â‰¤ b â†” a â‰¤ b * c",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a / c â‰¤ b â†” a â‰¤ b * c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_le_iffâ‚€",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0) : a / c â‰¤ b â†” a â‰¤ b * c",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? (hc : c â‰  0)"},
 {"type": "(OrderIso.mulLeftâ‚€' ha).symm = OrderIso.mulLeftâ‚€' (inv_ne_zero ha)",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0) : (OrderIso.mulLeftâ‚€' ha).symm = OrderIso.mulLeftâ‚€' (inv_ne_zero ha) := by ext; sorry",
  "name": "OrderIso.mulLeftâ‚€'_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0) : (OrderIso.mulLeftâ‚€' ha).symm = OrderIso.mulLeftâ‚€' (inv_ne_zero ha)",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0)"},
 {"type":
  "(OrderIso.mulRightâ‚€' ha).symm = OrderIso.mulRightâ‚€' (inv_ne_zero ha)",
  "tactic-prompt":
  "theorem {Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0) : (OrderIso.mulRightâ‚€' ha).symm = OrderIso.mulRightâ‚€' (inv_ne_zero ha) := by ext; sorry",
  "name": "OrderIso.mulRightâ‚€'_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0) : (OrderIso.mulRightâ‚€' ha).symm = OrderIso.mulRightâ‚€' (inv_ne_zero ha)",
  "args":
  "{Î± : Type _} {a b c d x y z : Î±} [LinearOrderedCommGroupWithZero Î±]  -- TODO: Do we really need the following two? {a : Î±}  (ha : a â‰  0)"},
 {"type": "â…Ÿ a â‰¤ 0 â†” a â‰¤ 0",
  "tactic-prompt":
  "theorem [LinearOrderedSemiring Î±]  {a : Î±} [Invertible a] : â…Ÿ a â‰¤ 0 â†” a â‰¤ 0 := by simp only [â† not_lt]; sorry",
  "name": "invOf_nonpos",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_lt]",
  "core-prompt":
  "[LinearOrderedSemiring Î±]  {a : Î±} [Invertible a] : â…Ÿ a â‰¤ 0 â†” a â‰¤ 0",
  "args": "[LinearOrderedSemiring Î±]  {a : Î±} [Invertible a]"},
 {"type": "â…Ÿ a < 0 â†” a < 0",
  "tactic-prompt":
  "theorem [LinearOrderedSemiring Î±]  {a : Î±} [Invertible a] : â…Ÿ a < 0 â†” a < 0 := by simp only [â† not_le]; sorry",
  "name": "invOf_lt_zero",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_le]",
  "core-prompt":
  "[LinearOrderedSemiring Î±]  {a : Î±} [Invertible a] : â…Ÿ a < 0 â†” a < 0",
  "args": "[LinearOrderedSemiring Î±]  {a : Î±} [Invertible a]"},
 {"type": "a + âŠ¤ = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  (a : WithTop Î±) : a + âŠ¤ = âŠ¤ := by cases a; sorry",
  "name": "add_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  (a : WithTop Î±) : a + âŠ¤ = âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  (a : WithTop Î±)"},
 {"type": "a + b = âŠ¤ â†” a = âŠ¤ âˆ¨ b = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±} : a + b = âŠ¤ â†” a = âŠ¤ âˆ¨ b = âŠ¤ := by cases a; sorry",
  "name": "add_eq_top",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±} : a + b = âŠ¤ â†” a = âŠ¤ âˆ¨ b = âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}"},
 {"type": "a + b < âŠ¤ â†” a < âŠ¤ âˆ§ b < âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [PartialOrder Î±]  {a b : WithTop Î±} : a + b < âŠ¤ â†” a < âŠ¤ âˆ§ b < âŠ¤ := by simp_rw [lt_top_iff_ne_top]; sorry",
  "name": "add_lt_top",
  "kind": "theorem",
  "first-tactic": "simp_rw [lt_top_iff_ne_top]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [PartialOrder Î±]  {a b : WithTop Î±} : a + b < âŠ¤ â†” a < âŠ¤ âˆ§ b < âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [PartialOrder Î±]  {a b : WithTop Î±}"},
 {"type": "x + y = âŠ¤ â†” x = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {x : WithTop Î±}  {y : Î±} : x + y = âŠ¤ â†” x = âŠ¤ := by induction x using WithTop.recTopCoe; sorry",
  "name": "add_coe_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "induction x using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {x : WithTop Î±}  {y : Î±} : x + y = âŠ¤ â†” x = âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {x : WithTop Î±}  {y : Î±}"},
 {"type": "â†‘x + y = âŠ¤ â†” y = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {y : WithTop Î±} : â†‘x + y = âŠ¤ â†” y = âŠ¤ := by induction y using WithTop.recTopCoe; sorry",
  "name": "coe_add_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "induction y using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {y : WithTop Î±} : â†‘x + y = âŠ¤ â†” y = âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  {y : WithTop Î±}"},
 {"type": "b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (ha : a â‰  âŠ¤)      (h : a + b â‰¤ a + c) : b â‰¤ c := by induction a using WithTop.recTopCoe; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (ha : a â‰  âŠ¤)      (h : a + b â‰¤ a + c) : b â‰¤ c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (ha : a â‰  âŠ¤)      (h : a + b â‰¤ a + c)"},
 {"type": "b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)]      (ha : a â‰  âŠ¤)  (h : b + a â‰¤ c + a) : b â‰¤ c := by induction a using WithTop.recTopCoe; sorry",
  "name": "le_of_add_le_add_right",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)]      (ha : a â‰  âŠ¤)  (h : b + a â‰¤ c + a) : b â‰¤ c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LE Î±]  [ContravariantClass Î± Î± (swap (Â· + Â·)) (Â· â‰¤ Â·)]      (ha : a â‰  âŠ¤)  (h : b + a â‰¤ c + a)"},
 {"type": "a + b < a + c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (Â· + Â·) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c) : a + b < a + c := by induction a using WithTop.recTopCoe; sorry",
  "name": "add_lt_add_left",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (Â· + Â·) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c) : a + b < a + c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (Â· + Â·) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c)"},
 {"type": "b + a < c + a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c) : b + a < c + a := by induction a using WithTop.recTopCoe; sorry",
  "name": "add_lt_add_right",
  "kind": "theorem",
  "first-tactic": "induction a using WithTop.recTopCoe",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c) : b + a < c + a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}  [LT Î±]  [CovariantClass Î± Î± (swap (Â· + Â·)) (Â· < Â·)]  (ha : a â‰  âŠ¤)      (h : b < c)"},
 {"type": "a + âŠ¥ = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}   [Add Î±]  {a b c d : WithBot Î±}  {x y : Î±}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot Î±) : a + âŠ¥ = âŠ¥ := by cases a; sorry",
  "name": "add_bot",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}   [Add Î±]  {a b c d : WithBot Î±}  {x y : Î±}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot Î±) : a + âŠ¥ = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [Add Î±]  {a b c d : WithTop Î±}  {x y : Î±}   [Add Î±]  {a b c d : WithBot Î±}  {x y : Î±}  -- `norm_cast` proves those lemmas, because `with_top`/`with_bot` are reducible  (a : WithBot Î±)"},
 {"type": "(0 : Î±) â‰¤ 2",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 2 := by rw [â† one_add_one_eq_two]; sorry",
  "name": "zero_le_two",
  "kind": "lemma",
  "first-tactic": "rw [â† one_add_one_eq_two]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 2",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)]"},
 {"type": "(0 : Î±) â‰¤ 3",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 3 := by rw [â† two_add_one_eq_three]; sorry",
  "name": "zero_le_three",
  "kind": "lemma",
  "first-tactic": "rw [â† two_add_one_eq_three]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 3",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)]"},
 {"type": "(0 : Î±) â‰¤ 4",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 4 := by rw [â† three_add_one_eq_four]; sorry",
  "name": "zero_le_four",
  "kind": "lemma",
  "first-tactic": "rw [â† three_add_one_eq_four]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) â‰¤ 4",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±] [Preorder Î±]  [ZeroLEOneClass Î±]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)]"},
 {"type": "(0 : Î±) < 3",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) < 3 := by rw [â† two_add_one_eq_three]; sorry",
  "name": "zero_lt_three",
  "kind": "lemma",
  "first-tactic": "rw [â† two_add_one_eq_three]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) < 3",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)]"},
 {"type": "(0 : Î±) < 4",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) < 4 := by rw [â† three_add_one_eq_four]; sorry",
  "name": "zero_lt_four",
  "kind": "lemma",
  "first-tactic": "rw [â† three_add_one_eq_four]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)] : (0 : Î±) < 4",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)]  [CovariantClass Î± Î± (Â·+Â·) (Â·â‰¤Â·)]"},
 {"type": "(1 : Î±) < 2",
  "tactic-prompt":
  "lemma {Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)] [CovariantClass Î± Î± (Â·+Â·) (Â·<Â·)] : (1 : Î±) < 2 := by rw [â† one_add_one_eq_two]; sorry",
  "name": "one_lt_two",
  "kind": "lemma",
  "first-tactic": "rw [â† one_add_one_eq_two]",
  "core-prompt":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)] [CovariantClass Î± Î± (Â·+Â·) (Â·<Â·)] : (1 : Î±) < 2",
  "args":
  "{Î± : Type _} [AddMonoidWithOne Î±]  [PartialOrder Î±]  [ZeroLEOneClass Î±]  [NeZero (1 : Î±)] [CovariantClass Î± Î± (Â·+Â·) (Â·<Â·)]"},
 {"type": "CovariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· â‰¤ Â·)",
  "tactic-prompt":
  "instance {Î± : Type u} [Mul Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] : CovariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· â‰¤ Â·) := by refine âŸ¨fun a b c hbc => ?_âŸ©; sorry",
  "name": "covariantClass_mul_le",
  "kind": "instance",
  "first-tactic": "refine âŸ¨fun a b c hbc => ?_âŸ©",
  "core-prompt":
  "{Î± : Type u} [Mul Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] : CovariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· â‰¤ Â·)",
  "args":
  "{Î± : Type u} [Mul Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]"},
 {"type": "CovariantClass (WithZero Î±) (WithZero Î±) (Â· + Â·) (Â· â‰¤ Â·)",
  "tactic-prompt":
  "theorem {Î± : Type u} [AddZeroClass Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (h : âˆ€ a : Î±, 0 â‰¤ a) : CovariantClass (WithZero Î±) (WithZero Î±) (Â· + Â·) (Â· â‰¤ Â·) := by refine âŸ¨fun a b c hbc => ?_âŸ©; sorry",
  "name": "covariantClass_add_le",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun a b c hbc => ?_âŸ©",
  "core-prompt":
  "{Î± : Type u} [AddZeroClass Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (h : âˆ€ a : Î±, 0 â‰¤ a) : CovariantClass (WithZero Î±) (WithZero Î±) (Â· + Â·) (Â· â‰¤ Â·)",
  "args":
  "{Î± : Type u} [AddZeroClass Î±]  [Preorder Î±]      [CovariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (h : âˆ€ a : Î±, 0 â‰¤ a)"},
 {"type": "ContravariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· < Â·)",
  "tactic-prompt":
  "instance {Î± : Type u} [Mul Î±]  [PartialOrder Î±]      [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)] : ContravariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· < Â·) := by refine âŸ¨fun a b c h => ?_âŸ©; sorry",
  "name": "contravariantClass_mul_lt",
  "kind": "instance",
  "first-tactic": "refine âŸ¨fun a b c h => ?_âŸ©",
  "core-prompt":
  "{Î± : Type u} [Mul Î±]  [PartialOrder Î±]      [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)] : ContravariantClass (WithZero Î±) (WithZero Î±) (Â· * Â·) (Â· < Â·)",
  "args":
  "{Î± : Type u} [Mul Î±]  [PartialOrder Î±]      [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)]"},
 {"type": "âˆƒ c, 1 < c âˆ§ a * c = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [MulOneClass Î±]  [Preorder Î±]  [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [ExistsMulOfLE Î±]    {a b : Î±} (h : a < b) : âˆƒ c, 1 < c âˆ§ a * c = b := by obtain âŸ¨c, rflâŸ© := exists_mul_of_le h.le; sorry",
  "name": "exists_one_lt_mul_of_lt'",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨c, rflâŸ© := exists_mul_of_le h.le",
  "core-prompt":
  "{Î± : Type u}  [MulOneClass Î±]  [Preorder Î±]  [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [ExistsMulOfLE Î±]    {a b : Î±} (h : a < b) : âˆƒ c, 1 < c âˆ§ a * c = b",
  "args":
  "{Î± : Type u}  [MulOneClass Î±]  [Preorder Î±]  [ContravariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [ExistsMulOfLE Î±]    {a b : Î±} (h : a < b)"},
 {"type": "a â‰¤ b * a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : a â‰¤ b * a := by rw [mul_comm]; sorry",
  "name": "le_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : a â‰¤ b * a",
  "args": "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±}"},
 {"type": "a â‰¤ b â†” âˆƒ c, b = c * a",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : a â‰¤ b â†” âˆƒ c, b = c * a := by simp only [mul_comm _ a]; sorry",
  "name": "le_iff_exists_mul'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_comm _ a]",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : a â‰¤ b â†” âˆƒ c, b = c * a",
  "args": "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±}"},
 {"type": "1 < a * b â†” 1 < a âˆ¨ 1 < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : 1 < a * b â†” 1 < a âˆ¨ 1 < b := by simp only [one_lt_iff_ne_one]; sorry",
  "name": "one_lt_mul_iff",
  "kind": "theorem",
  "first-tactic": "simp only [one_lt_iff_ne_one]",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} : 1 < a * b â†” 1 < a âˆ¨ 1 < b",
  "args": "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±}"},
 {"type": "âˆƒ (c : _) (_ : 1 < c), a * c = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} (h : a < b) : âˆƒ (c : _) (_ : 1 < c), a * c = b := by obtain âŸ¨c, hcâŸ© := le_iff_exists_mul.1 h.le; sorry",
  "name": "exists_one_lt_mul_of_lt",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨c, hcâŸ© := le_iff_exists_mul.1 h.le",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} (h : a < b) : âˆƒ (c : _) (_ : 1 < c), a * c = b",
  "args":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} (h : a < b)"},
 {"type": "a < b â†” âˆƒ c > 1, b = a * c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)] : a < b â†” âˆƒ c > 1, b = a * c := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_exists_mul",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)] : a < b â†” âˆƒ c > 1, b = a * c",
  "args":
  "{Î± : Type u}  [CanonicallyOrderedMonoid Î±]  {a b c d : Î±} [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]"},
 {"type": "min a (b * c) = min a (min a b * min a c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±) : min a (b * c) = min a (min a b * min a c) := by cases' le_total a b with hb hb; sorry",
  "name": "min_mul_distrib",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hb hb",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±) : min a (b * c) = min a (min a b * min a c)",
  "args":
  "{Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±)"},
 {"type": "min (a * b) c = min (min a c * min b c) c",
  "tactic-prompt":
  "theorem {Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±) : min (a * b) c = min (min a c * min b c) c := by simpa [min_comm _ c] using min_mul_distrib c a b; sorry",
  "name": "min_mul_distrib'",
  "kind": "theorem",
  "first-tactic": "simpa [min_comm _ c] using min_mul_distrib c a b",
  "core-prompt":
  "{Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±) : min (a * b) c = min (min a c * min b c) c",
  "args":
  "{Î± : Type u}  [CanonicallyLinearOrderedMonoid Î±]  -- see Note [lower instance priority] (a b c : Î±)"},
 {"type": "f (min n m) * f (max n m) = f n * f m",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  [CommSemigroup Î²]  (f : Î± â†’ Î²)  (n m : Î±) : f (min n m) * f (max n m) = f n * f m := by cases' le_total n m with h h; sorry",
  "name": "fn_min_mul_fn_max",
  "kind": "theorem",
  "first-tactic": "cases' le_total n m with h h",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  [CommSemigroup Î²]  (f : Î± â†’ Î²)  (n m : Î±) : f (min n m) * f (max n m) = f n * f m",
  "args":
  "{Î± Î² : Type _} [LinearOrder Î±]  [CommSemigroup Î²]  (f : Î± â†’ Î²)  (n m : Î±)"},
 {"type": "m < a âˆ¨ n < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b m n : Î±}      (h : m * n < a * b) : m < a âˆ¨ n < b := by contrapose! h; sorry",
  "name": "lt_or_lt_of_mul_lt_mul",
  "kind": "theorem",
  "first-tactic": "contrapose! h",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b m n : Î±}      (h : m * n < a * b) : m < a âˆ¨ n < b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b m n : Î±}      (h : m * n < a * b)"},
 {"type": "a * b < c * d â†” a < c âˆ¨ b < d",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· < Â·)]      [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]      {a b c d : Î±}  (ac : a â‰¤ c)  (bd : b â‰¤ d) : a * b < c * d â†” a < c âˆ¨ b < d := by refine' âŸ¨lt_or_lt_of_mul_lt_mul, fun h => _âŸ©; sorry",
  "name": "mul_lt_mul_iff_of_le_of_le",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨lt_or_lt_of_mul_lt_mul, fun h => _âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· < Â·)]      [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]      {a b c d : Î±}  (ac : a â‰¤ c)  (bd : b â‰¤ d) : a * b < c * d â†” a < c âˆ¨ b < d",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Mul Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)] [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· < Â·)]      [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  [CovariantClass Î± Î± (Function.swap (Â· * Â·)) (Â· â‰¤ Â·)]      {a b c d : Î±}  (ac : a â‰¤ c)  (bd : b â‰¤ d)"},
 {"type": "min a b â‰¤ max c d",
  "tactic-prompt":
  "lemma {Î± Î² : Type _}  [Mul Î±]  [LinearOrder Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)] (h : a * b â‰¤ c * d) : min a b â‰¤ max c d := by simp_rw [min_le_iff]; sorry",
  "name": "min_le_max_of_mul_le_mul",
  "kind": "lemma",
  "first-tactic": "simp_rw [min_le_iff]",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±]  [LinearOrder Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)] (h : a * b â‰¤ c * d) : min a b â‰¤ max c d",
  "args":
  "{Î± Î² : Type _}  [Mul Î±]  [LinearOrder Î±]  {a b c d : Î±}  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)] (h : a * b â‰¤ c * d)"},
 {"type": "aâ‚‚ * bâ‚‚ â‰¤ aâ‚ * bâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚",
  "tactic-prompt":
  "lemma {Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [PartialOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±}  (ha : aâ‚ â‰¤ aâ‚‚)  (hb : bâ‚ â‰¤ bâ‚‚) : aâ‚‚ * bâ‚‚ â‰¤ aâ‚ * bâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚ := by refine' âŸ¨fun h â†¦ _, by rintro âŸ¨rfl, rflâŸ©; rflâŸ©; sorry",
  "name": "mul_le_mul_iff_of_ge",
  "kind": "lemma",
  "first-tactic": "refine' âŸ¨fun h â†¦ _, by rintro âŸ¨rfl, rflâŸ©; rflâŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [PartialOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±}  (ha : aâ‚ â‰¤ aâ‚‚)  (hb : bâ‚ â‰¤ bâ‚‚) : aâ‚‚ * bâ‚‚ â‰¤ aâ‚ * bâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚",
  "args":
  "{Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [PartialOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]    [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±}  (ha : aâ‚ â‰¤ aâ‚‚)  (hb : bâ‚ â‰¤ bâ‚‚)"},
 {"type": "âˆƒ b : Î±, b * b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  (a : Î±) : âˆƒ b : Î±, b * b â‰¤ a := by by_cases h:a < 1; sorry",
  "name": "exists_square_le",
  "kind": "theorem",
  "first-tactic": "by_cases h:a < 1",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  (a : Î±) : âˆƒ b : Î±, b * b â‰¤ a",
  "args":
  "{Î± Î² : Type _}  [Mul Î±]  [MulOneClass Î±]  [LinearOrder Î±] [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  (a : Î±)"},
 {"type": "a * b = c * d â†” a = c âˆ§ b = d",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]      [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d := by refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©; sorry",
  "name": "Left.mul_eq_mul_iff_eq_and_eq",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]      [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d",
  "args":
  "{Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]      [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d)"},
 {"type": "a * b = c * d â†” a = c âˆ§ b = d",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d := by refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©; sorry",
  "name": "Right.mul_eq_mul_iff_eq_and_eq",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => congr_argâ‚‚ (Â· * Â·) h.1 h.2âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d) : a * b = c * d â†” a = c âˆ§ b = d",
  "args":
  "{Î± Î² : Type _}  [Mul Î±]  [Semigroup Î±]  [PartialOrder Î±]  /- This is not instance, since we want to have an instance from `LeftCancelSemigroup`s to the appropriate `CovariantClass`. -/ [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      [ContravariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]      [ContravariantClass Î± Î± (swap (Â· * Â·)) (Â· â‰¤ Â·)]  {a b c d : Î±}  (hac : a â‰¤ c)  (hbd : b â‰¤ d)"},
 {"type": "b * a â‰¤ c * a â†” b â‰¤ c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommSemigroup Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b c : Î±}  (ha : MulLECancellable a) : b * a â‰¤ c * a â†” b â‰¤ c := by rw [mul_comm b]; sorry",
  "name": "mul_le_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm b]",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommSemigroup Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b c : Î±}  (ha : MulLECancellable a) : b * a â‰¤ c * a â†” b â‰¤ c",
  "args":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommSemigroup Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b c : Î±}  (ha : MulLECancellable a)"},
 {"type": "a â‰¤ b * a â†” 1 â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a) : a â‰¤ b * a â†” 1 â‰¤ b := by rw [mul_comm]; sorry",
  "name": "le_mul_iff_one_le_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a) : a â‰¤ b * a â†” 1 â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a)"},
 {"type": "b * a â‰¤ a â†” b â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a) : b * a â‰¤ a â†” b â‰¤ 1 := by rw [mul_comm]; sorry",
  "name": "mul_le_iff_le_one_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a) : b * a â‰¤ a â†” b â‰¤ 1",
  "args":
  "{Î± Î² : Type _}  [Mul Î±] [LE Î±] [CommMonoid Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· â‰¤ Â·)]      {a b : Î±}  (ha : MulLECancellable a)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (m k : R) : m % k + m / k * k = m := by rw [mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R] (m k : R) : m % k + m / k * k = m",
  "args": "{R : Type u}  [EuclideanDomain R] (m k : R)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (m k : R) : m / k * k + m % k = m := by rw [mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R] (m k : R) : m / k * k + m % k = m",
  "args": "{R : Type u}  [EuclideanDomain R] (m k : R)"},
 {"type": "a % 0 = a",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R] (a : R) : a % 0 = a := by simpa only [zero_mul]; sorry",
  "name": "mod_zero",
  "kind": "theorem",
  "first-tactic": "simpa only [zero_mul]",
  "core-prompt": "{R : Type u}  [EuclideanDomain R] (a : R) : a % 0 = a",
  "args": "{R : Type u}  [EuclideanDomain R] (a : R)"},
 {"type": "gcd 0 a = a",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd 0 a = a := by rw [gcd]; sorry",
  "name": "gcd_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd 0 a = a",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] (a : R)"},
 {"type": "xgcdAux 0 s t r' s' t' = (r', s', t')",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t') := by unfold xgcdAux; sorry",
  "name": "xgcd_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold xgcdAux",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t')",
  "args":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s t r' s' t' : R}"},
 {"type":
  "xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r â‰  0) : xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t := by conv =>\n    lhs\n    rw [xgcdAux]; sorry",
  "name": "xgcdAux_rec",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [xgcdAux]",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r â‰  0) : xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t",
  "args":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {r s t r' s' t' : R}  (h : r â‰  0)"},
 {"type": "gcdA 0 s = 0",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdA 0 s = 0 := by unfold gcdA; sorry",
  "name": "gcdA_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdA",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdA 0 s = 0",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R}"},
 {"type": "gcdB 0 s = 1",
  "tactic-prompt":
  "theorem {R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdB 0 s = 1 := by unfold gcdB; sorry",
  "name": "gcdB_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdB",
  "core-prompt":
  "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R} : gcdB 0 s = 1",
  "args": "{R : Type u}  [EuclideanDomain R]  [DecidableEq R] {s : R}"},
 {"type": "c âˆ£ a % b â†” c âˆ£ a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (h : c âˆ£ b) : c âˆ£ a % b â†” c âˆ£ a := by rw [dvd_add_iff_right (h.mul_right _)]; sorry",
  "name": "dvd_mod_iff",
  "kind": "theorem",
  "first-tactic": "rw [dvd_add_iff_right (h.mul_right _)]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : c âˆ£ b) : c âˆ£ a % b â†” c âˆ£ a",
  "args": "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : c âˆ£ b)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a : R}  (a0 : a â‰  0) : a / a = 1 := by simpa only [one_mul] using mul_div_cancel 1 a0; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "simpa only [one_mul] using mul_div_cancel 1 a0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a : R}  (a0 : a â‰  0) : a / a = 1",
  "args": "{R : Type u} [EuclideanDomain R] {a : R}  (a0 : a â‰  0)"},
 {"type": "a = c / b",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b â‰  0)  (h : a * b = c) : a = c / b := by rw [â† h]; sorry",
  "name": "eq_div_of_mul_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b â‰  0)  (h : a * b = c) : a = c / b",
  "args":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (hb : b â‰  0)  (h : a * b = c)"},
 {"type": "b = c / a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a â‰  0)  (h : a * b = c) : b = c / a := by rw [â† h]; sorry",
  "name": "eq_div_of_mul_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a â‰  0)  (h : a * b = c) : b = c / a",
  "args":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (ha : a â‰  0)  (h : a * b = c)"},
 {"type": "x * y / z = x * (y / z)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z âˆ£ y) : x * y / z = x * (y / z) := by by_cases hz : z = 0; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "by_cases hz : z = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z âˆ£ y) : x * y / z = x * (y / z)",
  "args": "{R : Type u} [EuclideanDomain R] (x : R)  {y z : R}  (h : z âˆ£ y)"},
 {"type": "p / q âˆ£ p",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q âˆ£ p) : p / q âˆ£ p := by by_cases hq : q = 0; sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases hq : q = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q âˆ£ p) : p / q âˆ£ p",
  "args": "{R : Type u} [EuclideanDomain R] {p q : R}  (hpq : q âˆ£ p)"},
 {"type": "b âˆ£ c / a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b âˆ£ c) : b âˆ£ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b âˆ£ c) : b âˆ£ c / a",
  "args": "{R : Type u} [EuclideanDomain R] {a b c : R}  (h : a * b âˆ£ c)"},
 {"type": "gcd a 0 = a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd a 0 = a := by rw [gcd]; sorry",
  "name": "gcd_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R) : gcd a 0 = a",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a : R)"},
 {"type": "gcd a b = gcd (b % a) a",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : gcd a b = gcd (b % a) a := by rw [gcd]; sorry",
  "name": "gcd_val",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : gcd a b = gcd (b % a) a",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R)"},
 {"type": "xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) := by rw [xgcd]; sorry",
  "name": "xgcdAux_val",
  "kind": "theorem",
  "first-tactic": "rw [xgcd]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R)"},
 {"type": "(gcd a b : R) = a * gcdA a b + b * gcdB a b",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b := by have :=\n    @xgcdAux_P _ _ _ a b a b 1 0 0 1 (by dsimp [P]; rw [mul_one]; sorry",
  "name": "gcd_eq_gcd_ab",
  "kind": "theorem",
  "first-tactic":
  "have :=\n    @xgcdAux_P _ _ _ a b a b 1 0 0 1 (by dsimp [P]; rw [mul_one]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (a b : R)"},
 {"type": "lcm x y âˆ£ z",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x âˆ£ z)  (hyz : y âˆ£ z) : lcm x y âˆ£ z := by rw [lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x âˆ£ z)  (hyz : y âˆ£ z) : lcm x y âˆ£ z",
  "args":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y z : R}  (hxz : x âˆ£ z)  (hyz : y âˆ£ z)"},
 {"type": "lcm 0 x = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm 0 x = 0 := by rw [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm 0 x = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R)"},
 {"type": "lcm x 0 = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm x 0 = 0 := by rw [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R) : lcm x 0 = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x : R)"},
 {"type": "lcm x y = 0 â†” x = 0 âˆ¨ y = 0",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R} : lcm x y = 0 â†” x = 0 âˆ¨ y = 0 := by constructor; sorry",
  "name": "lcm_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R} : lcm x y = 0 â†” x = 0 âˆ¨ y = 0",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] {x y : R}"},
 {"type": "gcd x y * lcm x y = x * y",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : gcd x y * lcm x y = x * y := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R) : gcd x y * lcm x y = x * y",
  "args": "{R : Type u} [EuclideanDomain R]  [DecidableEq R] (x y : R)"},
 {"type": "a * b / (a * c) = b / c",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a â‰  0)  (hcb : c âˆ£ b) : a * b / (a * c) = b / c := by by_cases hc : c = 0; sorry",
  "name": "mul_div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "by_cases hc : c = 0",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a â‰  0)  (hcb : c âˆ£ b) : a * b / (a * c) = b / c",
  "args":
  "{R : Type u} [EuclideanDomain R]  {a b c : R}  (ha : a â‰  0)  (hcb : c âˆ£ b)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c âˆ£ a)  (hbd : d âˆ£ b) : a * b / (c * d) = a / c * (b / d) := by rcases eq_or_ne c 0 with (rfl | hc0); sorry",
  "name": "mul_div_mul_comm_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne c 0 with (rfl | hc0)",
  "core-prompt":
  "{R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c âˆ£ a)  (hbd : d âˆ£ b) : a * b / (c * d) = a / c * (b / d)",
  "args":
  "{R : Type u} [EuclideanDomain R]  {a b c d : R}  (hac : c âˆ£ a)  (hbd : d âˆ£ b)"},
 {"type": "c.symm.symm = c",
  "tactic-prompt":
  "theorem {Î¹ : Type _} (c : ComplexShape Î¹) : c.symm.symm = c := by ext; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": "{Î¹ : Type _} (c : ComplexShape Î¹) : c.symm.symm = c",
  "args": "{Î¹ : Type _} (c : ComplexShape Î¹)"},
 {"type": "Subsingleton { j // c.Rel i j }",
  "tactic-prompt":
  "instance {Î¹ : Type _} (c : ComplexShape Î¹)  (i : Î¹) : Subsingleton { j // c.Rel i j } := by constructor; sorry",
  "name": "subsingleton_next",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _} (c : ComplexShape Î¹)  (i : Î¹) : Subsingleton { j // c.Rel i j }",
  "args": "{Î¹ : Type _} (c : ComplexShape Î¹)  (i : Î¹)"},
 {"type": "Subsingleton { i // c.Rel i j }",
  "tactic-prompt":
  "instance {Î¹ : Type _} (c : ComplexShape Î¹)  (j : Î¹) : Subsingleton { i // c.Rel i j } := by constructor; sorry",
  "name": "subsingleton_prev",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _} (c : ComplexShape Î¹)  (j : Î¹) : Subsingleton { i // c.Rel i j }",
  "args": "{Î¹ : Type _} (c : ComplexShape Î¹)  (j : Î¹)"},
 {"type": "c.next i = j",
  "tactic-prompt":
  "theorem {Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j) : c.next i = j := by apply c.next_eq _ h; sorry",
  "name": "next_eq'",
  "kind": "theorem",
  "first-tactic": "apply c.next_eq _ h",
  "core-prompt":
  "{Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j) : c.next i = j",
  "args": "{Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j)"},
 {"type": "c.prev j = i",
  "tactic-prompt":
  "theorem {Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j) : c.prev j = i := by apply c.prev_eq _ h; sorry",
  "name": "prev_eq'",
  "kind": "theorem",
  "first-tactic": "apply c.prev_eq _ h",
  "core-prompt":
  "{Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j) : c.prev j = i",
  "args": "{Î¹ : Type _} (c : ComplexShape Î¹)  {i j : Î¹}  (h : c.Rel i j)"},
 {"type": "IsSquare m â†’ IsSquare (f m)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [MulOneClass Î±]  [MulOneClass Î²]  [MonoidHomClass F Î± Î²]  {m : Î±}  (f : F) : IsSquare m â†’ IsSquare (f m) := by rintro âŸ¨m, rflâŸ©; sorry",
  "name": "IsSquare.map",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨m, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _} [MulOneClass Î±]  [MulOneClass Î²]  [MonoidHomClass F Î± Î²]  {m : Î±}  (f : F) : IsSquare m â†’ IsSquare (f m)",
  "args":
  "{F Î± Î² R : Type _} [MulOneClass Î±]  [MulOneClass Î²]  [MonoidHomClass F Î± Î²]  {m : Î±}  (f : F)"},
 {"type": "IsSquare m â†” âˆƒ c, m = c ^ 2",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (m : Î±) : IsSquare m â†” âˆƒ c, m = c ^ 2 := by simp [IsSquare]; sorry",
  "name": "isSquare_iff_exists_sq",
  "kind": "theorem",
  "first-tactic": "simp [IsSquare]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (m : Î±) : IsSquare m â†” âˆƒ c, m = c ^ 2",
  "args": "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (m : Î±)"},
 {"type": "IsSquare a â†’ IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (n : â„•) : IsSquare a â†’ IsSquare (a ^ n) := by rintro âŸ¨a, rflâŸ©; sorry",
  "name": "IsSquare.pow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (n : â„•) : IsSquare a â†’ IsSquare (a ^ n)",
  "args": "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} (n : â„•)"},
 {"type": "Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} : Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n) := by rintro âŸ¨n, rflâŸ© a; sorry",
  "name": "Even.isSquare_pow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨n, rflâŸ© a",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} : Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n)",
  "args": "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±}"},
 {"type": "Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±] : Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n := by rintro âŸ¨c, rflâŸ© a; sorry",
  "name": "Even.neg_pow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨c, rflâŸ© a",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±] : Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n",
  "args": "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±]"},
 {"type": "(-1 : Î±) ^ n = 1",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±] (h : Even n) : (-1 : Î±) ^ n = 1 := by rw [h.neg_pow]; sorry",
  "name": "Even.neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_pow]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±] (h : Even n) : (-1 : Î±) ^ n = 1",
  "args":
  "{F Î± Î² R : Type _}  [Monoid Î±]  {n : â„•}  {a : Î±} [HasDistribNeg Î±] (h : Even n)"},
 {"type": "IsSquare a â†’ IsSquare b â†’ IsSquare (a * b)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [CommSemigroup Î±]  {a b : Î±} : IsSquare a â†’ IsSquare b â†’ IsSquare (a * b) := by rintro âŸ¨a, rflâŸ© âŸ¨b, rflâŸ©; sorry",
  "name": "IsSquare.mul",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, rflâŸ© âŸ¨b, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _} [CommSemigroup Î±]  {a b : Î±} : IsSquare a â†’ IsSquare b â†’ IsSquare (a * b)",
  "args": "{F Î± Î² R : Type _} [CommSemigroup Î±]  {a b : Î±}"},
 {"type": "IsSquare aâ»Â¹ â†” IsSquare a",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} : IsSquare aâ»Â¹ â†” IsSquare a := by refine' âŸ¨fun h => _, fun h => _âŸ©; sorry",
  "name": "isSquare_inv",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => _âŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} : IsSquare aâ»Â¹ â†” IsSquare a",
  "args": "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±}"},
 {"type": "IsSquare a â†’ IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} (n : â„¤) : IsSquare a â†’ IsSquare (a ^ n) := by rintro âŸ¨a, rflâŸ©; sorry",
  "name": "IsSquare.zpow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} (n : â„¤) : IsSquare a â†’ IsSquare (a ^ n)",
  "args": "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} (n : â„¤)"},
 {"type": "Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤} : Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n := by rintro âŸ¨c, rflâŸ© a; sorry",
  "name": "Even.neg_zpow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨c, rflâŸ© a",
  "core-prompt":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤} : Even n â†’ âˆ€ a : Î±, (-a) ^ n = a ^ n",
  "args":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤}"},
 {"type": "(-1 : Î±) ^ n = 1",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤} (h : Even n) : (-1 : Î±) ^ n = 1 := by rw [h.neg_zpow]; sorry",
  "name": "Even.neg_one_zpow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_zpow]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤} (h : Even n) : (-1 : Î±) ^ n = 1",
  "args":
  "{F Î± Î² R : Type _}  [DivisionMonoid Î±]  {a : Î±} [HasDistribNeg Î±]  {n : â„¤} (h : Even n)"},
 {"type": "Even (|a|) â†” Even a",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [SubtractionMonoid Î±]  [LinearOrder Î±]  {a : Î±} : Even (|a|) â†” Even a := by cases abs_choice a; sorry",
  "name": "even_abs",
  "kind": "theorem",
  "first-tactic": "cases abs_choice a",
  "core-prompt":
  "{F Î± Î² R : Type _} [SubtractionMonoid Î±]  [LinearOrder Î±]  {a : Î±} : Even (|a|) â†” Even a",
  "args": "{F Î± Î² R : Type _} [SubtractionMonoid Î±]  [LinearOrder Î±]  {a : Î±}"},
 {"type": "IsSquare (a / b)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [DivisionCommMonoid Î±]  {a b : Î±}  (ha : IsSquare a)  (hb : IsSquare b) : IsSquare (a / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "IsSquare.div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{F Î± Î² R : Type _} [DivisionCommMonoid Î±]  {a b : Î±}  (ha : IsSquare a)  (hb : IsSquare b) : IsSquare (a / b)",
  "args":
  "{F Î± Î² R : Type _} [DivisionCommMonoid Î±]  {a b : Î±}  (ha : IsSquare a)  (hb : IsSquare b)"},
 {"type": "Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [Group Î±]  {n : â„¤} : Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n) := by rintro âŸ¨n, rflâŸ© a; sorry",
  "name": "Even.isSquare_zpow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨n, rflâŸ© a",
  "core-prompt":
  "{F Î± Î² R : Type _} [Group Î±]  {n : â„¤} : Even n â†’ âˆ€ a : Î±, IsSquare (a ^ n)",
  "args": "{F Î± Î² R : Type _} [Group Î±]  {n : â„¤}"},
 {"type": "Even (m - n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _} [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {m n : Î±}  (hm : Even m)  (hn : Even n) : Even (m - n) := by obtain âŸ¨a, rflâŸ© := hm; sorry",
  "name": "Even.tsub",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨a, rflâŸ© := hm",
  "core-prompt":
  "{F Î± Î² R : Type _} [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {m n : Î±}  (hm : Even m)  (hn : Even n) : Even (m - n)",
  "args":
  "{F Î± Î² R : Type _} [CanonicallyLinearOrderedAddMonoid Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  {m n : Î±}  (hm : Even m)  (hn : Even n)"},
 {"type": "Even m â†” âˆƒ c, m = 2 * c",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (m : Î±) : Even m â†” âˆƒ c, m = 2 * c := by simp [even_iff_exists_two_nsmul]; sorry",
  "name": "even_iff_exists_two_mul",
  "kind": "theorem",
  "first-tactic": "simp [even_iff_exists_two_nsmul]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (m : Î±) : Even m â†” âˆƒ c, m = 2 * c",
  "args": "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (m : Î±)"},
 {"type": "Even a â†” 2 âˆ£ a",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} {a : Î±} : Even a â†” 2 âˆ£ a := by simp [Even]; sorry",
  "name": "even_iff_two_dvd",
  "kind": "theorem",
  "first-tactic": "simp [Even]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} {a : Î±} : Even a â†” 2 âˆ£ a",
  "args": "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} {a : Î±}"},
 {"type": "(Set.range fun x : Î± => 2 * x) = { a | Even a }",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (Î± : Type _)  [Semiring Î±] : (Set.range fun x : Î± => 2 * x) = { a | Even a } := by ext x; sorry",
  "name": "range_two_mul",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (Î± : Type _)  [Semiring Î±] : (Set.range fun x : Î± => 2 * x) = { a | Even a }",
  "args":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} (Î± : Type _)  [Semiring Î±]"},
 {"type": "(Set.range fun x : Î± => 2 * x + 1) = { a | Odd a }",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (Î± : Type _)  [Semiring Î±] : (Set.range fun x : Î± => 2 * x + 1) = { a | Odd a } := by ext x; sorry",
  "name": "range_two_mul_add_one",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (Î± : Type _)  [Semiring Î±] : (Set.range fun x : Î± => 2 * x + 1) = { a | Odd a }",
  "args":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (Î± : Type _)  [Semiring Î±]"},
 {"type": "Even m â†’ Odd n â†’ Odd (m + n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Even m â†’ Odd n â†’ Odd (m + n) := by rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©; sorry",
  "name": "Even.add_odd",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Even m â†’ Odd n â†’ Odd (m + n)",
  "args": "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}"},
 {"type": "Odd (m + n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (hm : Odd m)  (hn : Even n) : Odd (m + n) := by rw [add_comm]; sorry",
  "name": "Odd.add_even",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (hm : Odd m)  (hn : Even n) : Odd (m + n)",
  "args":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  (hm : Odd m)  (hn : Even n)"},
 {"type": "Odd m â†’ Odd n â†’ Even (m + n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Odd m â†’ Odd n â†’ Even (m + n) := by rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©; sorry",
  "name": "Odd.add_odd",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Odd m â†’ Odd n â†’ Even (m + n)",
  "args": "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}"},
 {"type": "Odd m â†’ Odd (f m)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  [RingHomClass F Î± Î²]  (f : F) : Odd m â†’ Odd (f m) := by rintro âŸ¨m, rflâŸ©; sorry",
  "name": "Odd.map",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨m, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  [RingHomClass F Î± Î²]  (f : F) : Odd m â†’ Odd (f m)",
  "args":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}  [RingHomClass F Î± Î²]  (f : F)"},
 {"type": "Odd m â†’ Odd n â†’ Odd (m * n)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Odd m â†’ Odd n â†’ Odd (m * n) := by rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©; sorry",
  "name": "Odd.mul",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨m, rflâŸ© âŸ¨n, rflâŸ©",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±} : Odd m â†’ Odd n â†’ Odd (m * n)",
  "args": "{F Î± Î² R : Type _}  [Semiring Î±]  [Semiring Î²]  {m n : Î±}"},
 {"type": "Odd n â†’ âˆ€ a : Î±, (-a) ^ n = -a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•} : Odd n â†’ âˆ€ a : Î±, (-a) ^ n = -a ^ n := by rintro âŸ¨c, rflâŸ© a; sorry",
  "name": "Odd.neg_pow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨c, rflâŸ© a",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•} : Odd n â†’ âˆ€ a : Î±, (-a) ^ n = -a ^ n",
  "args":
  "{F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•}"},
 {"type": "(-1 : Î±) ^ n = -1",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•} (h : Odd n) : (-1 : Î±) ^ n = -1 := by rw [h.neg_pow]; sorry",
  "name": "Odd.neg_one_pow",
  "kind": "theorem",
  "first-tactic": "rw [h.neg_pow]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•} (h : Odd n) : (-1 : Î±) ^ n = -1",
  "args":
  "{F Î± Î² R : Type _}  [Monoid Î±]  [HasDistribNeg Î±]  {a : Î±}  {n : â„•} (h : Odd n)"},
 {"type": "0 < n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [CanonicallyOrderedCommSemiring Î±]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 â€¢ t` or `t + t` instead of `2 * t`. [Nontrivial Î±]  {n : Î±}  (hn : Odd n) : 0 < n := by obtain âŸ¨k, rflâŸ© := hn; sorry",
  "name": "Odd.pos",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨k, rflâŸ© := hn",
  "core-prompt":
  "{F Î± Î² R : Type _}  [CanonicallyOrderedCommSemiring Î±]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 â€¢ t` or `t + t` instead of `2 * t`. [Nontrivial Î±]  {n : Î±}  (hn : Odd n) : 0 < n",
  "args":
  "{F Î± Î² R : Type _}  [CanonicallyOrderedCommSemiring Î±]  -- this holds more generally in a `CanonicallyOrderedAddMonoid` if we refactor `Odd` to use -- either `2 â€¢ t` or `t + t` instead of `2 * t`. [Nontrivial Î±]  {n : Î±}  (hn : Odd n)"},
 {"type": "Even (-2 : Î±)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Even (-2 : Î±) := by simp only [even_neg]; sorry",
  "name": "even_neg_two",
  "kind": "theorem",
  "first-tactic": "simp only [even_neg]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Even (-2 : Î±)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp]"},
 {"type": "Odd (-a)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a) : Odd (-a) := by obtain âŸ¨k, hkâŸ© := hp; sorry",
  "name": "Odd.neg",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨k, hkâŸ© := hp",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a) : Odd (-a)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (hp : Odd a)"},
 {"type": "Odd (-1 : Î±)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Odd (-1 : Î±) := by simp; sorry",
  "name": "odd_neg_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] : Odd (-1 : Î±)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp]"},
 {"type": "Odd (a - b)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b) : Odd (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Odd.sub_even",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b) : Odd (a - b)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Even b)"},
 {"type": "Odd (a - b)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b) : Odd (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Even.sub_odd",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b) : Odd (a - b)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Even a)  (hb : Odd b)"},
 {"type": "Even (a - b)",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b) : Even (a - b) := by rw [sub_eq_add_neg]; sorry",
  "name": "Odd.sub_odd",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_add_neg]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b) : Even (a - b)",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] (ha : Odd a)  (hb : Odd b)"},
 {"type": "Odd (abs a) â†” Odd a",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder Î±] : Odd (abs a) â†” Odd a := by cases' abs_choice a with h h; sorry",
  "name": "odd_abs",
  "kind": "theorem",
  "first-tactic": "cases' abs_choice a with h h",
  "core-prompt":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder Î±] : Odd (abs a) â†” Odd a",
  "args":
  "{F Î± Î² R : Type _}  [Ring Î±]  {a b : Î±}  {n : â„•}  /- Porting note: attribute `simp` removed based on linter report simp can prove this:   by simp only [even_neg, even_two] -/ -- @[simp] [LinearOrder Î±]"},
 {"type": "0 â‰¤ a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (a : R) : 0 â‰¤ a ^ n := by cases' hn with k hk; sorry",
  "name": "Even.pow_nonneg",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (a : R) : 0 â‰¤ a ^ n",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (a : R)"},
 {"type": "0 < a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (ha : a â‰  0) : 0 < a ^ n := by cases' hn with k hk; sorry",
  "name": "Even.pow_pos",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (ha : a â‰  0) : 0 < a ^ n",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Even n)  (ha : a â‰  0)"},
 {"type": "a ^ n â‰¤ 0",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a â‰¤ 0) : a ^ n â‰¤ 0 := by cases' hn with k hk; sorry",
  "name": "Odd.pow_nonpos",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a â‰¤ 0) : a ^ n â‰¤ 0",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a â‰¤ 0)"},
 {"type": "a ^ n < 0",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a < 0) : a ^ n < 0 := by cases' hn with k hk; sorry",
  "name": "Odd.pow_neg",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a < 0) : a ^ n < 0",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)  (ha : a < 0)"},
 {"type": "|a| ^ p = a ^ p",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} {p : â„•}  (hp : Even p)  (a : R) : |a| ^ p = a ^ p := by rw [â† abs_pow]; sorry",
  "name": "Even.pow_abs",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_pow]",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} {p : â„•}  (hp : Even p)  (a : R) : |a| ^ p = a ^ p",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} {p : â„•}  (hp : Even p)  (a : R)"},
 {"type": "StrictMono fun a : R => a ^ n",
  "tactic-prompt":
  "theorem {F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n) : StrictMono fun a : R => a ^ n := by cases' hn with k hk; sorry",
  "name": "Odd.strictMono_pow",
  "kind": "theorem",
  "first-tactic": "cases' hn with k hk",
  "core-prompt":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n) : StrictMono fun a : R => a ^ n",
  "args":
  "{F Î± Î² R : Type _}  [LinearOrderedRing R]  {a : R}  {n : â„•} (hn : Odd n)"},
 {"type": "0 = a * b â†” a = 0 âˆ¨ b = 0",
  "tactic-prompt":
  "theorem {Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0 := by rw [eq_comm]; sorry",
  "name": "zero_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0",
  "args":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€}"},
 {"type": "a * a = 0 â†” a = 0",
  "tactic-prompt":
  "theorem {Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : a * a = 0 â†” a = 0 := by simp; sorry",
  "name": "mul_self_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : a * a = 0 â†” a = 0",
  "args":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€}"},
 {"type": "0 = a * a â†” a = 0",
  "tactic-prompt":
  "theorem {Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : 0 = a * a â†” a = 0 := by simp; sorry",
  "name": "zero_eq_mul_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€} : 0 = a * a â†” a = 0",
  "args":
  "{Gâ‚€ : Type u}  {Mâ‚€ Mâ‚€' Gâ‚€' : Type _}  -- Porting note: -- This theorem was introduced during ad-hoc porting -- and hopefully can be removed again after `Mathlib.Algebra.Ring.Basic` is fully ported. [CommMonoidWithZero Mâ‚€]  [MulZeroClass Mâ‚€] [NoZeroDivisors Mâ‚€]  {a b : Mâ‚€}"},
 {"type": "SemiconjBy a 0 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (a : Gâ‚€) : SemiconjBy a 0 0 := by simp only [SemiconjBy]; sorry",
  "name": "zero_right",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (a : Gâ‚€) : SemiconjBy a 0 0",
  "args": "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (a : Gâ‚€)"},
 {"type": "SemiconjBy 0 x y",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (x y : Gâ‚€) : SemiconjBy 0 x y := by simp only [SemiconjBy]; sorry",
  "name": "zero_left",
  "kind": "theorem",
  "first-tactic": "simp only [SemiconjBy]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (x y : Gâ‚€) : SemiconjBy 0 x y",
  "args": "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MulZeroClass Gâ‚€]  (x y : Gâ‚€)"},
 {"type": "SemiconjBy a xâ»Â¹ yâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y) : SemiconjBy a xâ»Â¹ yâ»Â¹ := by by_cases ha : a = 0; sorry",
  "name": "inv_rightâ‚€",
  "kind": "theorem",
  "first-tactic": "by_cases ha : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y) : SemiconjBy a xâ»Â¹ yâ»Â¹",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y)"},
 {"type": "SemiconjBy a (x / x') (y / y')",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x / x') (y / y') := by rw [div_eq_mul_inv]; sorry",
  "name": "div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x / x') (y / y')",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [GroupWithZero Gâ‚€]  {a x y x' y' : Gâ‚€} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "DvdNotUnit a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommMonoidWithZero Î±] {a b : Î±}  (hd : a âˆ£ b)  (hnd : Â¬b âˆ£ a) : DvdNotUnit a b := by constructor; sorry",
  "name": "dvdNotUnit_of_dvd_of_not_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _}  [CommMonoidWithZero Î±] {a b : Î±}  (hd : a âˆ£ b)  (hnd : Â¬b âˆ£ a) : DvdNotUnit a b",
  "args":
  "{Î± : Type _}  [CommMonoidWithZero Î±] {a b : Î±}  (hd : a âˆ£ b)  (hnd : Â¬b âˆ£ a)"},
 {"type": "p â‰  0",
  "tactic-prompt":
  "theorem {Î± : Type _}  [MonoidWithZero Î±] {p q : Î±}  (hâ‚ : q â‰  0)  (hâ‚‚ : p âˆ£ q) : p â‰  0 := by rcases hâ‚‚ with âŸ¨u, rflâŸ©; sorry",
  "name": "ne_zero_of_dvd_ne_zero",
  "kind": "theorem",
  "first-tactic": "rcases hâ‚‚ with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [MonoidWithZero Î±] {p q : Î±}  (hâ‚ : q â‰  0)  (hâ‚‚ : p âˆ£ q) : p â‰  0",
  "args":
  "{Î± : Type _}  [MonoidWithZero Î±] {p q : Î±}  (hâ‚ : q â‰  0)  (hâ‚‚ : p âˆ£ q)"},
 {"type": "inverse (a * b) = inverse b * inverse a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] {a b : Mâ‚€}  (h : Commute a b) : inverse (a * b) = inverse b * inverse a := by by_cases hab : IsUnit (a * b); sorry",
  "name": "mul_inverse_rev'",
  "kind": "theorem",
  "first-tactic": "by_cases hab : IsUnit (a * b)",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] {a b : Mâ‚€}  (h : Commute a b) : inverse (a * b) = inverse b * inverse a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] {a b : Mâ‚€}  (h : Commute a b)"},
 {"type": "Commute (a / b) c",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (hac : Commute a c)  (hbc : Commute b c) : Commute (a / b) c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (hac : Commute a c)  (hbc : Commute b c) : Commute (a / b) c",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (hac : Commute a c)  (hbc : Commute b c)"},
 {"type": "a = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [MulZeroOneClass Mâ‚€] (h : (0 : Mâ‚€) = 1)  (a : Mâ‚€) : a = 0 := by rw [â† mul_one a]; sorry",
  "name": "eq_zero_of_zero_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_one a]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [MulZeroOneClass Mâ‚€] (h : (0 : Mâ‚€) = 1)  (a : Mâ‚€) : a = 0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [MulZeroOneClass Mâ‚€] (h : (0 : Mâ‚€) = 1)  (a : Mâ‚€)"},
 {"type": "aâ»Â¹ = b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c g h x : Gâ‚€} (h : a * b = 1) : aâ»Â¹ = b := by rw [â† inv_mul_cancel_leftâ‚€ (left_ne_zero_of_mul_eq_one h) b]; sorry",
  "name": "inv_eq_of_mul",
  "kind": "theorem",
  "first-tactic":
  "rw [â† inv_mul_cancel_leftâ‚€ (left_ne_zero_of_mul_eq_one h) b]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c g h x : Gâ‚€} (h : a * b = 1) : aâ»Â¹ = b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c g h x : Gâ‚€} (h : a * b = 1)"},
 {"type": "0 / a = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : 0 / a = 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "zero_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : 0 / a = 0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a / 0 = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / 0 = 0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / 0 = 0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a * a * aâ»Â¹ = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * a * aâ»Â¹ = a := by by_cases h : a = 0; sorry",
  "name": "mul_self_mul_inv",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * a * aâ»Â¹ = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a * aâ»Â¹ * a = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * aâ»Â¹ * a = a := by by_cases h : a = 0; sorry",
  "name": "mul_inv_mul_self",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * aâ»Â¹ * a = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "aâ»Â¹ * a * a = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : aâ»Â¹ * a * a = a := by by_cases h : a = 0; sorry",
  "name": "inv_mul_mul_self",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : aâ»Â¹ * a * a = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a * a / a = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * a / a = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_self_div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a * a / a = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a / a * a = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / a * a = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / a * a = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "1 / a â‰  0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€}  (h : a â‰  0) : 1 / a â‰  0 := by simpa only [one_div] using inv_ne_zero h; sorry",
  "name": "one_div_ne_zero",
  "kind": "theorem",
  "first-tactic": "simpa only [one_div] using inv_ne_zero h",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€}  (h : a â‰  0) : 1 / a â‰  0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€}  (h : a â‰  0)"},
 {"type": "aâ»Â¹ = 0 â†” a = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€} : aâ»Â¹ = 0 â†” a = 0 := by rw [inv_eq_iff_inv_eq]; sorry",
  "name": "inv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_inv_eq]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€} : aâ»Â¹ = 0 â†” a = 0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} {a : Gâ‚€}"},
 {"type": "a / (a / a) = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / (a / a) = a := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_self",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : a / (a / a) = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a / c * b = a * b / c",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a b c : Gâ‚€) : a / c * b = a * b / c := by simp_rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_eq_mul_divâ‚€",
  "kind": "theorem",
  "first-tactic": "simp_rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a b c : Gâ‚€) : a / c * b = a * b / c",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _}  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a b c : Gâ‚€)"},
 {"type": "inverse (u : Mâ‚€) = (uâ»Â¹ : Mâ‚€Ë£)",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£) : inverse (u : Mâ‚€) = (uâ»Â¹ : Mâ‚€Ë£) := by simp only [Units.isUnit]; sorry",
  "name": "inverse_unit",
  "kind": "theorem",
  "first-tactic": "simp only [Units.isUnit]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£) : inverse (u : Mâ‚€) = (uâ»Â¹ : Mâ‚€Ë£)",
  "args": "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (u : Mâ‚€Ë£)"},
 {"type": "x * inverse x = 1",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x) : x * inverse x = 1 := by rcases h with âŸ¨u, rflâŸ©; sorry",
  "name": "mul_inverse_cancel",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x) : x * inverse x = 1",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x)"},
 {"type": "inverse x * x = 1",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x) : inverse x * x = 1 := by rcases h with âŸ¨u, rflâŸ©; sorry",
  "name": "inverse_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x) : inverse x * x = 1",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x : Mâ‚€)  (h : IsUnit x)"},
 {"type": "y * x * inverse x = y",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : y * x * inverse x = y := by rw [mul_assoc]; sorry",
  "name": "mul_inverse_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : y * x * inverse x = y",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x)"},
 {"type": "y * inverse x * x = y",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : y * inverse x * x = y := by rw [mul_assoc]; sorry",
  "name": "inverse_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : y * inverse x * x = y",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x)"},
 {"type": "x * (inverse x * y) = y",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : x * (inverse x * y) = y := by rw [â† mul_assoc]; sorry",
  "name": "mul_inverse_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : x * (inverse x * y) = y",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x)"},
 {"type": "inverse x * (x * y) = y",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : inverse x * (x * y) = y := by rw [â† mul_assoc]; sorry",
  "name": "inverse_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x) : inverse x * (x * y) = y",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] (x y : Mâ‚€)  (h : IsUnit x)"},
 {"type": "inverse (0 : Mâ‚€) = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] : inverse (0 : Mâ‚€) = 0 := by nontriviality; sorry",
  "name": "inverse_zero",
  "kind": "theorem",
  "first-tactic": "nontriviality",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] : inverse (0 : Mâ‚€) = 0",
  "args": "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]"},
 {"type": "(âˆƒ u : Gâ‚€Ë£, â†‘u = x) â†” x â‰  0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} {x : Gâ‚€} : (âˆƒ u : Gâ‚€Ë£, â†‘u = x) â†” x â‰  0 := by simp [exists0]; sorry",
  "name": "exists_iff_ne_zero",
  "kind": "theorem",
  "first-tactic": "simp [exists0]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} {x : Gâ‚€} : (âˆƒ u : Gâ‚€Ë£, â†‘u = x) â†” x â‰  0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} {x : Gâ‚€}"},
 {"type": "a = 0 âˆ¨ âˆƒ u : Gâ‚€Ë£, a = u",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} (a : Gâ‚€) : a = 0 âˆ¨ âˆƒ u : Gâ‚€Ë£, a = u := by by_cases h : a = 0; sorry",
  "name": "_root_.GroupWithZero.eq_zero_or_unit",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} (a : Gâ‚€) : a = 0 âˆ¨ âˆƒ u : Gâ‚€Ë£, a = u",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a / b â‰  0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (ha : a â‰  0)  (hb : b â‰  0) : a / b â‰  0 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_ne_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (ha : a â‰  0)  (hb : b â‰  0) : a / b â‰  0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "a / b = 0 â†” a = 0 âˆ¨ b = 0",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} : a / b = 0 â†” a = 0 âˆ¨ b = 0 := by simp [div_eq_mul_inv]; sorry",
  "name": "div_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} : a / b = 0 â†” a = 0 âˆ¨ b = 0",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€}"},
 {"type": "Ring.inverse a = aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : Ring.inverse a = aâ»Â¹ := by obtain rfl | ha := eq_or_ne a 0; sorry",
  "name": "Ring.inverse_eq_inv",
  "kind": "theorem",
  "first-tactic": "obtain rfl | ha := eq_or_ne a 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€) : Ring.inverse a = aâ»Â¹",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€] [GroupWithZero Gâ‚€] {a b : Gâ‚€}  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0) : a / c / (b / c) = a / b := by rw [div_div_eq_mul_div]; sorry",
  "name": "div_div_div_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [div_div_eq_mul_div]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0) : a / c / (b / c) = a / b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0)"},
 {"type": "a / c * (c / b) = a / b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0) : a / c * (c / b) = a / b := by rw [â† mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0) : a / c * (c / b) = a / b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [GroupWithZero Gâ‚€]  {a b c : Gâ‚€} (a : Gâ‚€)  (hc : c â‰  0)"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : a = 0 â†’ b = 0) : a * b / a = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left_of_imp",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : a = 0 â†’ b = 0) : a * b / a = b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : a = 0 â†’ b = 0)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : b = 0 â†’ a = 0) : b * (a / b) = a := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_of_imp'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : b = 0 â†’ a = 0) : b * (a / b) = a",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} {a b : Gâ‚€}  (h : b = 0 â†’ a = 0)"},
 {"type": "a * d = c * b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a : Gâ‚€)  {b : Gâ‚€}  (c : Gâ‚€)  {d : Gâ‚€}  (hb : b â‰  0)  (hd : d â‰  0)      (h : a / b = c / d) : a * d = c * b := by rw [â† mul_one a]; sorry",
  "name": "mul_eq_mul_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_one a]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a : Gâ‚€)  {b : Gâ‚€}  (c : Gâ‚€)  {d : Gâ‚€}  (hb : b â‰  0)  (hd : d â‰  0)      (h : a / b = c / d) : a * d = c * b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (a : Gâ‚€)  {b : Gâ‚€}  (c : Gâ‚€)  {d : Gâ‚€}  (hb : b â‰  0)  (hd : d â‰  0)      (h : a / b = c / d)"},
 {"type": "1 / (a * b) * a = 1 / b",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (b : Gâ‚€)  (h : a â‰  0) : 1 / (a * b) * a = 1 / b := by rw [div_mul_eq_mul_div]; sorry",
  "name": "div_helper",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_mul_div]",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (b : Gâ‚€)  (h : a â‰  0) : 1 / (a * b) * a = 1 / b",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€} (b : Gâ‚€)  (h : a â‰  0)"},
 {"type": "f aâ»Â¹ = g aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [Nontrivial Mâ‚€]  [MonoidWithZero Mâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Mâ‚€]    [MonoidWithZeroHomClass F' Gâ‚€ Mâ‚€']  (f : F)  {a : Gâ‚€} (f g : F')  (h : f a = g a) : f aâ»Â¹ = g aâ»Â¹ := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "eq_on_invâ‚€",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [Nontrivial Mâ‚€]  [MonoidWithZero Mâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Mâ‚€]    [MonoidWithZeroHomClass F' Gâ‚€ Mâ‚€']  (f : F)  {a : Gâ‚€} (f g : F')  (h : f a = g a) : f aâ»Â¹ = g aâ»Â¹",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [Nontrivial Mâ‚€]  [MonoidWithZero Mâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Mâ‚€]    [MonoidWithZeroHomClass F' Gâ‚€ Mâ‚€']  (f : F)  {a : Gâ‚€} (f g : F')  (h : f a = g a)"},
 {"type": "f aâ»Â¹ = (f a)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [GroupWithZero Gâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Gâ‚€']  (f : F)  (a b : Gâ‚€) : f aâ»Â¹ = (f a)â»Â¹ := by by_cases h : a = 0; sorry",
  "name": "map_invâ‚€",
  "kind": "theorem",
  "first-tactic": "by_cases h : a = 0",
  "core-prompt":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [GroupWithZero Gâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Gâ‚€']  (f : F)  (a b : Gâ‚€) : f aâ»Â¹ = (f a)â»Â¹",
  "args":
  "{Î± Mâ‚€ Gâ‚€ Mâ‚€' Gâ‚€' F F' : Type _} [MonoidWithZero Mâ‚€]  [CommGroupWithZero Gâ‚€]  {a b c d : Gâ‚€}  [GroupWithZero Gâ‚€]  [GroupWithZero Gâ‚€']  [MonoidWithZeroHomClass F Gâ‚€ Gâ‚€']  (f : F)  (a b : Gâ‚€)"},
 {"type": "a âˆ£ c * b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommSemigroup Î±]  {a b c : Î±} (h : a âˆ£ b)  (c : Î±) : a âˆ£ c * b := by rw [mul_comm]; sorry",
  "name": "dvd_mul_of_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  [CommSemigroup Î±]  {a b c : Î±} (h : a âˆ£ b)  (c : Î±) : a âˆ£ c * b",
  "args": "{Î± : Type _}  [CommSemigroup Î±]  {a b c : Î±} (h : a âˆ£ b)  (c : Î±)"},
 {"type": "a âˆ£ u * b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£} : a âˆ£ u * b â†” a âˆ£ b := by rw [mul_comm]; sorry",
  "name": "dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£} : a âˆ£ u * b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£}"},
 {"type": "â†‘u * a âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£} : â†‘u * a âˆ£ b â†” a âˆ£ b := by rw [mul_comm]; sorry",
  "name": "mul_left_dvd",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£} : â†‘u * a âˆ£ b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [CommMonoid Î±]  {a b : Î±}  {u : Î±Ë£}"},
 {"type": "u âˆ£ a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : u âˆ£ a := by rcases hu with âŸ¨u, rflâŸ©; sorry",
  "name": "dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : u âˆ£ a",
  "args": "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u)"},
 {"type": "a âˆ£ b * u â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : a âˆ£ b * u â†” a âˆ£ b := by rcases hu with âŸ¨u, rflâŸ©; sorry",
  "name": "dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rcases hu with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : a âˆ£ b * u â†” a âˆ£ b",
  "args": "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u)"},
 {"type": "a * u âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : a * u âˆ£ b â†” a âˆ£ b := by rcases hu with âŸ¨u, rflâŸ©; sorry",
  "name": "mul_right_dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u) : a * u âˆ£ b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [Monoid Î±]  {a b u : Î±}  (hu : IsUnit u)"},
 {"type": "a âˆ£ u * b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u) : a âˆ£ u * b â†” a âˆ£ b := by rcases hu with âŸ¨u, rflâŸ©; sorry",
  "name": "dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "rcases hu with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u) : a âˆ£ u * b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u)"},
 {"type": "u * a âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u) : u * a âˆ£ b â†” a âˆ£ b := by rcases hu with âŸ¨u, rflâŸ©; sorry",
  "name": "mul_left_dvd",
  "kind": "theorem",
  "first-tactic": "rcases hu with âŸ¨u, rflâŸ©",
  "core-prompt":
  "{Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u) : u * a âˆ£ b â†” a âˆ£ b",
  "args": "{Î± : Type _}  [CommMonoid Î±]  (a b u : Î±)  (hu : IsUnit u)"},
 {"type": "f <$> x <*> g <$> y = (flip (Â· âˆ˜ Â·) g âˆ˜ f) <$> x <*> y",
  "tactic-prompt":
  "theorem {F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î² â†’ Î³)  (g : Ïƒ â†’ Î²)  (x : F Î±)  (y : F Ïƒ) : f <$> x <*> g <$> y = (flip (Â· âˆ˜ Â·) g âˆ˜ f) <$> x <*> y := by simp [flip]; sorry",
  "name": "Applicative.map_seq_map",
  "kind": "theorem",
  "first-tactic": "simp [flip]",
  "core-prompt":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î² â†’ Î³)  (g : Ïƒ â†’ Î²)  (x : F Î±)  (y : F Ïƒ) : f <$> x <*> g <$> y = (flip (Â· âˆ˜ Â·) g âˆ˜ f) <$> x <*> y",
  "args":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î² â†’ Î³)  (g : Ïƒ â†’ Î²)  (x : F Î±)  (y : F Ïƒ)"},
 {"type": "(Â· <*> Â·) (pure f : F (Î± â†’ Î²)) = (Â· <$> Â·) f",
  "tactic-prompt":
  "theorem {F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î²) : (Â· <*> Â·) (pure f : F (Î± â†’ Î²)) = (Â· <$> Â·) f := by ext; sorry",
  "name": "Applicative.pure_seq_eq_map'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î²) : (Â· <*> Â·) (pure f : F (Î± â†’ Î²)) = (Â· <$> Â·) f",
  "args":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} (f : Î± â†’ Î²)"},
 {"type": "CommApplicative Id",
  "tactic-prompt":
  "instance {F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} : CommApplicative Id := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} : CommApplicative Id",
  "args":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u}"},
 {"type": "CommApplicative (Comp f g)",
  "tactic-prompt":
  "instance {F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} {F : Type u â†’ Type w}  {G : Type v â†’ Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {Î± Î² Î³ : Type v} {f : Type u â†’ Type w}  {g : Type v â†’ Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g] : CommApplicative (Comp f g) := by refine' { @instLawfulApplicativeCompInstApplicativeComp f g _ _ _ _ with .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine' { @instLawfulApplicativeCompInstApplicativeComp f g _ _ _ _ with .. }",
  "core-prompt":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} {F : Type u â†’ Type w}  {G : Type v â†’ Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {Î± Î² Î³ : Type v} {f : Type u â†’ Type w}  {g : Type v â†’ Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g] : CommApplicative (Comp f g)",
  "args":
  "{F : Type u â†’ Type v} [Applicative F]  [LawfulApplicative F] {Î± Î² Î³ Ïƒ : Type u} {F : Type u â†’ Type w}  {G : Type v â†’ Type u} [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] {Î± Î² Î³ : Type v} {f : Type u â†’ Type w}  {g : Type v â†’ Type u}  [Applicative f]  [Applicative g]      [CommApplicative f]  [CommApplicative g]"},
 {"type": "x <*> f <$> y = (Â· âˆ˜ f) <$> x <*> y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (x : F (Î± â†’ Î²))  (f : Î³ â†’ Î±)  (y : F Î³) : x <*> f <$> y = (Â· âˆ˜ f) <$> x <*> y := by simp [â† pure_seq]; sorry",
  "name": "seq_map_assoc",
  "kind": "theorem",
  "first-tactic": "simp [â† pure_seq]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (x : F (Î± â†’ Î²))  (f : Î³ â†’ Î±)  (y : F Î³) : x <*> f <$> y = (Â· âˆ˜ f) <$> x <*> y",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (x : F (Î± â†’ Î²))  (f : Î³ â†’ Î±)  (y : F Î³)"},
 {"type": "f <$> (x <*> y) = (f âˆ˜ Â·) <$> x <*> y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (f : Î² â†’ Î³)  (x : F (Î± â†’ Î²))  (y : F Î±) : f <$> (x <*> y) = (f âˆ˜ Â·) <$> x <*> y := by simp only [â† pure_seq]; sorry",
  "name": "map_seq",
  "kind": "theorem",
  "first-tactic": "simp only [â† pure_seq]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (f : Î² â†’ Î³)  (x : F (Î± â†’ Î²))  (y : F Î±) : f <$> (x <*> y) = (f âˆ˜ Â·) <$> x <*> y",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] (f : Î² â†’ Î³)  (x : F (Î± â†’ Î²))  (y : F Î±)"},
 {"type": "f <$> (x >>= g) = x >>= fun a => f <$> g a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type v}  [Monad m]  [LawfulMonad m] (x : m Î±)  {g : Î± â†’ m Î²}  {f : Î² â†’ Î³} : f <$> (x >>= g) = x >>= fun a => f <$> g a := by rw [â† bind_pure_comp]; sorry",
  "name": "map_bind",
  "kind": "theorem",
  "first-tactic": "rw [â† bind_pure_comp]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type v}  [Monad m]  [LawfulMonad m] (x : m Î±)  {g : Î± â†’ m Î²}  {f : Î² â†’ Î³} : f <$> (x >>= g) = x >>= fun a => f <$> g a",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type v}  [Monad m]  [LawfulMonad m] (x : m Î±)  {g : Î± â†’ m Î²}  {f : Î² â†’ Î³}"},
 {"type": "joinM (Functor.map f <$> a) = f <$> joinM a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± Î² : Type u}  (f : Î± â†’ Î²)  (a : m (m Î±)) : joinM (Functor.map f <$> a) = f <$> joinM a := by simp only [joinM]; sorry",
  "name": "joinM_map_map",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± Î² : Type u}  (f : Î± â†’ Î²)  (a : m (m Î±)) : joinM (Functor.map f <$> a) = f <$> joinM a",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± Î² : Type u}  (f : Î± â†’ Î²)  (a : m (m Î±))"},
 {"type": "joinM (joinM <$> a) = joinM (joinM a)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m (m (m Î±))) : joinM (joinM <$> a) = joinM (joinM a) := by simp only [joinM]; sorry",
  "name": "joinM_map_joinM",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m (m (m Î±))) : joinM (joinM <$> a) = joinM (joinM a)",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m (m (m Î±)))"},
 {"type": "joinM (pure <$> a) = a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m Î±) : joinM (pure <$> a) = a := by simp only [joinM]; sorry",
  "name": "joinM_map_pure",
  "kind": "theorem",
  "first-tactic": "simp only [joinM]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m Î±) : joinM (pure <$> a) = a",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {m : Type u â†’ Type u}  [Monad m]  [LawfulMonad m] {Î± : Type u}  (a : m Î±)"},
 {"type": "@guard F _ True h = pure ()",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True} : @guard F _ True h = pure () := by simp [guard]; sorry",
  "name": "guard_true",
  "kind": "theorem",
  "first-tactic": "simp [guard]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True} : @guard F _ True h = pure ()",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable True}"},
 {"type": "@guard F _ False h = failure",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False} : @guard F _ False h = failure := by simp [guard]; sorry",
  "name": "guard_false",
  "kind": "theorem",
  "first-tactic": "simp [guard]",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False} : @guard F _ False h = failure",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F]  {F : Type â†’ Type v}  [Alternative F]  -- [todo] add notation for `Functor.mapConst` and port `functor.map_const_rev` {h : Decidable False}"},
 {"type": "LawfulFunctor (Sum.{v, u} e)",
  "tactic-prompt":
  "instance {Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] {e : Type v} : LawfulFunctor (Sum.{v, u} e) := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] {e : Type v} : LawfulFunctor (Sum.{v, u} e)",
  "args":
  "{Î± Î² Î³ : Type u}  {F : Type u â†’ Type v}  [Applicative F] [LawfulApplicative F] {e : Type v}"},
 {"type": "(Â· <$> Â·) id = (id : F Î± â†’ F Î±)",
  "tactic-prompt":
  "theorem {F : Type u â†’ Type v} {Î± Î² Î³ : Type u} [Functor F]  [LawfulFunctor F] : (Â· <$> Â·) id = (id : F Î± â†’ F Î±) := by apply funext; sorry",
  "name": "Functor.map_id",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{F : Type u â†’ Type v} {Î± Î² Î³ : Type u} [Functor F]  [LawfulFunctor F] : (Â· <$> Â·) id = (id : F Î± â†’ F Î±)",
  "args":
  "{F : Type u â†’ Type v} {Î± Î² Î³ : Type u} [Functor F]  [LawfulFunctor F]"},
 {"type": "Equiv.map eqv id x = x",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± : Type u}  (x : t' Î±) : Equiv.map eqv id x = x := by simp [Equiv.map]; sorry",
  "name": "id_map",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.map]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± : Type u}  (x : t' Î±) : Equiv.map eqv id x = x",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± : Type u}  (x : t' Î±)"},
 {"type": "Equiv.map eqv (h âˆ˜ g) x = Equiv.map eqv h (Equiv.map eqv g x)",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± Î² Î³ : Type u}  (g : Î± â†’ Î²)  (h : Î² â†’ Î³)  (x : t' Î±) : Equiv.map eqv (h âˆ˜ g) x = Equiv.map eqv h (Equiv.map eqv g x) := by simp [Equiv.map]; sorry",
  "name": "comp_map",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.map]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± Î² Î³ : Type u}  (g : Î± â†’ Î²)  (h : Î² â†’ Î³)  (x : t' Î±) : Equiv.map eqv (h âˆ˜ g) x = Equiv.map eqv h (Equiv.map eqv g x)",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t] {Î± Î² Î³ : Type u}  (g : Î± â†’ Î²)  (h : Î² â†’ Î³)  (x : t' Î±)"},
 {"type": "Equiv.traverse eqv (pure : Î± â†’ Id Î±) x = x",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (x : t' Î±) : Equiv.traverse eqv (pure : Î± â†’ Id Î±) x = x := by simp [Equiv.traverse]; sorry",
  "name": "id_traverse",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (x : t' Î±) : Equiv.traverse eqv (pure : Î± â†’ Id Î±) x = x",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (x : t' Î±)"},
 {"type":
  "Equiv.traverse eqv ((pure : Î² â†’ Id Î²) âˆ˜ f) x = pure (Equiv.map eqv f x)",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ Î²)  (x : t' Î±) : Equiv.traverse eqv ((pure : Î² â†’ Id Î²) âˆ˜ f) x = pure (Equiv.map eqv f x) := by simp [Equiv.traverse]; sorry",
  "name": "traverse_eq_map_id",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ Î²)  (x : t' Î±) : Equiv.traverse eqv ((pure : Î² â†’ Id Î²) âˆ˜ f) x = pure (Equiv.map eqv f x)",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ Î²)  (x : t' Î±)"},
 {"type":
  "Equiv.traverse eqv (Comp.mk âˆ˜ Functor.map f âˆ˜ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x)",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î² â†’ F Î³)  (g : Î± â†’ G Î²)  (x : t' Î±) : Equiv.traverse eqv (Comp.mk âˆ˜ Functor.map f âˆ˜ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x) := by simp [Equiv.traverse]; sorry",
  "name": "comp_traverse",
  "kind": "theorem",
  "first-tactic": "simp [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î² â†’ F Î³)  (g : Î± â†’ G Î²)  (x : t' Î±) : Equiv.traverse eqv (Comp.mk âˆ˜ Functor.map f âˆ˜ g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x)",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î² â†’ F Î³)  (g : Î± â†’ G Î²)  (x : t' Î±)"},
 {"type": "Î· (Equiv.traverse eqv f x) = Equiv.traverse eqv (@Î· _ âˆ˜ f) x",
  "tactic-prompt":
  "theorem {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ F Î²)  (x : t' Î±) : Î· (Equiv.traverse eqv f x) = Equiv.traverse eqv (@Î· _ âˆ˜ f) x := by simp only [Equiv.traverse]; sorry",
  "name": "naturality",
  "kind": "theorem",
  "first-tactic": "simp only [Equiv.traverse]",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ F Î²)  (x : t' Î±) : Î· (Equiv.traverse eqv f x) = Equiv.traverse eqv (@Î· _ âˆ˜ f) x",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u} (f : Î± â†’ F Î²)  (x : t' Î±)"},
 {"type": "IsLawfulTraversable t'",
  "tactic-prompt":
  "def {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u}  [Traversable t']      (hâ‚€ : âˆ€ {Î± Î²} (f : Î± â†’ Î²), map f = Equiv.map eqv f)      (hâ‚ : âˆ€ {Î± Î²} (f : Î²), mapConst f = (Equiv.map eqv âˆ˜ Function.const Î±) f)      (hâ‚‚ :       âˆ€ {F : Type u â†’ Type u} [Applicative F],         âˆ€ [LawfulApplicative F] {Î± Î²} (f : Î± â†’ F Î²), traverse f = Equiv.traverse eqv f) : IsLawfulTraversable t' := by refine' { toLawfulFunctor := Equiv.lawfulFunctor' eqv @hâ‚€ @hâ‚.. }; sorry",
  "name": "isLawfulTraversable'",
  "kind": "def",
  "first-tactic":
  "refine' { toLawfulFunctor := Equiv.lawfulFunctor' eqv @hâ‚€ @hâ‚.. }",
  "core-prompt":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u}  [Traversable t']      (hâ‚€ : âˆ€ {Î± Î²} (f : Î± â†’ Î²), map f = Equiv.map eqv f)      (hâ‚ : âˆ€ {Î± Î²} (f : Î²), mapConst f = (Equiv.map eqv âˆ˜ Function.const Î±) f)      (hâ‚‚ :       âˆ€ {F : Type u â†’ Type u} [Applicative F],         âˆ€ [LawfulApplicative F] {Î± Î²} (f : Î± â†’ F Î²), traverse f = Equiv.traverse eqv f) : IsLawfulTraversable t'",
  "args":
  "{t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±) [Functor t] [LawfulFunctor t]  {t t' : Type u â†’ Type u}  (eqv : âˆ€ Î±, t Î± â‰ƒ t' Î±)  -- Porting note: The naming `IsLawfulTraversable` seems weird, why not `LawfulTraversable`? -- Is this to do with the fact it lives in `Type (u+1)` not `Prop`? [Traversable t]  [IsLawfulTraversable t] {F G : Type u â†’ Type u}  [Applicative F]  [Applicative G] [LawfulApplicative F]  [LawfulApplicative G] (Î· : ApplicativeTransformation F G) {Î± Î² Î³ : Type u}  [Traversable t']      (hâ‚€ : âˆ€ {Î± Î²} (f : Î± â†’ Î²), map f = Equiv.map eqv f)      (hâ‚ : âˆ€ {Î± Î²} (f : Î²), mapConst f = (Equiv.map eqv âˆ˜ Function.const Î±) f)      (hâ‚‚ :       âˆ€ {F : Type u â†’ Type u} [Applicative F],         âˆ€ [LawfulApplicative F] {Î± Î²} (f : Î± â†’ F Î²), traverse f = Equiv.traverse eqv f)"},
 {"type": "IsLawfulTraversable Id",
  "tactic-prompt":
  "instance (F : Type u â†’ Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u â†’ Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u â†’ Type s}  [Applicative H]  [LawfulApplicative H] : IsLawfulTraversable Id := by refine' { .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "refine' { .. }",
  "core-prompt":
  "(F : Type u â†’ Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u â†’ Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u â†’ Type s}  [Applicative H]  [LawfulApplicative H] : IsLawfulTraversable Id",
  "args":
  "(F : Type u â†’ Type v)  [Applicative F]  [LawfulApplicative F] (G : Type u â†’ Type w)  [Applicative G]  [LawfulApplicative G] {H : Type u â†’ Type s}  [Applicative H]  [LawfulApplicative H]"},
 {"type": "map f <$> traverse g x = traverse (map f âˆ˜ g) x",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : map f <$> traverse g x = traverse (map f âˆ˜ g) x := by rw [map_eq_traverse_id f]; sorry",
  "name": "map_traverse",
  "kind": "theorem",
  "first-tactic": "rw [map_eq_traverse_id f]",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : map f <$> traverse g x = traverse (map f âˆ˜ g) x",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±)"},
 {"type": "traverse f (g <$> x) = traverse (f âˆ˜ g) x",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ F Î³)  (g : Î± â†’ Î²)  (x : t Î±) : traverse f (g <$> x) = traverse (f âˆ˜ g) x := by rw [@map_eq_traverse_id t _ _ _ _ g]; sorry",
  "name": "traverse_map",
  "kind": "theorem",
  "first-tactic": "rw [@map_eq_traverse_id t _ _ _ _ g]",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ F Î³)  (g : Î± â†’ Î²)  (x : t Î±) : traverse f (g <$> x) = traverse (f âˆ˜ g) x",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ F Î³)  (g : Î± â†’ Î²)  (x : t Î±)"},
 {"type": "traverse pure x = (pure x : F (t Î±))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : traverse pure x = (pure x : F (t Î±)) := by have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm; sorry",
  "name": "pure_traverse",
  "kind": "theorem",
  "first-tactic":
  "have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : traverse pure x = (pure x : F (t Î±))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±)"},
 {"type": "sequence (f := Id) (pure <$> x) = pure x",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : sequence (f := Id) (pure <$> x) = pure x := by simp [sequence]; sorry",
  "name": "id_sequence",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±) : sequence (f := Id) (pure <$> x) = pure x",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t Î±)"},
 {"type": "sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x)",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t (F (G Î±))) : sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by simp [sequence]; sorry",
  "name": "comp_sequence",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t (F (G Î±))) : sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x)",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (x : t (F (G Î±)))"},
 {"type": "Î· (sequence x) = sequence (@Î· _ <$> x)",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (x : t (F Î±)) : Î· (sequence x) = sequence (@Î· _ <$> x) := by simp [sequence]; sorry",
  "name": "naturality'",
  "kind": "theorem",
  "first-tactic": "simp [sequence]",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (x : t (F Î±)) : Î· (sequence x) = sequence (@Î· _ <$> x)",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (x : t (F Î±))"},
 {"type": "traverse pure = (pure : t Î± â†’ Id (t Î±))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) : traverse pure = (pure : t Î± â†’ Id (t Î±)) := by ext; sorry",
  "name": "traverse_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) : traverse pure = (pure : t Î± â†’ Id (t Î±))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³)"},
 {"type":
  "traverse (Comp.mk âˆ˜ map h âˆ˜ g) =\n      (Comp.mk âˆ˜ map (traverse h) âˆ˜ traverse g : t Î± â†’ Comp F G (t Î³))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ F Î²)  (h : Î² â†’ G Î³) : traverse (Comp.mk âˆ˜ map h âˆ˜ g) =\n      (Comp.mk âˆ˜ map (traverse h) âˆ˜ traverse g : t Î± â†’ Comp F G (t Î³)) := by ext; sorry",
  "name": "traverse_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ F Î²)  (h : Î² â†’ G Î³) : traverse (Comp.mk âˆ˜ map h âˆ˜ g) =\n      (Comp.mk âˆ˜ map (traverse h) âˆ˜ traverse g : t Î± â†’ Comp F G (t Î³))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ F Î²)  (h : Î² â†’ G Î³)"},
 {"type": "traverse (m := Id) (pure âˆ˜ f) = pure âˆ˜ (map f : t Î² â†’ t Î³)",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ Î³) : traverse (m := Id) (pure âˆ˜ f) = pure âˆ˜ (map f : t Î² â†’ t Î³) := by ext; sorry",
  "name": "traverse_eq_map_id'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ Î³) : traverse (m := Id) (pure âˆ˜ f) = pure âˆ˜ (map f : t Î² â†’ t Î³)",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (f : Î² â†’ Î³)"},
 {"type": "traverse (h âˆ˜ g) = (traverse h âˆ˜ map g : t Î± â†’ G (t Î³))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ Î²)  (h : Î² â†’ G Î³) : traverse (h âˆ˜ g) = (traverse h âˆ˜ map g : t Î± â†’ G (t Î³)) := by ext; sorry",
  "name": "traverse_map'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ Î²)  (h : Î² â†’ G Î³) : traverse (h âˆ˜ g) = (traverse h âˆ˜ map g : t Î± â†’ G (t Î³))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ Î²)  (h : Î² â†’ G Î³)"},
 {"type": "traverse (map h âˆ˜ g) = (map (map h) âˆ˜ traverse g : t Î± â†’ G (t Î³))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ G Î²)  (h : Î² â†’ Î³) : traverse (map h âˆ˜ g) = (map (map h) âˆ˜ traverse g : t Î± â†’ G (t Î³)) := by ext; sorry",
  "name": "map_traverse'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ G Î²)  (h : Î² â†’ Î³) : traverse (map h âˆ˜ g) = (map (map h) âˆ˜ traverse g : t Î± â†’ G (t Î³))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (g : Î± â†’ G Î²)  (h : Î² â†’ Î³)"},
 {"type": "traverse (@Î· _ âˆ˜ f) = @Î· _ âˆ˜ (traverse f : t Î± â†’ F (t Î²))",
  "tactic-prompt":
  "theorem {t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (f : Î± â†’ F Î²) : traverse (@Î· _ âˆ˜ f) = @Î· _ âˆ˜ (traverse f : t Î± â†’ F (t Î²)) := by ext; sorry",
  "name": "naturality_pf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (f : Î± â†’ F Î²) : traverse (@Î· _ âˆ˜ f) = @Î· _ âˆ˜ (traverse f : t Î± â†’ F (t Î²))",
  "args":
  "{t : Type u â†’ Type u} [Traversable t]  [IsLawfulTraversable t] (F G : Type u â†’ Type u) [Applicative F]  [LawfulApplicative F] [Applicative G]  [LawfulApplicative G] {Î± Î² Î³ : Type u} (g : Î± â†’ F Î²) (h : Î² â†’ G Î³) (f : Î² â†’ Î³) (Î· : ApplicativeTransformation F G)  (f : Î± â†’ F Î²)"},
 {"type": "f â‰« h = g â‰« h",
  "tactic-prompt":
  "theorem {C : Type _}  [Category C] {X Y : C}  {f g : X âŸ¶ Y}  (w : f = g)  {Z : C}  (h : Y âŸ¶ Z) : f â‰« h = g â‰« h := by rw [w]; sorry",
  "name": "eq_whisker'",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type _}  [Category C] {X Y : C}  {f g : X âŸ¶ Y}  (w : f = g)  {Z : C}  (h : Y âŸ¶ Z) : f â‰« h = g â‰« h",
  "args":
  "{C : Type _}  [Category C] {X Y : C}  {f g : X âŸ¶ Y}  (w : f = g)  {Z : C}  (h : Y âŸ¶ Z)"},
 {"type": "0 + b = b",
  "tactic-prompt": "theorem (b : R) : 0 + b = b := by simp; sorry",
  "name": "add_pf_zero_add",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : R) : 0 + b = b",
  "args": "(b : R)"},
 {"type": "a + 0 = a",
  "tactic-prompt": "theorem (a : R) : a + 0 = a := by simp; sorry",
  "name": "add_pf_add_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a + 0 = a",
  "args": "(a : R)"},
 {"type": "(aâ‚ + aâ‚‚ : R) + (bâ‚ + bâ‚‚) = c",
  "tactic-prompt":
  "theorem (h : IsNat (aâ‚ + bâ‚) (nat_lit 0))  (hâ‚„ : aâ‚‚ + bâ‚‚ = c) : (aâ‚ + aâ‚‚ : R) + (bâ‚ + bâ‚‚) = c := by subst_vars; sorry",
  "name": "add_pf_add_overlap_zero",
  "kind": "theorem",
  "first-tactic": "subst_vars",
  "core-prompt":
  "(h : IsNat (aâ‚ + bâ‚) (nat_lit 0))  (hâ‚„ : aâ‚‚ + bâ‚‚ = c) : (aâ‚ + aâ‚‚ : R) + (bâ‚ + bâ‚‚) = c",
  "args": "(h : IsNat (aâ‚ + bâ‚) (nat_lit 0))  (hâ‚„ : aâ‚‚ + bâ‚‚ = c)"},
 {"type": "(nat_lit 1).rawCast * a = a",
  "tactic-prompt":
  "theorem (a : R) : (nat_lit 1).rawCast * a = a := by simp [Nat.rawCast]; sorry",
  "name": "one_mul",
  "kind": "theorem",
  "first-tactic": "simp [Nat.rawCast]",
  "core-prompt": "(a : R) : (nat_lit 1).rawCast * a = a",
  "args": "(a : R)"},
 {"type": "a * (nat_lit 1).rawCast = a",
  "tactic-prompt":
  "theorem (a : R) : a * (nat_lit 1).rawCast = a := by simp [Nat.rawCast]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "simp [Nat.rawCast]",
  "core-prompt": "(a : R) : a * (nat_lit 1).rawCast = a",
  "args": "(a : R)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : R) : a * 0 = 0 := by simp; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a * 0 = 0",
  "args": "(a : R)"},
 {"type": "0 * b = 0",
  "tactic-prompt": "theorem (b : R) : 0 * b = 0 := by simp; sorry",
  "name": "zero_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(b : R) : 0 * b = 0",
  "args": "(b : R)"},
 {"type": "a ^ nat_lit 1 = a",
  "tactic-prompt": "theorem (a : R) : a ^ nat_lit 1 = a := by simp; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ nat_lit 1 = a",
  "args": "(a : R)"},
 {"type": "((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast",
  "tactic-prompt":
  "theorem (b : â„•) : ((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast := by simp; sorry",
  "name": "one_pow",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(b : â„•) : ((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast",
  "args": "(b : â„•)"},
 {"type": "k.rawCast = (nat_lit 1).rawCast * k",
  "tactic-prompt":
  "theorem (k : â„•) : k.rawCast = (nat_lit 1).rawCast * k := by simp; sorry",
  "name": "coeff_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(k : â„•) : k.rawCast = (nat_lit 1).rawCast * k",
  "args": "(k : â„•)"},
 {"type": "a ^ (nat_lit 1).rawCast = a",
  "tactic-prompt":
  "theorem (a : R) : a ^ (nat_lit 1).rawCast = a := by simp; sorry",
  "name": "pow_one_cast",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ (nat_lit 1).rawCast = a",
  "args": "(a : R)"},
 {"type": "a ^ 0 = (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (a : R) : a ^ 0 = (nat_lit 1).rawCast + 0 := by simp; sorry",
  "name": "pow_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : R) : a ^ 0 = (nat_lit 1).rawCast + 0",
  "args": "(a : R)"},
 {"type": "a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp; sorry",
  "name": "atom_pf",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "args": "(a : R)"},
 {"type": "a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "tactic-prompt":
  "theorem (p : (a : R) = a') : a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0 := by simp [*]; sorry",
  "name": "atom_pf'",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt":
  "(p : (a : R) = a') : a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0",
  "args": "(p : (a : R) = a')"},
 {"type": "(Nat.rawCast 0 : R) = 0",
  "tactic-prompt":
  "theorem [CommSemiring R] : (Nat.rawCast 0 : R) = 0 := by simp; sorry",
  "name": "nat_rawCast_0",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[CommSemiring R] : (Nat.rawCast 0 : R) = 0",
  "args": "[CommSemiring R]"},
 {"type": "(Nat.rawCast 1 : R) = 1",
  "tactic-prompt":
  "theorem [CommSemiring R] : (Nat.rawCast 1 : R) = 1 := by simp; sorry",
  "name": "nat_rawCast_1",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[CommSemiring R] : (Nat.rawCast 1 : R) = 1",
  "args": "[CommSemiring R]"},
 {"type": "Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b)",
  "tactic-prompt":
  "theorem (hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b) : Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b) := by refine âŸ¨fun H â†¦ by_contra fun hn â†¦ H âŸ¨fun c h â†¦ by_contra fun hn' â†¦ ?_âŸ©âŸ©; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun H â†¦ by_contra fun hn â†¦ H âŸ¨fun c h â†¦ by_contra fun hn' â†¦ ?_âŸ©âŸ©",
  "core-prompt":
  "(hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b) : Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b)",
  "args": "(hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b)"},
 {"type": "a â‰  b â†” (a : â„¤) â‰  (b : â„¤)",
  "tactic-prompt":
  "lemma (a b : â„•) : a â‰  b â†” (a : â„¤) â‰  (b : â„¤) := by simp only [ne_eq]; sorry",
  "name": "nat_cast_ne",
  "kind": "lemma",
  "first-tactic": "simp only [ne_eq]",
  "core-prompt": "(a b : â„•) : a â‰  b â†” (a : â„¤) â‰  (b : â„¤)",
  "args": "(a b : â„•)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a' = b'",
  "tactic-prompt":
  "theorem [AddGroup Î±]  (p : (a:Î±) = b)  (H : (a' - b') - (a - b) = 0) : a' = b' := by rw [â† sub_eq_zero] at p âŠ¢; sorry",
  "name": "eq_of_add",
  "kind": "theorem",
  "first-tactic": "rw [â† sub_eq_zero] at p âŠ¢",
  "core-prompt":
  "[AddGroup Î±]  (p : (a:Î±) = b)  (H : (a' - b') - (a - b) = 0) : a' = b'",
  "args": "[AddGroup Î±]  (p : (a:Î±) = b)  (H : (a' - b') - (a - b) = 0)"},
 {"type": "F.map (preimage F f) = f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)  [Full F]  {X Y : C}  (f : F.obj X âŸ¶ F.obj Y) : F.map (preimage F f) = f := by unfold preimage; sorry",
  "name": "image_preimage",
  "kind": "theorem",
  "first-tactic": "unfold preimage",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)  [Full F]  {X Y : C}  (f : F.obj X âŸ¶ F.obj Y) : F.map (preimage F f) = f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)  [Full F]  {X Y : C}  (f : F.obj X âŸ¶ F.obj Y)"},
 {"type": "Full F",
  "tactic-prompt":
  "def {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)      (h : âˆ€ (X Y : C) (f : F.obj X âŸ¶ F.obj Y), âˆƒ p, F.map p = f) : Full F := by choose p hp using h; sorry",
  "name": "fullOfExists",
  "kind": "def",
  "first-tactic": "choose p hp using h",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)      (h : âˆ€ (X Y : C) (f : F.obj X âŸ¶ F.obj Y), âˆƒ p, F.map p = f) : Full F",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} (F : C â¥¤ D)      (h : âˆ€ (X Y : C) (f : F.obj X âŸ¶ F.obj Y), âˆƒ p, F.map p = f)"},
 {"type": "F.preimageIso (F.mapIso f) = f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {F : C â¥¤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X â‰… Y) : F.preimageIso (F.mapIso f) = f := by ext; sorry",
  "name": "preimageIso_mapIso",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {F : C â¥¤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X â‰… Y) : F.preimageIso (F.mapIso f) = f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {F : C â¥¤ D}  [Full F]  [Faithful F]  {X Y Z : C} (f : X â‰… Y)"},
 {"type":
  "(natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H) : (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom := by ext; sorry",
  "name": "natIsoOfCompFullyFaithful_hom",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H) : (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H)"},
 {"type":
  "(natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H) : (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv := by ext; sorry",
  "name": "natIsoOfCompFullyFaithful_inv",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H) : (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C}  {E : Type _}  [Category E]  {F G : C â¥¤ D}  (H : D â¥¤ E)  [Full H]  [Faithful H] (i : F â‹™ H â‰… G â‹™ H)"},
 {"type": "Faithful.div F G obj @h_obj @map @h_map â‹™ G = F",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} {C : Type uâ‚}  [Category.{vâ‚} C] {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F F' : C â¥¤ D)  (G : D â¥¤ E) (F : C â¥¤ E)  [Faithful F]  (G : D â¥¤ E)  [Faithful G]  (obj : C â†’ D)      (h_obj : âˆ€ X, G.obj (obj X) = F.obj X)  (map : âˆ€ {X Y}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y))      (h_map : âˆ€ {X Y} {f : X âŸ¶ Y}, HEq (G.map (map f)) (F.map f)) : Faithful.div F G obj @h_obj @map @h_map â‹™ G = F := by cases' F with F_pre _ _; sorry",
  "name": "Faithful.div_comp",
  "kind": "theorem",
  "first-tactic": "cases' F with F_pre _ _",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} {C : Type uâ‚}  [Category.{vâ‚} C] {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F F' : C â¥¤ D)  (G : D â¥¤ E) (F : C â¥¤ E)  [Faithful F]  (G : D â¥¤ E)  [Faithful G]  (obj : C â†’ D)      (h_obj : âˆ€ X, G.obj (obj X) = F.obj X)  (map : âˆ€ {X Y}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y))      (h_map : âˆ€ {X Y} {f : X âŸ¶ Y}, HEq (G.map (map f)) (F.map f)) : Faithful.div F G obj @h_obj @map @h_map â‹™ G = F",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {X Y : C} {C : Type uâ‚}  [Category.{vâ‚} C] {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F F' : C â¥¤ D)  (G : D â¥¤ E) (F : C â¥¤ E)  [Faithful F]  (G : D â¥¤ E)  [Faithful G]  (obj : C â†’ D)      (h_obj : âˆ€ X, G.obj (obj X) = F.obj X)  (map : âˆ€ {X Y}, (X âŸ¶ Y) â†’ (obj X âŸ¶ obj Y))      (h_map : âˆ€ {X Y} {f : X âŸ¶ Y}, HEq (G.map (map f)) (F.map f))"},
 {"type": "F â‹™ ðŸ­ D = F",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D) : F â‹™ ðŸ­ D = F := by cases F; sorry",
  "name": "comp_id",
  "kind": "theorem",
  "first-tactic": "cases F",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D) : F â‹™ ðŸ­ D = F",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D)"},
 {"type": "ðŸ­ C â‹™ F = F",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D) : ðŸ­ C â‹™ F = F := by cases F; sorry",
  "name": "id_comp",
  "kind": "theorem",
  "first-tactic": "cases F",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D) : ðŸ­ C â‹™ F = F",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D)"},
 {"type":
  "F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h)",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P â†’ (X âŸ¶ Y))  (g : Â¬P â†’ (X âŸ¶ Y)) : F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h) := by aesop_cat; sorry",
  "name": "map_dite",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P â†’ (X âŸ¶ Y))  (g : Â¬P â†’ (X âŸ¶ Y)) : F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h)",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]    {E : Type uâ‚ƒ}  [Category.{vâ‚ƒ} E] (F : C â¥¤ D)  {X Y : C}  {P : Prop}  [Decidable P]      (f : P â†’ (X âŸ¶ Y))  (g : Â¬P â†’ (X âŸ¶ Y))"},
 {"type": "Î±.app X = Î².app X",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {Î± Î² : F âŸ¶ G}  (h : Î± = Î²)  (X : C) : Î±.app X = Î².app X := by rw [h]; sorry",
  "name": "congr_app",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {Î± Î² : F âŸ¶ G}  (h : Î± = Î²)  (X : C) : Î±.app X = Î².app X",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {Î± Î² : F âŸ¶ G}  (h : Î± = Î²)  (X : C)"},
 {"type": "(Î± â—« ðŸ™ H).app X = H.map (Î±.app X)",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : D â¥¤ E}  (Î± : F âŸ¶ G)  (X : C) : (Î± â—« ðŸ™ H).app X = H.map (Î±.app X) := by simp; sorry",
  "name": "hcomp_id_app",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : D â¥¤ E}  (Î± : F âŸ¶ G)  (X : C) : (Î± â—« ðŸ™ H).app X = H.map (Î±.app X)",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : D â¥¤ E}  (Î± : F âŸ¶ G)  (X : C)"},
 {"type": "(ðŸ™ H â—« Î±).app X = Î±.app _",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : E â¥¤ C}  (Î± : F âŸ¶ G)  (X : E) : (ðŸ™ H â—« Î±).app X = Î±.app _ := by simp; sorry",
  "name": "id_hcomp_app",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : E â¥¤ C}  (Î± : F âŸ¶ G)  (X : E) : (ðŸ™ H â—« Î±).app X = Î±.app _",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {H : E â¥¤ C}  (Î± : F âŸ¶ G)  (X : E)"},
 {"type": "(Î± â‰« Î²) â—« (Î³ â‰« Î´) = (Î± â—« Î³) â‰« Î² â—« Î´",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {I J K : D â¥¤ E}  (Î± : F âŸ¶ G)  (Î² : G âŸ¶ H)  (Î³ : I âŸ¶ J)  (Î´ : J âŸ¶ K) : (Î± â‰« Î²) â—« (Î³ â‰« Î´) = (Î± â—« Î³) â‰« Î² â—« Î´ := by aesop_cat; sorry",
  "name": "exchange",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {I J K : D â¥¤ E}  (Î± : F âŸ¶ G)  (Î² : G âŸ¶ H)  (Î³ : I âŸ¶ J)  (Î´ : J âŸ¶ K) : (Î± â‰« Î²) â—« (Î³ â‰« Î´) = (Î± â—« Î³) â‰« Î² â—« Î´",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} {I J K : D â¥¤ E}  (Î± : F âŸ¶ G)  (Î² : G âŸ¶ H)  (Î³ : I âŸ¶ J)  (Î´ : J âŸ¶ K)"},
 {"type": "(F.map e.hom).app Z â‰« (F.map e.inv).app Z = ðŸ™ _",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : (F.map e.hom).app Z â‰« (F.map e.inv).app Z = ðŸ™ _ := by simp [â† NatTrans.comp_app]; sorry",
  "name": "map_hom_inv_app",
  "kind": "theorem",
  "first-tactic": "simp [â† NatTrans.comp_app]",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : (F.map e.hom).app Z â‰« (F.map e.inv).app Z = ðŸ™ _",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D)"},
 {"type": "(F.map e.inv).app Z â‰« (F.map e.hom).app Z = ðŸ™ _",
  "tactic-prompt":
  "theorem (C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : (F.map e.inv).app Z â‰« (F.map e.hom).app Z = ðŸ™ _ := by simp [â† NatTrans.comp_app]; sorry",
  "name": "map_inv_hom_app",
  "kind": "theorem",
  "first-tactic": "simp [â† NatTrans.comp_app]",
  "core-prompt":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : (F.map e.inv).app Z â‰« (F.map e.hom).app Z = ðŸ™ _",
  "args":
  "(C : Type uâ‚)  [Category.{vâ‚} C]  (D : Type uâ‚‚)  [Category.{vâ‚‚} D] {F G H I : C â¥¤ D} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D)"},
 {"type": "Î±.hom.app X â‰« g = Î±.hom.app X â‰« g' â†” g = g'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : G.obj X âŸ¶ Z) : Î±.hom.app X â‰« g = Î±.hom.app X â‰« g' â†” g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_natIso_hom_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : G.obj X âŸ¶ Z) : Î±.hom.app X â‰« g = Î±.hom.app X â‰« g' â†” g = g'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : G.obj X âŸ¶ Z)"},
 {"type": "Î±.inv.app X â‰« g = Î±.inv.app X â‰« g' â†” g = g'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : F.obj X âŸ¶ Z) : Î±.inv.app X â‰« g = Î±.inv.app X â‰« g' â†” g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_natIso_inv_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : F.obj X âŸ¶ Z) : Î±.inv.app X â‰« g = Î±.inv.app X â‰« g' â†” g = g'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : C}  {Z : D}  (g g' : F.obj X âŸ¶ Z)"},
 {"type": "f â‰« Î±.hom.app Y = f' â‰« Î±.hom.app Y â†” f = f'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ F.obj Y) : f â‰« Î±.hom.app Y = f' â‰« Î±.hom.app Y â†” f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_natIso_hom_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ F.obj Y) : f â‰« Î±.hom.app Y = f' â‰« Î±.hom.app Y â†” f = f'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ F.obj Y)"},
 {"type": "f â‰« Î±.inv.app Y = f' â‰« Î±.inv.app Y â†” f = f'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ G.obj Y) : f â‰« Î±.inv.app Y = f' â‰« Î±.inv.app Y â†” f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_natIso_inv_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ G.obj Y) : f â‰« Î±.inv.app Y = f' â‰« Î±.inv.app Y â†” f = f'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {X : D}  {Y : C}  (f f' : X âŸ¶ G.obj Y)"},
 {"type": "f â‰« g â‰« Î±.hom.app Y = f' â‰« g' â‰« Î±.hom.app Y â†” f â‰« g = f' â‰« g'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ F.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ F.obj Y) : f â‰« g â‰« Î±.hom.app Y = f' â‰« g' â‰« Î±.hom.app Y â†” f â‰« g = f' â‰« g' := by simp only [â† Category.assoc]; sorry",
  "name": "cancel_natIso_hom_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [â† Category.assoc]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ F.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ F.obj Y) : f â‰« g â‰« Î±.hom.app Y = f' â‰« g' â‰« Î±.hom.app Y â†” f â‰« g = f' â‰« g'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ F.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ F.obj Y)"},
 {"type": "f â‰« g â‰« Î±.inv.app Y = f' â‰« g' â‰« Î±.inv.app Y â†” f â‰« g = f' â‰« g'",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ G.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ G.obj Y) : f â‰« g â‰« Î±.inv.app Y = f' â‰« g' â‰« Î±.inv.app Y â†” f â‰« g = f' â‰« g' := by simp only [â† Category.assoc]; sorry",
  "name": "cancel_natIso_inv_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [â† Category.assoc]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ G.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ G.obj Y) : f â‰« g â‰« Î±.inv.app Y = f' â‰« g' â‰« Î±.inv.app Y â†” f â‰« g = f' â‰« g'",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {W X X' : D}  {Y : C}  (f : W âŸ¶ X)  (g : X âŸ¶ G.obj Y)      (f' : W âŸ¶ X')  (g' : X' âŸ¶ G.obj Y)"},
 {"type": "inv (e.inv.app X) = e.hom.app X",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {F G : C â¥¤ D}  (e : F â‰… G)  (X : C) : inv (e.inv.app X) = e.hom.app X := by aesop_cat; sorry",
  "name": "inv_inv_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {F G : C â¥¤ D}  (e : F â‰… G)  (X : C) : inv (e.inv.app X) = e.hom.app X",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D}  (Î± : F â‰… G) {F G : C â¥¤ D}  (e : F â‰… G)  (X : C)"},
 {"type": "Î±.inv.app X â‰« F.map f â‰« Î±.hom.app Y = G.map f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y) : Î±.inv.app X â‰« F.map f â‰« Î±.hom.app Y = G.map f := by simp; sorry",
  "name": "naturality_1",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y) : Î±.inv.app X â‰« F.map f â‰« Î±.hom.app Y = G.map f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y)"},
 {"type": "Î±.hom.app X â‰« G.map f â‰« Î±.inv.app Y = F.map f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y) : Î±.hom.app X â‰« G.map f â‰« Î±.inv.app Y = F.map f := by simp; sorry",
  "name": "naturality_2",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y) : Î±.hom.app X â‰« G.map f â‰« Î±.inv.app Y = F.map f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F â‰… G)  (f : X âŸ¶ Y)"},
 {"type": "inv (Î±.app X) â‰« F.map f â‰« Î±.app Y = G.map f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app X)] : inv (Î±.app X) â‰« F.map f â‰« Î±.app Y = G.map f := by simp; sorry",
  "name": "naturality_1'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app X)] : inv (Î±.app X) â‰« F.map f â‰« Î±.app Y = G.map f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app X)]"},
 {"type": "Î±.app X â‰« G.map f â‰« inv (Î±.app Y) = F.map f",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app Y)] : Î±.app X â‰« G.map f â‰« inv (Î±.app Y) = F.map f := by rw [â† Category.assoc]; sorry",
  "name": "naturality_2'",
  "kind": "theorem",
  "first-tactic": "rw [â† Category.assoc]",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app Y)] : Î±.app X â‰« G.map f â‰« inv (Î±.app Y) = F.map f",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (Î± : F âŸ¶ G)  (f : X âŸ¶ Y)  [IsIso (Î±.app Y)]"},
 {"type": "inv ((F.map e.inv).app Z) = (F.map e.hom).app Z",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : inv ((F.map e.inv).app Z) = (F.map e.hom).app Z := by aesop_cat; sorry",
  "name": "inv_map_inv_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D) : inv ((F.map e.inv).app Z) = (F.map e.hom).app Z",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} (F : C â¥¤ D â¥¤ E)  {X Y : C}  (e : X â‰… Y)  (Z : D)"},
 {"type": "F â‹™ H â‰… G â‹™ I",
  "tactic-prompt":
  "def {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {F G : C â¥¤ D}  {H I : D â¥¤ E}  (Î± : F â‰… G)  (Î² : H â‰… I) : F â‹™ H â‰… G â‹™ I := by refine' âŸ¨Î±.hom â—« Î².hom, Î±.inv â—« Î².inv, _, _âŸ©; sorry",
  "name": "hcomp",
  "kind": "def",
  "first-tactic": "refine' âŸ¨Î±.hom â—« Î².hom, Î±.inv â—« Î².inv, _, _âŸ©",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {F G : C â¥¤ D}  {H I : D â¥¤ E}  (Î± : F â‰… G)  (Î² : H â‰… I) : F â‹™ H â‰… G â‹™ I",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {F G : C â¥¤ D}  {H I : D â¥¤ E}  (Î± : F â‰… G)  (Î² : H â‰… I)"},
 {"type": "IsIso (Fâ‚.map f) â†” IsIso (Fâ‚‚.map f)",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {Fâ‚ Fâ‚‚ : C â¥¤ D}  (e : Fâ‚ â‰… Fâ‚‚)  {X Y : C}  (f : X âŸ¶ Y) : IsIso (Fâ‚.map f) â†” IsIso (Fâ‚‚.map f) := by revert Fâ‚ Fâ‚‚; sorry",
  "name": "isIso_map_iff",
  "kind": "theorem",
  "first-tactic": "revert Fâ‚ Fâ‚‚",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {Fâ‚ Fâ‚‚ : C â¥¤ D}  (e : Fâ‚ â‰… Fâ‚‚)  {X Y : C}  (f : X âŸ¶ Y) : IsIso (Fâ‚.map f) â†” IsIso (Fâ‚‚.map f)",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D]  {E : Type uâ‚ƒ}    [Category.{vâ‚ƒ} E] {F G : C â¥¤ D} {X Y : C} {Fâ‚ Fâ‚‚ : C â¥¤ D}  (e : Fâ‚ â‰… Fâ‚‚)  {X Y : C}  (f : X âŸ¶ Y)"},
 {"type": "Î±.app X = Î².app X",
  "tactic-prompt":
  "theorem {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  {Î± Î² : NatTrans F G}  (h : Î± = Î²)  (X : C) : Î±.app X = Î².app X := by aesop_cat; sorry",
  "name": "congr_app",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  {Î± Î² : NatTrans F G}  (h : Î± = Î²)  (X : C) : Î±.app X = Î².app X",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  {Î± Î² : NatTrans F G}  (h : Î± = Î²)  (X : C)"},
 {"type":
  "Î±.app X â‰« G.map f â‰« G.map g â‰« G.map h = F.map f â‰« F.map g â‰« F.map h â‰« Î±.app V",
  "tactic-prompt":
  "example {C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  (Î± : NatTrans F G)  {X Y U V : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ U)  (h : U âŸ¶ V) : Î±.app X â‰« G.map f â‰« G.map g â‰« G.map h = F.map f â‰« F.map g â‰« F.map h â‰« Î±.app V := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  (Î± : NatTrans F G)  {X Y U V : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ U)  (h : U âŸ¶ V) : Î±.app X â‰« G.map f â‰« G.map g â‰« G.map h = F.map f â‰« F.map g â‰« F.map h â‰« Î±.app V",
  "args":
  "{C : Type uâ‚}  [Category.{vâ‚} C]  {D : Type uâ‚‚}  [Category.{vâ‚‚} D] {F G : C â¥¤ D}  (Î± : NatTrans F G)  {X Y U V : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ U)  (h : U âŸ¶ V)"},
 {"type":
  "(associator F (ðŸ­ B) G).hom â‰« whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G",
  "tactic-prompt":
  "theorem {A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] (F : A â¥¤ B)  (G : B â¥¤ C) : (associator F (ðŸ­ B) G).hom â‰« whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G := by aesop_cat; sorry",
  "name": "triangle",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] (F : A â¥¤ B)  (G : B â¥¤ C) : (associator F (ðŸ­ B) G).hom â‰« whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G",
  "args":
  "{A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] (F : A â¥¤ B)  (G : B â¥¤ C)"},
 {"type":
  "whiskerRight (associator F G H).hom K â‰«\n        (associator F (G â‹™ H) K).hom â‰« whiskerLeft F (associator G H K).hom =\n      (associator (F â‹™ G) H K).hom â‰« (associator F G (H â‹™ K)).hom",
  "tactic-prompt":
  "theorem {A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] {E : Type uâ‚…}  [Category.{vâ‚…} E] (F : A â¥¤ B)  (G : B â¥¤ C)  (H : C â¥¤ D)  (K : D â¥¤ E) : whiskerRight (associator F G H).hom K â‰«\n        (associator F (G â‹™ H) K).hom â‰« whiskerLeft F (associator G H K).hom =\n      (associator (F â‹™ G) H K).hom â‰« (associator F G (H â‹™ K)).hom := by aesop_cat; sorry",
  "name": "pentagon",
  "kind": "theorem",
  "first-tactic": "aesop_cat",
  "core-prompt":
  "{A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] {E : Type uâ‚…}  [Category.{vâ‚…} E] (F : A â¥¤ B)  (G : B â¥¤ C)  (H : C â¥¤ D)  (K : D â¥¤ E) : whiskerRight (associator F G H).hom K â‰«\n        (associator F (G â‹™ H) K).hom â‰« whiskerLeft F (associator G H K).hom =\n      (associator (F â‹™ G) H K).hom â‰« (associator F G (H â‹™ K)).hom",
  "args":
  "{A : Type uâ‚}  [Category.{vâ‚} A] {B : Type uâ‚‚}  [Category.{vâ‚‚} B] {C : Type uâ‚ƒ}  [Category.{vâ‚ƒ} C] {D : Type uâ‚„}  [Category.{vâ‚„} D] {E : Type uâ‚…}  [Category.{vâ‚…} E] (F : A â¥¤ B)  (G : B â¥¤ C)  (H : C â¥¤ D)  (K : D â¥¤ E)"},
 {"type": "Î±.symm.symm = Î±",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (Î± : X â‰… Y) : Î±.symm.symm = Î± := by cases Î±; sorry",
  "name": "symm_symm_eq",
  "kind": "theorem",
  "first-tactic": "cases Î±",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (Î± : X â‰… Y) : Î±.symm.symm = Î±",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y : C}  (Î± : X â‰… Y)"},
 {"type": "(Î± â‰ªâ‰« Î²) â‰ªâ‰« Î³ = Î± â‰ªâ‰« Î² â‰ªâ‰« Î³",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (Î± : X â‰… Y)  (Î² : Y â‰… Z)  (Î³ : Z â‰… Z') : (Î± â‰ªâ‰« Î²) â‰ªâ‰« Î³ = Î± â‰ªâ‰« Î² â‰ªâ‰« Î³ := by ext; sorry",
  "name": "trans_assoc",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (Î± : X â‰… Y)  (Î² : Y â‰… Z)  (Î³ : Z â‰… Z') : (Î± â‰ªâ‰« Î²) â‰ªâ‰« Î³ = Î± â‰ªâ‰« Î² â‰ªâ‰« Î³",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {Z' : C}  (Î± : X â‰… Y)  (Î² : Y â‰… Z)  (Î³ : Z â‰… Z')"},
 {"type": "Iso.refl X â‰ªâ‰« Î± = Î±",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y) : Iso.refl X â‰ªâ‰« Î± = Î± := by ext; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y) : Iso.refl X â‰ªâ‰« Î± = Î±",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)"},
 {"type": "Î± â‰ªâ‰« Iso.refl Y = Î±",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y) : Î± â‰ªâ‰« Iso.refl Y = Î± := by ext; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y) : Î± â‰ªâ‰« Iso.refl Y = Î±",
  "args": "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)"},
 {"type": "Î±.symm â‰ªâ‰« Î± â‰ªâ‰« Î² = Î²",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… Z) : Î±.symm â‰ªâ‰« Î± â‰ªâ‰« Î² = Î² := by rw [â† trans_assoc]; sorry",
  "name": "symm_self_id_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† trans_assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… Z) : Î±.symm â‰ªâ‰« Î± â‰ªâ‰« Î² = Î²",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… Z)"},
 {"type": "Î± â‰ªâ‰« Î±.symm â‰ªâ‰« Î² = Î²",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : X â‰… Z) : Î± â‰ªâ‰« Î±.symm â‰ªâ‰« Î² = Î² := by rw [â† trans_assoc]; sorry",
  "name": "self_symm_id_assoc",
  "kind": "theorem",
  "first-tactic": "rw [â† trans_assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : X â‰… Z) : Î± â‰ªâ‰« Î±.symm â‰ªâ‰« Î² = Î²",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : X â‰… Z)"},
 {"type": "Î±.hom â‰« f = ðŸ™ X â†” f = Î±.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X} : Î±.hom â‰« f = ðŸ™ X â†” f = Î±.inv := by rw [â† eq_inv_comp]; sorry",
  "name": "hom_comp_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [â† eq_inv_comp]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X} : Î±.hom â‰« f = ðŸ™ X â†” f = Î±.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X}"},
 {"type": "f â‰« Î±.hom = ðŸ™ Y â†” f = Î±.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X} : f â‰« Î±.hom = ðŸ™ Y â†” f = Î±.inv := by rw [â† eq_comp_inv]; sorry",
  "name": "comp_hom_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [â† eq_comp_inv]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X} : f â‰« Î±.hom = ðŸ™ Y â†” f = Î±.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  {f : Y âŸ¶ X}"},
 {"type": "Î±.hom = Î².inv â†” Î².hom = Î±.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… X) : Î±.hom = Î².inv â†” Î².hom = Î±.inv := by erw [inv_eq_inv Î±.symm Î²]; sorry",
  "name": "hom_eq_inv",
  "kind": "theorem",
  "first-tactic": "erw [inv_eq_inv Î±.symm Î²]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… X) : Î±.hom = Î².inv â†” Î².hom = Î±.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (Î± : X â‰… Y)  (Î² : Y â‰… X)"},
 {"type": "inv f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (hom_inv_id : f â‰« g = ðŸ™ X) : inv f = g := by apply (cancel_epi f).mp; sorry",
  "name": "inv_eq_of_hom_inv_id",
  "kind": "theorem",
  "first-tactic": "apply (cancel_epi f).mp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (hom_inv_id : f â‰« g = ðŸ™ X) : inv f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (hom_inv_id : f â‰« g = ðŸ™ X)"},
 {"type": "inv f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (inv_hom_id : g â‰« f = ðŸ™ Y) : inv f = g := by apply (cancel_mono f).mp; sorry",
  "name": "inv_eq_of_inv_hom_id",
  "kind": "theorem",
  "first-tactic": "apply (cancel_mono f).mp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (inv_hom_id : g â‰« f = ðŸ™ Y) : inv f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f : X âŸ¶ Y}  [IsIso f]  {g : Y âŸ¶ X}  (inv_hom_id : g â‰« f = ðŸ™ Y)"},
 {"type": "inv (ðŸ™ X) = ðŸ™ X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} : inv (ðŸ™ X) = ðŸ™ X := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_id",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} : inv (ðŸ™ X) = ðŸ™ X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z}"},
 {"type": "inv (f â‰« h) = inv h â‰« inv f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f]  [IsIso h] : inv (f â‰« h) = inv h â‰« inv f := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f]  [IsIso h] : inv (f â‰« h) = inv h â‰« inv f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f]  [IsIso h]"},
 {"type": "inv (inv f) = f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f] : inv (inv f) = f := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f] : inv (inv f) = f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} [IsIso f]"},
 {"type": "inv f.inv = f.hom",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y) : inv f.inv = f.hom := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "Iso.inv_inv",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y) : inv f.inv = f.hom",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y)"},
 {"type": "inv f.hom = f.inv",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y) : inv f.hom = f.inv := by apply inv_eq_of_hom_inv_id; sorry",
  "name": "Iso.inv_hom",
  "kind": "theorem",
  "first-tactic": "apply inv_eq_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y) : inv f.hom = f.inv",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (f : X â‰… Y)"},
 {"type": "IsIso g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso f]  [IsIso (f â‰« g)] : IsIso g := by rw [â† id_comp g]; sorry",
  "name": "of_isIso_comp_left",
  "kind": "theorem",
  "first-tactic": "rw [â† id_comp g]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso f]  [IsIso (f â‰« g)] : IsIso g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso f]  [IsIso (f â‰« g)]"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso g]  [IsIso (f â‰« g)] : IsIso f := by rw [â† comp_id f]; sorry",
  "name": "of_isIso_comp_right",
  "kind": "theorem",
  "first-tactic": "rw [â† comp_id f]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso g]  [IsIso (f â‰« g)] : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [IsIso g]  [IsIso (f â‰« g)]"},
 {"type": "IsIso g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso f]      [hh : IsIso h]  (w : f â‰« g = h) : IsIso g := by rw [â† w] at hh; sorry",
  "name": "of_isIso_fac_left",
  "kind": "theorem",
  "first-tactic": "rw [â† w] at hh",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso f]      [hh : IsIso h]  (w : f â‰« g = h) : IsIso g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso f]      [hh : IsIso h]  (w : f â‰« g = h)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso g]      [hh : IsIso h]  (w : f â‰« g = h) : IsIso f := by rw [â† w] at hh; sorry",
  "name": "of_isIso_fac_right",
  "kind": "theorem",
  "first-tactic": "rw [â† w] at hh",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso g]      [hh : IsIso h]  (w : f â‰« g = h) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [IsIso g]      [hh : IsIso h]  (w : f â‰« g = h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {f g : X âŸ¶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g) : f = g := by apply (cancel_epi (inv f)).1; sorry",
  "name": "eq_of_inv_eq_inv",
  "kind": "theorem",
  "first-tactic": "apply (cancel_epi (inv f)).1",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {f g : X âŸ¶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {f g : X âŸ¶ Y}  [IsIso f]  [IsIso g]  (p : inv f = inv g)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : g â‰« f = ðŸ™ X) : IsIso f := by rw [(hom_comp_eq_id _).mp h]; sorry",
  "name": "isIso_of_hom_comp_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [(hom_comp_eq_id _).mp h]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : g â‰« f = ðŸ™ X) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : g â‰« f = ðŸ™ X)"},
 {"type": "IsIso f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : f â‰« g = ðŸ™ Y) : IsIso f := by rw [(comp_hom_eq_id _).mp h]; sorry",
  "name": "isIso_of_comp_hom_eq_id",
  "kind": "theorem",
  "first-tactic": "rw [(comp_hom_eq_id _).mp h]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : f â‰« g = ðŸ™ Y) : IsIso f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} (g : X âŸ¶ Y)  [IsIso g]  {f : Y âŸ¶ X}  (h : f â‰« g = ðŸ™ Y)"},
 {"type": "f.hom â‰« g = f.hom â‰« g' â†” g = g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X â‰… Y)  (g g' : Y âŸ¶ Z) : f.hom â‰« g = f.hom â‰« g' â†” g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_iso_hom_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X â‰… Y)  (g g' : Y âŸ¶ Z) : f.hom â‰« g = f.hom â‰« g' â†” g = g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : X â‰… Y)  (g g' : Y âŸ¶ Z)"},
 {"type": "f.inv â‰« g = f.inv â‰« g' â†” g = g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : Y â‰… X)  (g g' : Y âŸ¶ Z) : f.inv â‰« g = f.inv â‰« g' â†” g = g' := by simp only [cancel_epi]; sorry",
  "name": "cancel_iso_inv_left",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_epi]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : Y â‰… X)  (g g' : Y âŸ¶ Z) : f.inv â‰« g = f.inv â‰« g' â†” g = g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f : Y â‰… X)  (g g' : Y âŸ¶ Z)"},
 {"type": "f â‰« g.hom = f' â‰« g.hom â†” f = f'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y â‰… Z) : f â‰« g.hom = f' â‰« g.hom â†” f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_iso_hom_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y â‰… Z) : f â‰« g.hom = f' â‰« g.hom â†” f = f'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y â‰… Z)"},
 {"type": "f â‰« g.inv = f' â‰« g.inv â†” f = f'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Z â‰… Y) : f â‰« g.inv = f' â‰« g.inv â†” f = f' := by simp only [cancel_mono]; sorry",
  "name": "cancel_iso_inv_right",
  "kind": "theorem",
  "first-tactic": "simp only [cancel_mono]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Z â‰… Y) : f â‰« g.inv = f' â‰« g.inv â†” f = f'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Z â‰… Y)"},
 {"type": "f â‰« g â‰« h.hom = f' â‰« g' â‰« h.hom â†” f â‰« g = f' â‰« g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Y â‰… Z) : f â‰« g â‰« h.hom = f' â‰« g' â‰« h.hom â†” f â‰« g = f' â‰« g' := by simp only [â† Category.assoc]; sorry",
  "name": "cancel_iso_hom_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [â† Category.assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Y â‰… Z) : f â‰« g â‰« h.hom = f' â‰« g' â‰« h.hom â†” f â‰« g = f' â‰« g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Y â‰… Z)"},
 {"type": "f â‰« g â‰« h.inv = f' â‰« g' â‰« h.inv â†” f â‰« g = f' â‰« g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Z â‰… Y) : f â‰« g â‰« h.inv = f' â‰« g' â‰« h.inv â†” f â‰« g = f' â‰« g' := by simp only [â† Category.assoc]; sorry",
  "name": "cancel_iso_inv_right_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [â† Category.assoc]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Z â‰… Y) : f â‰« g â‰« h.inv = f' â‰« g' â‰« h.inv â†” f â‰« g = f' â‰« g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {W X X' Y Z : C}  (f : W âŸ¶ X)  (g : X âŸ¶ Y)  (f' : W âŸ¶ X')      (g' : X' âŸ¶ Y)  (h : Z â‰… Y)"},
 {"type": "F.mapIso (i â‰ªâ‰« j) = F.mapIso i â‰ªâ‰« F.mapIso j",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y Z : C}  (i : X â‰… Y)  (j : Y â‰… Z) : F.mapIso (i â‰ªâ‰« j) = F.mapIso i â‰ªâ‰« F.mapIso j := by ext; sorry",
  "name": "mapIso_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y Z : C}  (i : X â‰… Y)  (j : Y â‰… Z) : F.mapIso (i â‰ªâ‰« j) = F.mapIso i â‰ªâ‰« F.mapIso j",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y Z : C}  (i : X â‰… Y)  (j : Y â‰… Z)"},
 {"type": "F.map (inv f) = inv (F.map f)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map (inv f) = inv (F.map f) := by apply eq_inv_of_hom_inv_id; sorry",
  "name": "map_inv",
  "kind": "theorem",
  "first-tactic": "apply eq_inv_of_hom_inv_id",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map (inv f) = inv (F.map f)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f]"},
 {"type": "F.map f â‰« F.map (inv f) = ðŸ™ (F.obj X)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map f â‰« F.map (inv f) = ðŸ™ (F.obj X) := by simp; sorry",
  "name": "map_hom_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map f â‰« F.map (inv f) = ðŸ™ (F.obj X)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f]"},
 {"type": "F.map (inv f) â‰« F.map f = ðŸ™ (F.obj Y)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map (inv f) â‰« F.map f = ðŸ™ (F.obj Y) := by simp; sorry",
  "name": "map_inv_hom",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f] : F.map (inv f) â‰« F.map f = ðŸ™ (F.obj Y)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  {h : Y âŸ¶ Z} {D : Type uâ‚‚} [Category.{vâ‚‚} D] (F : C â¥¤ D)  {X Y : C}  (f : X âŸ¶ Y)  [IsIso f]"},
 {"type": "f â‰« h = g â‰« h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : f = g)  (h : Y âŸ¶ Z) : f â‰« h = g â‰« h := by rw [w]; sorry",
  "name": "eq_whisker",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : f = g)  (h : Y âŸ¶ Z) : f â‰« h = g â‰« h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : f = g)  (h : Y âŸ¶ Z)"},
 {"type": "f â‰« g = f â‰« h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  {g h : Y âŸ¶ Z}  (w : g = h) : f â‰« g = f â‰« h := by rw [w]; sorry",
  "name": "whisker_eq",
  "kind": "theorem",
  "first-tactic": "rw [w]",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  {g h : Y âŸ¶ Z}  (w : g = h) : f â‰« g = f â‰« h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  {g h : Y âŸ¶ Z}  (w : g = h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : âˆ€ {Z : C} (h : Y âŸ¶ Z), f â‰« h = g â‰« h) : f = g := by convert w (ðŸ™ Y); sorry",
  "name": "eq_of_comp_left_eq",
  "kind": "theorem",
  "first-tactic": "convert w (ðŸ™ Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : âˆ€ {Z : C} (h : Y âŸ¶ Z), f â‰« h = g â‰« h) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : X âŸ¶ Y}  (w : âˆ€ {Z : C} (h : Y âŸ¶ Z), f â‰« h = g â‰« h)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y âŸ¶ Z}  (w : âˆ€ {X : C} (h : X âŸ¶ Y), h â‰« f = h â‰« g) : f = g := by convert w (ðŸ™ Y); sorry",
  "name": "eq_of_comp_right_eq",
  "kind": "theorem",
  "first-tactic": "convert w (ðŸ™ Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y âŸ¶ Z}  (w : âˆ€ {X : C} (h : X âŸ¶ Y), h â‰« f = h â‰« g) : f = g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {f g : Y âŸ¶ Z}  (w : âˆ€ {X : C} (h : X âŸ¶ Y), h â‰« f = h â‰« g)"},
 {"type": "f = ðŸ™ X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : X âŸ¶ Y), f â‰« g = g) : f = ðŸ™ X := by convert w (ðŸ™ X); sorry",
  "name": "id_of_comp_left_id",
  "kind": "theorem",
  "first-tactic": "convert w (ðŸ™ X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : X âŸ¶ Y), f â‰« g = g) : f = ðŸ™ X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : X âŸ¶ Y), f â‰« g = g)"},
 {"type": "f = ðŸ™ X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : Y âŸ¶ X), g â‰« f = g) : f = ðŸ™ X := by convert w (ðŸ™ X); sorry",
  "name": "id_of_comp_right_id",
  "kind": "theorem",
  "first-tactic": "convert w (ðŸ™ X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : Y âŸ¶ X), g â‰« f = g) : f = ðŸ™ X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ X)  (w : âˆ€ {Y : C} (g : Y âŸ¶ X), g â‰« f = g)"},
 {"type": "(f â‰« if P then g else g') = if P then f â‰« g else f â‰« g'",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X âŸ¶ Y)  (g g' : Y âŸ¶ Z) : (f â‰« if P then g else g') = if P then f â‰« g else f â‰« g' := by aesop; sorry",
  "name": "comp_ite",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X âŸ¶ Y)  (g g' : Y âŸ¶ Z) : (f â‰« if P then g else g') = if P then f â‰« g else f â‰« g'",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f : X âŸ¶ Y)  (g g' : Y âŸ¶ Z)"},
 {"type": "(if P then f else f') â‰« g = if P then f â‰« g else f' â‰« g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y âŸ¶ Z) : (if P then f else f') â‰« g = if P then f â‰« g else f' â‰« g := by aesop; sorry",
  "name": "ite_comp",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y âŸ¶ Z) : (if P then f else f') â‰« g = if P then f â‰« g else f' â‰« g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]  {X Y Z : C}  (f f' : X âŸ¶ Y)  (g : Y âŸ¶ Z)"},
 {"type":
  "(f â‰« if h : P then g h else g' h) = if h : P then f â‰« g h else f â‰« g' h",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X âŸ¶ Y)  (g : P â†’ (Y âŸ¶ Z))  (g' : Â¬P â†’ (Y âŸ¶ Z)) : (f â‰« if h : P then g h else g' h) = if h : P then f â‰« g h else f â‰« g' h := by aesop; sorry",
  "name": "comp_dite",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X âŸ¶ Y)  (g : P â†’ (Y âŸ¶ Z))  (g' : Â¬P â†’ (Y âŸ¶ Z)) : (f â‰« if h : P then g h else g' h) = if h : P then f â‰« g h else f â‰« g' h",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : X âŸ¶ Y)  (g : P â†’ (Y âŸ¶ Z))  (g' : Â¬P â†’ (Y âŸ¶ Z))"},
 {"type":
  "(if h : P then f h else f' h) â‰« g = if h : P then f h â‰« g else f' h â‰« g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P â†’ (X âŸ¶ Y))  (f' : Â¬P â†’ (X âŸ¶ Y))  (g : Y âŸ¶ Z) : (if h : P then f h else f' h) â‰« g = if h : P then f h â‰« g else f' h â‰« g := by aesop; sorry",
  "name": "dite_comp",
  "kind": "theorem",
  "first-tactic": "aesop",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P â†’ (X âŸ¶ Y))  (f' : Â¬P â†’ (X âŸ¶ Y))  (g : Y âŸ¶ Z) : (if h : P then f h else f' h) â‰« g = if h : P then f h â‰« g else f' h â‰« g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {P : Prop}  [Decidable P]      {X Y Z : C}  (f : P â†’ (X âŸ¶ Y))  (f' : Â¬P â†’ (X âŸ¶ Y))  (g : Y âŸ¶ Z)"},
 {"type": "f â‰« h = f â†” h = ðŸ™ Y",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Epi f]  {h : Y âŸ¶ Y} : f â‰« h = f â†” h = ðŸ™ Y := by convert @cancel_epi _ _ _ _ _ f _ h (ðŸ™ Y); sorry",
  "name": "cancel_epi_id",
  "kind": "theorem",
  "first-tactic": "convert @cancel_epi _ _ _ _ _ f _ h (ðŸ™ Y)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Epi f]  {h : Y âŸ¶ Y} : f â‰« h = f â†” h = ðŸ™ Y",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Epi f]  {h : Y âŸ¶ Y}"},
 {"type": "g â‰« f = f â†” g = ðŸ™ X",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Mono f]  {g : X âŸ¶ X} : g â‰« f = f â†” g = ðŸ™ X := by convert @cancel_mono _ _ _ _ _ f _ g (ðŸ™ X); sorry",
  "name": "cancel_mono_id",
  "kind": "theorem",
  "first-tactic": "convert @cancel_mono _ _ _ _ _ f _ g (ðŸ™ X)",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Mono f]  {g : X âŸ¶ X} : g â‰« f = f â†” g = ðŸ™ X",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} (f : X âŸ¶ Y)  [Mono f]  {g : X âŸ¶ X}"},
 {"type": "Epi (f â‰« g)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Epi f]  (g : Y âŸ¶ Z)  [Epi g] : Epi (f â‰« g) := by constructor; sorry",
  "name": "epi_comp",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Epi f]  (g : Y âŸ¶ Z)  [Epi g] : Epi (f â‰« g)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Epi f]  (g : Y âŸ¶ Z)  [Epi g]"},
 {"type": "Mono (f â‰« g)",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Mono f]  (g : Y âŸ¶ Z)  [Mono g] : Mono (f â‰« g) := by constructor; sorry",
  "name": "mono_comp",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Mono f]  (g : Y âŸ¶ Z)  [Mono g] : Mono (f â‰« g)",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  [Mono f]  (g : Y âŸ¶ Z)  [Mono g]"},
 {"type": "Mono f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Mono (f â‰« g)] : Mono f := by constructor; sorry",
  "name": "mono_of_mono",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Mono (f â‰« g)] : Mono f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Mono (f â‰« g)]"},
 {"type": "Mono f",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Mono h]      (w : f â‰« g = h) : Mono f := by subst h; sorry",
  "name": "mono_of_mono_fac",
  "kind": "theorem",
  "first-tactic": "subst h",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Mono h]      (w : f â‰« g = h) : Mono f",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Mono h]      (w : f â‰« g = h)"},
 {"type": "Epi g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Epi (f â‰« g)] : Epi g := by constructor; sorry",
  "name": "epi_of_epi",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Epi (f â‰« g)] : Epi g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  [Epi (f â‰« g)]"},
 {"type": "Epi g",
  "tactic-prompt":
  "theorem {C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Epi h]      (w : f â‰« g = h) : Epi g := by subst h; sorry",
  "name": "epi_of_epi_fac",
  "kind": "theorem",
  "first-tactic": "subst h",
  "core-prompt":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Epi h]      (w : f â‰« g = h) : Epi g",
  "args":
  "{C : Type u}  [Category.{v} C]  {X Y Z : C} {X Y Z : C}  {f : X âŸ¶ Y}  {g : Y âŸ¶ Z}  {h : X âŸ¶ Z}  [Epi h]      (w : f â‰« g = h)"},
 {"type": "LargeCategory (ULift.{u + 1} D)",
  "tactic-prompt":
  "example (C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D] : LargeCategory (ULift.{u + 1} D) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D] : LargeCategory (ULift.{u + 1} D)",
  "args": "(C : Type u) [Category.{v} C] (D : Type u)  [SmallCategory D]"},
 {"type": "Inhabited RelCat",
  "tactic-prompt": "instance  : Inhabited RelCat := by unfold RelCat; sorry",
  "name": "RelCat.inhabited",
  "kind": "instance",
  "first-tactic": "unfold RelCat",
  "core-prompt": " : Inhabited RelCat",
  "args": ""},
 {"type": "HEq a b â†” HEq (a : Î±) (b : Î²)",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q) : HEq a b â†” HEq (a : Î±) (b : Î²) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q) : HEq a b â†” HEq (a : Î±) (b : Î²)",
  "args":
  "{Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}      {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q)"},
 {"type": "(âˆƒ h : p b, Subtype.mk b h = a) â†” b = a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {a : Subtype p}  {b : Î±} : (âˆƒ h : p b, Subtype.mk b h = a) â†” b = a := by simp only [@eq_comm _ b]; sorry",
  "name": "_root_.exists_subtype_mk_eq_iff",
  "kind": "theorem",
  "first-tactic": "simp only [@eq_comm _ b]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {a : Subtype p}  {b : Î±} : (âˆƒ h : p b, Subtype.mk b h = a) â†” b = a",
  "args": "{Î± Î² Î³ : Sort _}  {p q : Î± â†’ Prop} {a : Subtype p}  {b : Î±}"},
 {"type":
  "(mod m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) (k : â„•) ((m : â„•) % (k : â„•))",
  "tactic-prompt":
  "theorem (m k : â„•+) : (mod m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) (k : â„•) ((m : â„•) % (k : â„•)) := by dsimp [mod]; sorry",
  "name": "mod_coe",
  "kind": "theorem",
  "first-tactic": "dsimp [mod]",
  "core-prompt":
  "(m k : â„•+) : (mod m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) (k : â„•) ((m : â„•) % (k : â„•))",
  "args": "(m k : â„•+)"},
 {"type":
  "(div m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) ((m : â„•) / (k : â„•)).pred ((m : â„•) / (k : â„•))",
  "tactic-prompt":
  "theorem (m k : â„•+) : (div m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) ((m : â„•) / (k : â„•)).pred ((m : â„•) / (k : â„•)) := by dsimp [div]; sorry",
  "name": "div_coe",
  "kind": "theorem",
  "first-tactic": "dsimp [div]",
  "core-prompt":
  "(m k : â„•+) : (div m k : â„•) = ite ((m : â„•) % (k : â„•) = 0) ((m : â„•) / (k : â„•)).pred ((m : â„•) / (k : â„•))",
  "args": "(m k : â„•+)"},
 {"type": "Finite Î²",
  "tactic-prompt":
  "theorem {Î± Î² : Sort _} (Î± : Sort _)  [h : Finite Î±]  (f : Î± â‰ƒ Î²) : Finite Î² := by cases' h with n e; sorry",
  "name": "Finite.of_equiv",
  "kind": "theorem",
  "first-tactic": "cases' h with n e",
  "core-prompt":
  "{Î± Î² : Sort _} (Î± : Sort _)  [h : Finite Î±]  (f : Î± â‰ƒ Î²) : Finite Î²",
  "args": "{Î± Î² : Sort _} (Î± : Sort _)  [h : Finite Î±]  (f : Î± â‰ƒ Î²)"},
 {"type": "(infâ‚› s).Rel = infâ‚› (Rel '' s)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)} : (infâ‚› s).Rel = infâ‚› (Rel '' s) := by ext; sorry",
  "name": "infâ‚›_def",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)} : (infâ‚› s).Rel = infâ‚› (Rel '' s)",
  "args": "{Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)}"},
 {"type": "s = (âŠ¤ : Setoid Î±) â†” âˆ€ x y : Î±, s.Rel x y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {s : Setoid Î±} : s = (âŠ¤ : Setoid Î±) â†” âˆ€ x y : Î±, s.Rel x y := by rw [_root_.eq_top_iff]; sorry",
  "name": "eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [_root_.eq_top_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {s : Setoid Î±} : s = (âŠ¤ : Setoid Î±) â†” âˆ€ x y : Î±, s.Rel x y",
  "args": "{Î± : Type _}  {Î² : Type _} {s : Setoid Î±}"},
 {"type": "r âŠ” s = EqvGen.Setoid fun x y => r.Rel x y âˆ¨ s.Rel x y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (r s : Setoid Î±) : r âŠ” s = EqvGen.Setoid fun x y => r.Rel x y âˆ¨ s.Rel x y := by rw [eqvGen_eq]; sorry",
  "name": "sup_eq_eqvGen",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (r s : Setoid Î±) : r âŠ” s = EqvGen.Setoid fun x y => r.Rel x y âˆ¨ s.Rel x y",
  "args": "{Î± : Type _}  {Î² : Type _} (r s : Setoid Î±)"},
 {"type": "r âŠ” s = EqvGen.Setoid (r.Rel âŠ” s.Rel)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {r s : Setoid Î±} : r âŠ” s = EqvGen.Setoid (r.Rel âŠ” s.Rel) := by rw [sup_eq_eqvGen]; sorry",
  "name": "sup_def",
  "kind": "theorem",
  "first-tactic": "rw [sup_eq_eqvGen]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {r s : Setoid Î±} : r âŠ” s = EqvGen.Setoid (r.Rel âŠ” s.Rel)",
  "args": "{Î± : Type _}  {Î² : Type _} {r s : Setoid Î±}"},
 {"type": "supâ‚› S = EqvGen.Setoid fun x y => âˆƒ r : Setoid Î±, r âˆˆ S âˆ§ r.Rel x y",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (S : Set (Setoid Î±)) : supâ‚› S = EqvGen.Setoid fun x y => âˆƒ r : Setoid Î±, r âˆˆ S âˆ§ r.Rel x y := by rw [eqvGen_eq]; sorry",
  "name": "supâ‚›_eq_eqvGen",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (S : Set (Setoid Î±)) : supâ‚› S = EqvGen.Setoid fun x y => âˆƒ r : Setoid Î±, r âˆˆ S âˆ§ r.Rel x y",
  "args": "{Î± : Type _}  {Î² : Type _} (S : Set (Setoid Î±))"},
 {"type": "supâ‚› s = EqvGen.Setoid (supâ‚› (Rel '' s))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)} : supâ‚› s = EqvGen.Setoid (supâ‚› (Rel '' s)) := by rw [supâ‚›_eq_eqvGen]; sorry",
  "name": "supâ‚›_def",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_eq_eqvGen]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)} : supâ‚› s = EqvGen.Setoid (supâ‚› (Rel '' s))",
  "args": "{Î± : Type _}  {Î² : Type _} {s : Set (Setoid Î±)}"},
 {"type": "EqvGen.Setoid r â‰¤ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {r : Î± â†’ Î± â†’ Prop}  {s : Setoid Î±}  (h : âˆ€ x y, r x y â†’ s.Rel x y) : EqvGen.Setoid r â‰¤ s := by rw [eqvGen_eq]; sorry",
  "name": "eqvGen_le",
  "kind": "theorem",
  "first-tactic": "rw [eqvGen_eq]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {r : Î± â†’ Î± â†’ Prop}  {s : Setoid Î±}  (h : âˆ€ x y, r x y â†’ s.Rel x y) : EqvGen.Setoid r â‰¤ s",
  "args":
  "{Î± : Type _}  {Î² : Type _} {r : Î± â†’ Î± â†’ Prop}  {s : Setoid Î±}  (h : âˆ€ x y, r x y â†’ s.Rel x y)"},
 {"type": "Quotient.lift f H = g",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} {r : Setoid Î±}  {f : Î± â†’ Î²}  (H : r â‰¤ ker f)  (g : Quotient r â†’ Î²)      (Hg : f = g âˆ˜ Quotient.mk'') : Quotient.lift f H = g := by ext âŸ¨xâŸ©; sorry",
  "name": "lift_unique",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨xâŸ©",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} {r : Setoid Î±}  {f : Î± â†’ Î²}  (H : r â‰¤ ker f)  (g : Quotient r â†’ Î²)      (Hg : f = g âˆ˜ Quotient.mk'') : Quotient.lift f H = g",
  "args":
  "{Î± : Type _}  {Î² : Type _} {r : Setoid Î±}  {f : Î± â†’ Î²}  (H : r â‰¤ ker f)  (g : Quotient r â†’ Î²)      (Hg : f = g âˆ˜ Quotient.mk'')"},
 {"type": "map r f = mapOfSurjective r f h hf",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (h : ker f â‰¤ r)  (hf : Surjective f) : map r f = mapOfSurjective r f h hf := by rw [â† eqvGen_of_setoid (mapOfSurjective r f h hf)]; sorry",
  "name": "mapOfSurjective_eq_map",
  "kind": "theorem",
  "first-tactic": "rw [â† eqvGen_of_setoid (mapOfSurjective r f h hf)]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (h : ker f â‰¤ r)  (hf : Surjective f) : map r f = mapOfSurjective r f h hf",
  "args":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (h : ker f â‰¤ r)  (hf : Surjective f)"},
 {"type": "Subsingleton (Quotient s) â†” s = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) {s : Setoid Î±} : Subsingleton (Quotient s) â†” s = âŠ¤ := by simp only [_root_.subsingleton_iff]; sorry",
  "name": "Quotient.subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.subsingleton_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) {s : Setoid Î±} : Subsingleton (Quotient s) â†” s = âŠ¤",
  "args":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) {s : Setoid Î±}"},
 {"type": "Subsingleton (Quot r) â†” EqvGen r = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (r : Î± â†’ Î± â†’ Prop) : Subsingleton (Quot r) â†” EqvGen r = âŠ¤ := by simp only [_root_.subsingleton_iff]; sorry",
  "name": "Quot.subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp only [_root_.subsingleton_iff]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (r : Î± â†’ Î± â†’ Prop) : Subsingleton (Quot r) â†” EqvGen r = âŠ¤",
  "args":
  "{Î± : Type _}  {Î² : Type _} (r : Setoid Î±)  (f : Î± â†’ Î²) (r : Î± â†’ Î± â†’ Prop)"},
 {"type":
  "(n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1)",
  "tactic-prompt":
  "theorem {n k : â„•}  (h : k < n) : (n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1) := by let t := n - k.succ; sorry",
  "name": "ascFactorial_of_sub",
  "kind": "theorem",
  "first-tactic": "let t := n - k.succ",
  "core-prompt":
  "{n k : â„•}  (h : k < n) : (n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1)",
  "args": "{n k : â„•}  (h : k < n)"},
 {"type": "(n + 1) ^ (k + 2) < n.ascFactorial (k + 2)",
  "tactic-prompt":
  "theorem (n k : â„•) : (n + 1) ^ (k + 2) < n.ascFactorial (k + 2) := by rw [pow_succ]; sorry",
  "name": "pow_lt_ascFactorial'",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt": "(n k : â„•) : (n + 1) ^ (k + 2) < n.ascFactorial (k + 2)",
  "args": "(n k : â„•)"},
 {"type": "(0 : â„•).descFactorial k.succ = 0",
  "tactic-prompt":
  "theorem (k : â„•) : (0 : â„•).descFactorial k.succ = 0 := by rw [descFactorial_succ]; sorry",
  "name": "zero_descFactorial_succ",
  "kind": "theorem",
  "first-tactic": "rw [descFactorial_succ]",
  "core-prompt": "(k : â„•) : (0 : â„•).descFactorial k.succ = 0",
  "args": "(k : â„•)"},
 {"type": "n.descFactorial 1 = n",
  "tactic-prompt":
  "theorem (n : â„•) : n.descFactorial 1 = n := by rw [descFactorial_succ]; sorry",
  "name": "descFactorial_one",
  "kind": "theorem",
  "first-tactic": "rw [descFactorial_succ]",
  "core-prompt": "(n : â„•) : n.descFactorial 1 = n",
  "args": "(n : â„•)"},
 {"type": "dist n m = dist m n",
  "tactic-prompt":
  "theorem (n m : â„•) : dist n m = dist m n := by simp [dist.def]; sorry",
  "name": "dist_comm",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "(n m : â„•) : dist n m = dist m n",
  "args": "(n m : â„•)"},
 {"type": "dist n n = 0",
  "tactic-prompt":
  "theorem (n : â„•) : dist n n = 0 := by simp [dist.def]; sorry",
  "name": "dist_self",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "(n : â„•) : dist n n = 0",
  "args": "(n : â„•)"},
 {"type": "dist n m = 0",
  "tactic-prompt":
  "theorem {n m : â„•}  (h : n = m) : dist n m = 0 := by rw [h]; sorry",
  "name": "dist_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{n m : â„•}  (h : n = m) : dist n m = 0",
  "args": "{n m : â„•}  (h : n = m)"},
 {"type": "dist n m = m - n",
  "tactic-prompt":
  "theorem {n m : â„•}  (h : n â‰¤ m) : dist n m = m - n := by rw [dist.def]; sorry",
  "name": "dist_eq_sub_of_le",
  "kind": "theorem",
  "first-tactic": "rw [dist.def]",
  "core-prompt": "{n m : â„•}  (h : n â‰¤ m) : dist n m = m - n",
  "args": "{n m : â„•}  (h : n â‰¤ m)"},
 {"type": "dist n m = n - m",
  "tactic-prompt":
  "theorem {n m : â„•}  (h : m â‰¤ n) : dist n m = n - m := by rw [dist_comm]; sorry",
  "name": "dist_eq_sub_of_le_right",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "{n m : â„•}  (h : m â‰¤ n) : dist n m = n - m",
  "args": "{n m : â„•}  (h : m â‰¤ n)"},
 {"type": "m â‰¤ n + dist n m",
  "tactic-prompt":
  "theorem (n m : â„•) : m â‰¤ n + dist n m := by rw [add_comm]; sorry",
  "name": "dist_tri_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(n m : â„•) : m â‰¤ n + dist n m",
  "args": "(n m : â„•)"},
 {"type": "n â‰¤ dist n m + m",
  "tactic-prompt":
  "theorem (n m : â„•) : n â‰¤ dist n m + m := by rw [dist_comm]; sorry",
  "name": "dist_tri_left'",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "(n m : â„•) : n â‰¤ dist n m + m",
  "args": "(n m : â„•)"},
 {"type": "n â‰¤ m + dist n m",
  "tactic-prompt":
  "theorem (n m : â„•) : n â‰¤ m + dist n m := by rw [dist_comm]; sorry",
  "name": "dist_tri_right'",
  "kind": "theorem",
  "first-tactic": "rw [dist_comm]",
  "core-prompt": "(n m : â„•) : n â‰¤ m + dist n m",
  "args": "(n m : â„•)"},
 {"type": "dist (k + n) (k + m) = dist n m",
  "tactic-prompt":
  "theorem (k n m : â„•) : dist (k + n) (k + m) = dist n m := by rw [add_comm k n]; sorry",
  "name": "dist_add_add_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm k n]",
  "core-prompt": "(k n m : â„•) : dist (k + n) (k + m) = dist n m",
  "args": "(k n m : â„•)"},
 {"type": "dist n k â‰¤ dist n m + dist m k",
  "tactic-prompt":
  "theorem (n m k : â„•) : dist n k â‰¤ dist n m + dist m k := by have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by\n    simp [dist.def]; sorry",
  "name": "dist.triangle_inequality",
  "kind": "theorem",
  "first-tactic":
  "have : dist n m + dist m k = n - m + (m - k) + (k - m + (m - n)) := by\n    simp [dist.def]",
  "core-prompt": "(n m k : â„•) : dist n k â‰¤ dist n m + dist m k",
  "args": "(n m k : â„•)"},
 {"type": "dist (n * k) (m * k) = dist n m * k",
  "tactic-prompt":
  "theorem (n k m : â„•) : dist (n * k) (m * k) = dist n m * k := by rw [dist.def]; sorry",
  "name": "dist_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [dist.def]",
  "core-prompt": "(n k m : â„•) : dist (n * k) (m * k) = dist n m * k",
  "args": "(n k m : â„•)"},
 {"type": "dist (k * n) (k * m) = k * dist n m",
  "tactic-prompt":
  "theorem (k n m : â„•) : dist (k * n) (k * m) = k * dist n m := by rw [mul_comm k n]; sorry",
  "name": "dist_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm k n]",
  "core-prompt": "(k n m : â„•) : dist (k * n) (k * m) = k * dist n m",
  "args": "(k n m : â„•)"},
 {"type": "dist (succ i) (succ j) = dist i j",
  "tactic-prompt":
  "theorem {i j : Nat} : dist (succ i) (succ j) = dist i j := by simp [dist.def]; sorry",
  "name": "dist_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [dist.def]",
  "core-prompt": "{i j : Nat} : dist (succ i) (succ j) = dist i j",
  "args": "{i j : Nat}"},
 {"type": "size 0 = 0",
  "tactic-prompt": "theorem  : size 0 = 0 := by simp [size]; sorry",
  "name": "size_zero",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": " : size 0 = 0",
  "args": ""},
 {"type": "n < 2 ^ size n",
  "tactic-prompt":
  "theorem (n : â„•) : n < 2 ^ size n := by rw [â† one_shiftl]; sorry",
  "name": "lt_size_self",
  "kind": "theorem",
  "first-tactic": "rw [â† one_shiftl]",
  "core-prompt": "(n : â„•) : n < 2 ^ size n",
  "args": "(n : â„•)"},
 {"type": "m < size n â†” 2 ^ m â‰¤ n",
  "tactic-prompt":
  "theorem {m n : â„•} : m < size n â†” 2 ^ m â‰¤ n := by rw [â† not_lt]; sorry",
  "name": "lt_size",
  "kind": "theorem",
  "first-tactic": "rw [â† not_lt]",
  "core-prompt": "{m n : â„•} : m < size n â†” 2 ^ m â‰¤ n",
  "args": "{m n : â„•}"},
 {"type": "0 < size n â†” 0 < n",
  "tactic-prompt":
  "theorem {n : â„•} : 0 < size n â†” 0 < n := by rw [lt_size]; sorry",
  "name": "size_pos",
  "kind": "theorem",
  "first-tactic": "rw [lt_size]",
  "core-prompt": "{n : â„•} : 0 < size n â†” 0 < n",
  "args": "{n : â„•}"},
 {"type": "size n = 0 â†” n = 0",
  "tactic-prompt":
  "theorem {n : â„•} : size n = 0 â†” n = 0 := by have := @size_pos n; sorry",
  "name": "size_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := @size_pos n",
  "core-prompt": "{n : â„•} : size n = 0 â†” n = 0",
  "args": "{n : â„•}"},
 {"type": "n.bits.length = n.size",
  "tactic-prompt":
  "theorem (n : â„•) : n.bits.length = n.size := by induction' n using Nat.binaryRec' with b n h ih; sorry",
  "name": "size_eq_bits_len",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h ih",
  "core-prompt": "(n : â„•) : n.bits.length = n.size",
  "args": "(n : â„•)"},
 {"type": "choose n 0 = 1",
  "tactic-prompt": "theorem (n : â„•) : choose n 0 = 1 := by cases n; sorry",
  "name": "choose_zero_right",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : â„•) : choose n 0 = 1",
  "args": "(n : â„•)"},
 {"type": "choose n n = 1",
  "tactic-prompt": "theorem (n : â„•) : choose n n = 1 := by induction n; sorry",
  "name": "choose_self",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : â„•) : choose n n = 1",
  "args": "(n : â„•)"},
 {"type": "choose n 1 = n",
  "tactic-prompt": "theorem (n : â„•) : choose n 1 = n := by induction n; sorry",
  "name": "choose_one_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : â„•) : choose n 1 = n",
  "args": "(n : â„•)"},
 {"type": "(n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n",
  "tactic-prompt":
  "theorem (n : â„•) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n := by rw [â† add_mul_div_left]; sorry",
  "name": "triangle_succ",
  "kind": "theorem",
  "first-tactic": "rw [â† add_mul_div_left]",
  "core-prompt": "(n : â„•) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n",
  "args": "(n : â„•)"},
 {"type": "choose n 2 = n * (n - 1) / 2",
  "tactic-prompt":
  "theorem (n : â„•) : choose n 2 = n * (n - 1) / 2 := by induction' n with n ih; sorry",
  "name": "choose_two_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "(n : â„•) : choose n 2 = n * (n - 1) / 2",
  "args": "(n : â„•)"},
 {"type": "n.choose k * k.choose s = n.choose s * (n - s).choose (k - s)",
  "tactic-prompt":
  "theorem {n k s : â„•}  (hkn : k â‰¤ n)  (hsk : s â‰¤ k) : n.choose k * k.choose s = n.choose s * (n - s).choose (k - s) := by have h : 0 < (n - k); sorry",
  "name": "choose_mul",
  "kind": "theorem",
  "first-tactic": "have h : 0 < (n - k)",
  "core-prompt":
  "{n k s : â„•}  (hkn : k â‰¤ n)  (hsk : s â‰¤ k) : n.choose k * k.choose s = n.choose s * (n - s).choose (k - s)",
  "args": "{n k s : â„•}  (hkn : k â‰¤ n)  (hsk : s â‰¤ k)"},
 {"type": "choose n (n - k) = choose n k",
  "tactic-prompt":
  "theorem {n k : â„•}  (hk : k â‰¤ n) : choose n (n - k) = choose n k := by rw [choose_eq_factorial_div_factorial hk]; sorry",
  "name": "choose_symm",
  "kind": "theorem",
  "first-tactic": "rw [choose_eq_factorial_div_factorial hk]",
  "core-prompt": "{n k : â„•}  (hk : k â‰¤ n) : choose n (n - k) = choose n k",
  "args": "{n k : â„•}  (hk : k â‰¤ n)"},
 {"type": "Nat.choose n a = Nat.choose n b",
  "tactic-prompt":
  "theorem {n a b : â„•}  (h : n = a + b) : Nat.choose n a = Nat.choose n b := by suffices : choose n (n - b) = choose n b; sorry",
  "name": "choose_symm_of_eq_add",
  "kind": "theorem",
  "first-tactic": "suffices : choose n (n - b) = choose n b",
  "core-prompt":
  "{n a b : â„•}  (h : n = a + b) : Nat.choose n a = Nat.choose n b",
  "args": "{n a b : â„•}  (h : n = a + b)"},
 {"type": "choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m",
  "tactic-prompt":
  "theorem (m : â„•) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m := by apply choose_symm_of_eq_add; sorry",
  "name": "choose_symm_half",
  "kind": "theorem",
  "first-tactic": "apply choose_symm_of_eq_add",
  "core-prompt": "(m : â„•) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m",
  "args": "(m : â„•)"},
 {"type": "choose n (k + 1) * (k + 1) = choose n k * (n - k)",
  "tactic-prompt":
  "theorem (n k : â„•) : choose n (k + 1) * (k + 1) = choose n k * (n - k) := by have e : (n + 1) * choose n k = choose n k * (k + 1) + choose n (k + 1) * (k + 1); sorry",
  "name": "choose_succ_right_eq",
  "kind": "theorem",
  "first-tactic":
  "have e : (n + 1) * choose n k = choose n k * (k + 1) + choose n (k + 1) * (k + 1)",
  "core-prompt":
  "(n k : â„•) : choose n (k + 1) * (k + 1) = choose n k * (n - k)",
  "args": "(n k : â„•)"},
 {"type": "n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k)",
  "tactic-prompt":
  "theorem (n k : â„•) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k) := by induction' k with k _; sorry",
  "name": "choose_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "induction' k with k _",
  "core-prompt":
  "(n k : â„•) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k)",
  "args": "(n k : â„•)"},
 {"type": "choose n r â‰¤ choose n (r + 1)",
  "tactic-prompt":
  "theorem {r n : â„•}  (h : r < n / 2) : choose n r â‰¤ choose n (r + 1) := by refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2))); sorry",
  "name": "choose_le_succ_of_lt_half_left",
  "kind": "theorem",
  "first-tactic":
  "refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2)))",
  "core-prompt": "{r n : â„•}  (h : r < n / 2) : choose n r â‰¤ choose n (r + 1)",
  "args": "{r n : â„•}  (h : r < n / 2)"},
 {"type": "choose n r â‰¤ choose n (n / 2)",
  "tactic-prompt":
  "theorem (r n : â„•) : choose n r â‰¤ choose n (n / 2) := by cases' le_or_gt r n with b b; sorry",
  "name": "choose_le_middle",
  "kind": "theorem",
  "first-tactic": "cases' le_or_gt r n with b b",
  "core-prompt": "(r n : â„•) : choose n r â‰¤ choose n (n / 2)",
  "args": "(r n : â„•)"},
 {"type": "choose a c â‰¤ choose a.succ c",
  "tactic-prompt":
  "theorem (a c : â„•) : choose a c â‰¤ choose a.succ c := by cases c; sorry",
  "name": "choose_le_succ",
  "kind": "theorem",
  "first-tactic": "cases c",
  "core-prompt": "(a c : â„•) : choose a c â‰¤ choose a.succ c",
  "args": "(a c : â„•)"},
 {"type": "choose a c â‰¤ choose (a + b) c",
  "tactic-prompt":
  "theorem (a b c : â„•) : choose a c â‰¤ choose (a + b) c := by induction' b with b_n b_ih; sorry",
  "name": "choose_le_add",
  "kind": "theorem",
  "first-tactic": "induction' b with b_n b_ih",
  "core-prompt": "(a b c : â„•) : choose a c â‰¤ choose (a + b) c",
  "args": "(a b c : â„•)"},
 {"type": "multichoose n 0 = 1",
  "tactic-prompt": "theorem (n : â„•) : multichoose n 0 = 1 := by cases n; sorry",
  "name": "multichoose_zero_right",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : â„•) : multichoose n 0 = 1",
  "args": "(n : â„•)"},
 {"type": "multichoose 0 (k + 1) = 0",
  "tactic-prompt":
  "theorem (k : â„•) : multichoose 0 (k + 1) = 0 := by simp [multichoose]; sorry",
  "name": "multichoose_zero_succ",
  "kind": "theorem",
  "first-tactic": "simp [multichoose]",
  "core-prompt": "(k : â„•) : multichoose 0 (k + 1) = 0",
  "args": "(k : â„•)"},
 {"type":
  "multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k",
  "tactic-prompt":
  "theorem (n k : â„•) : multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k := by simp [multichoose]; sorry",
  "name": "multichoose_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [multichoose]",
  "core-prompt":
  "(n k : â„•) : multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k",
  "args": "(n k : â„•)"},
 {"type": "multichoose 1 k = 1",
  "tactic-prompt":
  "theorem (k : â„•) : multichoose 1 k = 1 := by induction' k with k IH; sorry",
  "name": "multichoose_one",
  "kind": "theorem",
  "first-tactic": "induction' k with k IH",
  "core-prompt": "(k : â„•) : multichoose 1 k = 1",
  "args": "(k : â„•)"},
 {"type": "multichoose 2 k = k + 1",
  "tactic-prompt":
  "theorem (k : â„•) : multichoose 2 k = k + 1 := by induction' k with k IH; sorry",
  "name": "multichoose_two",
  "kind": "theorem",
  "first-tactic": "induction' k with k IH",
  "core-prompt": "(k : â„•) : multichoose 2 k = k + 1",
  "args": "(k : â„•)"},
 {"type": "multichoose n 1 = n",
  "tactic-prompt":
  "theorem (n : â„•) : multichoose n 1 = n := by induction' n with n IH; sorry",
  "name": "multichoose_one_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "(n : â„•) : multichoose n 1 = n",
  "args": "(n : â„•)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : â„•) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd m (n + m * k) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd m (n + m * k) = gcd m n := by simp [gcd_rec m (n + m * k)]; sorry",
  "name": "gcd_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + m * k)]",
  "core-prompt": "(m n k : â„•) : gcd m (n + m * k) = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd m (k * m + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd m (k * m + n) = gcd m n := by simp [add_comm _ n]; sorry",
  "name": "gcd_mul_right_add_right",
  "kind": "theorem",
  "first-tactic": "simp [add_comm _ n]",
  "core-prompt": "(m n k : â„•) : gcd m (k * m + n) = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd m (m * k + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd m (m * k + n) = gcd m n := by simp [add_comm _ n]; sorry",
  "name": "gcd_mul_left_add_right",
  "kind": "theorem",
  "first-tactic": "simp [add_comm _ n]",
  "core-prompt": "(m n k : â„•) : gcd m (m * k + n) = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd (m + k * n) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd (m + k * n) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : â„•) : gcd (m + k * n) n = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd (m + n * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd (m + n * k) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_mul_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : â„•) : gcd (m + n * k) n = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd (k * n + m) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd (k * n + m) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_add_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : â„•) : gcd (k * n + m) n = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd (n * k + m) n = gcd m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : gcd (n * k + m) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_add_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n k : â„•) : gcd (n * k + m) n = gcd m n",
  "args": "(m n k : â„•)"},
 {"type": "gcd (m + n) n = gcd m n",
  "tactic-prompt":
  "theorem (m n : â„•) : gcd (m + n) n = gcd m n := by rw [gcd_comm]; sorry",
  "name": "gcd_add_self_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : â„•) : gcd (m + n) n = gcd m n",
  "args": "(m n : â„•)"},
 {"type": "gcd (m + n) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : â„•) : gcd (m + n) m = gcd n m := by rw [add_comm]; sorry",
  "name": "gcd_self_add_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(m n : â„•) : gcd (m + n) m = gcd n m",
  "args": "(m n : â„•)"},
 {"type": "gcd m (m + n) = gcd m n",
  "tactic-prompt":
  "theorem (m n : â„•) : gcd m (m + n) = gcd m n := by rw [add_comm]; sorry",
  "name": "gcd_self_add_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "(m n : â„•) : gcd m (m + n) = gcd m n",
  "args": "(m n : â„•)"},
 {"type": "Decidable (coprime m n)",
  "tactic-prompt":
  "instance (m n : â„•) : Decidable (coprime m n) := by unfold coprime; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold coprime",
  "core-prompt": "(m n : â„•) : Decidable (coprime m n)",
  "args": "(m n : â„•)"},
 {"type": "lcm m n = m * n",
  "tactic-prompt":
  "theorem {m n : â„•}  (h : coprime m n) : lcm m n = m * n := by rw [â† one_mul (lcm m n)]; sorry",
  "name": "coprime.lcm_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† one_mul (lcm m n)]",
  "core-prompt": "{m n : â„•}  (h : coprime m n) : lcm m n = m * n",
  "args": "{m n : â„•}  (h : coprime m n)"},
 {"type": "coprime m (n + m) â†” coprime m n",
  "tactic-prompt":
  "theorem {m n : â„•} : coprime m (n + m) â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_self_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : â„•} : coprime m (n + m) â†” coprime m n",
  "args": "{m n : â„•}"},
 {"type": "coprime m (m + n) â†” coprime m n",
  "tactic-prompt":
  "theorem {m n : â„•} : coprime m (m + n) â†” coprime m n := by rw [add_comm]; sorry",
  "name": "coprime_self_add_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n : â„•} : coprime m (m + n) â†” coprime m n",
  "args": "{m n : â„•}"},
 {"type": "coprime (m + n) n â†” coprime m n",
  "tactic-prompt":
  "theorem {m n : â„•} : coprime (m + n) n â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_self_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : â„•} : coprime (m + n) n â†” coprime m n",
  "args": "{m n : â„•}"},
 {"type": "coprime (m + n) m â†” coprime n m",
  "tactic-prompt":
  "theorem {m n : â„•} : coprime (m + n) m â†” coprime n m := by rw [coprime]; sorry",
  "name": "coprime_self_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "{m n : â„•} : coprime (m + n) m â†” coprime n m",
  "args": "{m n : â„•}"},
 {"type": "coprime m (n + k * m) â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime m (n + k * m) â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime m (n + k * m) â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime m (n + m * k) â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime m (n + m * k) â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime m (n + m * k) â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime m (k * m + n) â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime m (k * m + n) â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_right_add_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime m (k * m + n) â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime m (m * k + n) â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime m (m * k + n) â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_left_add_right",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime m (m * k + n) â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime (m + k * n) n â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime (m + k * n) n â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime (m + k * n) n â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime (m + n * k) n â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime (m + n * k) n â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_add_mul_left_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime (m + n * k) n â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime (k * n + m) n â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime (k * n + m) n â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_right_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime (k * n + m) n â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "coprime (n * k + m) n â†” coprime m n",
  "tactic-prompt":
  "theorem (m n k : â„•) : coprime (n * k + m) n â†” coprime m n := by rw [coprime]; sorry",
  "name": "coprime_mul_left_add_left",
  "kind": "theorem",
  "first-tactic": "rw [coprime]",
  "core-prompt": "(m n k : â„•) : coprime (n * k + m) n â†” coprime m n",
  "args": "(m n k : â„•)"},
 {"type": "Nat.coprime (a ^ n) b â†” Nat.coprime a b",
  "tactic-prompt":
  "theorem {n : â„•}  (hn : 0 < n)  (a b : â„•) : Nat.coprime (a ^ n) b â†” Nat.coprime a b := by obtain âŸ¨n, rflâŸ© := exists_eq_succ_of_ne_zero hn.ne'; sorry",
  "name": "coprime_pow_left_iff",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨n, rflâŸ© := exists_eq_succ_of_ne_zero hn.ne'",
  "core-prompt":
  "{n : â„•}  (hn : 0 < n)  (a b : â„•) : Nat.coprime (a ^ n) b â†” Nat.coprime a b",
  "args": "{n : â„•}  (hn : 0 < n)  (a b : â„•)"},
 {"type": "Nat.coprime a (b ^ n) â†” Nat.coprime a b",
  "tactic-prompt":
  "theorem {n : â„•}  (hn : 0 < n)  (a b : â„•) : Nat.coprime a (b ^ n) â†” Nat.coprime a b := by rw [Nat.coprime_comm]; sorry",
  "name": "coprime_pow_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [Nat.coprime_comm]",
  "core-prompt":
  "{n : â„•}  (hn : 0 < n)  (a b : â„•) : Nat.coprime a (b ^ n) â†” Nat.coprime a b",
  "args": "{n : â„•}  (hn : 0 < n)  (a b : â„•)"},
 {"type": "Â¬coprime 0 0",
  "tactic-prompt": "theorem  : Â¬coprime 0 0 := by simp; sorry",
  "name": "not_coprime_zero_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : Â¬coprime 0 0",
  "args": ""},
 {"type": "coprime 1 n â†” True",
  "tactic-prompt":
  "theorem (n : â„•) : coprime 1 n â†” True := by simp [coprime]; sorry",
  "name": "coprime_one_left_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : â„•) : coprime 1 n â†” True",
  "args": "(n : â„•)"},
 {"type": "coprime n 1 â†” True",
  "tactic-prompt":
  "theorem (n : â„•) : coprime n 1 â†” True := by simp [coprime]; sorry",
  "name": "coprime_one_right_iff",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : â„•) : coprime n 1 â†” True",
  "args": "(n : â„•)"},
 {"type": "gcd (a * b) c = b",
  "tactic-prompt":
  "theorem {a b c : â„•}  (hac : coprime a c)  (b_dvd_c : b âˆ£ c) : gcd (a * b) c = b := by rcases exists_eq_mul_left_of_dvd b_dvd_c with âŸ¨d, rflâŸ©; sorry",
  "name": "gcd_mul_of_coprime_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases exists_eq_mul_left_of_dvd b_dvd_c with âŸ¨d, rflâŸ©",
  "core-prompt":
  "{a b c : â„•}  (hac : coprime a c)  (b_dvd_c : b âˆ£ c) : gcd (a * b) c = b",
  "args": "{a b c : â„•}  (hac : coprime a c)  (b_dvd_c : b âˆ£ c)"},
 {"type": "{ d : { m' // m' âˆ£ m } Ã— { n' // n' âˆ£ n } // k = d.1 * d.2 }",
  "tactic-prompt":
  "def {m n k : â„•}  (H : k âˆ£ m * n) : { d : { m' // m' âˆ£ m } Ã— { n' // n' âˆ£ n } // k = d.1 * d.2 } := by cases h0 : gcd k m; sorry",
  "name": "prodDvdAndDvdOfDvdProd",
  "kind": "def",
  "first-tactic": "cases h0 : gcd k m",
  "core-prompt":
  "{m n k : â„•}  (H : k âˆ£ m * n) : { d : { m' // m' âˆ£ m } Ã— { n' // n' âˆ£ n } // k = d.1 * d.2 }",
  "args": "{m n k : â„•}  (H : k âˆ£ m * n)"},
 {"type": "x âˆ£ m * n â†” âˆƒ y z, y âˆ£ m âˆ§ z âˆ£ n âˆ§ y * z = x",
  "tactic-prompt":
  "theorem {x m n : â„•} : x âˆ£ m * n â†” âˆƒ y z, y âˆ£ m âˆ§ z âˆ£ n âˆ§ y * z = x := by constructor; sorry",
  "name": "dvd_mul",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{x m n : â„•} : x âˆ£ m * n â†” âˆƒ y z, y âˆ£ m âˆ§ z âˆ£ n âˆ§ y * z = x",
  "args": "{x m n : â„•}"},
 {"type": "a ^ n âˆ£ b ^ n â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b n : â„•}  (n0 : 0 < n) : a ^ n âˆ£ b ^ n â†” a âˆ£ b := by refine' âŸ¨fun h => _, fun h => pow_dvd_pow_of_dvd h _âŸ©; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => pow_dvd_pow_of_dvd h _âŸ©",
  "core-prompt": "{a b n : â„•}  (n0 : 0 < n) : a ^ n âˆ£ b ^ n â†” a âˆ£ b",
  "args": "{a b n : â„•}  (n0 : 0 < n)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {a b k : â„•}  (h_ab_coprime : coprime a b)  (hka : k âˆ£ a)      (hkb : k âˆ£ b) : k = 1 := by rw [coprime_iff_gcd_eq_one] at h_ab_coprime; sorry",
  "name": "eq_one_of_dvd_coprimes",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one] at h_ab_coprime",
  "core-prompt":
  "{a b k : â„•}  (h_ab_coprime : coprime a b)  (hka : k âˆ£ a)      (hkb : k âˆ£ b) : k = 1",
  "args":
  "{a b k : â„•}  (h_ab_coprime : coprime a b)  (hka : k âˆ£ a)      (hkb : k âˆ£ b)"},
 {"type": "a * m + b * n â‰  m * n",
  "tactic-prompt":
  "theorem {m n a b : â„•}  (cop : coprime m n)  (ha : a â‰  0)  (hb : b â‰  0) : a * m + b * n â‰  m * n := by intro h; sorry",
  "name": "coprime.mul_add_mul_ne_mul",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{m n a b : â„•}  (cop : coprime m n)  (ha : a â‰  0)  (hb : b â‰  0) : a * m + b * n â‰  m * n",
  "args": "{m n a b : â„•}  (cop : coprime m n)  (ha : a â‰  0)  (hb : b â‰  0)"},
 {"type": "((m / n : â„•) : Î±) = m / n",
  "tactic-prompt":
  "theorem {Î± : Type _} [Field Î±]  {m n : â„•}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0) : ((m / n : â„•) : Î±) = m / n := by rcases n_dvd with âŸ¨k, rflâŸ©; sorry",
  "name": "cast_div",
  "kind": "theorem",
  "first-tactic": "rcases n_dvd with âŸ¨k, rflâŸ©",
  "core-prompt":
  "{Î± : Type _} [Field Î±]  {m n : â„•}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0) : ((m / n : â„•) : Î±) = m / n",
  "args":
  "{Î± : Type _} [Field Î±]  {m n : â„•}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0)"},
 {"type": "(â†‘(m / d) : Î±) / (â†‘(n / d) : Î±) = (m : Î±) / n",
  "tactic-prompt":
  "theorem {Î± : Type _} [Field Î±]  [CharZero Î±]  {m n d : â„•}  (hn : d âˆ£ n)  (hm : d âˆ£ m) : (â†‘(m / d) : Î±) / (â†‘(n / d) : Î±) = (m : Î±) / n := by rcases eq_or_ne d 0 with (rfl | hd); sorry",
  "name": "cast_div_div_div_cancel_right",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne d 0 with (rfl | hd)",
  "core-prompt":
  "{Î± : Type _} [Field Î±]  [CharZero Î±]  {m n d : â„•}  (hn : d âˆ£ n)  (hm : d âˆ£ m) : (â†‘(m / d) : Î±) / (â†‘(n / d) : Î±) = (m : Î±) / n",
  "args":
  "{Î± : Type _} [Field Î±]  [CharZero Î±]  {m n d : â„•}  (hn : d âˆ£ n)  (hm : d âˆ£ m)"},
 {"type": "((m / n : â„•) : Î±) â‰¤ m / n",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedSemifield Î±] {m n : â„•} : ((m / n : â„•) : Î±) â‰¤ m / n := by cases n; sorry",
  "name": "cast_div_le",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedSemifield Î±] {m n : â„•} : ((m / n : â„•) : Î±) â‰¤ m / n",
  "args": "{Î± : Type _}  [LinearOrderedSemifield Î±] {m n : â„•}"},
 {"type": "0 < 1 / ((n : Î±) + 1)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedSemifield Î±] {n : â„•} : 0 < 1 / ((n : Î±) + 1) := by rw [one_div]; sorry",
  "name": "one_div_pos_of_nat",
  "kind": "theorem",
  "first-tactic": "rw [one_div]",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedSemifield Î±] {n : â„•} : 0 < 1 / ((n : Î±) + 1)",
  "args": "{Î± : Type _}  [LinearOrderedSemifield Î±] {n : â„•}"},
 {"type": "1 / ((m : Î±) + 1) â‰¤ 1 / ((n : Î±) + 1)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n â‰¤ m) : 1 / ((m : Î±) + 1) â‰¤ 1 / ((n : Î±) + 1) := by refine' one_div_le_one_div_of_le _ _; sorry",
  "name": "one_div_le_one_div",
  "kind": "theorem",
  "first-tactic": "refine' one_div_le_one_div_of_le _ _",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n â‰¤ m) : 1 / ((m : Î±) + 1) â‰¤ 1 / ((n : Î±) + 1)",
  "args": "{Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n â‰¤ m)"},
 {"type": "1 / ((m : Î±) + 1) < 1 / ((n : Î±) + 1)",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n < m) : 1 / ((m : Î±) + 1) < 1 / ((n : Î±) + 1) := by refine' one_div_lt_one_div_of_lt _ _; sorry",
  "name": "one_div_lt_one_div",
  "kind": "theorem",
  "first-tactic": "refine' one_div_lt_one_div_of_lt _ _",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n < m) : 1 / ((m : Î±) + 1) < 1 / ((n : Î±) + 1)",
  "args": "{Î± : Type _}  [LinearOrderedSemifield Î±] {n m : â„•}  (h : n < m)"},
 {"type": "((ite P m n : â„•) : R) = ite P (m : R) (n : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : â„•) : ((ite P m n : â„•) : R) = ite P (m : R) (n : R) := by split_ifs; sorry",
  "name": "cast_ite",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "[AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : â„•) : ((ite P m n : â„•) : R) = ite P (m : R) (n : R)",
  "args": "[AddMonoidWithOne R] (P : Prop)  [Decidable P]  (m n : â„•)"},
 {"type": "((1 : â„•) : R) = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R] : ((1 : â„•) : R) = 1 := by rw [cast_succ]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "rw [cast_succ]",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R] : ((1 : â„•) : R) = 1",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]"},
 {"type": "((m + n : â„•) : R) = m + n",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : â„•) : ((m + n : â„•) : R) = m + n := by induction n; sorry",
  "name": "cast_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : â„•) : ((m + n : â„•) : R) = m + n",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]  (m n : â„•)"},
 {"type": "(Nat.binCast n : R) = ((n : â„•) : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne R]  (n : â„•) : (Nat.binCast n : R) = ((n : â„•) : R) := by apply Nat.strongInductionOn n; sorry",
  "name": "binCast_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.strongInductionOn n",
  "core-prompt":
  "[AddMonoidWithOne R] [AddMonoidWithOne R]  (n : â„•) : (Nat.binCast n : R) = ((n : â„•) : R)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne R]  (n : â„•)"},
 {"type": "((bit1 n : â„•) : R) = bit1 (n : R)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : â„•) : ((bit1 n : â„•) : R) = bit1 (n : R) := by rw [bit1]; sorry",
  "name": "cast_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "[AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : â„•) : ((bit1 n : â„•) : R) = bit1 (n : R)",
  "args": "[AddMonoidWithOne R]  [AddMonoidWithOne R]  (n : â„•)"},
 {"type": "1 + 1 = (2 : Î±)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne Î±] : 1 + 1 = (2 : Î±) := by rw [â†Nat.cast_one]; sorry",
  "name": "one_add_one_eq_two",
  "kind": "theorem",
  "first-tactic": "rw [â†Nat.cast_one]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne Î±] : 1 + 1 = (2 : Î±)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne Î±]"},
 {"type": "2 + 1 = (3 : Î±)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne Î±] : 2 + 1 = (3 : Î±) := by rw [â†one_add_one_eq_two]; sorry",
  "name": "two_add_one_eq_three",
  "kind": "theorem",
  "first-tactic": "rw [â†one_add_one_eq_two]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne Î±] : 2 + 1 = (3 : Î±)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne Î±]"},
 {"type": "3 + 1 = (4 : Î±)",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] [AddMonoidWithOne Î±] : 3 + 1 = (4 : Î±) := by rw [â†two_add_one_eq_three]; sorry",
  "name": "three_add_one_eq_four",
  "kind": "theorem",
  "first-tactic": "rw [â†two_add_one_eq_three]",
  "core-prompt": "[AddMonoidWithOne R] [AddMonoidWithOne Î±] : 3 + 1 = (4 : Î±)",
  "args": "[AddMonoidWithOne R] [AddMonoidWithOne Î±]"},
 {"type": "((m * n : â„•) : Î±) = m * n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [NonAssocSemiring Î±]  (m n : â„•) : ((m * n : â„•) : Î±) = m * n := by induction n; sorry",
  "name": "cast_mul",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{Î± Î² : Type _} [NonAssocSemiring Î±]  (m n : â„•) : ((m * n : â„•) : Î±) = m * n",
  "args": "{Î± Î² : Type _} [NonAssocSemiring Î±]  (m n : â„•)"},
 {"type": "Commute (n : Î±) x",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [NonAssocSemiring Î±]  (n : â„•)  (x : Î±) : Commute (n : Î±) x := by induction n; sorry",
  "name": "cast_commute",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{Î± Î² : Type _} [NonAssocSemiring Î±]  (n : â„•)  (x : Î±) : Commute (n : Î±) x",
  "args": "{Î± Î² : Type _} [NonAssocSemiring Î±]  (n : â„•)  (x : Î±)"},
 {"type": "(0 : Î±) < n â†” 0 < n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial Î±] {n : â„•} : (0 : Î±) < n â†” 0 < n := by cases n; sorry",
  "name": "cast_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial Î±] {n : â„•} : (0 : Î±) < n â†” 0 < n",
  "args":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono]  [Nontrivial Î±] {n : â„•}"},
 {"type": "1 < (n : Î±) â†” 1 < n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : 1 < (n : Î±) â†” 1 < n := by rw [â† cast_one]; sorry",
  "name": "one_lt_cast",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_one]",
  "core-prompt":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : 1 < (n : Î±) â†” 1 < n",
  "args":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•}"},
 {"type": "1 â‰¤ (n : Î±) â†” 1 â‰¤ n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : 1 â‰¤ (n : Î±) â†” 1 â‰¤ n := by rw [â† cast_one]; sorry",
  "name": "one_le_cast",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_one]",
  "core-prompt":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : 1 â‰¤ (n : Î±) â†” 1 â‰¤ n",
  "args":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•}"},
 {"type": "(n : Î±) < 1 â†” n = 0",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : (n : Î±) < 1 â†” n = 0 := by rw [â† cast_one]; sorry",
  "name": "cast_lt_one",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_one]",
  "core-prompt":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : (n : Î±) < 1 â†” n = 0",
  "args":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•}"},
 {"type": "(n : Î±) â‰¤ 1 â†” n â‰¤ 1",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : (n : Î±) â‰¤ 1 â†” n â‰¤ 1 := by rw [â† cast_one]; sorry",
  "name": "cast_le_one",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_one]",
  "core-prompt":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•} : (n : Î±) â‰¤ 1 â†” n â‰¤ 1",
  "args":
  "{Î± Î² : Type _}  [OrderedSemiring Î±]  -- porting note: missing mono attribute -- @[mono] [CharZero Î±]  {m n : â„•}"},
 {"type": "â†‘(m - n) = (m - n : Î±)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (m n : â„•) : â†‘(m - n) = (m - n : Î±) := by cases' le_total m n with h h; sorry",
  "name": "cast_tsub",
  "kind": "theorem",
  "first-tactic": "cases' le_total m n with h h",
  "core-prompt":
  "{Î± Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (m n : â„•) : â†‘(m - n) = (m - n : Î±)",
  "args":
  "{Î± Î² : Type _} [CanonicallyOrderedCommSemiring Î±]  [Sub Î±]  [OrderedSub Î±]      [ContravariantClass Î± Î± (Â· + Â·) (Â· â‰¤ Â·)]  (m n : â„•)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F â„• A]  (f g : F)  (h_pos : âˆ€ {n : â„•}, 0 < n â†’ f n = g n) : f = g := by apply FunLike.ext; sorry",
  "name": "ext_nat''",
  "kind": "theorem",
  "first-tactic": "apply FunLike.ext",
  "core-prompt":
  "{Î± Î² : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F â„• A]  (f g : F)  (h_pos : âˆ€ {n : â„•}, 0 < n â†’ f n = g n) : f = g",
  "args":
  "{Î± Î² : Type _}  {A F : Type _}  [MulZeroOneClass A] [MonoidWithZeroHomClass F â„• A]  (f g : F)  (h_pos : âˆ€ {n : â„•}, 0 < n â†’ f n = g n)"},
 {"type": "(n : Î± Ã— Î²).fst = n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•) : (n : Î± Ã— Î²).fst = n := by induction n; sorry",
  "name": "fst_natCast",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•) : (n : Î± Ã— Î²).fst = n",
  "args": "{Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•)"},
 {"type": "(n : Î± Ã— Î²).snd = n",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•) : (n : Î± Ã— Î²).snd = n := by induction n; sorry",
  "name": "snd_natCast",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•) : (n : Î± Ã— Î²).snd = n",
  "args": "{Î± Î² : Type _} [AddMonoidWithOne Î±]  [AddMonoidWithOne Î²] (n : â„•)"},
 {"type": "log b n = 0 â†” n < b âˆ¨ b â‰¤ 1",
  "tactic-prompt":
  "theorem {b n : â„•} : log b n = 0 â†” n < b âˆ¨ b â‰¤ 1 := by rw [log]; sorry",
  "name": "log_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [log]",
  "core-prompt": "{b n : â„•} : log b n = 0 â†” n < b âˆ¨ b â‰¤ 1",
  "args": "{b n : â„•}"},
 {"type": "0 < log b n â†” b â‰¤ n âˆ§ 1 < b",
  "tactic-prompt":
  "theorem {b n : â„•} : 0 < log b n â†” b â‰¤ n âˆ§ 1 < b := by rw [pos_iff_ne_zero]; sorry",
  "name": "log_pos_iff",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt": "{b n : â„•} : 0 < log b n â†” b â‰¤ n âˆ§ 1 < b",
  "args": "{b n : â„•}"},
 {"type": "log b n = log b (n / b) + 1",
  "tactic-prompt":
  "theorem {b n : â„•}  (h : 1 < b)  (hn : b â‰¤ n) : log b n = log b (n / b) + 1 := by rw [log]; sorry",
  "name": "log_of_one_lt_of_le",
  "kind": "theorem",
  "first-tactic": "rw [log]",
  "core-prompt":
  "{b n : â„•}  (h : 1 < b)  (hn : b â‰¤ n) : log b n = log b (n / b) + 1",
  "args": "{b n : â„•}  (h : 1 < b)  (hn : b â‰¤ n)"},
 {"type": "b ^ x â‰¤ y â†” x â‰¤ log b y",
  "tactic-prompt":
  "theorem {b : â„•}  (hb : 1 < b)  {x y : â„•}  (hy : y â‰  0) : b ^ x â‰¤ y â†” x â‰¤ log b y := by induction' y using Nat.strong_induction_on with y ih generalizing x; sorry",
  "name": "pow_le_iff_le_log",
  "kind": "theorem",
  "first-tactic":
  "induction' y using Nat.strong_induction_on with y ih generalizing x",
  "core-prompt":
  "{b : â„•}  (hb : 1 < b)  {x y : â„•}  (hy : y â‰  0) : b ^ x â‰¤ y â†” x â‰¤ log b y",
  "args": "{b : â„•}  (hb : 1 < b)  {x y : â„•}  (hy : y â‰  0)"},
 {"type": "b ^ x â‰¤ y",
  "tactic-prompt":
  "theorem {b x y : â„•}  (hy : y â‰  0)  (h : x â‰¤ log b y) : b ^ x â‰¤ y := by refine' (le_or_lt b 1).elim (fun hb => _) fun hb => (pow_le_iff_le_log hb hy).2 h; sorry",
  "name": "pow_le_of_le_log",
  "kind": "theorem",
  "first-tactic":
  "refine' (le_or_lt b 1).elim (fun hb => _) fun hb => (pow_le_iff_le_log hb hy).2 h",
  "core-prompt": "{b x y : â„•}  (hy : y â‰  0)  (h : x â‰¤ log b y) : b ^ x â‰¤ y",
  "args": "{b x y : â„•}  (hy : y â‰  0)  (h : x â‰¤ log b y)"},
 {"type": "x â‰¤ log b y",
  "tactic-prompt":
  "theorem {b x y : â„•}  (hb : 1 < b)  (h : b ^ x â‰¤ y) : x â‰¤ log b y := by rcases ne_or_eq y 0 with (hy | rfl); sorry",
  "name": "le_log_of_pow_le",
  "kind": "theorem",
  "first-tactic": "rcases ne_or_eq y 0 with (hy | rfl)",
  "core-prompt": "{b x y : â„•}  (hb : 1 < b)  (h : b ^ x â‰¤ y) : x â‰¤ log b y",
  "args": "{b x y : â„•}  (hb : 1 < b)  (h : b ^ x â‰¤ y)"},
 {"type": "log b n = m â†” b ^ m â‰¤ n âˆ§ n < b ^ (m + 1)",
  "tactic-prompt":
  "theorem {b m n : â„•}  (h : m â‰  0 âˆ¨ 1 < b âˆ§ n â‰  0) : log b n = m â†” b ^ m â‰¤ n âˆ§ n < b ^ (m + 1) := by rcases em (1 < b âˆ§ n â‰  0) with (âŸ¨hb, hnâŸ© | hbn); sorry",
  "name": "log_eq_iff",
  "kind": "theorem",
  "first-tactic": "rcases em (1 < b âˆ§ n â‰  0) with (âŸ¨hb, hnâŸ© | hbn)",
  "core-prompt":
  "{b m n : â„•}  (h : m â‰  0 âˆ¨ 1 < b âˆ§ n â‰  0) : log b n = m â†” b ^ m â‰¤ n âˆ§ n < b ^ (m + 1)",
  "args": "{b m n : â„•}  (h : m â‰  0 âˆ¨ 1 < b âˆ§ n â‰  0)"},
 {"type": "log b n = m",
  "tactic-prompt":
  "theorem {b m n : â„•}  (hâ‚ : b ^ m â‰¤ n)  (hâ‚‚ : n < b ^ (m + 1)) : log b n = m := by rcases eq_or_ne m 0 with (rfl | hm); sorry",
  "name": "log_eq_of_pow_le_of_lt_pow",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne m 0 with (rfl | hm)",
  "core-prompt":
  "{b m n : â„•}  (hâ‚ : b ^ m â‰¤ n)  (hâ‚‚ : n < b ^ (m + 1)) : log b n = m",
  "args": "{b m n : â„•}  (hâ‚ : b ^ m â‰¤ n)  (hâ‚‚ : n < b ^ (m + 1))"},
 {"type": "log b n = 1 â†” b â‰¤ n âˆ§ n < b * b",
  "tactic-prompt":
  "theorem {b n : â„•} : log b n = 1 â†” b â‰¤ n âˆ§ n < b * b := by rw [log_eq_iff (Or.inl one_ne_zero)]; sorry",
  "name": "log_eq_one_iff'",
  "kind": "theorem",
  "first-tactic": "rw [log_eq_iff (Or.inl one_ne_zero)]",
  "core-prompt": "{b n : â„•} : log b n = 1 â†” b â‰¤ n âˆ§ n < b * b",
  "args": "{b n : â„•}"},
 {"type": "log b (n * b) = log b n + 1",
  "tactic-prompt":
  "theorem {b n : â„•}  (hb : 1 < b)  (hn : n â‰  0) : log b (n * b) = log b n + 1 := by apply log_eq_of_pow_le_of_lt_pow; sorry",
  "name": "log_mul_base",
  "kind": "theorem",
  "first-tactic": "apply log_eq_of_pow_le_of_lt_pow",
  "core-prompt":
  "{b n : â„•}  (hb : 1 < b)  (hn : n â‰  0) : log b (n * b) = log b n + 1",
  "args": "{b n : â„•}  (hb : 1 < b)  (hn : n â‰  0)"},
 {"type": "Monotone (log b)",
  "tactic-prompt":
  "theorem {b : â„•} : Monotone (log b) := by refine' monotone_nat_of_le_succ fun n => _; sorry",
  "name": "log_monotone",
  "kind": "theorem",
  "first-tactic": "refine' monotone_nat_of_le_succ fun n => _",
  "core-prompt": "{b : â„•} : Monotone (log b)",
  "args": "{b : â„•}"},
 {"type": "log b n â‰¤ log c n",
  "tactic-prompt":
  "theorem {b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b) : log b n â‰¤ log c n := by rcases eq_or_ne n 0 with (rfl | hn); sorry",
  "name": "log_anti_left",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 0 with (rfl | hn)",
  "core-prompt": "{b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b) : log b n â‰¤ log c n",
  "args": "{b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b)"},
 {"type": "log b (n / b) = log b n - 1",
  "tactic-prompt":
  "theorem (b n : â„•) : log b (n / b) = log b n - 1 := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "log_div_base",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b n : â„•) : log b (n / b) = log b n - 1",
  "args": "(b n : â„•)"},
 {"type": "log b (n / b * b) = log b n",
  "tactic-prompt":
  "theorem (b n : â„•) : log b (n / b * b) = log b n := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "log_div_mul_self",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b n : â„•) : log b (n / b * b) = log b n",
  "args": "(b n : â„•)"},
 {"type": "(n + b - 1) / b < n",
  "tactic-prompt":
  "theorem {b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : (n + b - 1) / b < n := by rw [div_lt_iff_lt_mul (zero_lt_one.trans hb)]; sorry",
  "name": "add_pred_div_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_lt_iff_lt_mul (zero_lt_one.trans hb)]",
  "core-prompt": "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : (n + b - 1) / b < n",
  "args": "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n)"},
 {"type": "clog b n = 0",
  "tactic-prompt":
  "theorem {b : â„•}  (hb : b â‰¤ 1)  (n : â„•) : clog b n = 0 := by rw [clog]; sorry",
  "name": "clog_of_left_le_one",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt": "{b : â„•}  (hb : b â‰¤ 1)  (n : â„•) : clog b n = 0",
  "args": "{b : â„•}  (hb : b â‰¤ 1)  (n : â„•)"},
 {"type": "clog b n = 0",
  "tactic-prompt":
  "theorem {n : â„•}  (hn : n â‰¤ 1)  (b : â„•) : clog b n = 0 := by rw [clog]; sorry",
  "name": "clog_of_right_le_one",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt": "{n : â„•}  (hn : n â‰¤ 1)  (b : â„•) : clog b n = 0",
  "args": "{n : â„•}  (hn : n â‰¤ 1)  (b : â„•)"},
 {"type": "clog b n = clog b ((n + b - 1) / b) + 1",
  "tactic-prompt":
  "theorem {b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : clog b n = clog b ((n + b - 1) / b) + 1 := by rw [clog]; sorry",
  "name": "clog_of_two_le",
  "kind": "theorem",
  "first-tactic": "rw [clog]",
  "core-prompt":
  "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : clog b n = clog b ((n + b - 1) / b) + 1",
  "args": "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n)"},
 {"type": "0 < clog b n",
  "tactic-prompt":
  "theorem {b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : 0 < clog b n := by rw [clog_of_two_le hb hn]; sorry",
  "name": "clog_pos",
  "kind": "theorem",
  "first-tactic": "rw [clog_of_two_le hb hn]",
  "core-prompt": "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n) : 0 < clog b n",
  "args": "{b n : â„•}  (hb : 1 < b)  (hn : 2 â‰¤ n)"},
 {"type": "clog b n = 1",
  "tactic-prompt":
  "theorem {b n : â„•}  (hn : 2 â‰¤ n)  (h : n â‰¤ b) : clog b n = 1 := by rw [clog_of_two_le (hn.trans h) hn]; sorry",
  "name": "clog_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [clog_of_two_le (hn.trans h) hn]",
  "core-prompt": "{b n : â„•}  (hn : 2 â‰¤ n)  (h : n â‰¤ b) : clog b n = 1",
  "args": "{b n : â„•}  (hn : 2 â‰¤ n)  (h : n â‰¤ b)"},
 {"type": "x â‰¤ b ^ y â†” clog b x â‰¤ y",
  "tactic-prompt":
  "theorem {b : â„•}  (hb : 1 < b)  {x y : â„•} : x â‰¤ b ^ y â†” clog b x â‰¤ y := by induction' x using Nat.strong_induction_on with x ih generalizing y; sorry",
  "name": "le_pow_iff_clog_le",
  "kind": "theorem",
  "first-tactic":
  "induction' x using Nat.strong_induction_on with x ih generalizing y",
  "core-prompt": "{b : â„•}  (hb : 1 < b)  {x y : â„•} : x â‰¤ b ^ y â†” clog b x â‰¤ y",
  "args": "{b : â„•}  (hb : 1 < b)  {x y : â„•}"},
 {"type": "b ^ (clog b x).pred < x",
  "tactic-prompt":
  "theorem {b : â„•}  (hb : 1 < b)  {x : â„•}  (hx : 1 < x) : b ^ (clog b x).pred < x := by rw [â† not_le]; sorry",
  "name": "pow_pred_clog_lt_self",
  "kind": "theorem",
  "first-tactic": "rw [â† not_le]",
  "core-prompt":
  "{b : â„•}  (hb : 1 < b)  {x : â„•}  (hx : 1 < x) : b ^ (clog b x).pred < x",
  "args": "{b : â„•}  (hb : 1 < b)  {x : â„•}  (hx : 1 < x)"},
 {"type": "clog b n â‰¤ clog b m",
  "tactic-prompt":
  "theorem (b : â„•)  {n m : â„•}  (h : n â‰¤ m) : clog b n â‰¤ clog b m := by cases' le_or_lt b 1 with hb hb; sorry",
  "name": "clog_mono_right",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt b 1 with hb hb",
  "core-prompt": "(b : â„•)  {n m : â„•}  (h : n â‰¤ m) : clog b n â‰¤ clog b m",
  "args": "(b : â„•)  {n m : â„•}  (h : n â‰¤ m)"},
 {"type": "clog b n â‰¤ clog c n",
  "tactic-prompt":
  "theorem {b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b) : clog b n â‰¤ clog c n := by rw [â† le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]; sorry",
  "name": "clog_anti_left",
  "kind": "theorem",
  "first-tactic": "rw [â† le_pow_iff_clog_le (lt_of_lt_of_le hc hb)]",
  "core-prompt":
  "{b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b) : clog b n â‰¤ clog c n",
  "args": "{b c n : â„•}  (hc : 1 < c)  (hb : c â‰¤ b)"},
 {"type": "log b n â‰¤ clog b n",
  "tactic-prompt":
  "theorem (b n : â„•) : log b n â‰¤ clog b n := by obtain hb | hb := le_or_lt b 1; sorry",
  "name": "log_le_clog",
  "kind": "theorem",
  "first-tactic": "obtain hb | hb := le_or_lt b 1",
  "core-prompt": "(b n : â„•) : log b n â‰¤ clog b n",
  "args": "(b n : â„•)"},
 {"type": "boddDiv2 n = (bodd n, div2 n)",
  "tactic-prompt":
  "theorem {n : â„•} (n : â„•) : boddDiv2 n = (bodd n, div2 n) := by unfold bodd div2; sorry",
  "name": "boddDiv2_eq",
  "kind": "theorem",
  "first-tactic": "unfold bodd div2",
  "core-prompt": "{n : â„•} (n : â„•) : boddDiv2 n = (bodd n, div2 n)",
  "args": "{n : â„•} (n : â„•)"},
 {"type": "bit0 n % 2 = 0",
  "tactic-prompt":
  "theorem {n : â„•} : bit0 n % 2 = 0 := by rw [Nat.mod_two_of_bodd]; sorry",
  "name": "bit0_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mod_two_of_bodd]",
  "core-prompt": "{n : â„•} : bit0 n % 2 = 0",
  "args": "{n : â„•}"},
 {"type": "bit1 n % 2 = 1",
  "tactic-prompt":
  "theorem {n : â„•} : bit1 n % 2 = 1 := by rw [Nat.mod_two_of_bodd]; sorry",
  "name": "bit1_mod_two",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mod_two_of_bodd]",
  "core-prompt": "{n : â„•} : bit1 n % 2 = 1",
  "args": "{n : â„•}"},
 {"type": "0 < n",
  "tactic-prompt":
  "theorem {n : â„•} {n : â„•}  (h : 0 < bit0 n) : 0 < n := by cases n; sorry",
  "name": "pos_of_bit0_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{n : â„•} {n : â„•}  (h : 0 < bit0 n) : 0 < n",
  "args": "{n : â„•} {n : â„•}  (h : 0 < bit0 n)"},
 {"type":
  "Function.Injective fun H : âˆ€ b n, C (bit b n) => fun n => bitCasesOn n H",
  "tactic-prompt":
  "theorem {n : â„•} {C : â„• â†’ Sort u} : Function.Injective fun H : âˆ€ b n, C (bit b n) => fun n => bitCasesOn n H := by intro Hâ‚ Hâ‚‚ h; sorry",
  "name": "bit_cases_on_injective",
  "kind": "theorem",
  "first-tactic": "intro Hâ‚ Hâ‚‚ h",
  "core-prompt":
  "{n : â„•} {C : â„• â†’ Sort u} : Function.Injective fun H : âˆ€ b n, C (bit b n) => fun n => bitCasesOn n H",
  "args": "{n : â„•} {C : â„• â†’ Sort u}"},
 {"type": "bit b n = 0 â†” n = 0 âˆ§ b = false",
  "tactic-prompt":
  "theorem {n : â„•} {n : â„•}  {b : Bool} : bit b n = 0 â†” n = 0 âˆ§ b = false := by constructor; sorry",
  "name": "bit_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{n : â„•} {n : â„•}  {b : Bool} : bit b n = 0 â†” n = 0 âˆ§ b = false",
  "args": "{n : â„•} {n : â„•}  {b : Bool}"},
 {"type": "bits 0 = []",
  "tactic-prompt": "theorem {n : â„•} : bits 0 = [] := by simp [Nat.bits]; sorry",
  "name": "zero_bits",
  "kind": "theorem",
  "first-tactic": "simp [Nat.bits]",
  "core-prompt": "{n : â„•} : bits 0 = []",
  "args": "{n : â„•}"},
 {"type": "(bit b n).bits = b :: n.bits",
  "tactic-prompt":
  "theorem {n : â„•} (n : â„•)  (b : Bool)  (hn : n = 0 â†’ b = true) : (bit b n).bits = b :: n.bits := by rw [Nat.bits]; sorry",
  "name": "bits_append_bit",
  "kind": "theorem",
  "first-tactic": "rw [Nat.bits]",
  "core-prompt":
  "{n : â„•} (n : â„•)  (b : Bool)  (hn : n = 0 â†’ b = true) : (bit b n).bits = b :: n.bits",
  "args": "{n : â„•} (n : â„•)  (b : Bool)  (hn : n = 0 â†’ b = true)"},
 {"type": "Nat.bits 1 = [true]",
  "tactic-prompt":
  "theorem {n : â„•} : Nat.bits 1 = [true] := by convert bit1_bits 0; sorry",
  "name": "one_bits",
  "kind": "theorem",
  "first-tactic": "convert bit1_bits 0",
  "core-prompt": "{n : â„•} : Nat.bits 1 = [true]",
  "args": "{n : â„•}"},
 {"type": "n.bodd = n.bits.headI",
  "tactic-prompt":
  "theorem {n : â„•} (n : â„•) : n.bodd = n.bits.headI := by induction' n using Nat.binaryRec' with b n h _; sorry",
  "name": "bodd_eq_bits_head",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h _",
  "core-prompt": "{n : â„•} (n : â„•) : n.bodd = n.bits.headI",
  "args": "{n : â„•} (n : â„•)"},
 {"type": "n.div2.bits = n.bits.tail",
  "tactic-prompt":
  "theorem {n : â„•} (n : â„•) : n.div2.bits = n.bits.tail := by induction' n using Nat.binaryRec' with b n h _; sorry",
  "name": "div2_bits_eq_tail",
  "kind": "theorem",
  "first-tactic": "induction' n using Nat.binaryRec' with b n h _",
  "core-prompt": "{n : â„•} (n : â„•) : n.div2.bits = n.bits.tail",
  "args": "{n : â„•} (n : â„•)"},
 {"type": "max (succ m) (succ n) = succ (max m n)",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n : â„•} : max (succ m) (succ n) = succ (max m n) := by by_cases h1 : m â‰¤ n; sorry",
  "name": "max_succ_succ",
  "kind": "theorem",
  "first-tactic": "by_cases h1 : m â‰¤ n",
  "core-prompt":
  "{m n k : â„•} {m n : â„•} : max (succ m) (succ n) = succ (max m n)",
  "args": "{m n k : â„•} {m n : â„•}"},
 {"type": "m < n â†” m + 1 â‰¤ n",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n : â„•} : m < n â†” m + 1 â‰¤ n := by rw [succ_le_iff]; sorry",
  "name": "lt_iff_add_one_le",
  "kind": "theorem",
  "first-tactic": "rw [succ_le_iff]",
  "core-prompt": "{m n k : â„•} {m n : â„•} : m < n â†” m + 1 â‰¤ n",
  "args": "{m n k : â„•} {m n : â„•}"},
 {"type": "a < 1 + b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•} : a < 1 + b â†” a â‰¤ b := by simp only [add_comm]; sorry",
  "name": "lt_one_add_iff",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm]",
  "core-prompt": "{m n k : â„•} {a b : â„•} : a < 1 + b â†” a â‰¤ b",
  "args": "{m n k : â„•} {a b : â„•}"},
 {"type": "1 + a â‰¤ b â†” a < b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•} : 1 + a â‰¤ b â†” a < b := by simp only [add_comm]; sorry",
  "name": "one_add_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm]",
  "core-prompt": "{m n k : â„•} {a b : â„•} : 1 + a â‰¤ b â†” a < b",
  "args": "{m n k : â„•} {a b : â„•}"},
 {"type": "m / n â‰¤ k â†” m â‰¤ n * k + (n - 1)",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n k : â„•}  (n0 : 0 < n) : m / n â‰¤ k â†” m â‰¤ n * k + (n - 1) := by rw [â† lt_succ_iff]; sorry",
  "name": "div_le_iff_le_mul_add_pred",
  "kind": "theorem",
  "first-tactic": "rw [â† lt_succ_iff]",
  "core-prompt":
  "{m n k : â„•} {m n k : â„•}  (n0 : 0 < n) : m / n â‰¤ k â†” m â‰¤ n * k + (n - 1)",
  "args": "{m n k : â„•} {m n k : â„•}  (n0 : 0 < n)"},
 {"type": "(âˆ€ m < n + 1, P m) â†” (âˆ€ m < n, P m) âˆ§ P n",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Prop}  {n : â„•} : (âˆ€ m < n + 1, P m) â†” (âˆ€ m < n, P m) âˆ§ P n := by simp only [lt_succ_iff]; sorry",
  "name": "forall_lt_succ",
  "kind": "theorem",
  "first-tactic": "simp only [lt_succ_iff]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Prop}  {n : â„•} : (âˆ€ m < n + 1, P m) â†” (âˆ€ m < n, P m) âˆ§ P n",
  "args": "{m n k : â„•} {P : â„• â†’ Prop}  {n : â„•}"},
 {"type": "(âˆƒ m < n + 1, P m) â†” (âˆƒ m < n, P m) âˆ¨ P n",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Prop}  {n : â„•} : (âˆƒ m < n + 1, P m) â†” (âˆƒ m < n, P m) âˆ¨ P n := by rw [â† not_iff_not]; sorry",
  "name": "exists_lt_succ",
  "kind": "theorem",
  "first-tactic": "rw [â† not_iff_not]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Prop}  {n : â„•} : (âˆƒ m < n + 1, P m) â†” (âˆƒ m < n, P m) âˆ¨ P n",
  "args": "{m n k : â„•} {P : â„• â†’ Prop}  {n : â„•}"},
 {"type": "n + succ m - 1 = n + m",
  "tactic-prompt":
  "theorem {m n k : â„•} (n m : â„•) : n + succ m - 1 = n + m := by rw [add_succ]; sorry",
  "name": "add_succ_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [add_succ]",
  "core-prompt": "{m n k : â„•} (n m : â„•) : n + succ m - 1 = n + m",
  "args": "{m n k : â„•} (n m : â„•)"},
 {"type": "succ n + m - 1 = n + m",
  "tactic-prompt":
  "theorem {m n k : â„•} (n m : â„•) : succ n + m - 1 = n + m := by rw [succ_add]; sorry",
  "name": "succ_add_sub_one",
  "kind": "theorem",
  "first-tactic": "rw [succ_add]",
  "core-prompt": "{m n k : â„•} (n m : â„•) : succ n + m - 1 = n + m",
  "args": "{m n k : â„•} (n m : â„•)"},
 {"type": "m.pred = n",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n : â„•}  (H : m = n.succ) : m.pred = n := by simp [H]; sorry",
  "name": "pred_eq_of_eq_succ",
  "kind": "theorem",
  "first-tactic": "simp [H]",
  "core-prompt": "{m n k : â„•} {m n : â„•}  (H : m = n.succ) : m.pred = n",
  "args": "{m n k : â„•} {m n : â„•}  (H : m = n.succ)"},
 {"type": "pred n = succ m â†” n = m + 2",
  "tactic-prompt":
  "theorem {m n k : â„•} {n m : â„•} : pred n = succ m â†” n = m + 2 := by cases n; sorry",
  "name": "pred_eq_succ_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : â„•} {n m : â„•} : pred n = succ m â†” n = m + 2",
  "args": "{m n k : â„•} {n m : â„•}"},
 {"type": "pred n - m = pred (n - m)",
  "tactic-prompt":
  "theorem {m n k : â„•} (n m : â„•) : pred n - m = pred (n - m) := by rw [â† Nat.sub_one]; sorry",
  "name": "pred_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.sub_one]",
  "core-prompt": "{m n k : â„•} (n m : â„•) : pred n - m = pred (n - m)",
  "args": "{m n k : â„•} (n m : â„•)"},
 {"type": "pred (1 + n) = n",
  "tactic-prompt":
  "theorem {m n k : â„•} (n : â„•) : pred (1 + n) = n := by rw [add_comm]; sorry",
  "name": "pred_one_add",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n k : â„•} (n : â„•) : pred (1 + n) = n",
  "args": "{m n k : â„•} (n : â„•)"},
 {"type": "a * b = b â†” a = 1",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (hb : 0 < b) : a * b = b â†” a = 1 := by rw [mul_comm]; sorry",
  "name": "mul_left_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (hb : 0 < b) : a * b = b â†” a = 1",
  "args": "{m n k : â„•} {a b : â„•}  (hb : 0 < b)"},
 {"type": "(decreasingInduction h nn hP : P n) = hP",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {n : â„•}  (nn : n â‰¤ n)      (hP : P n) : (decreasingInduction h nn hP : P n) = hP := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_self",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {n : â„•}  (nn : n â‰¤ n)      (hP : P n) : (decreasingInduction h nn hP : P n) = hP",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {n : â„•}  (nn : n â‰¤ n)      (hP : P n)"},
 {"type":
  "(decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP)",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}  (mn : m â‰¤ n)      (msn : m â‰¤ n + 1)  (hP : P (n + 1)) : (decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP) := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_succ",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}  (mn : m â‰¤ n)      (msn : m â‰¤ n + 1)  (hP : P (n + 1)) : (decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP)",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}  (mn : m â‰¤ n)      (msn : m â‰¤ n + 1)  (hP : P (n + 1))"},
 {"type": "(decreasingInduction h msm hP : P m) = h m hP",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m : â„•}      (msm : m â‰¤ m + 1)  (hP : P (m + 1)) : (decreasingInduction h msm hP : P m) = h m hP := by dsimp only [decreasingInduction]; sorry",
  "name": "decreasingInduction_succ'",
  "kind": "theorem",
  "first-tactic": "dsimp only [decreasingInduction]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m : â„•}      (msm : m â‰¤ m + 1)  (hP : P (m + 1)) : (decreasingInduction h msm hP : P m) = h m hP",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m : â„•}      (msm : m â‰¤ m + 1)  (hP : P (m + 1))"},
 {"type":
  "(decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP)",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n k : â„•}      (mn : m â‰¤ n)  (nk : n â‰¤ k)  (hP : P k) : (decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP) := by induction' nk with k nk ih; sorry",
  "name": "decreasingInduction_trans",
  "kind": "theorem",
  "first-tactic": "induction' nk with k nk ih",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n k : â„•}      (mn : m â‰¤ n)  (nk : n â‰¤ k)  (hP : P k) : (decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP)",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n k : â„•}      (mn : m â‰¤ n)  (nk : n â‰¤ k)  (hP : P k)"},
 {"type":
  "(decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP)",
  "tactic-prompt":
  "theorem {m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}      (smn : m + 1 â‰¤ n)  (mn : m â‰¤ n)  (hP : P n) : (decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP) := by rw [Subsingleton.elim mn (le_trans (le_succ m) smn)]; sorry",
  "name": "decreasingInduction_succ_left",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim mn (le_trans (le_succ m) smn)]",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}      (smn : m + 1 â‰¤ n)  (mn : m â‰¤ n)  (hP : P n) : (decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP)",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  (h : âˆ€ n, P (n + 1) â†’ P n)  {m n : â„•}      (smn : m + 1 â‰¤ n)  (mn : m â‰¤ n)  (hP : P n)"},
 {"type": "P m",
  "tactic-prompt":
  "def {m n k : â„•} {P : â„• â†’ Sort _}  {m n : â„•}  (h : âˆ€ k < n, m â‰¤ k â†’ P (k + 1) â†’ P k)      (mn : m â‰¤ n)  (hP : P n) : P m := by revert h hP; sorry",
  "name": "decreasingInduction'",
  "kind": "def",
  "first-tactic": "revert h hP",
  "core-prompt":
  "{m n k : â„•} {P : â„• â†’ Sort _}  {m n : â„•}  (h : âˆ€ k < n, m â‰¤ k â†’ P (k + 1) â†’ P k)      (mn : m â‰¤ n)  (hP : P n) : P m",
  "args":
  "{m n k : â„•} {P : â„• â†’ Sort _}  {m n : â„•}  (h : âˆ€ k < n, m â‰¤ k â†’ P (k + 1) â†’ P k)      (mn : m â‰¤ n)  (hP : P n)"},
 {"type": "1 â‰¤ a / b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (hb : 0 < b) : 1 â‰¤ a / b â†” b â‰¤ a := by rw [le_div_iff_mul_le hb]; sorry",
  "name": "one_le_div_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_div_iff_mul_le hb]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (hb : 0 < b) : 1 â‰¤ a / b â†” b â‰¤ a",
  "args": "{m n k : â„•} {a b : â„•}  (hb : 0 < b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c := by rw [â† H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† H2]",
  "core-prompt":
  "{m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c",
  "args": "{m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b c : â„•}  (H : 0 < b)  (H' : b âˆ£ a) : a / b = c â†” a = c * b := by rw [mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : â„•} {a b c : â„•}  (H : 0 < b)  (H' : b âˆ£ a) : a / b = c â†” a = c * b",
  "args": "{m n k : â„•} {a b c : â„•}  (H : 0 < b)  (H' : b âˆ£ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b := by rw [mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b",
  "args": "{m n k : â„•} {a b c : â„•}  (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (Hd : a âˆ£ b) : a * (b / a) = b := by rw [mul_comm]; sorry",
  "name": "mul_div_cancel_left'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (Hd : a âˆ£ b) : a * (b / a) = b",
  "args": "{m n k : â„•} {a b : â„•}  (Hd : a âˆ£ b)"},
 {"type": "a < a / b * b + b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (hb : 0 < b) : a < a / b * b + b := by rw [â† Nat.succ_mul]; sorry",
  "name": "lt_div_mul_add",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.succ_mul]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (hb : 0 < b) : a < a / b * b + b",
  "args": "{m n k : â„•} {a b : â„•}  (hb : 0 < b)"},
 {"type": "a / d = b / d â†” a = b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b d : â„•}  (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b := by refine âŸ¨fun h => ?_, congr_arg fun n => n / dâŸ©; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, congr_arg fun n => n / dâŸ©",
  "core-prompt":
  "{m n k : â„•} {a b d : â„•}  (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b",
  "args": "{m n k : â„•} {a b d : â„•}  (hda : d âˆ£ a)  (hdb : d âˆ£ b)"},
 {"type": "a % b = a â†” a < b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (h : b â‰  0) : a % b = a â†” a < b := by cases b; sorry",
  "name": "mod_eq_iff_lt",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (h : b â‰  0) : a % b = a â†” a < b",
  "args": "{m n k : â„•} {a b : â„•}  (h : b â‰  0)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem {m n k : â„•} (m k : â„•) : m % k + m / k * k = m := by rw [mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : â„•} (m k : â„•) : m % k + m / k * k = m",
  "args": "{m n k : â„•} (m k : â„•)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem {m n k : â„•} (m k : â„•) : m / k * k + m % k = m := by rw [mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt": "{m n k : â„•} (m k : â„•) : m / k * k + m % k = m",
  "args": "{m n k : â„•} (m k : â„•)"},
 {"type": "n % k % m = n % m",
  "tactic-prompt":
  "theorem {m n k : â„•} (n : Nat)  {m k : Nat}  (h : m âˆ£ k) : n % k % m = n % m := by conv =>\n  rhs\n  rw [â† mod_add_div n k]; sorry",
  "name": "mod_mod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv =>\n  rhs\n  rw [â† mod_add_div n k]",
  "core-prompt":
  "{m n k : â„•} (n : Nat)  {m k : Nat}  (h : m âˆ£ k) : n % k % m = n % m",
  "args": "{m n k : â„•} (n : Nat)  {m k : Nat}  (h : m âˆ£ k)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [â† mod_add_mod]; sorry",
  "name": "add_mod_eq_add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† mod_add_mod]",
  "core-prompt":
  "{m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n)"},
 {"type": "(i + m) % n = (i + k) % n",
  "tactic-prompt":
  "theorem {m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n) : (i + m) % n = (i + k) % n := by rw [add_comm]; sorry",
  "name": "add_mod_eq_add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n) : (i + m) % n = (i + k) % n",
  "args": "{m n k : â„•} {m n k : â„•}  (i : â„•)  (H : m % n = k % n)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 1) : a = b := by rw [â† Nat.div_mul_cancel w]; sorry",
  "name": "eq_of_dvd_of_div_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.div_mul_cancel w]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 1) : a = b",
  "args": "{m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 1)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 0) : b = 0 := by rw [â† Nat.div_mul_cancel w]; sorry",
  "name": "eq_zero_of_dvd_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.div_mul_cancel w]",
  "core-prompt": "{m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 0) : b = 0",
  "args": "{m n k : â„•} {a b : â„•}  (w : a âˆ£ b)  (h : b / a = 0)"},
 {"type": "m < n * (m / n + 1)",
  "tactic-prompt":
  "theorem {m n k : â„•} (m : â„•)  {n : â„•}  (n0 : 0 < n) : m < n * (m / n + 1) := by rw [mul_comm]; sorry",
  "name": "lt_mul_div_succ",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{m n k : â„•} (m : â„•)  {n : â„•}  (n0 : 0 < n) : m < n * (m / n + 1)",
  "args": "{m n k : â„•} (m : â„•)  {n : â„•}  (n0 : 0 < n)"},
 {"type": "(a * b + c) % b = c % b",
  "tactic-prompt":
  "theorem {m n k : â„•} (a b c : â„•) : (a * b + c) % b = c % b := by simp [Nat.add_mod]; sorry",
  "name": "mul_add_mod",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_mod]",
  "core-prompt": "{m n k : â„•} (a b c : â„•) : (a * b + c) % b = c % b",
  "args": "{m n k : â„•} (a b c : â„•)"},
 {"type": "(a * b + c) % b = c",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b c : â„•}  (h : c < b) : (a * b + c) % b = c := by rw [Nat.mul_add_mod]; sorry",
  "name": "mul_add_mod_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_add_mod]",
  "core-prompt": "{m n k : â„•} {a b c : â„•}  (h : c < b) : (a * b + c) % b = c",
  "args": "{m n k : â„•} {a b c : â„•}  (h : c < b)"},
 {"type": "n.pred = n â†” n = 0",
  "tactic-prompt":
  "theorem {m n k : â„•} {n : â„•} : n.pred = n â†” n = 0 := by cases n; sorry",
  "name": "pred_eq_self_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : â„•} {n : â„•} : n.pred = n â†” n = 0",
  "args": "{m n k : â„•} {n : â„•}"},
 {"type": "Nat.find h = m â†” p m âˆ§ âˆ€ n < m, Â¬p n",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n) : Nat.find h = m â†” p m âˆ§ âˆ€ n < m, Â¬p n := by constructor; sorry",
  "name": "find_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n) : Nat.find h = m â†” p m âˆ§ âˆ€ n < m, Â¬p n",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)"},
 {"type": "Nat.find h â‰¤ n â†” âˆƒ m â‰¤ n, p m",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : Nat.find h â‰¤ n â†” âˆƒ m â‰¤ n, p m := by simp only [exists_prop]; sorry",
  "name": "find_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : Nat.find h â‰¤ n â†” âˆƒ m â‰¤ n, p m",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•)"},
 {"type": "n â‰¤ Nat.find h â†” âˆ€ m < n, Â¬p m",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : n â‰¤ Nat.find h â†” âˆ€ m < n, Â¬p m := by simp_rw [â† not_lt]; sorry",
  "name": "le_find_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† not_lt]",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : n â‰¤ Nat.find h â†” âˆ€ m < n, Â¬p m",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•)"},
 {"type": "n < Nat.find h â†” âˆ€ m â‰¤ n, Â¬p m",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : n < Nat.find h â†” âˆ€ m â‰¤ n, Â¬p m := by simp only [â† succ_le_iff]; sorry",
  "name": "lt_find_iff",
  "kind": "theorem",
  "first-tactic": "simp only [â† succ_le_iff]",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•) : n < Nat.find h â†” âˆ€ m â‰¤ n, Â¬p m",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)  (n : â„•)"},
 {"type": "Nat.find h = 0 â†” p 0",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n) : Nat.find h = 0 â†” p 0 := by simp [find_eq_iff]; sorry",
  "name": "find_eq_zero",
  "kind": "theorem",
  "first-tactic": "simp [find_eq_iff]",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n) : Nat.find h = 0 â†” p 0",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (h : âˆƒ n : â„•, p n)"},
 {"type": "Nat.find hâ‚ = Nat.find hâ‚‚ + 1",
  "tactic-prompt":
  "theorem {m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (hâ‚ : âˆƒ n, p n)  (hâ‚‚ : âˆƒ n, p (n + 1))  (h0 : Â¬p 0) : Nat.find hâ‚ = Nat.find hâ‚‚ + 1 := by refine' (find_eq_iff _).2 âŸ¨Nat.find_spec hâ‚‚, fun n hn => _âŸ©; sorry",
  "name": "find_comp_succ",
  "kind": "theorem",
  "first-tactic": "refine' (find_eq_iff _).2 âŸ¨Nat.find_spec hâ‚‚, fun n hn => _âŸ©",
  "core-prompt":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (hâ‚ : âˆƒ n, p n)  (hâ‚‚ : âˆƒ n, p (n + 1))  (h0 : Â¬p 0) : Nat.find hâ‚ = Nat.find hâ‚‚ + 1",
  "args":
  "{m n k : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q] (hâ‚ : âˆƒ n, p n)  (hâ‚‚ : âˆƒ n, p (n + 1))  (h0 : Â¬p 0)"},
 {"type": "Nat.findGreatest P (b + 1) = Nat.findGreatest P b",
  "tactic-prompt":
  "theorem {m n k : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P]  {b : â„•} (h : Â¬P (b + 1)) : Nat.findGreatest P (b + 1) = Nat.findGreatest P b := by simp [Nat.findGreatest]; sorry",
  "name": "findGreatest_of_not",
  "kind": "theorem",
  "first-tactic": "simp [Nat.findGreatest]",
  "core-prompt":
  "{m n k : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P]  {b : â„•} (h : Â¬P (b + 1)) : Nat.findGreatest P (b + 1) = Nat.findGreatest P b",
  "args":
  "{m n k : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P]  {b : â„•} (h : Â¬P (b + 1))"},
 {"type": "IsSqrt n (sqrt n)",
  "tactic-prompt":
  "theorem (n : â„•) : IsSqrt n (sqrt n) := by match n with\n  | 0 => simp [IsSqrt]\n  | 1 => simp [IsSqrt]\n  | n + 2 =>\n    have h : Â¬ (n + 2) â‰¤ 1 := by simp\n    simp only [IsSqrt]; sorry",
  "name": "sqrt_isSqrt",
  "kind": "theorem",
  "first-tactic":
  "match n with\n  | 0 => simp [IsSqrt]\n  | 1 => simp [IsSqrt]\n  | n + 2 =>\n    have h : Â¬ (n + 2) â‰¤ 1 := by simp\n    simp only [IsSqrt]",
  "core-prompt": "(n : â„•) : IsSqrt n (sqrt n)",
  "args": "(n : â„•)"},
 {"type": "n â‰¤ sqrt n * sqrt n + sqrt n + sqrt n",
  "tactic-prompt":
  "theorem (n : â„•) : n â‰¤ sqrt n * sqrt n + sqrt n + sqrt n := by rw [â† succ_mul]; sorry",
  "name": "sqrt_le_add",
  "kind": "theorem",
  "first-tactic": "rw [â† succ_mul]",
  "core-prompt": "(n : â„•) : n â‰¤ sqrt n * sqrt n + sqrt n + sqrt n",
  "args": "(n : â„•)"},
 {"type": "m â‰¤ sqrt n â†” m ^ 2 â‰¤ n",
  "tactic-prompt":
  "theorem {m n : â„•} : m â‰¤ sqrt n â†” m ^ 2 â‰¤ n := by simpa only [pow_two] using le_sqrt; sorry",
  "name": "le_sqrt'",
  "kind": "theorem",
  "first-tactic": "simpa only [pow_two] using le_sqrt",
  "core-prompt": "{m n : â„•} : m â‰¤ sqrt n â†” m ^ 2 â‰¤ n",
  "args": "{m n : â„•}"},
 {"type": "(âˆƒ n, n ^ 2 = x) â†” sqrt x ^ 2 = x",
  "tactic-prompt":
  "theorem (x : â„•) : (âˆƒ n, n ^ 2 = x) â†” sqrt x ^ 2 = x := by simpa only [pow_two] using exists_mul_self x; sorry",
  "name": "exists_mul_self'",
  "kind": "theorem",
  "first-tactic": "simpa only [pow_two] using exists_mul_self x",
  "core-prompt": "(x : â„•) : (âˆƒ n, n ^ 2 = x) â†” sqrt x ^ 2 = x",
  "args": "(x : â„•)"},
 {"type": "Â¬âˆƒ t, t * t = n",
  "tactic-prompt":
  "theorem {n m : â„•}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ t, t * t = n := by rintro âŸ¨t, rflâŸ©; sorry",
  "name": "not_exists_sq",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨t, rflâŸ©",
  "core-prompt":
  "{n m : â„•}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ t, t * t = n",
  "args": "{n m : â„•}  (hl : m * m < n)  (hr : n < (m + 1) * (m + 1))"},
 {"type": "Â¬âˆƒ t, t ^ 2 = n",
  "tactic-prompt":
  "theorem {n m : â„•}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2) : Â¬âˆƒ t, t ^ 2 = n := by simpa only [pow_two] using\n    not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr); sorry",
  "name": "not_exists_sq'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [pow_two] using\n    not_exists_sq (by simpa only [pow_two] using hl) (by simpa only [pow_two] using hr)",
  "core-prompt":
  "{n m : â„•}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2) : Â¬âˆƒ t, t ^ 2 = n",
  "args": "{n m : â„•}  (hl : m ^ 2 < n)  (hr : n < (m + 1) ^ 2)"},
 {"type": "m = 1 âˆ¨ m = p",
  "tactic-prompt":
  "theorem {p : â„•}  (pp : p.Prime)  (m : â„•)  (hm : m âˆ£ p) : m = 1 âˆ¨ m = p := by obtain âŸ¨n, hnâŸ© := hm; sorry",
  "name": "Prime.eq_one_or_self_of_dvd",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨n, hnâŸ© := hm",
  "core-prompt":
  "{p : â„•}  (pp : p.Prime)  (m : â„•)  (hm : m âˆ£ p) : m = 1 âˆ¨ m = p",
  "args": "{p : â„•}  (pp : p.Prime)  (m : â„•)  (hm : m âˆ£ p)"},
 {"type": "Prime p â†” 2 â‰¤ p âˆ§ âˆ€ (m) (_ : m âˆ£ p), m = 1 âˆ¨ m = p",
  "tactic-prompt":
  "theorem {p : â„•} : Prime p â†” 2 â‰¤ p âˆ§ âˆ€ (m) (_ : m âˆ£ p), m = 1 âˆ¨ m = p := by refine' âŸ¨fun h => âŸ¨h.two_le, h.eq_one_or_self_of_dvdâŸ©, fun h => _âŸ©; sorry",
  "name": "prime_def_lt''",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun h => âŸ¨h.two_le, h.eq_one_or_self_of_dvdâŸ©, fun h => _âŸ©",
  "core-prompt": "{p : â„•} : Prime p â†” 2 â‰¤ p âˆ§ âˆ€ (m) (_ : m âˆ£ p), m = 1 âˆ¨ m = p",
  "args": "{p : â„•}"},
 {"type": "Prime n",
  "tactic-prompt":
  "theorem (n : â„•)  (h1 : 1 < n)  (h : âˆ€ m < n, m â‰  0 â†’ n.coprime m) : Prime n := by refine' prime_def_lt.mpr âŸ¨h1, fun m mlt mdvd => _âŸ©; sorry",
  "name": "prime_of_coprime",
  "kind": "theorem",
  "first-tactic": "refine' prime_def_lt.mpr âŸ¨h1, fun m mlt mdvd => _âŸ©",
  "core-prompt":
  "(n : â„•)  (h1 : 1 < n)  (h : âˆ€ m < n, m â‰  0 â†’ n.coprime m) : Prime n",
  "args": "(n : â„•)  (h1 : 1 < n)  (h : âˆ€ m < n, m â‰  0 â†’ n.coprime m)"},
 {"type": "Prime 2",
  "tactic-prompt": "theorem  : Prime 2 := by decide; sorry",
  "name": "prime_two",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Prime 2",
  "args": ""},
 {"type": "Prime 3",
  "tactic-prompt": "theorem  : Prime 3 := by decide; sorry",
  "name": "prime_three",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : Prime 3",
  "args": ""},
 {"type": "5 â‰¤ p",
  "tactic-prompt":
  "theorem {p : â„•}  (hp : p.Prime)  (h_two : p â‰  2)      (h_three : p â‰  3) : 5 â‰¤ p := by by_contra' h; sorry",
  "name": "Prime.five_le_of_ne_two_of_ne_three",
  "kind": "theorem",
  "first-tactic": "by_contra' h",
  "core-prompt":
  "{p : â„•}  (hp : p.Prime)  (h_two : p â‰  2)      (h_three : p â‰  3) : 5 â‰¤ p",
  "args": "{p : â„•}  (hp : p.Prime)  (h_two : p â‰  2)      (h_three : p â‰  3)"},
 {"type": "Â¬Prime n",
  "tactic-prompt":
  "theorem {a b n : â„•}  (h : a * b = n)  (hâ‚ : 1 < a)  (hâ‚‚ : 1 < b) : Â¬Prime n := by rw [â† h]; sorry",
  "name": "not_prime_mul'",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{a b n : â„•}  (h : a * b = n)  (hâ‚ : 1 < a)  (hâ‚‚ : 1 < b) : Â¬Prime n",
  "args": "{a b n : â„•}  (h : a * b = n)  (hâ‚ : 1 < a)  (hâ‚‚ : 1 < b)"},
 {"type": "Nat.Prime (a * b) â†” a.Prime âˆ§ b = 1 âˆ¨ b.Prime âˆ§ a = 1",
  "tactic-prompt":
  "theorem {a b : â„•} : Nat.Prime (a * b) â†” a.Prime âˆ§ b = 1 âˆ¨ b.Prime âˆ§ a = 1 := by simp only [iff_self_iff]; sorry",
  "name": "prime_mul_iff",
  "kind": "theorem",
  "first-tactic": "simp only [iff_self_iff]",
  "core-prompt":
  "{a b : â„•} : Nat.Prime (a * b) â†” a.Prime âˆ§ b = 1 âˆ¨ b.Prime âˆ§ a = 1",
  "args": "{a b : â„•}"},
 {"type": "a âˆ£ p â†” p = a",
  "tactic-prompt":
  "theorem {p a : â„•}  (hp : p.Prime)  (a1 : a â‰  1) : a âˆ£ p â†” p = a := by refine'\n    âŸ¨_, by\n      rintro rfl\n      rflâŸ©; sorry",
  "name": "Prime.dvd_iff_eq",
  "kind": "theorem",
  "first-tactic": "refine'\n    âŸ¨_, by\n      rintro rfl\n      rflâŸ©",
  "core-prompt": "{p a : â„•}  (hp : p.Prime)  (a1 : a â‰  1) : a âˆ£ p â†” p = a",
  "args": "{p a : â„•}  (hp : p.Prime)  (a1 : a â‰  1)"},
 {"type": "minFacProp n (minFac n)",
  "tactic-prompt":
  "theorem {n : â„•}  (n1 : n â‰  1) : minFacProp n (minFac n) := by by_cases n0 : n = 0; sorry",
  "name": "minFac_has_prop",
  "kind": "theorem",
  "first-tactic": "by_cases n0 : n = 0",
  "core-prompt": "{n : â„•}  (n1 : n â‰  1) : minFacProp n (minFac n)",
  "args": "{n : â„•}  (n1 : n â‰  1)"},
 {"type": "âˆ€ {m : â„•}, 2 â‰¤ m â†’ m âˆ£ n â†’ minFac n â‰¤ m",
  "tactic-prompt":
  "theorem {n : â„•} : âˆ€ {m : â„•}, 2 â‰¤ m â†’ m âˆ£ n â†’ minFac n â‰¤ m := by by_cases n1 : n = 1; sorry",
  "name": "minFac_le_of_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases n1 : n = 1",
  "core-prompt": "{n : â„•} : âˆ€ {m : â„•}, 2 â‰¤ m â†’ m âˆ£ n â†’ minFac n â‰¤ m",
  "args": "{n : â„•}"},
 {"type": "0 < minFac n",
  "tactic-prompt":
  "theorem (n : â„•) : 0 < minFac n := by by_cases n1 : n = 1; sorry",
  "name": "minFac_pos",
  "kind": "theorem",
  "first-tactic": "by_cases n1 : n = 1",
  "core-prompt": "(n : â„•) : 0 < minFac n",
  "args": "(n : â„•)"},
 {"type": "minFac n = 1 â†” n = 1",
  "tactic-prompt":
  "theorem {n : â„•} : minFac n = 1 â†” n = 1 := by constructor; sorry",
  "name": "minFac_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{n : â„•} : minFac n = 1 â†” n = 1",
  "args": "{n : â„•}"},
 {"type": "minFac n = 2 â†” 2 âˆ£ n",
  "tactic-prompt":
  "theorem (n : â„•) : minFac n = 2 â†” 2 âˆ£ n := by constructor; sorry",
  "name": "minFac_eq_two_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "(n : â„•) : minFac n = 2 â†” 2 âˆ£ n",
  "args": "(n : â„•)"},
 {"type": "a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : â„•}      (hdvd : âˆ€ p : â„•, p.Prime â†’ p âˆ£ a â†’ p * a âˆ£ b) : a âˆ£ b := by obtain rfl | ha := eq_or_ne a 1; sorry",
  "name": "dvd_of_forall_prime_mul_dvd",
  "kind": "theorem",
  "first-tactic": "obtain rfl | ha := eq_or_ne a 1",
  "core-prompt":
  "{a b : â„•}      (hdvd : âˆ€ p : â„•, p.Prime â†’ p âˆ£ a â†’ p * a âˆ£ b) : a âˆ£ b",
  "args": "{a b : â„•}      (hdvd : âˆ€ p : â„•, p.Prime â†’ p âˆ£ a â†’ p * a âˆ£ b)"},
 {"type": "Â¬BddAbove { p | Prime p }",
  "tactic-prompt":
  "theorem  : Â¬BddAbove { p | Prime p } := by rw [not_bddAbove_iff]; sorry",
  "name": "not_bddAbove_setOf_prime",
  "kind": "theorem",
  "first-tactic": "rw [not_bddAbove_iff]",
  "core-prompt": " : Â¬BddAbove { p | Prime p }",
  "args": ""},
 {"type": "Even p â†” p = 2",
  "tactic-prompt":
  "theorem {p : â„•}  (hp : Prime p) : Even p â†” p = 2 := by rw [even_iff_two_dvd]; sorry",
  "name": "Prime.even_iff",
  "kind": "theorem",
  "first-tactic": "rw [even_iff_two_dvd]",
  "core-prompt": "{p : â„•}  (hp : Prime p) : Even p â†” p = 2",
  "args": "{p : â„•}  (hp : Prime p)"},
 {"type": "p % 2 = 1 â†” p â‰  2",
  "tactic-prompt":
  "theorem {p : â„•}  [Fact p.Prime] : p % 2 = 1 â†” p â‰  2 := by refine' âŸ¨fun h hf => _, (Nat.Prime.eq_two_or_odd <| @Fact.out p.Prime _).resolve_leftâŸ©; sorry",
  "name": "Prime.mod_two_eq_one_iff_ne_two",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun h hf => _, (Nat.Prime.eq_two_or_odd <| @Fact.out p.Prime _).resolve_leftâŸ©",
  "core-prompt": "{p : â„•}  [Fact p.Prime] : p % 2 = 1 â†” p â‰  2",
  "args": "{p : â„•}  [Fact p.Prime]"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem {m n : â„•}  (H : âˆ€ k, Prime k â†’ k âˆ£ m â†’ Â¬k âˆ£ n) : coprime m n := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "{m n : â„•}  (H : âˆ€ k, Prime k â†’ k âˆ£ m â†’ Â¬k âˆ£ n) : coprime m n",
  "args": "{m n : â„•}  (H : âˆ€ k, Prime k â†’ k âˆ£ m â†’ Â¬k âˆ£ n)"},
 {"type": "Â¬coprime m n â†” âˆƒ p, Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n",
  "tactic-prompt":
  "theorem {m n : â„•} : Â¬coprime m n â†” âˆƒ p, Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n := by apply Iff.intro; sorry",
  "name": "Prime.not_coprime_iff_dvd",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{m n : â„•} : Â¬coprime m n â†” âˆƒ p, Prime p âˆ§ p âˆ£ m âˆ§ p âˆ£ n",
  "args": "{m n : â„•}"},
 {"type": "p âˆ£ m",
  "tactic-prompt":
  "theorem {p m n : â„•}  (pp : Prime p)  (h : p âˆ£ m ^ n) : p âˆ£ m := by induction' n with n IH; sorry",
  "name": "Prime.dvd_of_dvd_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n IH",
  "core-prompt": "{p m n : â„•}  (pp : Prime p)  (h : p âˆ£ m ^ n) : p âˆ£ m",
  "args": "{p m n : â„•}  (pp : Prime p)  (h : p âˆ£ m ^ n)"},
 {"type": "a ^ k = p â†” a = p âˆ§ k = 1",
  "tactic-prompt":
  "theorem {p a k : â„•}  (hp : p.Prime) : a ^ k = p â†” a = p âˆ§ k = 1 := by refine' âŸ¨fun h => _, fun h => by rw [h.1, h.2, pow_one]âŸ©; sorry",
  "name": "Prime.pow_eq_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => by rw [h.1, h.2, pow_one]âŸ©",
  "core-prompt": "{p a k : â„•}  (hp : p.Prime) : a ^ k = p â†” a = p âˆ§ k = 1",
  "args": "{p a k : â„•}  (hp : p.Prime)"},
 {"type": "(n ^ k).minFac = n.minFac",
  "tactic-prompt":
  "theorem {n k : â„•}  (hk : k â‰  0) : (n ^ k).minFac = n.minFac := by rcases eq_or_ne n 1 with (rfl | hn); sorry",
  "name": "pow_minFac",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 1 with (rfl | hn)",
  "core-prompt": "{n k : â„•}  (hk : k â‰  0) : (n ^ k).minFac = n.minFac",
  "args": "{n k : â„•}  (hk : k â‰  0)"},
 {"type": "(p ^ k).minFac = p",
  "tactic-prompt":
  "theorem {p k : â„•}  (hp : p.Prime)  (hk : k â‰  0) : (p ^ k).minFac = p := by rw [Nat.pow_minFac hk]; sorry",
  "name": "Prime.pow_minFac",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_minFac hk]",
  "core-prompt": "{p k : â„•}  (hp : p.Prime)  (hk : k â‰  0) : (p ^ k).minFac = p",
  "args": "{p k : â„•}  (hp : p.Prime)  (hk : k â‰  0)"},
 {"type": "i âˆ£ p ^ m â†” âˆƒ k â‰¤ m, i = p ^ k",
  "tactic-prompt":
  "theorem {p : â„•}  (pp : Prime p)  {m i : â„•} : i âˆ£ p ^ m â†” âˆƒ k â‰¤ m, i = p ^ k := by simp_rw [_root_.dvd_prime_pow  (prime_iff.mp pp)  m]; sorry",
  "name": "dvd_prime_pow",
  "kind": "theorem",
  "first-tactic": "simp_rw [_root_.dvd_prime_pow  (prime_iff.mp pp)  m]",
  "core-prompt":
  "{p : â„•}  (pp : Prime p)  {m i : â„•} : i âˆ£ p ^ m â†” âˆƒ k â‰¤ m, i = p ^ k",
  "args": "{p : â„•}  (pp : Prime p)  {m i : â„•}"},
 {"type": "a = p ^ (k + 1)",
  "tactic-prompt":
  "theorem {a p k : â„•}  (pp : Prime p)  (hâ‚ : Â¬a âˆ£ p ^ k)      (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1) := by obtain âŸ¨l, âŸ¨h, rflâŸ©âŸ© := (dvd_prime_pow pp).1 hâ‚‚; sorry",
  "name": "eq_prime_pow_of_dvd_least_prime_pow",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨l, âŸ¨h, rflâŸ©âŸ© := (dvd_prime_pow pp).1 hâ‚‚",
  "core-prompt":
  "{a p k : â„•}  (pp : Prime p)  (hâ‚ : Â¬a âˆ£ p ^ k)      (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)",
  "args":
  "{a p k : â„•}  (pp : Prime p)  (hâ‚ : Â¬a âˆ£ p ^ k)      (hâ‚‚ : a âˆ£ p ^ (k + 1))"},
 {"type": "n = 1 â†” âˆ€ p : â„•, p.Prime â†’ Â¬p âˆ£ n",
  "tactic-prompt":
  "theorem {n : â„•} : n = 1 â†” âˆ€ p : â„•, p.Prime â†’ Â¬p âˆ£ n := by simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd; sorry",
  "name": "eq_one_iff_not_exists_prime_dvd",
  "kind": "theorem",
  "first-tactic": "simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd",
  "core-prompt": "{n : â„•} : n = 1 â†” âˆ€ p : â„•, p.Prime â†’ Â¬p âˆ£ n",
  "args": "{n : â„•}"},
 {"type": "p ^ (k + 1) âˆ£ m âˆ¨ p ^ (l + 1) âˆ£ n",
  "tactic-prompt":
  "theorem {p : â„•}  (p_prime : Prime p)  {m n k l : â„•}      (hpm : p ^ k âˆ£ m)  (hpn : p ^ l âˆ£ n)  (hpmn : p ^ (k + l + 1) âˆ£ m * n) : p ^ (k + 1) âˆ£ m âˆ¨ p ^ (l + 1) âˆ£ n := by have hpd : p ^ (k + l) * p âˆ£ m * n := by\n      let hpmn' : p ^ (succ (k + l)) âˆ£ m * n := hpmn\n      rwa [pow_succ'] at hpmn'; sorry",
  "name": "succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul",
  "kind": "theorem",
  "first-tactic":
  "have hpd : p ^ (k + l) * p âˆ£ m * n := by\n      let hpmn' : p ^ (succ (k + l)) âˆ£ m * n := hpmn\n      rwa [pow_succ'] at hpmn'",
  "core-prompt":
  "{p : â„•}  (p_prime : Prime p)  {m n k l : â„•}      (hpm : p ^ k âˆ£ m)  (hpn : p ^ l âˆ£ n)  (hpmn : p ^ (k + l + 1) âˆ£ m * n) : p ^ (k + 1) âˆ£ m âˆ¨ p ^ (l + 1) âˆ£ n",
  "args":
  "{p : â„•}  (p_prime : Prime p)  {m n k l : â„•}      (hpm : p ^ k âˆ£ m)  (hpn : p ^ l âˆ£ n)  (hpmn : p ^ (k + l + 1) âˆ£ m * n)"},
 {"type": "pred n = (ppred n).getD 0",
  "tactic-prompt":
  "theorem (n : â„•) : pred n = (ppred n).getD 0 := by cases n; sorry",
  "name": "pred_eq_ppred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : â„•) : pred n = (ppred n).getD 0",
  "args": "(n : â„•)"},
 {"type": "psub m n = none â†” m < n",
  "tactic-prompt":
  "theorem {m n : â„•} : psub m n = none â†” m < n := by cases s : psub m n; sorry",
  "name": "psub_eq_none",
  "kind": "theorem",
  "first-tactic": "cases s : psub m n",
  "core-prompt": "{m n : â„•} : psub m n = none â†” m < n",
  "args": "{m n : â„•}"},
 {"type": "0 = m * n â†” m = 0 âˆ¨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : 0 = m * n â†” m = 0 âˆ¨ n = 0 := by rw [eq_comm]; sorry",
  "name": "zero_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": "{m n k l : â„•} : 0 = m * n â†” m = 0 âˆ¨ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "min m n = 0 â†” m = 0 âˆ¨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : min m n = 0 â†” m = 0 âˆ¨ n = 0 := by constructor; sorry",
  "name": "min_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : â„•} : min m n = 0 â†” m = 0 âˆ¨ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "max m n = 0 â†” m = 0 âˆ§ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : max m n = 0 â†” m = 0 âˆ§ n = 0 := by constructor; sorry",
  "name": "max_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : â„•} : max m n = 0 â†” m = 0 âˆ§ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "m + n = max m n â†” m = 0 âˆ¨ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m + n = max m n â†” m = 0 âˆ¨ n = 0 := by rw [â† min_eq_zero_iff]; sorry",
  "name": "add_eq_max_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† min_eq_zero_iff]",
  "core-prompt": "{m n k l : â„•} : m + n = max m n â†” m = 0 âˆ¨ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "m + n = min m n â†” m = 0 âˆ§ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m + n = min m n â†” m = 0 âˆ§ n = 0 := by rw [â† max_eq_zero_iff]; sorry",
  "name": "add_eq_min_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† max_eq_zero_iff]",
  "core-prompt": "{m n k l : â„•} : m + n = min m n â†” m = 0 âˆ§ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "0 < m + n",
  "tactic-prompt":
  "theorem {m n k l : â„•} (m : â„•)  {n : â„•}  (h : 0 < n) : 0 < m + n := by rw [add_comm]; sorry",
  "name": "add_pos_right",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{m n k l : â„•} (m : â„•)  {n : â„•}  (h : 0 < n) : 0 < m + n",
  "args": "{m n k l : â„•} (m : â„•)  {n : â„•}  (h : 0 < n)"},
 {"type": "m + n = 1 â†” m = 0 âˆ§ n = 1 âˆ¨ m = 1 âˆ§ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m + n = 1 â†” m = 0 âˆ§ n = 1 âˆ¨ m = 1 âˆ§ n = 0 := by cases n; sorry",
  "name": "add_eq_one_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k l : â„•} : m + n = 1 â†” m = 0 âˆ§ n = 1 âˆ¨ m = 1 âˆ§ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "m + n = 2 â†” m = 0 âˆ§ n = 2 âˆ¨ m = 1 âˆ§ n = 1 âˆ¨ m = 2 âˆ§ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m + n = 2 â†” m = 0 âˆ§ n = 2 âˆ¨ m = 1 âˆ§ n = 1 âˆ¨ m = 2 âˆ§ n = 0 := by cases n; sorry",
  "name": "add_eq_two_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{m n k l : â„•} : m + n = 2 â†” m = 0 âˆ§ n = 2 âˆ¨ m = 1 âˆ§ n = 1 âˆ¨ m = 2 âˆ§ n = 0",
  "args": "{m n k l : â„•}"},
 {"type":
  "m + n = 3 â†” m = 0 âˆ§ n = 3 âˆ¨ m = 1 âˆ§ n = 2 âˆ¨ m = 2 âˆ§ n = 1 âˆ¨ m = 3 âˆ§ n = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m + n = 3 â†” m = 0 âˆ§ n = 3 âˆ¨ m = 1 âˆ§ n = 2 âˆ¨ m = 2 âˆ§ n = 1 âˆ¨ m = 3 âˆ§ n = 0 := by cases n; sorry",
  "name": "add_eq_three_iff",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{m n k l : â„•} : m + n = 3 â†” m = 0 âˆ§ n = 3 âˆ¨ m = 1 âˆ§ n = 2 âˆ¨ m = 2 âˆ§ n = 1 âˆ¨ m = 3 âˆ§ n = 0",
  "args": "{m n k l : â„•}"},
 {"type": "n â‰¤ m âˆ§ m â‰¤ n + 1 â†” m = n âˆ¨ m = n + 1",
  "tactic-prompt":
  "theorem {m n k l : â„•} : n â‰¤ m âˆ§ m â‰¤ n + 1 â†” m = n âˆ¨ m = n + 1 := by rw [le_add_one_iff]; sorry",
  "name": "le_and_le_add_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_add_one_iff]",
  "core-prompt": "{m n k l : â„•} : n â‰¤ m âˆ§ m â‰¤ n + 1 â†” m = n âˆ¨ m = n + 1",
  "args": "{m n k l : â„•}"},
 {"type": "m + k + 1 < n + l",
  "tactic-prompt":
  "theorem {m n k l : â„•} (hab : m < n)  (hcd : k < l) : m + k + 1 < n + l := by rw [add_assoc]; sorry",
  "name": "add_succ_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [add_assoc]",
  "core-prompt":
  "{m n k l : â„•} (hab : m < n)  (hcd : k < l) : m + k + 1 < n + l",
  "args": "{m n k l : â„•} (hab : m < n)  (hcd : k < l)"},
 {"type": "OrderedSub â„•",
  "tactic-prompt":
  "instance {m n k l : â„•} : OrderedSub â„• := by constructor; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : â„•} : OrderedSub â„•",
  "args": "{m n k l : â„•}"},
 {"type": "m â‰¤ k âˆ¨ n â‰¤ l",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h : k + l = m + n - 1) : m â‰¤ k âˆ¨ n â‰¤ l := by cases' le_or_lt m k with h' h'; sorry",
  "name": "le_or_le_of_add_eq_add_pred",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt m k with h' h'",
  "core-prompt": "{m n k l : â„•} (h : k + l = m + n - 1) : m â‰¤ k âˆ¨ n â‰¤ l",
  "args": "{m n k l : â„•} (h : k + l = m + n - 1)"},
 {"type": "m â‰¤ n * m",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h : 0 < n) : m â‰¤ n * m := by conv =>\n    lhs\n    rw [â† one_mul m]; sorry",
  "name": "le_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [â† one_mul m]",
  "core-prompt": "{m n k l : â„•} (h : 0 < n) : m â‰¤ n * m",
  "args": "{m n k l : â„•} (h : 0 < n)"},
 {"type": "m â‰¤ m * n",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h : 0 < n) : m â‰¤ m * n := by conv =>\n    lhs\n    rw [â† mul_one m]; sorry",
  "name": "le_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [â† mul_one m]",
  "core-prompt": "{m n k l : â„•} (h : 0 < n) : m â‰¤ m * n",
  "args": "{m n k l : â„•} (h : 0 < n)"},
 {"type": "n â‰¤ i + (n - 1)",
  "tactic-prompt":
  "theorem {m n k l : â„•} (n : â„•)  {i : â„•}  (hi : i â‰  0) : n â‰¤ i + (n - 1) := by refine le_trans ?_ add_tsub_le_assoc; sorry",
  "name": "le_add_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "refine le_trans ?_ add_tsub_le_assoc",
  "core-prompt":
  "{m n k l : â„•} (n : â„•)  {i : â„•}  (hi : i â‰  0) : n â‰¤ i + (n - 1)",
  "args": "{m n k l : â„•} (n : â„•)  {i : â„•}  (hi : i â‰  0)"},
 {"type": "m * n / (k * l) = m / k * (n / l)",
  "tactic-prompt":
  "theorem {m n k l : â„•} (hmk : k âˆ£ m)  (hnl : l âˆ£ n) : m * n / (k * l) = m / k * (n / l) := by rcases k.eq_zero_or_pos with (rfl | hk0); sorry",
  "name": "mul_div_mul_comm_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "rcases k.eq_zero_or_pos with (rfl | hk0)",
  "core-prompt":
  "{m n k l : â„•} (hmk : k âˆ£ m)  (hnl : l âˆ£ n) : m * n / (k * l) = m / k * (n / l)",
  "args": "{m n k l : â„•} (hmk : k âˆ£ m)  (hnl : l âˆ£ n)"},
 {"type": "2 * (n / 2) = n - 1",
  "tactic-prompt":
  "theorem {m n k l : â„•} (hn : n % 2 = 1) : 2 * (n / 2) = n - 1 := by conv =>\n    rhs\n    rw [â† Nat.mod_add_div n 2]; sorry",
  "name": "two_mul_odd_div_two",
  "kind": "theorem",
  "first-tactic": "conv =>\n    rhs\n    rw [â† Nat.mod_add_div n 2]",
  "core-prompt": "{m n k l : â„•} (hn : n % 2 = 1) : 2 * (n / 2) = n - 1",
  "args": "{m n k l : â„•} (hn : n % 2 = 1)"},
 {"type": "m / (m / n) = n",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h : n âˆ£ m)  (hm : m â‰  0) : m / (m / n) = n := by rcases h with âŸ¨_, rflâŸ©; sorry",
  "name": "div_div_self",
  "kind": "theorem",
  "first-tactic": "rcases h with âŸ¨_, rflâŸ©",
  "core-prompt": "{m n k l : â„•} (h : n âˆ£ m)  (hm : m â‰  0) : m / (m / n) = n",
  "args": "{m n k l : â„•} (h : n âˆ£ m)  (hm : m â‰  0)"},
 {"type": "m % (n * k) / n = m / n % k",
  "tactic-prompt":
  "theorem {m n k l : â„•} (m n k : â„•) : m % (n * k) / n = m / n % k := by rcases Nat.eq_zero_or_pos n with (rfl | hn); sorry",
  "name": "mod_mul_right_div_self",
  "kind": "theorem",
  "first-tactic": "rcases Nat.eq_zero_or_pos n with (rfl | hn)",
  "core-prompt": "{m n k l : â„•} (m n k : â„•) : m % (n * k) / n = m / n % k",
  "args": "{m n k l : â„•} (m n k : â„•)"},
 {"type": "m % (k * n) / n = m / n % k",
  "tactic-prompt":
  "theorem {m n k l : â„•} (m n k : â„•) : m % (k * n) / n = m / n % k := by rw [mul_comm k]; sorry",
  "name": "mod_mul_left_div_self",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm k]",
  "core-prompt": "{m n k l : â„•} (m n k : â„•) : m % (k * n) / n = m / n % k",
  "args": "{m n k l : â„•} (m n k : â„•)"},
 {"type": "Â¬m âˆ£ n",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h1 : 0 < n)  (h2 : n < m) : Â¬m âˆ£ n := by rintro âŸ¨k, rflâŸ©; sorry",
  "name": "not_dvd_of_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨k, rflâŸ©",
  "core-prompt": "{m n k l : â„•} (h1 : 0 < n)  (h2 : n < m) : Â¬m âˆ£ n",
  "args": "{m n k l : â„•} (h1 : 0 < n)  (h2 : n < m)"},
 {"type": "(m - n) % k = 0",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h : m % k = n % k) : (m - n) % k = 0 := by rw [â† Nat.mod_add_div m k]; sorry",
  "name": "sub_mod_eq_zero_of_mod_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.mod_add_div m k]",
  "core-prompt": "{m n k l : â„•} (h : m % k = n % k) : (m - n) % k = 0",
  "args": "{m n k l : â„•} (h : m % k = n % k)"},
 {"type":
  "(m + n) % k = if k â‰¤ m % k + n % k then m % k + n % k - k else m % k + n % k",
  "tactic-prompt":
  "theorem {m n k l : â„•} : (m + n) % k = if k â‰¤ m % k + n % k then m % k + n % k - k else m % k + n % k := by cases k; sorry",
  "name": "add_mod_eq_ite",
  "kind": "theorem",
  "first-tactic": "cases k",
  "core-prompt":
  "{m n k l : â„•} : (m + n) % k = if k â‰¤ m % k + n % k then m % k + n % k - k else m % k + n % k",
  "args": "{m n k l : â„•}"},
 {"type": "m / n = m â†” m = 0 âˆ¨ n = 1",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m / n = m â†” m = 0 âˆ¨ n = 1 := by constructor; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{m n k l : â„•} : m / n = m â†” m = 0 âˆ¨ n = 1",
  "args": "{m n k l : â„•}"},
 {"type": "m / n = (m - m % n) / n",
  "tactic-prompt":
  "theorem {m n k l : â„•} : m / n = (m - m % n) / n := by by_cases n0 : n = 0; sorry",
  "name": "div_eq_sub_mod_div",
  "kind": "theorem",
  "first-tactic": "by_cases n0 : n = 0",
  "core-prompt": "{m n k l : â„•} : m / n = (m - m % n) / n",
  "args": "{m n k l : â„•}"},
 {"type": "Â¬n âˆ£ m",
  "tactic-prompt":
  "theorem {m n k l : â„•} (h1 : n * k < m)  (h2 : m < n * (k + 1)) : Â¬n âˆ£ m := by rintro âŸ¨d, rflâŸ©; sorry",
  "name": "not_dvd_of_between_consec_multiples",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨d, rflâŸ©",
  "core-prompt":
  "{m n k l : â„•} (h1 : n * k < m)  (h2 : m < n * (k + 1)) : Â¬n âˆ£ m",
  "args": "{m n k l : â„•} (h1 : n * k < m)  (h2 : m < n * (k + 1))"},
 {"type": "0 < Nat.find h â†” Â¬p 0",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : âˆƒ n : â„•, p n) : 0 < Nat.find h â†” Â¬p 0 := by rw [pos_iff_ne_zero]; sorry",
  "name": "find_pos",
  "kind": "theorem",
  "first-tactic": "rw [pos_iff_ne_zero]",
  "core-prompt":
  "{m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : âˆƒ n : â„•, p n) : 0 < Nat.find h â†” Â¬p 0",
  "args":
  "{m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it (h : âˆƒ n : â„•, p n)"},
 {"type": "Nat.find hâ‚˜ + n = Nat.find hâ‚™",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hâ‚˜ : âˆƒ m, p (m + n)}  {hâ‚™ : âˆƒ n, p n}  (hn : n â‰¤ Nat.find hâ‚™) : Nat.find hâ‚˜ + n = Nat.find hâ‚™ := by refine ((le_find_iff _ _).2 fun m hm hpm => hm.not_le ?_).antisymm ?_; sorry",
  "name": "find_add",
  "kind": "theorem",
  "first-tactic":
  "refine ((le_find_iff _ _).2 fun m hm hpm => hm.not_le ?_).antisymm ?_",
  "core-prompt":
  "{m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hâ‚˜ : âˆƒ m, p (m + n)}  {hâ‚™ : âˆƒ n, p n}  (hn : n â‰¤ Nat.find hâ‚™) : Nat.find hâ‚˜ + n = Nat.find hâ‚™",
  "args":
  "{m n k l : â„•}  {p q : â„• â†’ Prop}  [DecidablePred p]  [DecidablePred q]  --Porting note: removing `simp` attribute as `simp` can prove it {hâ‚˜ : âˆƒ m, p (m + n)}  {hâ‚™ : âˆƒ n, p n}  (hn : n â‰¤ Nat.find hâ‚™)"},
 {"type":
  "Nat.findGreatest P k = m â†” m â‰¤ k âˆ§ (m â‰  0 â†’ P m) âˆ§ âˆ€ â¦ƒnâ¦„, m < n â†’ n â‰¤ k â†’ Â¬P n",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] : Nat.findGreatest P k = m â†” m â‰¤ k âˆ§ (m â‰  0 â†’ P m) âˆ§ âˆ€ â¦ƒnâ¦„, m < n â†’ n â‰¤ k â†’ Â¬P n := by induction' k with k ihk generalizing m; sorry",
  "name": "findGreatest_eq_iff",
  "kind": "theorem",
  "first-tactic": "induction' k with k ihk generalizing m",
  "core-prompt":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] : Nat.findGreatest P k = m â†” m â‰¤ k âˆ§ (m â‰  0 â†’ P m) âˆ§ âˆ€ â¦ƒnâ¦„, m < n â†’ n â‰¤ k â†’ Â¬P n",
  "args": "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P]"},
 {"type": "Nat.findGreatest P k = 0 â†” âˆ€ â¦ƒnâ¦„, 0 < n â†’ n â‰¤ k â†’ Â¬P n",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] : Nat.findGreatest P k = 0 â†” âˆ€ â¦ƒnâ¦„, 0 < n â†’ n â‰¤ k â†’ Â¬P n := by simp [findGreatest_eq_iff]; sorry",
  "name": "findGreatest_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "simp [findGreatest_eq_iff]",
  "core-prompt":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] : Nat.findGreatest P k = 0 â†” âˆ€ â¦ƒnâ¦„, 0 < n â†’ n â‰¤ k â†’ Â¬P n",
  "args": "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P]"},
 {"type": "P (Nat.findGreatest P n)",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (hmb : m â‰¤ n)  (hm : P m) : P (Nat.findGreatest P n) := by by_cases h : Nat.findGreatest P n = 0; sorry",
  "name": "findGreatest_spec",
  "kind": "theorem",
  "first-tactic": "by_cases h : Nat.findGreatest P n = 0",
  "core-prompt":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (hmb : m â‰¤ n)  (hm : P m) : P (Nat.findGreatest P n)",
  "args":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (hmb : m â‰¤ n)  (hm : P m)"},
 {"type": "Monotone (Nat.findGreatest P)",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (P : â„• â†’ Prop)  [DecidablePred P] : Monotone (Nat.findGreatest P) := by refine monotone_nat_of_le_succ fun n => ?_; sorry",
  "name": "findGreatest_mono_right",
  "kind": "theorem",
  "first-tactic": "refine monotone_nat_of_le_succ fun n => ?_",
  "core-prompt":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (P : â„• â†’ Prop)  [DecidablePred P] : Monotone (Nat.findGreatest P)",
  "args":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] (P : â„• â†’ Prop)  [DecidablePred P]"},
 {"type": "Nat.findGreatest P â‰¤ Nat.findGreatest Q",
  "tactic-prompt":
  "theorem {m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P â‰¤ Q) : Nat.findGreatest P â‰¤ Nat.findGreatest Q := by intro n; sorry",
  "name": "findGreatest_mono_left",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P â‰¤ Q) : Nat.findGreatest P â‰¤ Nat.findGreatest Q",
  "args":
  "{m n k l : â„•}  {P Q : â„• â†’ Prop}  [DecidablePred P] [DecidablePred Q]  (hPQ : P â‰¤ Q)"},
 {"type": "a < n / d â†” d * a < n",
  "tactic-prompt":
  "theorem {m n k : â„•} {n d : â„•}  (hnd : d âˆ£ n)  (a : â„•) : a < n / d â†” d * a < n := by rcases d.eq_zero_or_pos with (rfl | hd0); sorry",
  "name": "lt_div_iff_mul_lt",
  "kind": "theorem",
  "first-tactic": "rcases d.eq_zero_or_pos with (rfl | hd0)",
  "core-prompt":
  "{m n k : â„•} {n d : â„•}  (hnd : d âˆ£ n)  (a : â„•) : a < n / d â†” d * a < n",
  "args": "{m n k : â„•} {n d : â„•}  (hnd : d âˆ£ n)  (a : â„•)"},
 {"type": "n / x = n / y â†” x = y",
  "tactic-prompt":
  "theorem {m n k : â„•} {n x y : â„•}  (hn : n â‰  0)  (hx : x âˆ£ n)  (hy : y âˆ£ n) : n / x = n / y â†” x = y := by constructor; sorry",
  "name": "div_eq_iff_eq_of_dvd_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{m n k : â„•} {n x y : â„•}  (hn : n â‰  0)  (hx : x âˆ£ n)  (hy : y âˆ£ n) : n / x = n / y â†” x = y",
  "args": "{m n k : â„•} {n x y : â„•}  (hn : n â‰  0)  (hx : x âˆ£ n)  (hy : y âˆ£ n)"},
 {"type": "Â¬2 âˆ£ bit1 n",
  "tactic-prompt":
  "theorem {m n k : â„•} (n : â„•) : Â¬2 âˆ£ bit1 n := by rw [bit1]; sorry",
  "name": "not_two_dvd_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt": "{m n k : â„•} (n : â„•) : Â¬2 âˆ£ bit1 n",
  "args": "{m n k : â„•} (n : â„•)"},
 {"type": "k âˆ£ m - n",
  "tactic-prompt":
  "theorem {m n k : â„•} {k m n : â„•}  (hâ‚ : k âˆ£ m)  (hâ‚‚ : k âˆ£ n) : k âˆ£ m - n := by cases' le_total n m with H H; sorry",
  "name": "dvd_sub'",
  "kind": "theorem",
  "first-tactic": "cases' le_total n m with H H",
  "core-prompt":
  "{m n k : â„•} {k m n : â„•}  (hâ‚ : k âˆ£ m)  (hâ‚‚ : k âˆ£ n) : k âˆ£ m - n",
  "args": "{m n k : â„•} {k m n : â„•}  (hâ‚ : k âˆ£ m)  (hâ‚‚ : k âˆ£ n)"},
 {"type": "(a + 1) / b = a / b + 1",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (hba : b âˆ£ a + 1) : (a + 1) / b = a / b + 1 := by rw [succ_div]; sorry",
  "name": "succ_div_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [succ_div]",
  "core-prompt":
  "{m n k : â„•} {a b : â„•}  (hba : b âˆ£ a + 1) : (a + 1) / b = a / b + 1",
  "args": "{m n k : â„•} {a b : â„•}  (hba : b âˆ£ a + 1)"},
 {"type": "(a + 1) / b = a / b",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b : â„•}  (hba : Â¬b âˆ£ a + 1) : (a + 1) / b = a / b := by rw [succ_div]; sorry",
  "name": "succ_div_of_not_dvd",
  "kind": "theorem",
  "first-tactic": "rw [succ_div]",
  "core-prompt":
  "{m n k : â„•} {a b : â„•}  (hba : Â¬b âˆ£ a + 1) : (a + 1) / b = a / b",
  "args": "{m n k : â„•} {a b : â„•}  (hba : Â¬b âˆ£ a + 1)"},
 {"type": "m % n / n = 0",
  "tactic-prompt":
  "theorem {m n k : â„•} (m n : â„•) : m % n / n = 0 := by cases n; sorry",
  "name": "mod_div_self",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{m n k : â„•} (m n : â„•) : m % n / n = 0",
  "args": "{m n k : â„•} (m n : â„•)"},
 {"type": "(âˆƒ k : â„•, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n",
  "tactic-prompt":
  "theorem {m n k : â„•} (n : â„•)  {a : â„•}  (ha : 0 < a) : (âˆƒ k : â„•, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n := by refine'\n    âŸ¨fun âŸ¨k, hk1, hk2âŸ© => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>\n      âŸ¨n / a, âŸ¨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ haâŸ©âŸ©âŸ©; sorry",
  "name": "not_dvd_iff_between_consec_multiples",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun âŸ¨k, hk1, hk2âŸ© => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>\n      âŸ¨n / a, âŸ¨lt_of_le_of_ne (mul_div_le n a) _, lt_mul_div_succ _ haâŸ©âŸ©âŸ©",
  "core-prompt":
  "{m n k : â„•} (n : â„•)  {a : â„•}  (ha : 0 < a) : (âˆƒ k : â„•, a * k < n âˆ§ n < a * (k + 1)) â†” Â¬a âˆ£ n",
  "args": "{m n k : â„•} (n : â„•)  {a : â„•}  (ha : 0 < a)"},
 {"type": "a / d < b / d",
  "tactic-prompt":
  "theorem {m n k : â„•} {a b d : â„•}  (hdb : d âˆ£ b)  (h : a < b) : a / d < b / d := by rw [Nat.lt_div_iff_mul_lt hdb]; sorry",
  "name": "div_lt_div_of_lt_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Nat.lt_div_iff_mul_lt hdb]",
  "core-prompt":
  "{m n k : â„•} {a b d : â„•}  (hdb : d âˆ£ b)  (h : a < b) : a / d < b / d",
  "args": "{m n k : â„•} {a b d : â„•}  (hdb : d âˆ£ b)  (h : a < b)"},
 {"type": "{0} âˆª range succ = univ",
  "tactic-prompt": "theorem  : {0} âˆª range succ = univ := by ext n; sorry",
  "name": "zero_union_range_succ",
  "kind": "theorem",
  "first-tactic": "ext n",
  "core-prompt": " : {0} âˆª range succ = univ",
  "args": ""},
 {"type": "range succ = { i | 0 < i }",
  "tactic-prompt":
  "theorem  : range succ = { i | 0 < i } := by ext (_ | i); sorry",
  "name": "range_succ",
  "kind": "theorem",
  "first-tactic": "ext (_ | i)",
  "core-prompt": " : range succ = { i | 0 < i }",
  "args": ""},
 {"type": "{f 0} âˆª range (f âˆ˜ succ) = range f",
  "tactic-prompt":
  "theorem {Î± : Type _} (f : â„• â†’ Î±) : {f 0} âˆª range (f âˆ˜ succ) = range f := by rw [â† image_singleton]; sorry",
  "name": "range_of_succ",
  "kind": "theorem",
  "first-tactic": "rw [â† image_singleton]",
  "core-prompt":
  "{Î± : Type _} (f : â„• â†’ Î±) : {f 0} âˆª range (f âˆ˜ succ) = range f",
  "args": "{Î± : Type _} (f : â„• â†’ Î±)"},
 {"type":
  "(Set.range fun n => Nat.rec x f n : Set Î±) =\n      {x} âˆª Set.range fun n => Nat.rec (f 0 x) (f âˆ˜ succ) n",
  "tactic-prompt":
  "theorem {Î± : Type _} {Î± : Type _}  (x : Î±)  (f : â„• â†’ Î± â†’ Î±) : (Set.range fun n => Nat.rec x f n : Set Î±) =\n      {x} âˆª Set.range fun n => Nat.rec (f 0 x) (f âˆ˜ succ) n := by convert (range_of_succ (fun n => Nat.rec x f n : â„• â†’ Î±)).symm; sorry",
  "name": "range_rec",
  "kind": "theorem",
  "first-tactic":
  "convert (range_of_succ (fun n => Nat.rec x f n : â„• â†’ Î±)).symm",
  "core-prompt":
  "{Î± : Type _} {Î± : Type _}  (x : Î±)  (f : â„• â†’ Î± â†’ Î±) : (Set.range fun n => Nat.rec x f n : Set Î±) =\n      {x} âˆª Set.range fun n => Nat.rec (f 0 x) (f âˆ˜ succ) n",
  "args": "{Î± : Type _} {Î± : Type _}  (x : Î±)  (f : â„• â†’ Î± â†’ Î±)"},
 {"type": "1 â‰¤ m ^ n",
  "tactic-prompt":
  "theorem (n m : â„•)  (h : 0 < m) : 1 â‰¤ m ^ n := by rw [â† one_pow n]; sorry",
  "name": "one_le_pow",
  "kind": "theorem",
  "first-tactic": "rw [â† one_pow n]",
  "core-prompt": "(n m : â„•)  (h : 0 < m) : 1 â‰¤ m ^ n",
  "args": "(n m : â„•)  (h : 0 < m)"},
 {"type": "1 < m ^ n",
  "tactic-prompt":
  "theorem (n m : â„•)  (hâ‚€ : 0 < n)  (hâ‚ : 1 < m) : 1 < m ^ n := by rw [â† one_pow n]; sorry",
  "name": "one_lt_pow",
  "kind": "theorem",
  "first-tactic": "rw [â† one_pow n]",
  "core-prompt": "(n m : â„•)  (hâ‚€ : 0 < n)  (hâ‚ : 1 < m) : 1 < m ^ n",
  "args": "(n m : â„•)  (hâ‚€ : 0 < n)  (hâ‚ : 1 < m)"},
 {"type": "1 < n ^ k â†” 1 < n",
  "tactic-prompt":
  "theorem {k n : â„•}  (h : 0 â‰  k) : 1 < n ^ k â†” 1 < n := by rcases n with (rfl | n); sorry",
  "name": "one_lt_pow_iff",
  "kind": "theorem",
  "first-tactic": "rcases n with (rfl | n)",
  "core-prompt": "{k n : â„•}  (h : 0 â‰  k) : 1 < n ^ k â†” 1 < n",
  "args": "{k n : â„•}  (h : 0 â‰  k)"},
 {"type": "n * q < a * q ^ (n + 1)",
  "tactic-prompt":
  "theorem {n a q : â„•}  (a0 : 0 < a)  (q1 : 1 < q) : n * q < a * q ^ (n + 1) := by rw [pow_succ]; sorry",
  "name": "mul_lt_mul_pow_succ",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt":
  "{n a q : â„•}  (a0 : 0 < a)  (q1 : 1 < q) : n * q < a * q ^ (n + 1)",
  "args": "{n a q : â„•}  (a0 : 0 < a)  (q1 : 1 < q)"},
 {"type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by rw [sq]; sorry",
  "name": "sq_sub_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt": "(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
  "args": "(a b : â„•)"},
 {"type": "a ^ b % n = (a % n) ^ b % n",
  "tactic-prompt":
  "theorem (a b n : â„•) : a ^ b % n = (a % n) ^ b % n := by induction' b with b ih; sorry",
  "name": "pow_mod",
  "kind": "theorem",
  "first-tactic": "induction' b with b ih",
  "core-prompt": "(a b n : â„•) : a ^ b % n = (a % n) ^ b % n",
  "args": "(a b n : â„•)"},
 {"type": "m % b ^ succ w = b * (m / b % b ^ w) + m % b",
  "tactic-prompt":
  "theorem {b : â„•}  (w m : â„•) : m % b ^ succ w = b * (m / b % b ^ w) + m % b := by by_cases b_h : b = 0; sorry",
  "name": "mod_pow_succ",
  "kind": "theorem",
  "first-tactic": "by_cases b_h : b = 0",
  "core-prompt":
  "{b : â„•}  (w m : â„•) : m % b ^ succ w = b * (m / b % b ^ w) + m % b",
  "args": "{b : â„•}  (w m : â„•)"},
 {"type": "x ^ k âˆ£ x ^ l â†” k â‰¤ l",
  "tactic-prompt":
  "theorem {x k l : â„•}  (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l := by rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w)]; sorry",
  "name": "pow_dvd_pow_iff_le_right",
  "kind": "theorem",
  "first-tactic": "rw [pow_dvd_pow_iff_pow_le_pow (lt_of_succ_lt w)]",
  "core-prompt": "{x k l : â„•}  (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l",
  "args": "{x k l : â„•}  (w : 1 < x)"},
 {"type": "p âˆ£ m",
  "tactic-prompt":
  "theorem {p k m : â„•}  (hk : 1 â‰¤ k)  (hpk : p ^ k âˆ£ m) : p âˆ£ m := by rw [â† pow_one p]; sorry",
  "name": "dvd_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_one p]",
  "core-prompt": "{p k m : â„•}  (hk : 1 â‰¤ k)  (hpk : p ^ k âˆ£ m) : p âˆ£ m",
  "args": "{p k m : â„•}  (hk : 1 â‰¤ k)  (hpk : p ^ k âˆ£ m)"},
 {"type": "x ^ m / x ^ n = x ^ (m - n)",
  "tactic-prompt":
  "theorem {x m n : â„•}  (h : n â‰¤ m)  (hx : 0 < x) : x ^ m / x ^ n = x ^ (m - n) := by rw [Nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h)]; sorry",
  "name": "pow_div",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.div_eq_iff_eq_mul_left (pow_pos hx n) (pow_dvd_pow _ h)]",
  "core-prompt":
  "{x m n : â„•}  (h : n â‰¤ m)  (hx : 0 < x) : x ^ m / x ^ n = x ^ (m - n)",
  "args": "{x m n : â„•}  (h : n â‰¤ m)  (hx : 0 < x)"},
 {"type": "i < n",
  "tactic-prompt":
  "theorem {p i n : â„•}  (hn : n â‰  0)  (hp : 2 â‰¤ p)  (h : p ^ i âˆ£ n) : i < n := by rw [â† pow_lt_iff_lt_right hp]; sorry",
  "name": "lt_of_pow_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_lt_iff_lt_right hp]",
  "core-prompt":
  "{p i n : â„•}  (hn : n â‰  0)  (hp : 2 â‰¤ p)  (h : p ^ i âˆ£ n) : i < n",
  "args": "{p i n : â„•}  (hn : n â‰  0)  (hp : 2 â‰¤ p)  (h : p ^ i âˆ£ n)"},
 {"type": "x * k â‰¤ y",
  "tactic-prompt":
  "lemma (k x y : â„•)  (h : x â‰¤ y / k) : x * k â‰¤ y := by by_cases hk : k = 0; sorry",
  "name": "mul_le_of_le_div",
  "kind": "lemma",
  "first-tactic": "by_cases hk : k = 0",
  "core-prompt": "(k x y : â„•)  (h : x â‰¤ y / k) : x * k â‰¤ y",
  "args": "(k x y : â„•)  (h : x â‰¤ y / k)"},
 {"type": "(a / b) * (c / d) â‰¤ (a * c) / (b * d)",
  "tactic-prompt":
  "lemma (a b c d : â„•) : (a / b) * (c / d) â‰¤ (a * c) / (b * d) := by by_cases hb : b = 0; sorry",
  "name": "div_mul_div_le",
  "kind": "lemma",
  "first-tactic": "by_cases hb : b = 0",
  "core-prompt": "(a b c d : â„•) : (a / b) * (c / d) â‰¤ (a * c) / (b * d)",
  "args": "(a b c d : â„•)"},
 {"type":
  "let iter_next (n guess : â„•) := (guess + n / guess) / 2;\n  sqrt.iter n k â‰¤ iter_next n (sqrt.iter n k)",
  "tactic-prompt":
  "lemma (n k : â„•) : let iter_next (n guess : â„•) := (guess + n / guess) / 2;\n  sqrt.iter n k â‰¤ iter_next n (sqrt.iter n k) := by intro iter_next; sorry",
  "name": "iter_fp_bound",
  "kind": "lemma",
  "first-tactic": "intro iter_next",
  "core-prompt":
  "(n k : â„•) : let iter_next (n guess : â„•) := (guess + n / guess) / 2;\n  sqrt.iter n k â‰¤ iter_next n (sqrt.iter n k)",
  "args": "(n k : â„•)"},
 {"type": "sqrt.iter n guess * sqrt.iter n guess â‰¤ n",
  "tactic-prompt":
  "lemma (n guess : â„•) : sqrt.iter n guess * sqrt.iter n guess â‰¤ n := by unfold sqrt.iter; sorry",
  "name": "sqrt.iter_sq_le",
  "kind": "lemma",
  "first-tactic": "unfold sqrt.iter",
  "core-prompt": "(n guess : â„•) : sqrt.iter n guess * sqrt.iter n guess â‰¤ n",
  "args": "(n guess : â„•)"},
 {"type": "n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1)",
  "tactic-prompt":
  "lemma (n guess : â„•)  (hn : n < (guess + 1) * (guess + 1)) : n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1) := by unfold sqrt.iter; sorry",
  "name": "sqrt.lt_iter_succ_sq",
  "kind": "lemma",
  "first-tactic": "unfold sqrt.iter",
  "core-prompt":
  "(n guess : â„•)  (hn : n < (guess + 1) * (guess + 1)) : n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1)",
  "args": "(n guess : â„•)  (hn : n < (guess + 1) * (guess + 1))"},
 {"type": "tail (map f s) = map f (tail s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±) : tail (map f s) = map f (tail s) := by rw [tail_eq_drop]; sorry",
  "name": "tail_map",
  "kind": "theorem",
  "first-tactic": "rw [tail_eq_drop]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±) : tail (map f s) = map f (tail s)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±)"},
 {"type": "map f s = f (head s)::map f (tail s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±) : map f s = f (head s)::map f (tail s) := by rw [â† Stream'.eta (map f s)]; sorry",
  "name": "map_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Stream'.eta (map f s)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±) : map f s = f (head s)::map f (tail s)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (s : Stream' Î±)"},
 {"type": "map f (a::s) = f a::map f s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (a : Î±)  (s : Stream' Î±) : map f (a::s) = f a::map f s := by rw [â† Stream'.eta (map f (a::s))]; sorry",
  "name": "map_cons",
  "kind": "theorem",
  "first-tactic": "rw [â† Stream'.eta (map f (a::s))]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (a : Î±)  (s : Stream' Î±) : map f (a::s) = f a::map f s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²) (a : Î±)  (s : Stream' Î±)"},
 {"type": "zip f sâ‚ sâ‚‚ = f (head sâ‚) (head sâ‚‚)::zip f (tail sâ‚) (tail sâ‚‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î² â†’ Î´) (sâ‚ : Stream' Î±)  (sâ‚‚ : Stream' Î²) : zip f sâ‚ sâ‚‚ = f (head sâ‚) (head sâ‚‚)::zip f (tail sâ‚) (tail sâ‚‚) := by rw [â† Stream'.eta (zip f sâ‚ sâ‚‚)]; sorry",
  "name": "zip_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Stream'.eta (zip f sâ‚ sâ‚‚)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î² â†’ Î´) (sâ‚ : Stream' Î±)  (sâ‚‚ : Stream' Î²) : zip f sâ‚ sâ‚‚ = f (head sâ‚) (head sâ‚‚)::zip f (tail sâ‚) (tail sâ‚‚)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î² â†’ Î´) (sâ‚ : Stream' Î±)  (sâ‚‚ : Stream' Î²)"},
 {"type": "const a = a::const a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (a : Î±) : const a = a::const a := by apply Stream'.ext; sorry",
  "name": "const_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (a : Î±) : const a = a::const a",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (a : Î±)"},
 {"type": "tail (iterate f a) = iterate f (f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : tail (iterate f a) = iterate f (f a) := by funext n; sorry",
  "name": "tail_iterate",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : tail (iterate f a) = iterate f (f a)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±)"},
 {"type": "iterate f a = a::iterate f (f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : iterate f a = a::iterate f (f a) := by rw [â† Stream'.eta (iterate f a)]; sorry",
  "name": "iterate_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Stream'.eta (iterate f a)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : iterate f a = a::iterate f (f a)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±)"},
 {"type": "nth (iterate f a) (succ n) = nth (iterate f (f a)) n",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : Nat)  (f : Î± â†’ Î±)  (a : Î±) : nth (iterate f a) (succ n) = nth (iterate f (f a)) n := by rw [nth_succ]; sorry",
  "name": "nth_succ_iterate",
  "kind": "theorem",
  "first-tactic": "rw [nth_succ]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : Nat)  (f : Î± â†’ Î±)  (a : Î±) : nth (iterate f a) (succ n) = nth (iterate f (f a)) n",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : Nat)  (f : Î± â†’ Î±)  (a : Î±)"},
 {"type": "iterate f (f a) = map f (iterate f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : iterate f (f a) = map f (iterate f a) := by funext n; sorry",
  "name": "map_iterate",
  "kind": "theorem",
  "first-tactic": "funext n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±) : iterate f (f a) = map f (iterate f a)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (f : Î± â†’ Î±)  (a : Î±)"},
 {"type": "corec f g a = f a::corec f g (g a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²)  (g : Î± â†’ Î±)  (a : Î±) : corec f g a = f a::corec f g (g a) := by rw [corec_def]; sorry",
  "name": "corec_eq",
  "kind": "theorem",
  "first-tactic": "rw [corec_def]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²)  (g : Î± â†’ Î±)  (a : Î±) : corec f g a = f a::corec f g (g a)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (f : Î± â†’ Î²)  (g : Î± â†’ Î±)  (a : Î±)"},
 {"type": "corec id id a = const a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (a : Î±) : corec id id a = const a := by rw [corec_def]; sorry",
  "name": "corec_id_id_eq_const",
  "kind": "theorem",
  "first-tactic": "rw [corec_def]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (a : Î±) : corec id id a = const a",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}  (a : Î±)"},
 {"type": "unfolds g f a = g a::unfolds g f (f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (g : Î± â†’ Î²)  (f : Î± â†’ Î±)  (a : Î±) : unfolds g f a = g a::unfolds g f (f a) := by unfold unfolds; sorry",
  "name": "unfolds_eq",
  "kind": "theorem",
  "first-tactic": "unfold unfolds",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (g : Î± â†’ Î²)  (f : Î± â†’ Î±)  (a : Î±) : unfolds g f a = g a::unfolds g f (f a)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (g : Î± â†’ Î²)  (f : Î± â†’ Î±)  (a : Î±)"},
 {"type":
  "âˆ€ (n : Nat) (s : Stream' Î±),\n    nth (unfolds head tail s) n = nth s n",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±),\n    nth (unfolds head tail s) n = nth s n := by intro n; sorry",
  "name": "nth_unfolds_head_tail",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±),\n    nth (unfolds head tail s) n = nth s n",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "sâ‚ â‹ˆ sâ‚‚ = head sâ‚::head sâ‚‚::(tail sâ‚ â‹ˆ tail sâ‚‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : sâ‚ â‹ˆ sâ‚‚ = head sâ‚::head sâ‚‚::(tail sâ‚ â‹ˆ tail sâ‚‚) := by let t := tail sâ‚ â‹ˆ tail sâ‚‚; sorry",
  "name": "interleave_eq",
  "kind": "theorem",
  "first-tactic": "let t := tail sâ‚ â‹ˆ tail sâ‚‚",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : sâ‚ â‹ˆ sâ‚‚ = head sâ‚::head sâ‚‚::(tail sâ‚ â‹ˆ tail sâ‚‚)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±)"},
 {"type": "tail (sâ‚ â‹ˆ sâ‚‚) = sâ‚‚ â‹ˆ tail sâ‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : tail (sâ‚ â‹ˆ sâ‚‚) = sâ‚‚ â‹ˆ tail sâ‚ := by unfold interleave corecOn; sorry",
  "name": "tail_interleave",
  "kind": "theorem",
  "first-tactic": "unfold interleave corecOn",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : tail (sâ‚ â‹ˆ sâ‚‚) = sâ‚‚ â‹ˆ tail sâ‚",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±)"},
 {"type": "tail sâ‚ â‹ˆ tail sâ‚‚ = tail (tail (sâ‚ â‹ˆ sâ‚‚))",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : tail sâ‚ â‹ˆ tail sâ‚‚ = tail (tail (sâ‚ â‹ˆ sâ‚‚)) := by rw [interleave_eq sâ‚ sâ‚‚]; sorry",
  "name": "interleave_tail_tail",
  "kind": "theorem",
  "first-tactic": "rw [interleave_eq sâ‚ sâ‚‚]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : tail sâ‚ â‹ˆ tail sâ‚‚ = tail (tail (sâ‚ â‹ˆ sâ‚‚))",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±)"},
 {"type": "tail (even s) = even (tail (tail s))",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tail (even s) = even (tail (tail s)) := by unfold even; sorry",
  "name": "tail_even",
  "kind": "theorem",
  "first-tactic": "unfold even",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tail (even s) = even (tail (tail s))",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type": "even (aâ‚::aâ‚‚::s) = aâ‚::even s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (aâ‚ aâ‚‚ : Î±)  (s : Stream' Î±) : even (aâ‚::aâ‚‚::s) = aâ‚::even s := by unfold even; sorry",
  "name": "even_cons_cons",
  "kind": "theorem",
  "first-tactic": "unfold even",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (aâ‚ aâ‚‚ : Î±)  (s : Stream' Î±) : even (aâ‚::aâ‚‚::s) = aâ‚::even s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (aâ‚ aâ‚‚ : Î±)  (s : Stream' Î±)"},
 {"type": "[head s] ++â‚› tail s = s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : [head s] ++â‚› tail s = s := by rw [cons_append_stream]; sorry",
  "name": "append_stream_head_tail",
  "kind": "theorem",
  "first-tactic": "rw [cons_append_stream]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : [head s] ++â‚› tail s = s",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type": "(take n s).length = n",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : â„•)  (s : Stream' Î±) : (take n s).length = n := by induction n generalizing s; sorry",
  "name": "length_take",
  "kind": "theorem",
  "first-tactic": "induction n generalizing s",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : â„•)  (s : Stream' Î±) : (take n s).length = n",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (n : â„•)  (s : Stream' Î±)"},
 {"type":
  "âˆ€ (n : Nat) (s : Stream' Î±),\n    appendStream' (take n s) (drop n s) = s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±),\n    appendStream' (take n s) (drop n s) = s := by intro n; sorry",
  "name": "append_take_drop",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±),\n    appendStream' (take n s) (drop n s) = s",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "(âˆ€ n : Nat, take n sâ‚ = take n sâ‚‚) â†’ sâ‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : (âˆ€ n : Nat, take n sâ‚ = take n sâ‚‚) â†’ sâ‚ = sâ‚‚ := by intro h; sorry",
  "name": "take_theorem",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±) : (âˆ€ n : Nat, take n sâ‚ = take n sâ‚‚) â†’ sâ‚ = sâ‚‚",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (sâ‚ sâ‚‚ : Stream' Î±)"},
 {"type": "tails s = tail s::tails (tail s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tails s = tail s::tails (tail s) := by unfold tails; sorry",
  "name": "tails_eq",
  "kind": "theorem",
  "first-tactic": "unfold tails",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tails s = tail s::tails (tail s)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type": "âˆ€ (n : Nat) (s : Stream' Î±), nth (tails s) n = drop n (tail s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±), nth (tails s) n = drop n (tail s) := by intro n; sorry",
  "name": "nth_tails",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±), nth (tails s) n = drop n (tail s)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "initsCore l s = l::initsCore (l ++ [head s]) (tail s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (l : List Î±)  (s : Stream' Î±) : initsCore l s = l::initsCore (l ++ [head s]) (tail s) := by unfold initsCore corecOn; sorry",
  "name": "inits_core_eq",
  "kind": "theorem",
  "first-tactic": "unfold initsCore corecOn",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (l : List Î±)  (s : Stream' Î±) : initsCore l s = l::initsCore (l ++ [head s]) (tail s)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (l : List Î±)  (s : Stream' Î±)"},
 {"type": "tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s))",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s)) := by unfold inits; sorry",
  "name": "tail_inits",
  "kind": "theorem",
  "first-tactic": "unfold inits",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : tail (inits s) = initsCore [head s, head (tail s)] (tail (tail s))",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type":
  "âˆ€ (a : Î±) (n : Nat) (l : List Î±) (s : Stream' Î±),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (a : Î±) (n : Nat) (l : List Î±) (s : Stream' Î±),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n := by intro a n; sorry",
  "name": "cons_nth_inits_core",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (a : Î±) (n : Nat) (l : List Î±) (s : Stream' Î±),\n      (a::nth (initsCore l s) n) = nth (initsCore (a::l) s) n",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "âˆ€ (n : Nat) (s : Stream' Î±), nth (inits s) n = take (succ n) s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±), nth (inits s) n = take (succ n) s := by intro n; sorry",
  "name": "nth_inits",
  "kind": "theorem",
  "first-tactic": "intro n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : âˆ€ (n : Nat) (s : Stream' Î±), nth (inits s) n = take (succ n) s",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "inits s = [head s]::map (List.cons (head s)) (inits (tail s))",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : inits s = [head s]::map (List.cons (head s)) (inits (tail s)) := by apply Stream'.ext; sorry",
  "name": "inits_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : inits s = [head s]::map (List.cons (head s)) (inits (tail s))",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type": "zip appendStream' (inits s) (tails s) = const s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : zip appendStream' (inits s) (tails s) = const s := by apply Stream'.ext; sorry",
  "name": "zip_inits_tails",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±) : zip appendStream' (inits s) (tails s) = const s",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} (s : Stream' Î±)"},
 {"type": "nats = cons 0 (map succ nats)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : nats = cons 0 (map succ nats) := by apply Stream'.ext; sorry",
  "name": "nats_eq",
  "kind": "theorem",
  "first-tactic": "apply Stream'.ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w} : nats = cons 0 (map succ nats)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î´ : Type w}"},
 {"type": "âˆƒ lb : â„¤ , P lb âˆ§ âˆ€ z : â„¤ , P z â†’ lb â‰¤ z",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ b â‰¤ z)      (Hinh : âˆƒ z : â„¤ , P z) : âˆƒ lb : â„¤ , P lb âˆ§ âˆ€ z : â„¤ , P z â†’ lb â‰¤ z := by let âŸ¨b , HbâŸ© := Hbdd; sorry",
  "name": "exists_least_of_bdd",
  "kind": "theorem",
  "first-tactic": "let âŸ¨b , HbâŸ© := Hbdd",
  "core-prompt":
  "{P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ b â‰¤ z)      (Hinh : âˆƒ z : â„¤ , P z) : âˆƒ lb : â„¤ , P lb âˆ§ âˆ€ z : â„¤ , P z â†’ lb â‰¤ z",
  "args":
  "{P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ b â‰¤ z)      (Hinh : âˆƒ z : â„¤ , P z)"},
 {"type": "(leastOfBdd b Hb Hinh : â„¤) = leastOfBdd b' Hb' Hinh",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}  (Hb : âˆ€ z : â„¤, P z â†’ b â‰¤ z)      (Hb' : âˆ€ z : â„¤, P z â†’ b' â‰¤ z)  (Hinh : âˆƒ z : â„¤, P z) : (leastOfBdd b Hb Hinh : â„¤) = leastOfBdd b' Hb' Hinh := by rcases leastOfBdd b Hb Hinh with âŸ¨n, hn, h2nâŸ©; sorry",
  "name": "coe_leastOfBdd_eq",
  "kind": "theorem",
  "first-tactic": "rcases leastOfBdd b Hb Hinh with âŸ¨n, hn, h2nâŸ©",
  "core-prompt":
  "{P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}  (Hb : âˆ€ z : â„¤, P z â†’ b â‰¤ z)      (Hb' : âˆ€ z : â„¤, P z â†’ b' â‰¤ z)  (Hinh : âˆƒ z : â„¤, P z) : (leastOfBdd b Hb Hinh : â„¤) = leastOfBdd b' Hb' Hinh",
  "args":
  "{P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}  (Hb : âˆ€ z : â„¤, P z â†’ b â‰¤ z)      (Hb' : âˆ€ z : â„¤, P z â†’ b' â‰¤ z)  (Hinh : âˆƒ z : â„¤, P z)"},
 {"type": "âˆƒ ub : â„¤ , P ub âˆ§ âˆ€ z : â„¤ , P z â†’ z â‰¤ ub",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ z â‰¤ b)      (Hinh : âˆƒ z : â„¤ , P z) : âˆƒ ub : â„¤ , P ub âˆ§ âˆ€ z : â„¤ , P z â†’ z â‰¤ ub := by let âŸ¨ b , Hb âŸ© := Hbdd; sorry",
  "name": "exists_greatest_of_bdd",
  "kind": "theorem",
  "first-tactic": "let âŸ¨ b , Hb âŸ© := Hbdd",
  "core-prompt":
  "{P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ z â‰¤ b)      (Hinh : âˆƒ z : â„¤ , P z) : âˆƒ ub : â„¤ , P ub âˆ§ âˆ€ z : â„¤ , P z â†’ z â‰¤ ub",
  "args":
  "{P : â„¤ â†’ Prop}      [DecidablePred P]      (Hbdd : âˆƒ b : â„¤ , âˆ€ z : â„¤ , P z â†’ z â‰¤ b)      (Hinh : âˆƒ z : â„¤ , P z)"},
 {"type": "(greatestOfBdd b Hb Hinh : â„¤) = greatestOfBdd b' Hb' Hinh",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}      (Hb : âˆ€ z : â„¤, P z â†’ z â‰¤ b)  (Hb' : âˆ€ z : â„¤, P z â†’ z â‰¤ b')  (Hinh : âˆƒ z : â„¤, P z) : (greatestOfBdd b Hb Hinh : â„¤) = greatestOfBdd b' Hb' Hinh := by rcases greatestOfBdd b Hb Hinh with âŸ¨n, hn, h2nâŸ©; sorry",
  "name": "coe_greatestOfBdd_eq",
  "kind": "theorem",
  "first-tactic": "rcases greatestOfBdd b Hb Hinh with âŸ¨n, hn, h2nâŸ©",
  "core-prompt":
  "{P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}      (Hb : âˆ€ z : â„¤, P z â†’ z â‰¤ b)  (Hb' : âˆ€ z : â„¤, P z â†’ z â‰¤ b')  (Hinh : âˆƒ z : â„¤, P z) : (greatestOfBdd b Hb Hinh : â„¤) = greatestOfBdd b' Hb' Hinh",
  "args":
  "{P : â„¤ â†’ Prop}  [DecidablePred P]  {b b' : â„¤}      (Hb : âˆ€ z : â„¤, P z â†’ z â‰¤ b)  (Hb' : âˆ€ z : â„¤, P z â†’ z â‰¤ b')  (Hinh : âˆƒ z : â„¤, P z)"},
 {"type": "((m / n : â„¤) : Î±) = m / n",
  "tactic-prompt":
  "theorem {Î± : Type _} [Field Î±]  {m n : â„¤}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0) : ((m / n : â„¤) : Î±) = m / n := by rcases n_dvd with âŸ¨k, rflâŸ©; sorry",
  "name": "cast_div",
  "kind": "theorem",
  "first-tactic": "rcases n_dvd with âŸ¨k, rflâŸ©",
  "core-prompt":
  "{Î± : Type _} [Field Î±]  {m n : â„¤}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0) : ((m / n : â„¤) : Î±) = m / n",
  "args":
  "{Î± : Type _} [Field Î±]  {m n : â„¤}  (n_dvd : n âˆ£ m)  (n_nonzero : (n : Î±) â‰  0)"},
 {"type": "((1 : â„¤) : R) = 1",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] : ((1 : â„¤) : R) = 1 := by erw [cast_ofNat]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] : ((1 : â„¤) : R) = 1",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]"},
 {"type": "((negOfNat n : â„¤) : R) = -n",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : â„•) : ((negOfNat n : â„¤) : R) = -n := by simp [Int.cast_neg]; sorry",
  "name": "cast_negOfNat",
  "kind": "theorem",
  "first-tactic": "simp [Int.cast_neg]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : â„•) : ((negOfNat n : â„¤) : R) = -n",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R] (n : â„•)"},
 {"type": "((bit1 n : â„¤) : R) = bit1 (n : R)",
  "tactic-prompt":
  "theorem {R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : â„¤) : ((bit1 n : â„¤) : R) = bit1 (n : R) := by rw [bit1]; sorry",
  "name": "cast_bit1",
  "kind": "theorem",
  "first-tactic": "rw [bit1]",
  "core-prompt":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : â„¤) : ((bit1 n : â„¤) : R) = bit1 (n : R)",
  "args":
  "{R : Type u}  [AddGroupWithOne R] {R : Type u}  [AddGroupWithOne R]  (n : â„¤)"},
 {"type": "Monotone (fun x : â„¤ => (x : Î±))",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}  [OrderedRing Î±] : Monotone (fun x : â„¤ => (x : Î±)) := by intro m n h; sorry",
  "name": "cast_mono",
  "kind": "theorem",
  "first-tactic": "intro m n h",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±] : Monotone (fun x : â„¤ => (x : Î±))",
  "args": "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]"},
 {"type": "(m : Î±) â‰¤ n â†” m â‰¤ n",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {m n : â„¤} : (m : Î±) â‰¤ n â†” m â‰¤ n := by rw [â† sub_nonneg]; sorry",
  "name": "cast_le",
  "kind": "theorem",
  "first-tactic": "rw [â† sub_nonneg]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {m n : â„¤} : (m : Î±) â‰¤ n â†” m â‰¤ n",
  "args": "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {m n : â„¤}"},
 {"type": "(n : Î±) â‰¤ 0 â†” n â‰¤ 0",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (n : Î±) â‰¤ 0 â†” n â‰¤ 0 := by rw [â† cast_zero]; sorry",
  "name": "cast_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_zero]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (n : Î±) â‰¤ 0 â†” n â‰¤ 0",
  "args": "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤}"},
 {"type": "(0 : Î±) < n â†” 0 < n",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (0 : Î±) < n â†” 0 < n := by rw [â† cast_zero]; sorry",
  "name": "cast_pos",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_zero]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (0 : Î±) < n â†” 0 < n",
  "args": "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤}"},
 {"type": "(n : Î±) < 0 â†” n < 0",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (n : Î±) < 0 â†” n < 0 := by rw [â† cast_zero]; sorry",
  "name": "cast_lt_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† cast_zero]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤} : (n : Î±) < 0 â†” n < 0",
  "args": "{F Î¹ Î± Î² : Type _}  [OrderedRing Î±]  [Nontrivial Î±]  {n : â„¤}"},
 {"type": "((|a| : â„¤) : Î±) = |(a : Î±)|",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) : ((|a| : â„¤) : Î±) = |(a : Î±)| := by simp [abs_eq_max_neg]; sorry",
  "name": "cast_abs",
  "kind": "theorem",
  "first-tactic": "simp [abs_eq_max_neg]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) : ((|a| : â„¤) : Î±) = |(a : Î±)|",
  "args": "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤)"},
 {"type": "(1 : Î±) â‰¤ a",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : 0 < a) : (1 : Î±) â‰¤ a := by exact_mod_cast Int.add_one_le_of_lt h; sorry",
  "name": "cast_one_le_of_pos",
  "kind": "theorem",
  "first-tactic": "exact_mod_cast Int.add_one_le_of_lt h",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : 0 < a) : (1 : Î±) â‰¤ a",
  "args":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : 0 < a)"},
 {"type": "(a : Î±) â‰¤ -1",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : a < 0) : (a : Î±) â‰¤ -1 := by rw [â† Int.cast_one]; sorry",
  "name": "cast_le_neg_one_of_neg",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_one]",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : a < 0) : (a : Î±) â‰¤ -1",
  "args":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) (h : a < 0)"},
 {"type": "(0 : Î±) â‰¤ n * x + n * n",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) {x : Î±}  (hx : |x| â‰¤ 1) : (0 : Î±) â‰¤ n * x + n * n := by have hnx : 0 < n â†’ 0 â‰¤ x + n := fun hn => by\n    have := _root_.add_le_add (neg_le_of_abs_le hx) (cast_one_le_of_pos hn)\n    rwa [add_left_neg] at this; sorry",
  "name": "nneg_mul_add_sq_of_abs_le_one",
  "kind": "theorem",
  "first-tactic":
  "have hnx : 0 < n â†’ 0 â‰¤ x + n := fun hn => by\n    have := _root_.add_le_add (neg_le_of_abs_le hx) (cast_one_le_of_pos hn)\n    rwa [add_left_neg] at this",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) {x : Î±}  (hx : |x| â‰¤ 1) : (0 : Î±) â‰¤ n * x + n * n",
  "args":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) {x : Î±}  (hx : |x| â‰¤ 1)"},
 {"type": "(n.natAbs : Î±) = |n|",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) : (n.natAbs : Î±) = |n| := by cases n; sorry",
  "name": "cast_natAbs",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤) : (n.natAbs : Î±) = |n|",
  "args": "{F Î¹ Î± Î² : Type _}   [LinearOrderedRing Î±]  {a b : â„¤}  (n : â„¤)"},
 {"type": "f = g",
  "tactic-prompt":
  "theorem {F Î¹ Î± Î² : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : â„¤ â†’* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g := by ext (x | x); sorry",
  "name": "ext_int",
  "kind": "theorem",
  "first-tactic": "ext (x | x)",
  "core-prompt":
  "{F Î¹ Î± Î² : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : â„¤ â†’* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g",
  "args":
  "{F Î¹ Î± Î² : Type _} {A : Type _} [AddGroupWithOne A] {M : Type _}  [Monoid M] {f g : â„¤ â†’* M}  (h_neg_one : f (-1) = g (-1))      (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : â„¤}  (hb : b â‰  0)  (hbc : b âˆ£ c)      (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : â„¤}  (hb : b â‰  0)  (hbc : b âˆ£ c)      (h : b * a = c * d) : a = c / b * d",
  "args":
  "{a b c d : â„¤}  (hb : b â‰  0)  (hbc : b âˆ£ c)      (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : â„¤}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [â† natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_of_natAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd]",
  "core-prompt": "{a b : â„¤}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : â„¤}  (w : a âˆ£ b)  (h : natAbs b < natAbs a)"},
 {"type": "(â†‘n : â„¤) âˆ£ z â†” n âˆ£ z.natAbs",
  "tactic-prompt":
  "theorem {n : â„•}  {z : â„¤} : (â†‘n : â„¤) âˆ£ z â†” n âˆ£ z.natAbs := by rcases natAbs_eq z with (eq | eq); sorry",
  "name": "coe_nat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rcases natAbs_eq z with (eq | eq)",
  "core-prompt": "{n : â„•}  {z : â„¤} : (â†‘n : â„¤) âˆ£ z â†” n âˆ£ z.natAbs",
  "args": "{n : â„•}  {z : â„¤}"},
 {"type": "z âˆ£ (â†‘n : â„¤) â†” z.natAbs âˆ£ n",
  "tactic-prompt":
  "theorem {n : â„•}  {z : â„¤} : z âˆ£ (â†‘n : â„¤) â†” z.natAbs âˆ£ n := by rcases natAbs_eq z with (eq | eq); sorry",
  "name": "coe_nat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rcases natAbs_eq z with (eq | eq)",
  "core-prompt": "{n : â„•}  {z : â„¤} : z âˆ£ (â†‘n : â„¤) â†” z.natAbs âˆ£ n",
  "args": "{n : â„•}  {z : â„¤}"},
 {"type": "â†‘(p ^ m) âˆ£ k",
  "tactic-prompt":
  "theorem {p m n : â„•}  {k : â„¤}  (hmn : m â‰¤ n)  (hdiv : â†‘(p ^ n) âˆ£ k) : â†‘(p ^ m) âˆ£ k := by induction k; sorry",
  "name": "pow_dvd_of_le_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "induction k",
  "core-prompt":
  "{p m n : â„•}  {k : â„¤}  (hmn : m â‰¤ n)  (hdiv : â†‘(p ^ n) âˆ£ k) : â†‘(p ^ m) âˆ£ k",
  "args": "{p m n : â„•}  {k : â„¤}  (hmn : m â‰¤ n)  (hdiv : â†‘(p ^ n) âˆ£ k)"},
 {"type": "â†‘p âˆ£ m",
  "tactic-prompt":
  "theorem {p k : â„•}  {m : â„¤}  (hk : 1 â‰¤ k)  (hpk : â†‘(p ^ k) âˆ£ m) : â†‘p âˆ£ m := by rw [â† pow_one p]; sorry",
  "name": "dvd_of_pow_dvd",
  "kind": "theorem",
  "first-tactic": "rw [â† pow_one p]",
  "core-prompt":
  "{p k : â„•}  {m : â„¤}  (hk : 1 â‰¤ k)  (hpk : â†‘(p ^ k) âˆ£ m) : â†‘p âˆ£ m",
  "args": "{p k : â„•}  {m : â„¤}  (hk : 1 â‰¤ k)  (hpk : â†‘(p ^ k) âˆ£ m)"},
 {"type": "AddCommMonoid â„¤",
  "tactic-prompt": "instance  : AddCommMonoid â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommMonoid â„¤",
  "args": ""},
 {"type": "AddMonoid â„¤",
  "tactic-prompt": "instance  : AddMonoid â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddMonoid â„¤",
  "args": ""},
 {"type": "Monoid â„¤",
  "tactic-prompt": "instance  : Monoid â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Monoid â„¤",
  "args": ""},
 {"type": "CommMonoid â„¤",
  "tactic-prompt": "instance  : CommMonoid â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommMonoid â„¤",
  "args": ""},
 {"type": "CommSemigroup â„¤",
  "tactic-prompt": "instance  : CommSemigroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommSemigroup â„¤",
  "args": ""},
 {"type": "Semigroup â„¤",
  "tactic-prompt": "instance  : Semigroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Semigroup â„¤",
  "args": ""},
 {"type": "AddCommGroup â„¤",
  "tactic-prompt": "instance  : AddCommGroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommGroup â„¤",
  "args": ""},
 {"type": "AddGroup â„¤",
  "tactic-prompt": "instance  : AddGroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddGroup â„¤",
  "args": ""},
 {"type": "AddCommSemigroup â„¤",
  "tactic-prompt": "instance  : AddCommSemigroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddCommSemigroup â„¤",
  "args": ""},
 {"type": "AddSemigroup â„¤",
  "tactic-prompt": "instance  : AddSemigroup â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : AddSemigroup â„¤",
  "args": ""},
 {"type": "CommSemiring â„¤",
  "tactic-prompt": "instance  : CommSemiring â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : CommSemiring â„¤",
  "args": ""},
 {"type": "Semiring â„¤",
  "tactic-prompt": "instance  : Semiring â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Semiring â„¤",
  "args": ""},
 {"type": "Ring â„¤",
  "tactic-prompt": "instance  : Ring â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Ring â„¤",
  "args": ""},
 {"type": "Distrib â„¤",
  "tactic-prompt": "instance  : Distrib â„¤ := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : Distrib â„¤",
  "args": ""},
 {"type": "succ (-succ a) = -a",
  "tactic-prompt":
  "theorem (a : â„¤) : succ (-succ a) = -a := by rw [neg_succ]; sorry",
  "name": "succ_neg_succ",
  "kind": "theorem",
  "first-tactic": "rw [neg_succ]",
  "core-prompt": "(a : â„¤) : succ (-succ a) = -a",
  "args": "(a : â„¤)"},
 {"type": "-pred a = succ (-a)",
  "tactic-prompt":
  "theorem (a : â„¤) : -pred a = succ (-a) := by rw [eq_neg_of_eq_neg (neg_succ (-a)).symm]; sorry",
  "name": "neg_pred",
  "kind": "theorem",
  "first-tactic": "rw [eq_neg_of_eq_neg (neg_succ (-a)).symm]",
  "core-prompt": "(a : â„¤) : -pred a = succ (-a)",
  "args": "(a : â„¤)"},
 {"type": "pred (-pred a) = -a",
  "tactic-prompt":
  "theorem (a : â„¤) : pred (-pred a) = -a := by rw [neg_pred]; sorry",
  "name": "pred_neg_pred",
  "kind": "theorem",
  "first-tactic": "rw [neg_pred]",
  "core-prompt": "(a : â„¤) : pred (-pred a) = -a",
  "args": "(a : â„¤)"},
 {"type": "((n - 1 : â„•) : â„¤) = (n : â„¤) - 1",
  "tactic-prompt":
  "theorem {n : â„•}  (h : 0 < n) : ((n - 1 : â„•) : â„¤) = (n : â„¤) - 1 := by cases n; sorry",
  "name": "coe_pred_of_pos",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "{n : â„•}  (h : 0 < n) : ((n - 1 : â„•) : â„¤) = (n : â„¤) - 1",
  "args": "{n : â„•}  (h : 0 < n)"},
 {"type": "p i",
  "tactic-prompt":
  "theorem {p : â„¤ â†’ Prop}  (i : â„¤)      (hz : p 0)  (hp : âˆ€ i : â„•, p i â†’ p (i + 1))  (hn : âˆ€ i : â„•, p (-i) â†’ p (-i - 1)) : p i := by induction i; sorry",
  "name": "induction_on",
  "kind": "theorem",
  "first-tactic": "induction i",
  "core-prompt":
  "{p : â„¤ â†’ Prop}  (i : â„¤)      (hz : p 0)  (hp : âˆ€ i : â„•, p i â†’ p (i + 1))  (hn : âˆ€ i : â„•, p (-i) â†’ p (-i - 1)) : p i",
  "args":
  "{p : â„¤ â†’ Prop}  (i : â„¤)      (hz : p 0)  (hp : âˆ€ i : â„•, p i â†’ p (i + 1))  (hn : âˆ€ i : â„•, p (-i) â†’ p (-i - 1))"},
 {"type": "u = 1 âˆ¨ u = -1",
  "tactic-prompt":
  "theorem (u : â„¤Ë£) : u = 1 âˆ¨ u = -1 := by simpa only [Units.ext_iff]; sorry",
  "name": "units_eq_one_or",
  "kind": "theorem",
  "first-tactic": "simpa only [Units.ext_iff]",
  "core-prompt": "(u : â„¤Ë£) : u = 1 âˆ¨ u = -1",
  "args": "(u : â„¤Ë£)"},
 {"type": "IsUnit a â†” a = 1 âˆ¨ a = -1",
  "tactic-prompt":
  "theorem {a : â„¤} : IsUnit a â†” a = 1 âˆ¨ a = -1 := by refine' âŸ¨fun h â†¦ is_unit_eq_one_or h, fun h â†¦ _âŸ©; sorry",
  "name": "is_unit_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h â†¦ is_unit_eq_one_or h, fun h â†¦ _âŸ©",
  "core-prompt": "{a : â„¤} : IsUnit a â†” a = 1 âˆ¨ a = -1",
  "args": "{a : â„¤}"},
 {"type": "a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b) : a = b âˆ¨ a = -b := by rcases is_unit_eq_one_or hb with (rfl | rfl); sorry",
  "name": "is_unit_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rcases is_unit_eq_one_or hb with (rfl | rfl)",
  "core-prompt": "{a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b) : a = b âˆ¨ a = -b",
  "args": "{a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "tactic-prompt":
  "theorem {z w : â„¤}  (h : z * w = 1) : z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1 := by have h' : w * z = 1 := mul_comm z w â–¸ h; sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_one'",
  "kind": "theorem",
  "first-tactic": "have h' : w * z = 1 := mul_comm z w â–¸ h",
  "core-prompt": "{z w : â„¤}  (h : z * w = 1) : z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "args": "{z w : â„¤}  (h : z * w = 1)"},
 {"type": "IsUnit n â†” n.natAbs = 1",
  "tactic-prompt":
  "theorem {n : â„¤} : IsUnit n â†” n.natAbs = 1 := by simp [nat_abs_eq_iff]; sorry",
  "name": "is_unit_iff_nat_abs_eq",
  "kind": "theorem",
  "first-tactic": "simp [nat_abs_eq_iff]",
  "core-prompt": "{n : â„¤} : IsUnit n â†” n.natAbs = 1",
  "args": "{n : â„¤}"},
 {"type": "IsUnit (n : â„¤) â†” IsUnit n",
  "tactic-prompt":
  "theorem {n : â„•} : IsUnit (n : â„¤) â†” IsUnit n := by rw [Nat.is_unit_iff]; sorry",
  "name": "of_nat_is_unit",
  "kind": "theorem",
  "first-tactic": "rw [Nat.is_unit_iff]",
  "core-prompt": "{n : â„•} : IsUnit (n : â„¤) â†” IsUnit n",
  "args": "{n : â„•}"},
 {"type": "a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c",
  "tactic-prompt":
  "theorem {a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d) : a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c := by rw [is_unit_iff] at ha hb hc hd; sorry",
  "name": "is_unit_add_is_unit_eq_is_unit_add_is_unit",
  "kind": "theorem",
  "first-tactic": "rw [is_unit_iff] at ha hb hc hd",
  "core-prompt":
  "{a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d) : a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c",
  "args":
  "{a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)  (hc : IsUnit c)      (hd : IsUnit d)"},
 {"type": "sqrt (n * n) = n.natAbs",
  "tactic-prompt":
  "theorem (n : â„¤) : sqrt (n * n) = n.natAbs := by rw [sqrt]; sorry",
  "name": "sqrt_eq",
  "kind": "theorem",
  "first-tactic": "rw [sqrt]",
  "core-prompt": "(n : â„¤) : sqrt (n * n) = n.natAbs",
  "args": "(n : â„¤)"},
 {"type": "u = 1 âˆ¨ u = -1",
  "tactic-prompt":
  "theorem (u : â„¤Ë£) : u = 1 âˆ¨ u = -1 := by simpa only [Units.ext_iff]; sorry",
  "name": "units_eq_one_or",
  "kind": "theorem",
  "first-tactic": "simpa only [Units.ext_iff]",
  "core-prompt": "(u : â„¤Ë£) : u = 1 âˆ¨ u = -1",
  "args": "(u : â„¤Ë£)"},
 {"type": "IsUnit a â†” a = 1 âˆ¨ a = -1",
  "tactic-prompt":
  "theorem {a : â„¤} : IsUnit a â†” a = 1 âˆ¨ a = -1 := by refine' âŸ¨fun h => isUnit_eq_one_or h, fun h => _âŸ©; sorry",
  "name": "isUnit_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => isUnit_eq_one_or h, fun h => _âŸ©",
  "core-prompt": "{a : â„¤} : IsUnit a â†” a = 1 âˆ¨ a = -1",
  "args": "{a : â„¤}"},
 {"type": "a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b) : a = b âˆ¨ a = -b := by rcases isUnit_eq_one_or hb with (rfl | rfl); sorry",
  "name": "isUnit_eq_or_eq_neg",
  "kind": "theorem",
  "first-tactic": "rcases isUnit_eq_one_or hb with (rfl | rfl)",
  "core-prompt": "{a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b) : a = b âˆ¨ a = -b",
  "args": "{a b : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)"},
 {"type": "z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "tactic-prompt":
  "theorem {z w : â„¤}  (h : z * w = 1) : z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1 := by have h' : w * z = 1 := mul_comm z w â–¸ h; sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_one'",
  "kind": "theorem",
  "first-tactic": "have h' : w * z = 1 := mul_comm z w â–¸ h",
  "core-prompt": "{z w : â„¤}  (h : z * w = 1) : z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "args": "{z w : â„¤}  (h : z * w = 1)"},
 {"type": "z * w = 1 â†” z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "tactic-prompt":
  "theorem {z w : â„¤} : z * w = 1 â†” z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1 := by refine' âŸ¨eq_one_or_neg_one_of_mul_eq_one', fun h => Or.elim h (fun H => _) fun H => _âŸ©; sorry",
  "name": "mul_eq_one_iff_eq_one_or_neg_one",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨eq_one_or_neg_one_of_mul_eq_one', fun h => Or.elim h (fun H => _) fun H => _âŸ©",
  "core-prompt": "{z w : â„¤} : z * w = 1 â†” z = 1 âˆ§ w = 1 âˆ¨ z = -1 âˆ§ w = -1",
  "args": "{z w : â„¤}"},
 {"type": "z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1",
  "tactic-prompt":
  "theorem {z w : â„¤}  (h : z * w = -1) : z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1 := by rcases isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1 with (rfl | rfl); sorry",
  "name": "eq_one_or_neg_one_of_mul_eq_neg_one'",
  "kind": "theorem",
  "first-tactic":
  "rcases isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1 with (rfl | rfl)",
  "core-prompt":
  "{z w : â„¤}  (h : z * w = -1) : z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1",
  "args": "{z w : â„¤}  (h : z * w = -1)"},
 {"type": "z * w = -1 â†” z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1",
  "tactic-prompt":
  "theorem {z w : â„¤} : z * w = -1 â†” z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1 := by refine' âŸ¨eq_one_or_neg_one_of_mul_eq_neg_one', fun h => Or.elim h (fun H => _) fun H => _âŸ©; sorry",
  "name": "mul_eq_neg_one_iff_eq_one_or_neg_one",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨eq_one_or_neg_one_of_mul_eq_neg_one', fun h => Or.elim h (fun H => _) fun H => _âŸ©",
  "core-prompt": "{z w : â„¤} : z * w = -1 â†” z = 1 âˆ§ w = -1 âˆ¨ z = -1 âˆ§ w = 1",
  "args": "{z w : â„¤}"},
 {"type": "IsUnit n â†” n.natAbs = 1",
  "tactic-prompt":
  "theorem {n : â„¤} : IsUnit n â†” n.natAbs = 1 := by simp [natAbs_eq_iff]; sorry",
  "name": "isUnit_iff_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "simp [natAbs_eq_iff]",
  "core-prompt": "{n : â„¤} : IsUnit n â†” n.natAbs = 1",
  "args": "{n : â„¤}"},
 {"type": "IsUnit (n : â„¤) â†” IsUnit n",
  "tactic-prompt":
  "theorem {n : â„•} : IsUnit (n : â„¤) â†” IsUnit n := by simp [isUnit_iff_natAbs_eq]; sorry",
  "name": "ofNat_isUnit",
  "kind": "theorem",
  "first-tactic": "simp [isUnit_iff_natAbs_eq]",
  "core-prompt": "{n : â„•} : IsUnit (n : â„¤) â†” IsUnit n",
  "args": "{n : â„•}"},
 {"type": "a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c",
  "tactic-prompt":
  "theorem {a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d) : a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c := by rw [isUnit_iff] at ha hb hc hd; sorry",
  "name": "isUnit_add_isUnit_eq_isUnit_add_isUnit",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff] at ha hb hc hd",
  "core-prompt":
  "{a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d) : a + b = c + d â†” a = c âˆ§ b = d âˆ¨ a = d âˆ§ b = c",
  "args":
  "{a b c d : â„¤}  (ha : IsUnit a)  (hb : IsUnit b)      (hc : IsUnit c)  (hd : IsUnit d)"},
 {"type": "LinearOrderedAddCommGroup â„¤",
  "tactic-prompt":
  "instance  : LinearOrderedAddCommGroup â„¤ := by infer_instance; sorry",
  "name": "linearOrderedAddCommGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : LinearOrderedAddCommGroup â„¤",
  "args": ""},
 {"type": "natAbs (|a|) = natAbs a",
  "tactic-prompt":
  "theorem (a : â„¤) : natAbs (|a|) = natAbs a := by rw [abs_eq_natAbs]; sorry",
  "name": "natAbs_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "(a : â„¤) : natAbs (|a|) = natAbs a",
  "args": "(a : â„¤)"},
 {"type": "sign a * |a| = a",
  "tactic-prompt":
  "theorem (a : â„¤) : sign a * |a| = a := by rw [abs_eq_natAbs]; sorry",
  "name": "sign_mul_abs",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "(a : â„¤) : sign a * |a| = a",
  "args": "(a : â„¤)"},
 {"type": "(n : â„¤) â‰  0 â†” n â‰  0",
  "tactic-prompt": "theorem {n : â„•} : (n : â„¤) â‰  0 â†” n â‰  0 := by simp; sorry",
  "name": "coe_nat_ne_zero",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{n : â„•} : (n : â„¤) â‰  0 â†” n â‰  0",
  "args": "{n : â„•}"},
 {"type": "|a| â‰¤ 1 â†” a = 0 âˆ¨ a = 1 âˆ¨ a = -1",
  "tactic-prompt":
  "theorem {a : â„¤} : |a| â‰¤ 1 â†” a = 0 âˆ¨ a = 1 âˆ¨ a = -1 := by rw [le_iff_lt_or_eq]; sorry",
  "name": "abs_le_one_iff",
  "kind": "theorem",
  "first-tactic": "rw [le_iff_lt_or_eq]",
  "core-prompt": "{a : â„¤} : |a| â‰¤ 1 â†” a = 0 âˆ¨ a = 1 âˆ¨ a = -1",
  "args": "{a : â„¤}"},
 {"type": "C z",
  "tactic-prompt":
  "def {C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1)) : C z := by rw [â† sub_add_cancel (G := â„¤) z b]; sorry",
  "name": "inductionOn'",
  "kind": "def",
  "first-tactic": "rw [â† sub_add_cancel (G := â„¤) z b]",
  "core-prompt":
  "{C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1)) : C z",
  "args":
  "{C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1))"},
 {"type": "m â‰¤ n â†’ P n",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, m â‰¤ n â†’ P n â†’ P (n + 1))  (n : â„¤) : m â‰¤ n â†’ P n := by refine Int.inductionOn' n m ?_ ?_ ?_; sorry",
  "name": "le_induction",
  "kind": "theorem",
  "first-tactic": "refine Int.inductionOn' n m ?_ ?_ ?_",
  "core-prompt":
  "{P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, m â‰¤ n â†’ P n â†’ P (n + 1))  (n : â„¤) : m â‰¤ n â†’ P n",
  "args":
  "{P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, m â‰¤ n â†’ P n â†’ P (n + 1))  (n : â„¤)"},
 {"type": "n â‰¤ m â†’ P n",
  "tactic-prompt":
  "theorem {P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, n â‰¤ m â†’ P n â†’ P (n - 1))  (n : â„¤) : n â‰¤ m â†’ P n := by refine Int.inductionOn' n m ?_ ?_ ?_; sorry",
  "name": "le_induction_down",
  "kind": "theorem",
  "first-tactic": "refine Int.inductionOn' n m ?_ ?_ ?_",
  "core-prompt":
  "{P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, n â‰¤ m â†’ P n â†’ P (n - 1))  (n : â„¤) : n â‰¤ m â†’ P n",
  "args":
  "{P : â„¤ â†’ Prop}  {m : â„¤}  (h0 : P m)      (h1 : âˆ€ n : â„¤, n â‰¤ m â†’ P n â†’ P (n - 1))  (n : â„¤)"},
 {"type": "a % b < |b|",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} (a : â„¤)  {b : â„¤}  (H : b â‰  0) : a % b < |b| := by rw [â† emod_abs]; sorry",
  "name": "emod_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† emod_abs]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} (a : â„¤)  {b : â„¤}  (H : b â‰  0) : a % b < |b|",
  "args": "{a b : â„¤}  {n : â„•} (a : â„¤)  {b : â„¤}  (H : b â‰  0)"},
 {"type": "(m + i) % n = (k + i) % n",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {m n k : â„¤}  (i : â„¤)  (H : m % n = k % n) : (m + i) % n = (k + i) % n := by rw [â† emod_add_emod]; sorry",
  "name": "add_emod_eq_add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† emod_add_emod]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {m n k : â„¤}  (i : â„¤)  (H : m % n = k % n) : (m + i) % n = (k + i) % n",
  "args": "{a b : â„¤}  {n : â„•} {m n k : â„¤}  (i : â„¤)  (H : m % n = k % n)"},
 {"type": "-i % 2 = i % 2",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} (i : â„¤) : -i % 2 = i % 2 := by apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr; sorry",
  "name": "neg_emod_two",
  "kind": "theorem",
  "first-tactic": "apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr",
  "core-prompt": "{a b : â„¤}  {n : â„•} (i : â„¤) : -i % 2 = i % 2",
  "args": "{a b : â„¤}  {n : â„•} (i : â„¤)"},
 {"type": "|z.sign| = 1",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {z : â„¤}  (hz : z â‰  0) : |z.sign| = 1 := by rw [abs_eq_natAbs]; sorry",
  "name": "abs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [abs_eq_natAbs]",
  "core-prompt": "{a b : â„¤}  {n : â„•} {z : â„¤}  (hz : z â‰  0) : |z.sign| = 1",
  "args": "{a b : â„¤}  {n : â„•} {z : â„¤}  (hz : z â‰  0)"},
 {"type": "(âˆƒ k, n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} (m : â„¤)  {n : â„¤}  (hn : 0 < n) : (âˆƒ k, n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m := by constructor; sorry",
  "name": "exists_lt_and_lt_iff_not_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} (m : â„¤)  {n : â„¤}  (hn : 0 < n) : (âˆƒ k, n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m",
  "args": "{a b : â„¤}  {n : â„•} (m : â„¤)  {n : â„¤}  (hn : 0 < n)"},
 {"type": "a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b c : â„¤}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b := by rw [â† Int.ediv_mul_cancel H2]; sorry",
  "name": "le_mul_of_ediv_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.ediv_mul_cancel H2]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {a b c : â„¤}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b",
  "args":
  "{a b : â„¤}  {n : â„•} {a b c : â„¤}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c)"},
 {"type": "t / s âˆ£ t",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {s t : â„¤}  (hst : s âˆ£ t) : t / s âˆ£ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "ediv_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{a b : â„¤}  {n : â„•} {s t : â„¤}  (hst : s âˆ£ t) : t / s âˆ£ t",
  "args": "{a b : â„¤}  {n : â„•} {s t : â„¤}  (hst : s âˆ£ t)"},
 {"type": "toNat a â‰¤ n â†” a â‰¤ n",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a : â„¤}  {n : â„•} : toNat a â‰¤ n â†” a â‰¤ n := by rw [ofNat_le.symm]; sorry",
  "name": "toNat_le",
  "kind": "theorem",
  "first-tactic": "rw [ofNat_le.symm]",
  "core-prompt": "{a b : â„¤}  {n : â„•} {a : â„¤}  {n : â„•} : toNat a â‰¤ n â†” a â‰¤ n",
  "args": "{a b : â„¤}  {n : â„•} {a : â„¤}  {n : â„•}"},
 {"type": "toNat a â‰¤ toNat b",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b : â„¤}  (h : a â‰¤ b) : toNat a â‰¤ toNat b := by rw [toNat_le]; sorry",
  "name": "toNat_le_toNat",
  "kind": "theorem",
  "first-tactic": "rw [toNat_le]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {a b : â„¤}  (h : a â‰¤ b) : toNat a â‰¤ toNat b",
  "args": "{a b : â„¤}  {n : â„•} {a b : â„¤}  (h : a â‰¤ b)"},
 {"type": "((i.toNat - 1 : â„•) : â„¤) = i - 1",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {i : â„¤}  (h : 0 < i) : ((i.toNat - 1 : â„•) : â„¤) = i - 1 := by simp [h]; sorry",
  "name": "toNat_pred_coe_of_pos",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {i : â„¤}  (h : 0 < i) : ((i.toNat - 1 : â„•) : â„¤) = i - 1",
  "args": "{a b : â„¤}  {n : â„•} {i : â„¤}  (h : 0 < i)"},
 {"type": "IsUnit x â†” abs x = 1",
  "tactic-prompt":
  "theorem {x : â„¤} : IsUnit x â†” abs x = 1 := by rw [isUnit_iff_natAbs_eq]; sorry",
  "name": "isUnit_iff_abs_eq",
  "kind": "theorem",
  "first-tactic": "rw [isUnit_iff_natAbs_eq]",
  "core-prompt": "{x : â„¤} : IsUnit x â†” abs x = 1",
  "args": "{x : â„¤}"},
 {"type": "a ^ 2 = 1",
  "tactic-prompt":
  "theorem {a : â„¤}  (ha : IsUnit a) : a ^ 2 = 1 := by rw [sq]; sorry",
  "name": "isUnit_sq",
  "kind": "theorem",
  "first-tactic": "rw [sq]",
  "core-prompt": "{a : â„¤}  (ha : IsUnit a) : a ^ 2 = 1",
  "args": "{a : â„¤}  (ha : IsUnit a)"},
 {"type": "u ^ 2 = 1",
  "tactic-prompt":
  "theorem (u : â„¤Ë£) : u ^ 2 = 1 := by rw [Units.ext_iff]; sorry",
  "name": "units_sq",
  "kind": "theorem",
  "first-tactic": "rw [Units.ext_iff]",
  "core-prompt": "(u : â„¤Ë£) : u ^ 2 = 1",
  "args": "(u : â„¤Ë£)"},
 {"type": "u * u = 1",
  "tactic-prompt": "theorem (u : â„¤Ë£) : u * u = 1 := by rw [â† sq]; sorry",
  "name": "units_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [â† sq]",
  "core-prompt": "(u : â„¤Ë£) : u * u = 1",
  "args": "(u : â„¤Ë£)"},
 {"type": "uâ»Â¹ = u",
  "tactic-prompt":
  "theorem (u : â„¤Ë£) : uâ»Â¹ = u := by rw [inv_eq_iff_mul_eq_one]; sorry",
  "name": "units_inv_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [inv_eq_iff_mul_eq_one]",
  "core-prompt": "(u : â„¤Ë£) : uâ»Â¹ = u",
  "args": "(u : â„¤Ë£)"},
 {"type": "(u * u : â„¤) = 1",
  "tactic-prompt":
  "theorem (u : â„¤Ë£) : (u * u : â„¤) = 1 := by rw [â† Units.val_mul]; sorry",
  "name": "units_coe_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [â† Units.val_mul]",
  "core-prompt": "(u : â„¤Ë£) : (u * u : â„¤) = 1",
  "args": "(u : â„¤Ë£)"},
 {"type": "u ^ n = u ^ (n % 2)",
  "tactic-prompt":
  "theorem (u : â„¤Ë£)  (n : â„•) : u ^ n = u ^ (n % 2) := by conv =>\n      lhs\n      rw [â† Nat.mod_add_div n 2];\n      rw [pow_add]; sorry",
  "name": "units_pow_eq_pow_mod_two",
  "kind": "theorem",
  "first-tactic":
  "conv =>\n      lhs\n      rw [â† Nat.mod_add_div n 2];\n      rw [pow_add]",
  "core-prompt": "(u : â„¤Ë£)  (n : â„•) : u ^ n = u ^ (n % 2)",
  "args": "(u : â„¤Ë£)  (n : â„•)"},
 {"type": "a.natAbs = b.natAbs â†” a * a = b * b",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs = b.natAbs â†” a * a = b * b := by rw [â† abs_eq_iff_mul_self_eq]; sorry",
  "name": "natAbs_eq_iff_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_eq_iff_mul_self_eq]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs = b.natAbs â†” a * a = b * b",
  "args": "{a b : â„¤}  {n : â„•} {a b : â„¤}"},
 {"type": "a.natAbs < b.natAbs â†” a * a < b * b",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs < b.natAbs â†” a * a < b * b := by rw [â† abs_lt_iff_mul_self_lt]; sorry",
  "name": "natAbs_lt_iff_mul_self_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_lt_iff_mul_self_lt]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs < b.natAbs â†” a * a < b * b",
  "args": "{a b : â„¤}  {n : â„•} {a b : â„¤}"},
 {"type": "a.natAbs â‰¤ b.natAbs â†” a * a â‰¤ b * b",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs â‰¤ b.natAbs â†” a * a â‰¤ b * b := by rw [â† abs_le_iff_mul_self_le]; sorry",
  "name": "natAbs_le_iff_mul_self_le",
  "kind": "theorem",
  "first-tactic": "rw [â† abs_le_iff_mul_self_le]",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {a b : â„¤} : a.natAbs â‰¤ b.natAbs â†” a * a â‰¤ b * b",
  "args": "{a b : â„¤}  {n : â„•} {a b : â„¤}"},
 {"type": "b âˆ£ c / a",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {a b c : â„¤}  (h : a * b âˆ£ c) : b âˆ£ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b : â„¤}  {n : â„•} {a b c : â„¤}  (h : a * b âˆ£ c) : b âˆ£ c / a",
  "args": "{a b : â„¤}  {n : â„•} {a b c : â„¤}  (h : a * b âˆ£ c)"},
 {"type": "x = 0",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} {m x : â„¤}  (h1 : m âˆ£ x)  (h2 : |x| < m) : x = 0 := by by_cases hm : m = 0; sorry",
  "name": "eq_zero_of_abs_lt_dvd",
  "kind": "theorem",
  "first-tactic": "by_cases hm : m = 0",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} {m x : â„¤}  (h1 : m âˆ£ x)  (h2 : |x| < m) : x = 0",
  "args": "{a b : â„¤}  {n : â„•} {m x : â„¤}  (h1 : m âˆ£ x)  (h2 : |x| < m)"},
 {"type": "gcdA 0 s = 0",
  "tactic-prompt": "theorem {s : â„•} : gcdA 0 s = 0 := by unfold gcdA; sorry",
  "name": "gcdA_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdA",
  "core-prompt": "{s : â„•} : gcdA 0 s = 0",
  "args": "{s : â„•}"},
 {"type": "gcdB 0 s = 1",
  "tactic-prompt": "theorem {s : â„•} : gcdB 0 s = 1 := by unfold gcdB; sorry",
  "name": "gcdB_zero_left",
  "kind": "theorem",
  "first-tactic": "unfold gcdB",
  "core-prompt": "{s : â„•} : gcdB 0 s = 1",
  "args": "{s : â„•}"},
 {"type": "gcdA s 0 = 1",
  "tactic-prompt":
  "theorem {s : â„•}  (h : s â‰  0) : gcdA s 0 = 1 := by unfold gcdA xgcd; sorry",
  "name": "gcdA_zero_right",
  "kind": "theorem",
  "first-tactic": "unfold gcdA xgcd",
  "core-prompt": "{s : â„•}  (h : s â‰  0) : gcdA s 0 = 1",
  "args": "{s : â„•}  (h : s â‰  0)"},
 {"type": "gcdB s 0 = 0",
  "tactic-prompt":
  "theorem {s : â„•}  (h : s â‰  0) : gcdB s 0 = 0 := by unfold gcdB xgcd; sorry",
  "name": "gcdB_zero_right",
  "kind": "theorem",
  "first-tactic": "unfold gcdB xgcd",
  "core-prompt": "{s : â„•}  (h : s â‰  0) : gcdB s 0 = 0",
  "args": "{s : â„•}  (h : s â‰  0)"},
 {"type": "(gcd x y : â„¤) = x * gcdA x y + y * gcdB x y",
  "tactic-prompt":
  "theorem (x y : â„•) : (gcd x y : â„¤) = x * gcdA x y + y * gcdB x y := by have := @xgcd_aux_P x y x y 1 0 0 1 (by simp [P]) (by simp [P]); sorry",
  "name": "gcd_eq_gcd_ab",
  "kind": "theorem",
  "first-tactic":
  "have := @xgcd_aux_P x y x y 1 0 0 1 (by simp [P]) (by simp [P])",
  "core-prompt": "(x y : â„•) : (gcd x y : â„¤) = x * gcdA x y + y * gcdB x y",
  "args": "(x y : â„•)"},
 {"type": "âˆƒ m, n * m % k = gcd n k",
  "tactic-prompt":
  "theorem {k n : â„•}  (hk : gcd n k < k) : âˆƒ m, n * m % k = gcd n k := by have hk' := Int.ofNat_ne_zero.2 (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk)); sorry",
  "name": "exists_mul_emod_eq_gcd",
  "kind": "theorem",
  "first-tactic":
  "have hk' := Int.ofNat_ne_zero.2 (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk))",
  "core-prompt": "{k n : â„•}  (hk : gcd n k < k) : âˆƒ m, n * m % k = gcd n k",
  "args": "{k n : â„•}  (hk : gcd n k < k)"},
 {"type": "natAbs (a / b) = natAbs a / natAbs b",
  "tactic-prompt":
  "theorem (a b : â„¤)  (H : b âˆ£ a) : natAbs (a / b) = natAbs a / natAbs b := by rcases Nat.eq_zero_or_pos (natAbs b) with (h | h); sorry",
  "name": "natAbs_ediv",
  "kind": "theorem",
  "first-tactic": "rcases Nat.eq_zero_or_pos (natAbs b) with (h | h)",
  "core-prompt":
  "(a b : â„¤)  (H : b âˆ£ a) : natAbs (a / b) = natAbs a / natAbs b",
  "args": "(a b : â„¤)  (H : b âˆ£ a)"},
 {"type": "i âˆ£ j",
  "tactic-prompt":
  "theorem {i j k : â„¤}  (k_non_zero : k â‰  0)  (H : i * k âˆ£ j * k) : i âˆ£ j := by rw [mul_comm i k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm i k]",
  "core-prompt":
  "{i j k : â„¤}  (k_non_zero : k â‰  0)  (H : i * k âˆ£ j * k) : i âˆ£ j",
  "args": "{i j k : â„¤}  (k_non_zero : k â‰  0)  (H : i * k âˆ£ j * k)"},
 {"type": "gcd i j * lcm i j = natAbs (i * j)",
  "tactic-prompt":
  "theorem (i j : â„¤) : gcd i j * lcm i j = natAbs (i * j) := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j : â„¤) : gcd i j * lcm i j = natAbs (i * j)",
  "args": "(i j : â„¤)"},
 {"type": "gcd i i = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : gcd i i = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : â„¤) : gcd i i = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "gcd 0 i = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : gcd 0 i = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : â„¤) : gcd 0 i = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "gcd i 0 = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : gcd i 0 = natAbs i := by simp [gcd]; sorry",
  "name": "gcd_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [gcd]",
  "core-prompt": "(i : â„¤) : gcd i 0 = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "gcd x (-y) = gcd x y",
  "tactic-prompt":
  "theorem {x y : â„¤} : gcd x (-y) = gcd x y := by rw [Int.gcd]; sorry",
  "name": "gcd_neg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{x y : â„¤} : gcd x (-y) = gcd x y",
  "args": "{x y : â„¤}"},
 {"type": "gcd (-x) y = gcd x y",
  "tactic-prompt":
  "theorem {x y : â„¤} : gcd (-x) y = gcd x y := by rw [Int.gcd]; sorry",
  "name": "gcd_neg_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{x y : â„¤} : gcd (-x) y = gcd x y",
  "args": "{x y : â„¤}"},
 {"type": "gcd (i * j) (i * k) = natAbs i * gcd j k",
  "tactic-prompt":
  "theorem (i j k : â„¤) : gcd (i * j) (i * k) = natAbs i * gcd j k := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j k : â„¤) : gcd (i * j) (i * k) = natAbs i * gcd j k",
  "args": "(i j k : â„¤)"},
 {"type": "gcd (i * j) (k * j) = gcd i k * natAbs j",
  "tactic-prompt":
  "theorem (i j k : â„¤) : gcd (i * j) (k * j) = gcd i k * natAbs j := by rw [Int.gcd]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "(i j k : â„¤) : gcd (i * j) (k * j) = gcd i k * natAbs j",
  "args": "(i j k : â„¤)"},
 {"type": "gcd i j = 0 â†” i = 0 âˆ§ j = 0",
  "tactic-prompt":
  "theorem {i j : â„¤} : gcd i j = 0 â†” i = 0 âˆ§ j = 0 := by rw [Int.gcd]; sorry",
  "name": "gcd_eq_zero_iff",
  "kind": "theorem",
  "first-tactic": "rw [Int.gcd]",
  "core-prompt": "{i j : â„¤} : gcd i j = 0 â†” i = 0 âˆ§ j = 0",
  "args": "{i j : â„¤}"},
 {"type": "gcd (i / k) (j / k) = gcd i j / natAbs k",
  "tactic-prompt":
  "theorem {i j k : â„¤}  (H1 : k âˆ£ i)  (H2 : k âˆ£ j) : gcd (i / k) (j / k) = gcd i j / natAbs k := by rw [gcd]; sorry",
  "name": "gcd_div",
  "kind": "theorem",
  "first-tactic": "rw [gcd]",
  "core-prompt":
  "{i j k : â„¤}  (H1 : k âˆ£ i)  (H2 : k âˆ£ j) : gcd (i / k) (j / k) = gcd i j / natAbs k",
  "args": "{i j k : â„¤}  (H1 : k âˆ£ i)  (H2 : k âˆ£ j)"},
 {"type": "gcd (i / gcd i j) (j / gcd i j) = 1",
  "tactic-prompt":
  "theorem {i j : â„¤}  (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1 := by rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]; sorry",
  "name": "gcd_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_div (gcd_dvd_left i j) (gcd_dvd_right i j)]",
  "core-prompt":
  "{i j : â„¤}  (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1",
  "args": "{i j : â„¤}  (H : 0 < gcd i j)"},
 {"type": "gcd i j = natAbs j",
  "tactic-prompt":
  "theorem {i j : â„¤}  (H : j âˆ£ i) : gcd i j = natAbs j := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{i j : â„¤}  (H : j âˆ£ i) : gcd i j = natAbs j",
  "args": "{i j : â„¤}  (H : j âˆ£ i)"},
 {"type": "x â‰  0 âˆ¨ y â‰  0",
  "tactic-prompt":
  "theorem {x y : â„¤}  (hc : gcd x y â‰  0) : x â‰  0 âˆ¨ y â‰  0 := by contrapose! hc; sorry",
  "name": "ne_zero_of_gcd",
  "kind": "theorem",
  "first-tactic": "contrapose! hc",
  "core-prompt": "{x y : â„¤}  (hc : gcd x y â‰  0) : x â‰  0 âˆ¨ y â‰  0",
  "args": "{x y : â„¤}  (hc : gcd x y â‰  0)"},
 {"type": "m ^ k âˆ£ n ^ k â†” m âˆ£ n",
  "tactic-prompt":
  "theorem {m n : â„¤}  {k : â„•}  (k0 : 0 < k) : m ^ k âˆ£ n ^ k â†” m âˆ£ n := by refine' âŸ¨fun h => _, fun h => pow_dvd_pow_of_dvd h _âŸ©; sorry",
  "name": "pow_dvd_pow_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => pow_dvd_pow_of_dvd h _âŸ©",
  "core-prompt": "{m n : â„¤}  {k : â„•}  (k0 : 0 < k) : m ^ k âˆ£ n ^ k â†” m âˆ£ n",
  "args": "{m n : â„¤}  {k : â„•}  (k0 : 0 < k)"},
 {"type": "gcd a b âˆ£ n â†” âˆƒ x y : â„¤, â†‘n = a * x + b * y",
  "tactic-prompt":
  "theorem {a b : â„¤}  {n : â„•} : gcd a b âˆ£ n â†” âˆƒ x y : â„¤, â†‘n = a * x + b * y := by constructor; sorry",
  "name": "gcd_dvd_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b : â„¤}  {n : â„•} : gcd a b âˆ£ n â†” âˆƒ x y : â„¤, â†‘n = a * x + b * y",
  "args": "{a b : â„¤}  {n : â„•}"},
 {"type": "a âˆ£ b",
  "tactic-prompt":
  "theorem {a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a c = 1) : a âˆ£ b := by have := gcd_eq_gcd_ab a c; sorry",
  "name": "dvd_of_dvd_mul_left_of_gcd_one",
  "kind": "theorem",
  "first-tactic": "have := gcd_eq_gcd_ab a c",
  "core-prompt": "{a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a c = 1) : a âˆ£ b",
  "args": "{a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a c = 1)"},
 {"type": "a âˆ£ c",
  "tactic-prompt":
  "theorem {a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a b = 1) : a âˆ£ c := by rw [mul_comm] at habc; sorry",
  "name": "dvd_of_dvd_mul_right_of_gcd_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm] at habc",
  "core-prompt": "{a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a b = 1) : a âˆ£ c",
  "args": "{a b c : â„¤}  (habc : a âˆ£ b * c)  (hab : gcd a b = 1)"},
 {"type": "IsLeast { n : â„• | 0 < n âˆ§ âˆƒ x y : â„¤, â†‘n = a * x + b * y } (a.gcd b)",
  "tactic-prompt":
  "theorem {a b : â„¤}  (ha : a â‰  0) : IsLeast { n : â„• | 0 < n âˆ§ âˆƒ x y : â„¤, â†‘n = a * x + b * y } (a.gcd b) := by simp_rw [â† gcd_dvd_iff]; sorry",
  "name": "gcd_least_linear",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† gcd_dvd_iff]",
  "core-prompt":
  "{a b : â„¤}  (ha : a â‰  0) : IsLeast { n : â„• | 0 < n âˆ§ âˆƒ x y : â„¤, â†‘n = a * x + b * y } (a.gcd b)",
  "args": "{a b : â„¤}  (ha : a â‰  0)"},
 {"type": "lcm i j = lcm j i",
  "tactic-prompt":
  "theorem (i j : â„¤) : lcm i j = lcm j i := by rw [Int.lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : â„¤) : lcm i j = lcm j i",
  "args": "(i j : â„¤)"},
 {"type": "lcm (lcm i j) k = lcm i (lcm j k)",
  "tactic-prompt":
  "theorem (i j k : â„¤) : lcm (lcm i j) k = lcm i (lcm j k) := by rw [Int.lcm]; sorry",
  "name": "lcm_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j k : â„¤) : lcm (lcm i j) k = lcm i (lcm j k)",
  "args": "(i j k : â„¤)"},
 {"type": "lcm 0 i = 0",
  "tactic-prompt": "theorem (i : â„¤) : lcm 0 i = 0 := by rw [Int.lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : â„¤) : lcm 0 i = 0",
  "args": "(i : â„¤)"},
 {"type": "lcm i 0 = 0",
  "tactic-prompt": "theorem (i : â„¤) : lcm i 0 = 0 := by rw [Int.lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : â„¤) : lcm i 0 = 0",
  "args": "(i : â„¤)"},
 {"type": "lcm 1 i = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : lcm 1 i = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : â„¤) : lcm 1 i = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "lcm i 1 = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : lcm i 1 = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : â„¤) : lcm i 1 = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "lcm i i = natAbs i",
  "tactic-prompt":
  "theorem (i : â„¤) : lcm i i = natAbs i := by rw [Int.lcm]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i : â„¤) : lcm i i = natAbs i",
  "args": "(i : â„¤)"},
 {"type": "i âˆ£ lcm i j",
  "tactic-prompt": "theorem (i j : â„¤) : i âˆ£ lcm i j := by rw [Int.lcm]; sorry",
  "name": "dvd_lcm_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : â„¤) : i âˆ£ lcm i j",
  "args": "(i j : â„¤)"},
 {"type": "j âˆ£ lcm i j",
  "tactic-prompt": "theorem (i j : â„¤) : j âˆ£ lcm i j := by rw [Int.lcm]; sorry",
  "name": "dvd_lcm_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "(i j : â„¤) : j âˆ£ lcm i j",
  "args": "(i j : â„¤)"},
 {"type": "i âˆ£ k â†’ j âˆ£ k â†’ (lcm i j : â„¤) âˆ£ k",
  "tactic-prompt":
  "theorem {i j k : â„¤} : i âˆ£ k â†’ j âˆ£ k â†’ (lcm i j : â„¤) âˆ£ k := by rw [Int.lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.lcm]",
  "core-prompt": "{i j k : â„¤} : i âˆ£ k â†’ j âˆ£ k â†’ (lcm i j : â„¤) âˆ£ k",
  "args": "{i j k : â„¤}"},
 {"type": "x ^ m.gcd n = 1",
  "tactic-prompt":
  "theorem {M : Type _}  [Monoid M]  (x : M)  {m n : â„•}  (hm : x ^ m = 1)  (hn : x ^ n = 1) : x ^ m.gcd n = 1 := by rcases m with (rfl | m); sorry",
  "name": "pow_gcd_eq_one",
  "kind": "theorem",
  "first-tactic": "rcases m with (rfl | m)",
  "core-prompt":
  "{M : Type _}  [Monoid M]  (x : M)  {m n : â„•}  (hm : x ^ m = 1)  (hn : x ^ n = 1) : x ^ m.gcd n = 1",
  "args":
  "{M : Type _}  [Monoid M]  (x : M)  {m n : â„•}  (hm : x ^ m = 1)  (hn : x ^ n = 1)"},
 {"type": "m.gcd n â€¢ x = 0",
  "tactic-prompt":
  "theorem {M : Type _}  [AddMonoid M]  (x : M)  {m n : â„•}  (hm : m â€¢ x = 0)      (hn : n â€¢ x = 0) : m.gcd n â€¢ x = 0 := by apply Multiplicative.ofAdd.injective; sorry",
  "name": "gcd_nsmul_eq_zero",
  "kind": "theorem",
  "first-tactic": "apply Multiplicative.ofAdd.injective",
  "core-prompt":
  "{M : Type _}  [AddMonoid M]  (x : M)  {m n : â„•}  (hm : m â€¢ x = 0)      (hn : n â€¢ x = 0) : m.gcd n â€¢ x = 0",
  "args":
  "{M : Type _}  [AddMonoid M]  (x : M)  {m n : â„•}  (hm : m â€¢ x = 0)      (hn : n â€¢ x = 0)"},
 {"type": "(m : Î±) = n â†” m = n",
  "tactic-prompt":
  "theorem {Î± : Type _} [AddGroupWithOne Î±]  [CharZero Î±]  {m n : â„¤} : (m : Î±) = n â†” m = n := by rw [â† sub_eq_zero]; sorry",
  "name": "cast_inj",
  "kind": "theorem",
  "first-tactic": "rw [â† sub_eq_zero]",
  "core-prompt":
  "{Î± : Type _} [AddGroupWithOne Î±]  [CharZero Î±]  {m n : â„¤} : (m : Î±) = n â†” m = n",
  "args": "{Î± : Type _} [AddGroupWithOne Î±]  [CharZero Î±]  {m n : â„¤}"},
 {"type": "((m / n : â„¤) : k) = m / n",
  "tactic-prompt":
  "theorem {Î± : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : â„¤}  (n_dvd : n âˆ£ m) : ((m / n : â„¤) : k) = m / n := by rcases eq_or_ne n 0 with (rfl | hn); sorry",
  "name": "cast_div_charZero",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne n 0 with (rfl | hn)",
  "core-prompt":
  "{Î± : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : â„¤}  (n_dvd : n âˆ£ m) : ((m / n : â„¤) : k) = m / n",
  "args":
  "{Î± : Type _} {k : Type _}  [Field k]  [CharZero k]  {m n : â„¤}  (n_dvd : n âˆ£ m)"},
 {"type": "f.symm.symm = f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.symm.symm = f := by cases f; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "cases f",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.symm.symm = f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)"},
 {"type": "f.trans g a = none â†” âˆ€ b c, b âˆ‰ f a âˆ¨ c âˆ‰ g b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  (g : Î² â‰ƒ. Î³)  (a : Î±) : f.trans g a = none â†” âˆ€ b c, b âˆ‰ f a âˆ¨ c âˆ‰ g b := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "trans_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  (g : Î² â‰ƒ. Î³)  (a : Î±) : f.trans g a = none â†” âˆ€ b c, b âˆ‰ f a âˆ¨ c âˆ‰ g b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  (g : Î² â‰ƒ. Î³)  (a : Î±)"},
 {"type": "(PEquiv.refl Î±).trans f = f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : (PEquiv.refl Î±).trans f = f := by ext; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : (PEquiv.refl Î±).trans f = f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)"},
 {"type": "f.trans (PEquiv.refl Î²) = f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans (PEquiv.refl Î²) = f := by ext; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans (PEquiv.refl Î²) = f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)"},
 {"type": "aâ‚ = aâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  {aâ‚ aâ‚‚ : Î±}  {b : Î²}  (hâ‚ : b âˆˆ f aâ‚)  (hâ‚‚ : b âˆˆ f aâ‚‚) : aâ‚ = aâ‚‚ := by rw [â† mem_iff_mem] at *; sorry",
  "name": "inj",
  "kind": "theorem",
  "first-tactic": "rw [â† mem_iff_mem] at *",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  {aâ‚ aâ‚‚ : Î±}  {b : Î²}  (hâ‚ : b âˆˆ f aâ‚)  (hâ‚‚ : b âˆˆ f aâ‚‚) : aâ‚ = aâ‚‚",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)  {aâ‚ aâ‚‚ : Î±}  {b : Î²}  (hâ‚ : b âˆˆ f aâ‚)  (hâ‚‚ : b âˆˆ f aâ‚‚)"},
 {"type": "a âˆˆ ofSet s a â†” a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a : Î±} : a âˆˆ ofSet s a â†” a âˆˆ s := by dsimp [ofSet]; sorry",
  "name": "mem_ofSet_self_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [ofSet]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a : Î±} : a âˆˆ ofSet s a â†” a âˆˆ s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a : Î±}"},
 {"type": "a âˆˆ ofSet s b â†” a = b âˆ§ a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a b : Î±} : a âˆˆ ofSet s b â†” a = b âˆ§ a âˆˆ s := by dsimp [ofSet]; sorry",
  "name": "mem_ofSet_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [ofSet]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a b : Î±} : a âˆˆ ofSet s b â†” a = b âˆ§ a âˆˆ s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  (s : Set Î±)  [DecidablePred (Â· âˆˆ s)] {s : Set Î±}  [DecidablePred (Â· âˆˆ s)]  {a b : Î±}"},
 {"type": "f.trans f.symm = ofSet { a | (f a).isSome }",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans f.symm = ofSet { a | (f a).isSome } := by ext; sorry",
  "name": "self_trans_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans f.symm = ofSet { a | (f a).isSome }",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)"},
 {"type": "f.trans f.symm = PEquiv.refl Î± â†” âˆ€ a, isSome (f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} {f : Î± â‰ƒ. Î²} : f.trans f.symm = PEquiv.refl Î± â†” âˆ€ a, isSome (f a) := by rw [self_trans_symm]; sorry",
  "name": "trans_symm_eq_iff_forall_is_some",
  "kind": "theorem",
  "first-tactic": "rw [self_trans_symm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} {f : Î± â‰ƒ. Î²} : f.trans f.symm = PEquiv.refl Î± â†” âˆ€ a, isSome (f a)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} {f : Î± â‰ƒ. Î²}"},
 {"type": "f.trans (âŠ¥ : Î² â‰ƒ. Î³) = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans (âŠ¥ : Î² â‰ƒ. Î³) = âŠ¥ := by ext; sorry",
  "name": "trans_bot",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²) : f.trans (âŠ¥ : Î² â‰ƒ. Î³) = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î± â‰ƒ. Î²)"},
 {"type": "(âŠ¥ : Î± â‰ƒ. Î²).trans f = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î² â‰ƒ. Î³) : (âŠ¥ : Î± â‰ƒ. Î²).trans f = âŠ¥ := by ext; sorry",
  "name": "bot_trans",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î² â‰ƒ. Î³) : (âŠ¥ : Î± â‰ƒ. Î²).trans f = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x} (f : Î² â‰ƒ. Î³)"},
 {"type": "bâ‚ âˆˆ single aâ‚‚ bâ‚‚ aâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²) : bâ‚ âˆˆ single aâ‚‚ bâ‚‚ aâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚ := by dsimp [single]; sorry",
  "name": "mem_single_iff",
  "kind": "theorem",
  "first-tactic": "dsimp [single]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²) : bâ‚ âˆˆ single aâ‚‚ bâ‚‚ aâ‚ â†” aâ‚ = aâ‚‚ âˆ§ bâ‚ = bâ‚‚",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²)"},
 {"type": "(single a b).trans f = single a c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (a : Î±)  {b : Î²}  {c : Î³}  {f : Î² â‰ƒ. Î³}  (h : c âˆˆ f b) : (single a b).trans f = single a c := by ext; sorry",
  "name": "single_trans_of_mem",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (a : Î±)  {b : Î²}  {c : Î³}  {f : Î² â‰ƒ. Î³}  (h : c âˆˆ f b) : (single a b).trans f = single a c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] (a : Î±)  {b : Î²}  {c : Î³}  {f : Î² â‰ƒ. Î³}  (h : c âˆˆ f b)"},
 {"type": "single a b = PEquiv.refl Î±",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] [Subsingleton Î±]  (a b : Î±) : single a b = PEquiv.refl Î± := by ext (i j); sorry",
  "name": "single_subsingleton_eq_refl",
  "kind": "theorem",
  "first-tactic": "ext (i j)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] [Subsingleton Î±]  (a b : Î±) : single a b = PEquiv.refl Î±",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] [Subsingleton Î±]  (a b : Î±)"},
 {"type": "f.trans (single b c) = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] {b : Î²}  (c : Î³)  {f : Î´ â‰ƒ. Î²}  (h : f.symm b = none) : f.trans (single b c) = âŠ¥ := by ext; sorry",
  "name": "trans_single_of_eq_none",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] {b : Î²}  (c : Î³)  {f : Î´ â‰ƒ. Î²}  (h : f.symm b = none) : f.trans (single b c) = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type x}  [DecidableEq Î±]  [DecidableEq Î²]  [DecidableEq Î³] {b : Î²}  (c : Î³)  {f : Î´ â‰ƒ. Î²}  (h : f.symm b = none)"},
 {"type": "xâ‚€ = xâ‚",
  "tactic-prompt":
  "theorem {Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚ := by cases xâ‚€; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚",
  "args":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2)"},
 {"type": "xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "tactic-prompt":
  "theorem {Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2 := by cases xâ‚€; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "args":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}"},
 {"type": "Function.Surjective (Sigma.map fâ‚ fâ‚‚)",
  "tactic-prompt":
  "theorem {fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a)) : Function.Surjective (Sigma.map fâ‚ fâ‚‚) := by simp only [Function.Surjective]; sorry",
  "name": "Function.Surjective.sigma_map",
  "kind": "theorem",
  "first-tactic": "simp only [Function.Surjective]",
  "core-prompt":
  "{fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a)) : Function.Surjective (Sigma.map fâ‚ fâ‚‚)",
  "args":
  "{fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a))"},
 {"type": "xâ‚€ = xâ‚",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚ := by cases xâ‚€; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚",
  "args":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2)"},
 {"type": "xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2 := by cases xâ‚€; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "args": "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}"},
 {"type": "Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} : Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by constructor; sorry",
  "name": "lex_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} : Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "args":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i}"},
 {"type": "Lex râ‚‚ sâ‚‚ a b",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£ i, Î± i}      (h : Lex râ‚ sâ‚ a b) : Lex râ‚‚ sâ‚‚ a b := by obtain âŸ¨a, b, hijâŸ© | âŸ¨a, b, habâŸ© := h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨a, b, hijâŸ© | âŸ¨a, b, habâŸ© := h",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£ i, Î± i}      (h : Lex râ‚ sâ‚ a b) : Lex râ‚‚ sâ‚‚ a b",
  "args":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£ i, Î± i}      (h : Lex râ‚ sâ‚ a b)"},
 {"type":
  "Lex (Function.swap r) s a b â†” Lex r (fun i => Function.swap (s i)) b a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} : Lex (Function.swap r) s a b â†” Lex r (fun i => Function.swap (s i)) b a := by constructor; sorry",
  "name": "lex_swap",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} : Lex (Function.swap r) s a b â†” Lex r (fun i => Function.swap (s i)) b a",
  "args":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i}"},
 {"type": "Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {a b : Î£' i, Î± i} : Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by constructor; sorry",
  "name": "lex_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {a b : Î£' i, Î± i} : Lex r s a b â†” r a.1 b.1 âˆ¨ âˆƒ h : a.1 = b.1, s b.1 (h.rec a.2) b.2",
  "args":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {a b : Î£' i, Î± i}"},
 {"type": "Lex râ‚‚ sâ‚‚ a b",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£' i, Î± i}      (h : Lex râ‚ sâ‚ a b) : Lex râ‚‚ sâ‚‚ a b := by obtain âŸ¨a, b, hijâŸ© | âŸ¨i, habâŸ© := h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨a, b, hijâŸ© | âŸ¨i, habâŸ© := h",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£' i, Î± i}      (h : Lex râ‚ sâ‚ a b) : Lex râ‚‚ sâ‚‚ a b",
  "args":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    {a b : Î£ i, Î± i} {Î¹ : Sort _}  {Î± : Î¹ â†’ Sort _}  {r râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {s sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop} {râ‚ râ‚‚ : Î¹ â†’ Î¹ â†’ Prop}  {sâ‚ sâ‚‚ : âˆ€ i, Î± i â†’ Î± i â†’ Prop}    (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ i a b, sâ‚ i a b â†’ sâ‚‚ i a b)  {a b : Î£' i, Î± i}      (h : Lex râ‚ sâ‚ a b)"},
 {"type": "a â‰¤ b â†” âˆƒ h : a.1 = b.1, h.rec a.2 â‰¤ b.2",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LE (Î± i)]  {a b : Î£i, Î± i} : a â‰¤ b â†” âˆƒ h : a.1 = b.1, h.rec a.2 â‰¤ b.2 := by constructor; sorry",
  "name": "le_def",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LE (Î± i)]  {a b : Î£i, Î± i} : a â‰¤ b â†” âˆƒ h : a.1 = b.1, h.rec a.2 â‰¤ b.2",
  "args": "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LE (Î± i)]  {a b : Î£i, Î± i}"},
 {"type": "a < b â†” âˆƒ h : a.1 = b.1, h.rec a.2 < b.2",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LT (Î± i)]  {a b : Î£i, Î± i} : a < b â†” âˆƒ h : a.1 = b.1, h.rec a.2 < b.2 := by constructor; sorry",
  "name": "lt_def",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LT (Î± i)]  {a b : Î£i, Î± i} : a < b â†” âˆƒ h : a.1 = b.1, h.rec a.2 < b.2",
  "args": "{Î¹ : Type _}  {Î± : Î¹ â†’ Type _} [âˆ€ i, LT (Î± i)]  {a b : Î£i, Î± i}"},
 {"type": "some x â‰  none",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Î±) : some x â‰  none := by intro h; sorry",
  "name": "some_ne_none",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Î±) : some x â‰  none",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Î±)"},
 {"type": "o â‰  none â†” âˆƒ x, o = some x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±} : o â‰  none â†” âˆƒ x, o = some x := by constructor; sorry",
  "name": "ne_none_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±} : o â‰  none â†” âˆƒ x, o = some x",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}"},
 {"type": "a.get ha = b.get (h â–¸ ha)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (a : Part Î±)  (ha : a.Dom)  {b : Part Î±}  (h : a = b) : a.get ha = b.get (h â–¸ ha) := by congr; sorry",
  "name": "get_eq_get_of_eq",
  "kind": "theorem",
  "first-tactic": "congr",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (a : Part Î±)  (ha : a.Dom)  {b : Part Î±}  (h : a = b) : a.get ha = b.get (h â–¸ ha)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (a : Part Î±)  (ha : a.Dom)  {b : Part Î±}  (h : a = b)"},
 {"type": "a âˆˆ toOption o â†” a âˆˆ o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±} : a âˆˆ toOption o â†” a âˆˆ o := by unfold toOption; sorry",
  "name": "mem_toOption",
  "kind": "theorem",
  "first-tactic": "unfold toOption",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±} : a âˆˆ toOption o â†” a âˆˆ o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±}"},
 {"type": "toOption o = Option.some a â†” a âˆˆ o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±} : toOption o = Option.some a â†” a âˆˆ o := by rw [â† Option.mem_def]; sorry",
  "name": "toOption_eq_some_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† Option.mem_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±} : toOption o = Option.some a â†” a âˆˆ o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  [Decidable o.Dom]  {a : Î±}"},
 {"type": "a.toOption.elim b f = if h : a.Dom then f (a.get h) else b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {Î± Î² : Type _}  (a : Part Î±)  [Decidable a.Dom]  (b : Î²)  (f : Î± â†’ Î²) : a.toOption.elim b f = if h : a.Dom then f (a.get h) else b := by split_ifs with h; sorry",
  "name": "elim_toOption",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {Î± Î² : Type _}  (a : Part Î±)  [Decidable a.Dom]  (b : Î²)  (f : Î± â†’ Î²) : a.toOption.elim b f = if h : a.Dom then f (a.get h) else b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {Î± Î² : Type _}  (a : Part Î±)  [Decidable a.Dom]  (b : Î²)  (f : Î± â†’ Î²)"},
 {"type": "toOption (ofOption o) = o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (o : Option Î±) : toOption (ofOption o) = o := by cases o; sorry",
  "name": "to_ofOption",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (o : Option Î±) : toOption (ofOption o) = o",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (o : Option Î±)"},
 {"type": "x â‰¤ y âˆ¨ y â‰¤ x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {x y : Part Î±}  (z : Part Î±)  (hx : x â‰¤ z)  (hy : y â‰¤ z) : x â‰¤ y âˆ¨ y â‰¤ x := by rcases Part.eq_none_or_eq_some x with (h | âŸ¨b, hâ‚€âŸ©); sorry",
  "name": "le_total_of_le_of_le",
  "kind": "theorem",
  "first-tactic": "rcases Part.eq_none_or_eq_some x with (h | âŸ¨b, hâ‚€âŸ©)",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {x y : Part Î±}  (z : Part Î±)  (hx : x â‰¤ z)  (hy : y â‰¤ z) : x â‰¤ y âˆ¨ y â‰¤ x",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {x y : Part Î±}  (z : Part Î±)  (hx : x â‰¤ z)  (hy : y â‰¤ z)"},
 {"type": "assert p f = f h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : p) : assert p f = f h := by dsimp [assert]; sorry",
  "name": "assert_pos",
  "kind": "theorem",
  "first-tactic": "dsimp [assert]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : p) : assert p f = f h",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : p)"},
 {"type": "assert p f = none",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : Â¬p) : assert p f = none := by dsimp [assert]; sorry",
  "name": "assert_neg",
  "kind": "theorem",
  "first-tactic": "dsimp [assert]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : Â¬p) : assert p f = none",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {p : Prop}  {f : p â†’ Part Î±}  (h : Â¬p)"},
 {"type": "o.bind f = f (o.get h)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  (h : o.Dom)  (f : Î± â†’ Part Î²) : o.bind f = f (o.get h) := by ext b; sorry",
  "name": "Dom.bind",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  (h : o.Dom)  (f : Î± â†’ Part Î²) : o.bind f = f (o.get h)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  (h : o.Dom)  (f : Î± â†’ Part Î²)"},
 {"type": "o.bind f = f a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  {a : Î±}  (h : a âˆˆ o)  (f : Î± â†’ Part Î²) : o.bind f = f a := by rw [eq_some_iff.2 h]; sorry",
  "name": "bind_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [eq_some_iff.2 h]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  {a : Î±}  (h : a âˆˆ o)  (f : Î± â†’ Part Î²) : o.bind f = f a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} {o : Part Î±}  {a : Î±}  (h : a âˆˆ o)  (f : Î± â†’ Part Î²)"},
 {"type":
  "(o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (f : Î± â†’ Part Î²)  (o : Part Î±)  [Decidable o.Dom]  [âˆ€ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom] : (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption := by by_cases o.Dom; sorry",
  "name": "bind_toOption",
  "kind": "theorem",
  "first-tactic": "by_cases o.Dom",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (f : Î± â†’ Part Î²)  (o : Part Î±)  [Decidable o.Dom]  [âˆ€ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom] : (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (f : Î± â†’ Part Î²)  (o : Part Î±)  [Decidable o.Dom]  [âˆ€ a, Decidable (f a).Dom]      [Decidable (o.bind f).Dom]"},
 {"type": "map g (map f o) = map (g âˆ˜ f) o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (o : Part Î±) : map g (map f o) = map (g âˆ˜ f) o := by erw [â† bind_some_eq_map]; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "erw [â† bind_some_eq_map]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (o : Part Î±) : map g (map f o) = map (g âˆ˜ f) o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (o : Part Î±)"},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Part Î±) : x.bind some = x := by erw [bind_some_eq_map]; sorry",
  "name": "bind_some_right",
  "kind": "theorem",
  "first-tactic": "erw [bind_some_eq_map]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Part Î±) : x.bind some = x",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (x : Part Î±)"},
 {"type": "a âˆˆ restrict p o h â†” p âˆ§ a âˆˆ o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (p : Prop)  (o : Part Î±)  (h : p â†’ o.Dom)  (a : Î±) : a âˆˆ restrict p o h â†” p âˆ§ a âˆˆ o := by dsimp [restrict]; sorry",
  "name": "mem_restrict",
  "kind": "theorem",
  "first-tactic": "dsimp [restrict]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (p : Prop)  (o : Part Î±)  (h : p â†’ o.Dom)  (a : Î±) : a âˆˆ restrict p o h â†” p âˆ§ a âˆˆ o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _} (p : Prop)  (o : Part Î±)  (h : p â†’ o.Dom)  (a : Î±)"},
 {"type": "some a * some b = some (a * b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mul Î±]  (a b : Î±) : some a * some b = some (a * b) := by simp [mul_def]; sorry",
  "name": "some_mul_some",
  "kind": "theorem",
  "first-tactic": "simp [mul_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mul Î±]  (a b : Î±) : some a * some b = some (a * b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mul Î±]  (a b : Î±)"},
 {"type": "maâ»Â¹ âˆˆ aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inv Î±]  (a : Part Î±)  (ma : Î±)  (ha : ma âˆˆ a) : maâ»Â¹ âˆˆ aâ»Â¹ := by simp [inv_def]; sorry",
  "name": "inv_mem_inv",
  "kind": "theorem",
  "first-tactic": "simp [inv_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inv Î±]  (a : Part Î±)  (ma : Î±)  (ha : ma âˆˆ a) : maâ»Â¹ âˆˆ aâ»Â¹",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inv Î±]  (a : Part Î±)  (ma : Î±)  (ha : ma âˆˆ a)"},
 {"type": "ma / mb âˆˆ a / b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma / mb âˆˆ a / b := by simp [div_def]; sorry",
  "name": "div_mem_div",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma / mb âˆˆ a / b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (hab : Dom (a / b)) : (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab) := by simp [div_def]; sorry",
  "name": "div_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (hab : Dom (a / b)) : (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Part Î±)  (hab : Dom (a / b))"},
 {"type": "some a / some b = some (a / b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Î±) : some a / some b = some (a / b) := by simp [div_def]; sorry",
  "name": "some_div_some",
  "kind": "theorem",
  "first-tactic": "simp [div_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Î±) : some a / some b = some (a / b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Div Î±]  (a b : Î±)"},
 {"type": "ma % mb âˆˆ a % b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma % mb âˆˆ a % b := by simp [mod_def]; sorry",
  "name": "mod_mem_mod",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma % mb âˆˆ a % b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (hab : Dom (a % b)) : (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab) := by simp [mod_def]; sorry",
  "name": "mod_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (hab : Dom (a % b)) : (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Part Î±)  (hab : Dom (a % b))"},
 {"type": "some a % some b = some (a % b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Î±) : some a % some b = some (a % b) := by simp [mod_def]; sorry",
  "name": "some_mod_some",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Î±) : some a % some b = some (a % b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Mod Î±]  (a b : Î±)"},
 {"type": "ma ++ mb âˆˆ a ++ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma ++ mb âˆˆ a ++ b := by simp [append_def]; sorry",
  "name": "append_mem_append",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma ++ mb âˆˆ a ++ b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (hab : Dom (a ++ b)) : (a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab) := by simp [append_def]; sorry",
  "name": "append_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (hab : Dom (a ++ b)) : (a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Part Î±)  (hab : Dom (a ++ b))"},
 {"type": "some a ++ some b = some (a ++ b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Î±) : some a ++ some b = some (a ++ b) := by simp [append_def]; sorry",
  "name": "some_append_some",
  "kind": "theorem",
  "first-tactic": "simp [append_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Î±) : some a ++ some b = some (a ++ b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Append Î±]  (a b : Î±)"},
 {"type": "ma âˆ© mb âˆˆ a âˆ© b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma âˆ© mb âˆˆ a âˆ© b := by simp [inter_def]; sorry",
  "name": "inter_mem_inter",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma âˆ© mb âˆˆ a âˆ© b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a âˆ© b).get hab = a.get (left_dom_of_inter_dom hab) âˆ© b.get (right_dom_of_inter_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (hab : Dom (a âˆ© b)) : (a âˆ© b).get hab = a.get (left_dom_of_inter_dom hab) âˆ© b.get (right_dom_of_inter_dom hab) := by simp [inter_def]; sorry",
  "name": "inter_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (hab : Dom (a âˆ© b)) : (a âˆ© b).get hab = a.get (left_dom_of_inter_dom hab) âˆ© b.get (right_dom_of_inter_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Part Î±)  (hab : Dom (a âˆ© b))"},
 {"type": "some a âˆ© some b = some (a âˆ© b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Î±) : some a âˆ© some b = some (a âˆ© b) := by simp [inter_def]; sorry",
  "name": "some_inter_some",
  "kind": "theorem",
  "first-tactic": "simp [inter_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Î±) : some a âˆ© some b = some (a âˆ© b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Inter Î±]  (a b : Î±)"},
 {"type": "ma âˆª mb âˆˆ a âˆª b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma âˆª mb âˆˆ a âˆª b := by simp [union_def]; sorry",
  "name": "union_mem_union",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma âˆª mb âˆˆ a âˆª b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a âˆª b).get hab = a.get (left_dom_of_union_dom hab) âˆª b.get (right_dom_of_union_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (hab : Dom (a âˆª b)) : (a âˆª b).get hab = a.get (left_dom_of_union_dom hab) âˆª b.get (right_dom_of_union_dom hab) := by simp [union_def]; sorry",
  "name": "union_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (hab : Dom (a âˆª b)) : (a âˆª b).get hab = a.get (left_dom_of_union_dom hab) âˆª b.get (right_dom_of_union_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Part Î±)  (hab : Dom (a âˆª b))"},
 {"type": "some a âˆª some b = some (a âˆª b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Î±) : some a âˆª some b = some (a âˆª b) := by simp [union_def]; sorry",
  "name": "some_union_some",
  "kind": "theorem",
  "first-tactic": "simp [union_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Î±) : some a âˆª some b = some (a âˆª b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [Union Î±]  (a b : Î±)"},
 {"type": "ma \\ mb âˆˆ a \\ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma \\ mb âˆˆ a \\ b := by simp [sdiff_def]; sorry",
  "name": "sdiff_mem_sdiff",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b) : ma \\ mb âˆˆ a \\ b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (ma mb : Î±)  (ha : ma âˆˆ a)  (hb : mb âˆˆ b)"},
 {"type":
  "(a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (hab : Dom (a \\ b)) : (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab) := by simp [sdiff_def]; sorry",
  "name": "sdiff_get_eq",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (hab : Dom (a \\ b)) : (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Part Î±)  (hab : Dom (a \\ b))"},
 {"type": "some a \\ some b = some (a \\ b)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Î±) : some a \\ some b = some (a \\ b) := by simp [sdiff_def]; sorry",
  "name": "some_sdiff_some",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_def]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Î±) : some a \\ some b = some (a \\ b)",
  "args": "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  [SDiff Î±]  (a b : Î±)"},
 {"type": "a /. b = 0 â†” a = 0",
  "tactic-prompt":
  "theorem {a b : â„¤}  (b0 : b â‰  0) : a /. b = 0 â†” a = 0 := by rw [â†zero_divInt b]; sorry",
  "name": "divInt_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â†zero_divInt b]",
  "core-prompt": "{a b : â„¤}  (b0 : b â‰  0) : a /. b = 0 â†” a = 0",
  "args": "{a b : â„¤}  (b0 : b â‰  0)"},
 {"type": "f (a /. b) (c /. d) = fâ‚ a b c d /. fâ‚‚ a b c d",
  "tactic-prompt":
  "theorem (f : â„š â†’ â„š â†’ â„š)  (fâ‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)  (fâ‚‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)      (fv :       âˆ€ {nâ‚ dâ‚ hâ‚ câ‚ nâ‚‚ dâ‚‚ hâ‚‚ câ‚‚},         f âŸ¨nâ‚, dâ‚, hâ‚, câ‚âŸ© âŸ¨nâ‚‚, dâ‚‚, hâ‚‚, câ‚‚âŸ© = fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ /. fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚)      (f0 : âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, dâ‚ â‰  0 â†’ dâ‚‚ â‰  0 â†’ fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ â‰  0)  (a b c d : â„¤)      (b0 : b â‰  0)  (d0 : d â‰  0)      (H :       âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, a * dâ‚ = nâ‚ * b â†’ c * dâ‚‚ = nâ‚‚ * d â†’         fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ * fâ‚‚ a b c d = fâ‚ a b c d * fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚) : f (a /. b) (c /. d) = fâ‚ a b c d /. fâ‚‚ a b c d := by generalize ha : a /. b = x; sorry",
  "name": "lift_binop_eq",
  "kind": "theorem",
  "first-tactic": "generalize ha : a /. b = x",
  "core-prompt":
  "(f : â„š â†’ â„š â†’ â„š)  (fâ‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)  (fâ‚‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)      (fv :       âˆ€ {nâ‚ dâ‚ hâ‚ câ‚ nâ‚‚ dâ‚‚ hâ‚‚ câ‚‚},         f âŸ¨nâ‚, dâ‚, hâ‚, câ‚âŸ© âŸ¨nâ‚‚, dâ‚‚, hâ‚‚, câ‚‚âŸ© = fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ /. fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚)      (f0 : âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, dâ‚ â‰  0 â†’ dâ‚‚ â‰  0 â†’ fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ â‰  0)  (a b c d : â„¤)      (b0 : b â‰  0)  (d0 : d â‰  0)      (H :       âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, a * dâ‚ = nâ‚ * b â†’ c * dâ‚‚ = nâ‚‚ * d â†’         fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ * fâ‚‚ a b c d = fâ‚ a b c d * fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚) : f (a /. b) (c /. d) = fâ‚ a b c d /. fâ‚‚ a b c d",
  "args":
  "(f : â„š â†’ â„š â†’ â„š)  (fâ‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)  (fâ‚‚ : â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤ â†’ â„¤)      (fv :       âˆ€ {nâ‚ dâ‚ hâ‚ câ‚ nâ‚‚ dâ‚‚ hâ‚‚ câ‚‚},         f âŸ¨nâ‚, dâ‚, hâ‚, câ‚âŸ© âŸ¨nâ‚‚, dâ‚‚, hâ‚‚, câ‚‚âŸ© = fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ /. fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚)      (f0 : âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, dâ‚ â‰  0 â†’ dâ‚‚ â‰  0 â†’ fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ â‰  0)  (a b c d : â„¤)      (b0 : b â‰  0)  (d0 : d â‰  0)      (H :       âˆ€ {nâ‚ dâ‚ nâ‚‚ dâ‚‚}, a * dâ‚ = nâ‚ * b â†’ c * dâ‚‚ = nâ‚‚ * d â†’         fâ‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚ * fâ‚‚ a b c d = fâ‚ a b c d * fâ‚‚ nâ‚ dâ‚ nâ‚‚ dâ‚‚)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround. : a * (b + c) = a * b + a * c := by rw [Rat.mul_comm]; sorry",
  "name": "mul_add",
  "kind": "theorem",
  "first-tactic": "rw [Rat.mul_comm]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : a * (b + c) = a * b + a * c",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "0 â‰  (1 : â„š)",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround. : 0 â‰  (1 : â„š) := by rw [ne_comm]; sorry",
  "name": "zero_ne_one",
  "kind": "theorem",
  "first-tactic": "rw [ne_comm]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : 0 â‰  (1 : â„š)",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "Nontrivial â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : Nontrivial â„š := by infer_instance; sorry",
  "name": "nontrivial",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : Nontrivial â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "CommSemiring â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : CommSemiring â„š := by infer_instance; sorry",
  "name": "commSemiring",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : CommSemiring â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "Semiring â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : Semiring â„š := by infer_instance; sorry",
  "name": "semiring",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : Semiring â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommGroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommGroup â„š := by infer_instance; sorry",
  "name": "addCommGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommGroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddGroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddGroup â„š := by infer_instance; sorry",
  "name": "addGroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddGroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommMonoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommMonoid â„š := by infer_instance; sorry",
  "name": "addCommMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommMonoid â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddMonoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddMonoid â„š := by infer_instance; sorry",
  "name": "addMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddMonoid â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddLeftCancelSemigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddLeftCancelSemigroup â„š := by infer_instance; sorry",
  "name": "addLeftCancelSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddLeftCancelSemigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddRightCancelSemigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddRightCancelSemigroup â„š := by infer_instance; sorry",
  "name": "addRightCancelSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddRightCancelSemigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddCommSemigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommSemigroup â„š := by infer_instance; sorry",
  "name": "addCommSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddCommSemigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "AddSemigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : AddSemigroup â„š := by infer_instance; sorry",
  "name": "addSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : AddSemigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "CommMonoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : CommMonoid â„š := by infer_instance; sorry",
  "name": "commMonoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : CommMonoid â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "Monoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : Monoid â„š := by infer_instance; sorry",
  "name": "monoid",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : Monoid â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "CommSemigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : CommSemigroup â„š := by infer_instance; sorry",
  "name": "commSemigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : CommSemigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "Semigroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š)  -- Porting note: TODO this is a workaround. : Semigroup â„š := by infer_instance; sorry",
  "name": "semigroup",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. : Semigroup â„š",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround."},
 {"type": "p = q â†” p.num * q.den = q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround. {p q : â„š} : p = q â†” p.num * q.den = q.num * p.den := by conv =>\n    lhs\n    rw [â† @num_den p]; sorry",
  "name": "eq_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "conv =>\n    lhs\n    rw [â† @num_den p]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. {p q : â„š} : p = q â†” p.num * q.den = q.num * p.den",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround. {p q : â„š}"},
 {"type": "q = 0",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround. {q : â„š}  (hq : q.num = 0) : q = 0 := by have : q = q.num /. q.den := num_den.symm; sorry",
  "name": "zero_of_num_zero",
  "kind": "theorem",
  "first-tactic": "have : q = q.num /. q.den := num_den.symm",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. {q : â„š}  (hq : q.num = 0) : q = 0",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. {q : â„š}  (hq : q.num = 0)"},
 {"type": "q * r = q.num * r.num /. â†‘(q.den * r.den)",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround. (q r : â„š) : q * r = q.num * r.num /. â†‘(q.den * r.den) := by have hq' : (â†‘q.den : â„¤) â‰  0 := by have := den_nz q; simpa; sorry",
  "name": "mul_num_den",
  "kind": "theorem",
  "first-tactic": "have hq' : (â†‘q.den : â„¤) â‰  0 := by have := den_nz q; simpa",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround. (q r : â„š) : q * r = q.num * r.num /. â†‘(q.den * r.den)",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround. (q r : â„š)"},
 {"type": "n /. d = (n : â„š) / d",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  (n d : â„¤) : n /. d = (n : â„š) / d := by by_cases d0 : d = 0; sorry",
  "name": "divInt_eq_div",
  "kind": "theorem",
  "first-tactic": "by_cases d0 : d = 0",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n d : â„¤) : n /. d = (n : â„š) / d",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n d : â„¤)"},
 {"type": "n /. x * (x /. d) = n /. d",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : n /. x * (x /. d) = n /. d := by by_cases hd : d = 0; sorry",
  "name": "divInt_mul_divInt_cancel",
  "kind": "theorem",
  "first-tactic": "by_cases hd : d = 0",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : n /. x * (x /. d) = n /. d",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤)"},
 {"type": "n /. x / (d /. x) = n /. d",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : n /. x / (d /. x) = n /. d := by rw [div_eq_mul_inv]; sorry",
  "name": "divInt_div_divInt_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : n /. x / (d /. x) = n /. d",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤)"},
 {"type": "x /. n / (x /. d) = d /. n",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : x /. n / (x /. d) = d /. n := by rw [div_eq_mul_inv]; sorry",
  "name": "divInt_div_divInt_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤) : x /. n / (x /. d) = d /. n",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {x : â„¤}  (hx : x â‰  0)  (n d : â„¤)"},
 {"type": "(n : â„š) / (d) = n /. d",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  {n d : â„¤} : (n : â„š) / (d) = n /. d := by repeat' rw [coe_int_eq_divInt]; sorry",
  "name": "coe_int_div_eq_divInt",
  "kind": "theorem",
  "first-tactic": "repeat' rw [coe_int_eq_divInt]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {n d : â„¤} : (n : â„š) / (d) = n /. d",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {n d : â„¤}"},
 {"type": "(r.num : â„š) / (r.den : â„š) = r",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  (r : â„š) : (r.num : â„š) / (r.den : â„š) = r := by rw [â† Int.cast_ofNat]; sorry",
  "name": "num_div_den",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_ofNat]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (r : â„š) : (r.num : â„š) / (r.den : â„š) = r",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (r : â„š)"},
 {"type": "(q.num : â„š) = q",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  {q : â„š}  (hq : q.den = 1) : (q.num : â„š) = q := by conv_rhs => rw [â† @num_den q]; sorry",
  "name": "coe_int_num_of_den_eq_one",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [â† @num_den q]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {q : â„š}  (hq : q.den = 1) : (q.num : â„š) = q",
  "args":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  {q : â„š}  (hq : q.den = 1)"},
 {"type": "â†‘n = n /. 1",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : â†‘n = n /. 1 := by rw [â† Int.cast_ofNat]; sorry",
  "name": "coe_nat_eq_divInt",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_ofNat]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : â†‘n = n /. 1",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•)"},
 {"type": "(n : â„š).num = n",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : (n : â„š).num = n := by rw [â† Int.cast_ofNat]; sorry",
  "name": "coe_nat_num",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_ofNat]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : (n : â„š).num = n",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•)"},
 {"type": "(n : â„š).den = 1",
  "tactic-prompt":
  "theorem (a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : (n : â„š).den = 1 := by rw [â† Int.cast_ofNat]; sorry",
  "name": "coe_nat_den",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_ofNat]",
  "core-prompt":
  "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•) : (n : â„š).den = 1",
  "args": "(a b c : â„š)  -- Porting note: TODO this is a workaround.  (n : â„•)"},
 {"type": "DivisionRing â„š",
  "tactic-prompt": "instance  : DivisionRing â„š := by infer_instance; sorry",
  "name": "divisionRing",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": " : DivisionRing â„š",
  "args": ""},
 {"type": "(a /. b).Nonneg â†” 0 â‰¤ a",
  "tactic-prompt":
  "theorem (a b c : â„š) (a : â„¤)  {b : â„¤}  (h : 0 < b) : (a /. b).Nonneg â†” 0 â‰¤ a := by generalize ha : a /. b = x; sorry",
  "name": "divInt_nonneg",
  "kind": "theorem",
  "first-tactic": "generalize ha : a /. b = x",
  "core-prompt":
  "(a b c : â„š) (a : â„¤)  {b : â„¤}  (h : 0 < b) : (a /. b).Nonneg â†” 0 â‰¤ a",
  "args": "(a b c : â„š) (a : â„¤)  {b : â„¤}  (h : 0 < b)"},
 {"type": "Rat.Nonneg a âˆ¨ Rat.Nonneg (-a)",
  "tactic-prompt":
  "theorem (a b c : â„š) : Rat.Nonneg a âˆ¨ Rat.Nonneg (-a) := by cases' a with n; sorry",
  "name": "nonneg_total",
  "kind": "theorem",
  "first-tactic": "cases' a with n",
  "core-prompt": "(a b c : â„š) : Rat.Nonneg a âˆ¨ Rat.Nonneg (-a)",
  "args": "(a b c : â„š)"},
 {"type": "Decidable (Rat.Nonneg a)",
  "tactic-prompt":
  "instance (a b c : â„š) : Decidable (Rat.Nonneg a) := by cases a; sorry",
  "name": "decidableNonneg",
  "kind": "instance",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : â„š) : Decidable (Rat.Nonneg a)",
  "args": "(a b c : â„š)"},
 {"type": "a /. b â‰¤ c /. d â†” a * d â‰¤ c * b",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b c d : â„¤}  (b0 : 0 < b)  (d0 : 0 < d) : a /. b â‰¤ c /. d â†” a * d â‰¤ c * b := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "le_def",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt":
  "(a b c : â„š) {a b c d : â„¤}  (b0 : 0 < b)  (d0 : 0 < d) : a /. b â‰¤ c /. d â†” a * d â‰¤ c * b",
  "args": "(a b c : â„š) {a b c d : â„¤}  (b0 : 0 < b)  (d0 : 0 < d)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "theorem (a b c : â„š) : a â‰¤ a := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "le_refl",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt": "(a b c : â„š) : a â‰¤ a",
  "args": "(a b c : â„š)"},
 {"type": "a â‰¤ b âˆ¨ b â‰¤ a",
  "tactic-prompt":
  "theorem (a b c : â„š) : a â‰¤ b âˆ¨ b â‰¤ a := by have := Rat.nonneg_total (b - a); sorry",
  "name": "le_total",
  "kind": "theorem",
  "first-tactic": "have := Rat.nonneg_total (b - a)",
  "core-prompt": "(a b c : â„š) : a â‰¤ b âˆ¨ b â‰¤ a",
  "args": "(a b c : â„š)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b : â„š}  (hab : a â‰¤ b)  (hba : b â‰¤ a) : a = b := by rw [Rat.le_iff_Nonneg] at hab hba; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg] at hab hba",
  "core-prompt": "(a b c : â„š) {a b : â„š}  (hab : a â‰¤ b)  (hba : b â‰¤ a) : a = b",
  "args": "(a b c : â„š) {a b : â„š}  (hab : a â‰¤ b)  (hba : b â‰¤ a)"},
 {"type": "a â‰¤ c",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b c : â„š}  (hab : a â‰¤ b)  (hbc : b â‰¤ c) : a â‰¤ c := by rw [Rat.le_iff_Nonneg] at hab hbc; sorry",
  "name": "le_trans",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg] at hab hbc",
  "core-prompt":
  "(a b c : â„š) {a b c : â„š}  (hab : a â‰¤ b)  (hbc : b â‰¤ c) : a â‰¤ c",
  "args": "(a b c : â„š) {a b c : â„š}  (hab : a â‰¤ b)  (hbc : b â‰¤ c)"},
 {"type": "LT â„š",
  "tactic-prompt": "instance (a b c : â„š) : LT â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : LT â„š",
  "args": "(a b c : â„š)"},
 {"type": "DistribLattice â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : DistribLattice â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : DistribLattice â„š",
  "args": "(a b c : â„š)"},
 {"type": "Lattice â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : Lattice â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : Lattice â„š",
  "args": "(a b c : â„š)"},
 {"type": "SemilatticeInf â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : SemilatticeInf â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : SemilatticeInf â„š",
  "args": "(a b c : â„š)"},
 {"type": "SemilatticeSup â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : SemilatticeSup â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : SemilatticeSup â„š",
  "args": "(a b c : â„š)"},
 {"type": "HasInf â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : HasInf â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : HasInf â„š",
  "args": "(a b c : â„š)"},
 {"type": "HasSup â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : HasSup â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : HasSup â„š",
  "args": "(a b c : â„š)"},
 {"type": "PartialOrder â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : PartialOrder â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : PartialOrder â„š",
  "args": "(a b c : â„š)"},
 {"type": "Preorder â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : Preorder â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : Preorder â„š",
  "args": "(a b c : â„š)"},
 {"type": "p â‰¤ q â†” p.num * q.den â‰¤ q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : â„š) {p q : â„š} : p â‰¤ q â†” p.num * q.den â‰¤ q.num * p.den := by rw [â† @num_den q]; sorry",
  "name": "le_def'",
  "kind": "theorem",
  "first-tactic": "rw [â† @num_den q]",
  "core-prompt":
  "(a b c : â„š) {p q : â„š} : p â‰¤ q â†” p.num * q.den â‰¤ q.num * p.den",
  "args": "(a b c : â„š) {p q : â„š}"},
 {"type": "p < q â†” p.num * q.den < q.num * p.den",
  "tactic-prompt":
  "theorem (a b c : â„š) {p q : â„š} : p < q â†” p.num * q.den < q.num * p.den := by rw [lt_iff_le_and_ne]; sorry",
  "name": "lt_def",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_and_ne]",
  "core-prompt":
  "(a b c : â„š) {p q : â„š} : p < q â†” p.num * q.den < q.num * p.den",
  "args": "(a b c : â„š) {p q : â„š}"},
 {"type": "c + a â‰¤ c + b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b c : â„š} : c + a â‰¤ c + b â†” a â‰¤ b := by rw [Rat.le_iff_Nonneg]; sorry",
  "name": "add_le_add_left",
  "kind": "theorem",
  "first-tactic": "rw [Rat.le_iff_Nonneg]",
  "core-prompt": "(a b c : â„š) {a b c : â„š} : c + a â‰¤ c + b â†” a â‰¤ b",
  "args": "(a b c : â„š) {a b c : â„š}"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by rw [â† nonneg_iff_zero_le] at ha hbâŠ¢; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "rw [â† nonneg_iff_zero_le] at ha hbâŠ¢",
  "core-prompt":
  "(a b c : â„š) {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args": "(a b c : â„š) {a b : â„š}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "LinearOrderedCommRing â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : LinearOrderedCommRing â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : LinearOrderedCommRing â„š",
  "args": "(a b c : â„š)"},
 {"type": "LinearOrderedRing â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : LinearOrderedRing â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : LinearOrderedRing â„š",
  "args": "(a b c : â„š)"},
 {"type": "OrderedRing â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : OrderedRing â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : OrderedRing â„š",
  "args": "(a b c : â„š)"},
 {"type": "LinearOrderedSemiring â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : LinearOrderedSemiring â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : LinearOrderedSemiring â„š",
  "args": "(a b c : â„š)"},
 {"type": "OrderedSemiring â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : OrderedSemiring â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : OrderedSemiring â„š",
  "args": "(a b c : â„š)"},
 {"type": "LinearOrderedAddCommGroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : LinearOrderedAddCommGroup â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : LinearOrderedAddCommGroup â„š",
  "args": "(a b c : â„š)"},
 {"type": "OrderedAddCommGroup â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : OrderedAddCommGroup â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : OrderedAddCommGroup â„š",
  "args": "(a b c : â„š)"},
 {"type": "OrderedCancelAddCommMonoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : OrderedCancelAddCommMonoid â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : OrderedCancelAddCommMonoid â„š",
  "args": "(a b c : â„š)"},
 {"type": "OrderedAddCommMonoid â„š",
  "tactic-prompt":
  "instance (a b c : â„š) : OrderedAddCommMonoid â„š := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt": "(a b c : â„š) : OrderedAddCommMonoid â„š",
  "args": "(a b c : â„š)"},
 {"type": "(a : â„š) / b < c / d â†” a * d < c * b",
  "tactic-prompt":
  "theorem (a b c : â„š) {a b c d : â„¤}  (b_pos : 0 < b)  (d_pos : 0 < d) : (a : â„š) / b < c / d â†” a * d < c * b := by simp only [lt_iff_le_not_le]; sorry",
  "name": "div_lt_div_iff_mul_lt_mul",
  "kind": "theorem",
  "first-tactic": "simp only [lt_iff_le_not_le]",
  "core-prompt":
  "(a b c : â„š) {a b c d : â„¤}  (b_pos : 0 < b)  (d_pos : 0 < d) : (a : â„š) / b < c / d â†” a * d < c * b",
  "args": "(a b c : â„š) {a b c d : â„¤}  (b_pos : 0 < b)  (d_pos : 0 < d)"},
 {"type": "q < 1 â†” q.num < q.den",
  "tactic-prompt":
  "theorem (a b c : â„š) {q : â„š} : q < 1 â†” q.num < q.den := by simp [Rat.lt_def]; sorry",
  "name": "lt_one_iff_num_lt_denom",
  "kind": "theorem",
  "first-tactic": "simp [Rat.lt_def]",
  "core-prompt": "(a b c : â„š) {q : â„š} : q < 1 â†” q.num < q.den",
  "args": "(a b c : â„š) {q : â„š}"},
 {"type": "|q| = q.num.natAbs /. q.den",
  "tactic-prompt":
  "theorem (a b c : â„š) (q : â„š) : |q| = q.num.natAbs /. q.den := by cases' le_total q 0 with hq hq; sorry",
  "name": "abs_def",
  "kind": "theorem",
  "first-tactic": "cases' le_total q 0 with hq hq",
  "core-prompt": "(a b c : â„š) (q : â„š) : |q| = q.num.natAbs /. q.den",
  "args": "(a b c : â„š) (q : â„š)"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m)"},
 {"type": "âˆƒ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind Î±) : âˆƒ (m : UFModel self.arr.size), m.Models self.arr := by let âŸ¨n, m, hmâŸ© := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, m, hmâŸ© := self.model",
  "core-prompt":
  "(self : UnionFind Î±) : âˆƒ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind Î±)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind Î±)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind Î±)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind Î±)  (i : Nat)"},
 {"type":
  "(s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root",
  "tactic-prompt":
  "def (self : UnionFind Î±)  (x : Fin self.size) : (s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root := by let y := self.arr[x].parent; sorry",
  "name": "findAux",
  "kind": "def",
  "first-tactic": "let y := self.arr[x].parent",
  "core-prompt":
  "(self : UnionFind Î±)  (x : Fin self.size) : (s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root",
  "args": "(self : UnionFind Î±)  (x : Fin self.size)"},
 {"type": "UnionFind Î±",
  "tactic-prompt":
  "def (self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind Î± := by refine if ne : x.1 = y then self else\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      âŸ¨self.arr.set y {ny with parent := x}]; sorry",
  "name": "link",
  "kind": "def",
  "first-tactic":
  "refine if ne : x.1 = y then self else\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      âŸ¨self.arr.set y {ny with parent := x}]",
  "core-prompt":
  "(self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind Î±",
  "args":
  "(self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y)"},
 {"type": "x.getLeft = none â†” x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getLeft = none â†” x.isRight := by cases x; sorry",
  "name": "getLeft_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getLeft = none â†” x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "x.getRight = none â†” x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getRight = none â†” x.isLeft := by cases x; sorry",
  "name": "getRight_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getRight = none â†” x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "not x.isLeft = x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²) : not x.isLeft = x.isRight := by cases x; sorry",
  "name": "not_isLeft",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²) : not x.isLeft = x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²)"},
 {"type": "x.isLeft = false â†” x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isLeft = false â†” x.isRight := by cases x; sorry",
  "name": "isLeft_eq_false",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isLeft = false â†” x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "Â¬x.isLeft â†” x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : Â¬x.isLeft â†” x.isRight := by simp; sorry",
  "name": "Not_isLeft",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : Â¬x.isLeft â†” x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "!x.isRight = x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²) : !x.isRight = x.isLeft := by cases x; sorry",
  "name": "not_isRight",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²) : !x.isRight = x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} (x : Sum Î± Î²)"},
 {"type": "x.isRight = false â†” x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isRight = false â†” x.isLeft := by cases x; sorry",
  "name": "isRight_eq_false",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isRight = false â†” x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "Â¬x.isRight â†” x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : Â¬x.isRight â†” x.isLeft := by simp; sorry",
  "name": "Not_isRight",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : Â¬x.isRight â†” x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "x.isLeft â†” âˆƒ y, x = Sum.inl y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isLeft â†” âˆƒ y, x = Sum.inl y := by cases x; sorry",
  "name": "isLeft_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isLeft â†” âˆƒ y, x = Sum.inl y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "x.isRight â†” âˆƒ y, x = Sum.inr y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isRight â†” âˆƒ y, x = Sum.inr y := by cases x; sorry",
  "name": "isRight_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.isRight â†” âˆƒ y, x = Sum.inr y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ} : Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚) := by ext (_ | _); sorry",
  "name": "elim_comp_map",
  "kind": "theorem",
  "first-tactic": "ext (_ | _)",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ} : Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚)",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ}"},
 {"type": "isLeft (x.map f g) = isLeft x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : isLeft (x.map f g) = isLeft x := by cases x; sorry",
  "name": "isLeft_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : isLeft (x.map f g) = isLeft x",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³)"},
 {"type": "isRight (x.map f g) = isRight x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : isRight (x.map f g) = isRight x := by cases x; sorry",
  "name": "isRight_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : isRight (x.map f g) = isRight x",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³)"},
 {"type": "(x.map f g).getLeft = x.getLeft.map f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : (x.map f g).getLeft = x.getLeft.map f := by cases x; sorry",
  "name": "getLeft_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³) : (x.map f g).getLeft = x.getLeft.map f",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Sum Î± Î³)"},
 {"type": "(x.map f g).getRight = x.getRight.map g",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Î± âŠ• Î³) : (x.map f g).getRight = x.getRight.map g := by cases x; sorry",
  "name": "getRight_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Î± âŠ• Î³) : (x.map f g).getRight = x.getRight.map g",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (f : Î± â†’ Î²)  (g : Î³ â†’ Î´)  (x : Î± âŠ• Î³)"},
 {"type": "update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³} : update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j := by rw [â† update_inl_comp_inl]; sorry",
  "name": "update_inl_apply_inl",
  "kind": "theorem",
  "first-tactic": "rw [â† update_inl_comp_inl]",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³} : update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³}"},
 {"type": "update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³} : update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j := by rw [â† update_inr_comp_inr]; sorry",
  "name": "update_inr_apply_inr",
  "kind": "theorem",
  "first-tactic": "rw [â† update_inr_comp_inr]",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³} : update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³}"},
 {"type": "swap (swap x) = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : swap (swap x) = x := by cases x; sorry",
  "name": "swap_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : swap (swap x) = x",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "x.swap.isLeft = x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.isLeft = x.isRight := by cases x; sorry",
  "name": "isLeft_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.isLeft = x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "x.swap.isRight = x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.isRight = x.isLeft := by cases x; sorry",
  "name": "isRight_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.isRight = x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "x.swap.getLeft = x.getRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.getLeft = x.getRight := by cases x; sorry",
  "name": "getLeft_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.getLeft = x.getRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "x.swap.getRight = x.getLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.getRight = x.getLeft := by cases x; sorry",
  "name": "getRight_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : x.swap.getRight = x.getLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "LiftRel râ‚‚ sâ‚‚ x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y) : LiftRel râ‚‚ sâ‚‚ x y := by cases h; sorry",
  "name": "LiftRel.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y) : LiftRel râ‚‚ sâ‚‚ x y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y)"},
 {"type": "LiftRel s r x.swap y.swap",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap := by cases h; sorry",
  "name": "LiftRel.swap",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y)"},
 {"type": "Lex r s a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b) : Lex r s a b := by cases h; sorry",
  "name": "LiftRel.lex",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b) : Lex r s a b",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b)"},
 {"type": "Lex râ‚‚ sâ‚‚ x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y) : Lex râ‚‚ sâ‚‚ x y := by cases h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y) : Lex râ‚‚ sâ‚‚ x y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y)"},
 {"type": "Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³) : Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c := by ext x; sorry",
  "name": "elim_const_const",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³) : Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³)"},
 {"type":
  "Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c := by ext x; sorry",
  "name": "elim_update_left",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³)"},
 {"type":
  "Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c := by ext x; sorry",
  "name": "elim_update_right",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³)"},
 {"type": "BijOn (Â· + d) (Ici a) (Ici (a + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ici a) (Ici (a + d)) := by refine'\n    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => _âŸ©; sorry",
  "name": "Ici_add_bij",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => _âŸ©",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ici a) (Ici (a + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (Â· + d) (Ioi a) (Ioi (a + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioi a) (Ioi (a + d)) := by refine'\n    âŸ¨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>\n      _âŸ©; sorry",
  "name": "Ioi_add_bij",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun x h => add_lt_add_right (mem_Ioi.mp h) _, fun _ _ _ _ h => add_right_cancel h, fun _ h =>\n      _âŸ©",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioi a) (Ioi (a + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (Â· + d) (Icc a b) (Icc (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Icc a b) (Icc (a + d) (b + d)) := by rw [â† Ici_inter_Iic]; sorry",
  "name": "Icc_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [â† Ici_inter_Iic]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Icc a b) (Icc (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (Â· + d) (Ioo a b) (Ioo (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioo a b) (Ioo (a + d) (b + d)) := by rw [â† Ioi_inter_Iio]; sorry",
  "name": "Ioo_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioi_inter_Iio]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioo a b) (Ioo (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (Â· + d) (Ioc a b) (Ioc (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioc a b) (Ioc (a + d) (b + d)) := by rw [â† Ioi_inter_Iic]; sorry",
  "name": "Ioc_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioi_inter_Iic]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ioc a b) (Ioc (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "BijOn (Â· + d) (Ico a b) (Ico (a + d) (b + d))",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ico a b) (Ico (a + d) (b + d)) := by rw [â† Ici_inter_Iio]; sorry",
  "name": "Ico_add_bij",
  "kind": "theorem",
  "first-tactic": "rw [â† Ici_inter_Iio]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : BijOn (Â· + d) (Ico a b) (Ico (a + d) (b + d))",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ici b = Ici (a + b)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ici b = Ici (a + b) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ici",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ici b = Ici (a + b)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioi b = Ioi (a + b)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioi b = Ioi (a + b) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioi",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioi b = Ioi (a + b)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Icc b c = Icc (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Icc",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ico b c = Ico (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ico",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioc",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "(fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c)",
  "tactic-prompt":
  "theorem {M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) := by simp only [add_comm a]; sorry",
  "name": "image_const_add_Ioo",
  "kind": "theorem",
  "first-tactic": "simp only [add_comm a]",
  "core-prompt":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M) : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c)",
  "args":
  "{M : Type _}  [OrderedCancelAddCommMonoid M]  [ExistsAddOfLE M]  (a b c d : M)"},
 {"type": "SurjOn f (Ioo a b) (Ioo (f a) (f b))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ioo a b) (Ioo (f a) (f b)) := by intro p hp; sorry",
  "name": "surjOn_Ioo_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "intro p hp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ioo a b) (Ioo (f a) (f b))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±)"},
 {"type": "SurjOn f (Ico a b) (Ico (f a) (f b))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ico a b) (Ico (f a) (f b)) := by obtain hab | hab := lt_or_le a b; sorry",
  "name": "surjOn_Ico_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "obtain hab | hab := lt_or_le a b",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ico a b) (Ico (f a) (f b))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±)"},
 {"type": "SurjOn f (Ioc a b) (Ioc (f a) (f b))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ioc a b) (Ioc (f a) (f b)) := by simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a); sorry",
  "name": "surjOn_Ioc_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic":
  "simpa using surjOn_Ico_of_monotone_surjective h_mono.dual h_surj (toDual b) (toDual a)",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±) : SurjOn f (Ioc a b) (Ioc (f a) (f b))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a b : Î±)"},
 {"type": "SurjOn f (Icc a b) (Icc (f a) (f b))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : Î±}  (hab : a â‰¤ b) : SurjOn f (Icc a b) (Icc (f a) (f b)) := by intro p hp; sorry",
  "name": "surjOn_Icc_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "intro p hp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : Î±}  (hab : a â‰¤ b) : SurjOn f (Icc a b) (Icc (f a) (f b))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      {a b : Î±}  (hab : a â‰¤ b)"},
 {"type": "SurjOn f (Ioi a) (Ioi (f a))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±) : SurjOn f (Ioi a) (Ioi (f a)) := by rw [â† compl_Iic]; sorry",
  "name": "surjOn_Ioi_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "rw [â† compl_Iic]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±) : SurjOn f (Ioi a) (Ioi (f a))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±)"},
 {"type": "SurjOn f (Ici a) (Ici (f a))",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±) : SurjOn f (Ici a) (Ici (f a)) := by rw [â† Ioi_union_left]; sorry",
  "name": "surjOn_Ici_of_monotone_surjective",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioi_union_left]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±) : SurjOn f (Ici a) (Ici (f a))",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î±]  [PartialOrder Î²]  {f : Î± â†’ Î²} (h_mono : Monotone f)  (h_surj : Function.Surjective f)      (a : Î±)"},
 {"type": "Decidable (x âˆˆ Ioo a b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x < b)] : Decidable (x âˆˆ Ioo a b) := by assumption; sorry",
  "name": "decidableMemIoo",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x < b)] : Decidable (x âˆˆ Ioo a b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x < b)]"},
 {"type": "Decidable (x âˆˆ Ico a b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x < b)] : Decidable (x âˆˆ Ico a b) := by assumption; sorry",
  "name": "decidableMemIco",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x < b)] : Decidable (x âˆˆ Ico a b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x < b)]"},
 {"type": "Decidable (x âˆˆ Iio b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x < b)] : Decidable (x âˆˆ Iio b) := by assumption; sorry",
  "name": "decidableMemIio",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x < b)] : Decidable (x âˆˆ Iio b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x < b)]"},
 {"type": "Decidable (x âˆˆ Icc a b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x â‰¤ b)] : Decidable (x âˆˆ Icc a b) := by assumption; sorry",
  "name": "decidableMemIcc",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x â‰¤ b)] : Decidable (x âˆˆ Icc a b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x âˆ§ x â‰¤ b)]"},
 {"type": "Decidable (x âˆˆ Iic b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x â‰¤ b)] : Decidable (x âˆˆ Iic b) := by assumption; sorry",
  "name": "decidableMemIic",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x â‰¤ b)] : Decidable (x âˆˆ Iic b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (x â‰¤ b)]"},
 {"type": "Decidable (x âˆˆ Ioc a b)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x â‰¤ b)] : Decidable (x âˆˆ Ioc a b) := by assumption; sorry",
  "name": "decidableMemIoc",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x â‰¤ b)] : Decidable (x âˆˆ Ioc a b)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x âˆ§ x â‰¤ b)]"},
 {"type": "Decidable (x âˆˆ Ici a)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x)] : Decidable (x âˆˆ Ici a) := by assumption; sorry",
  "name": "decidableMemIci",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x)] : Decidable (x âˆˆ Ici a)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a â‰¤ x)]"},
 {"type": "Decidable (x âˆˆ Ioi a)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x)] : Decidable (x âˆˆ Ioi a) := by assumption; sorry",
  "name": "decidableMemIoi",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x)] : Decidable (x âˆˆ Ioi a)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [Decidable (a < x)]"},
 {"type": "a âˆˆ Ioo a b â†” False",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ioo a b â†” False := by simp [lt_irrefl]; sorry",
  "name": "left_mem_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ioo a b â†” False",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Ico a b â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ico a b â†” a < b := by simp [le_refl]; sorry",
  "name": "left_mem_Ico",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ico a b â†” a < b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Icc a b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Icc a b â†” a â‰¤ b := by simp [le_refl]; sorry",
  "name": "left_mem_Icc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Icc a b â†” a â‰¤ b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Ioc a b â†” False",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ioc a b â†” False := by simp [lt_irrefl]; sorry",
  "name": "left_mem_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ioc a b â†” False",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Ici a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ici a := by simp; sorry",
  "name": "left_mem_Ici",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Ici a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Ioo a b â†” False",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ioo a b â†” False := by simp [lt_irrefl]; sorry",
  "name": "right_mem_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ioo a b â†” False",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Ico a b â†” False",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ico a b â†” False := by simp [lt_irrefl]; sorry",
  "name": "right_mem_Ico",
  "kind": "theorem",
  "first-tactic": "simp [lt_irrefl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ico a b â†” False",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Icc a b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Icc a b â†” a â‰¤ b := by simp [le_refl]; sorry",
  "name": "right_mem_Icc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Icc a b â†” a â‰¤ b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Ioc a b â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ioc a b â†” a < b := by simp [le_refl]; sorry",
  "name": "right_mem_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [le_refl]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Ioc a b â†” a < b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Iic a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Iic a := by simp; sorry",
  "name": "right_mem_Iic",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Iic a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Icc a b = âˆ… â†” Â¬a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Icc a b = âˆ… â†” Â¬a â‰¤ b := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "Icc_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Icc a b = âˆ… â†” Â¬a â‰¤ b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Ico a b = âˆ… â†” Â¬a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Ico a b = âˆ… â†” Â¬a < b := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "Ico_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Ico a b = âˆ… â†” Â¬a < b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Ioc a b = âˆ… â†” Â¬a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Ioc a b = âˆ… â†” Â¬a < b := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "Ioc_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Ioc a b = âˆ… â†” Â¬a < b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Ioo a b = âˆ… â†” Â¬a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [DenselyOrdered Î±] : Ioo a b = âˆ… â†” Â¬a < b := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "Ioo_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [DenselyOrdered Î±] : Ioo a b = âˆ… â†” Â¬a < b",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} [DenselyOrdered Î±]"},
 {"type": "Icc a b = {c} â†” a = c âˆ§ b = c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Icc a b = {c} â†” a = c âˆ§ b = c := by refine' âŸ¨fun h => _, _âŸ©; sorry",
  "name": "Icc_eq_singleton_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, _âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Icc a b = {c} â†” a = c âˆ§ b = c",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±}"},
 {"type": "Icc a b \\ {a, b} = Ioo a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Icc a b \\ {a, b} = Ioo a b := by rw [insert_eq]; sorry",
  "name": "Icc_diff_both",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Icc a b \\ {a, b} = Ioo a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±}"},
 {"type": "Ico a b \\ Ioo a b = {a}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : Ico a b \\ Ioo a b = {a} := by rw [â† Ico_diff_left]; sorry",
  "name": "Ico_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Ico_diff_left]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : Ico a b \\ Ioo a b = {a}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b)"},
 {"type": "Ioc a b \\ Ioo a b = {b}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : Ioc a b \\ Ioo a b = {b} := by rw [â† Ioc_diff_right]; sorry",
  "name": "Ioc_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioc_diff_right]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : Ioc a b \\ Ioo a b = {b}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b)"},
 {"type": "Icc a b \\ Ico a b = {b}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ico a b = {b} := by rw [â† Icc_diff_right]; sorry",
  "name": "Icc_diff_Ico_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Icc_diff_right]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ico a b = {b}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b)"},
 {"type": "Icc a b \\ Ioc a b = {a}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ioc a b = {a} := by rw [â† Icc_diff_left]; sorry",
  "name": "Icc_diff_Ioc_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Icc_diff_left]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ioc a b = {a}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b)"},
 {"type": "Icc a b \\ Ioo a b = {a, b}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ioo a b = {a, b} := by rw [â† Icc_diff_both]; sorry",
  "name": "Icc_diff_Ioo_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Icc_diff_both]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : Icc a b \\ Ioo a b = {a, b}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b)"},
 {"type": "Ici a \\ Ioi a = {a}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Ici a \\ Ioi a = {a} := by rw [â† Ici_diff_left]; sorry",
  "name": "Ici_diff_Ioi_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Ici_diff_left]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Ici a \\ Ioi a = {a}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±}"},
 {"type": "Iic a \\ Iio a = {a}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Iic a \\ Iio a = {a} := by rw [â† Iic_diff_right]; sorry",
  "name": "Iic_diff_Iio_same",
  "kind": "theorem",
  "first-tactic": "rw [â† Iic_diff_right]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} : Iic a \\ Iio a = {a}",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±}"},
 {"type": "Ioo a b âˆª {a} = Ico a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b) : Ioo a b âˆª {a} = Ico a b := by rw [â† Ico_diff_left]; sorry",
  "name": "Ioo_union_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Ico_diff_left]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b) : Ioo a b âˆª {a} = Ico a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b)"},
 {"type": "Ioo a b âˆª {b} = Ioc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b) : Ioo a b âˆª {b} = Ioc a b := by simpa only [dual_Ioo]; sorry",
  "name": "Ioo_union_right",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioo]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b) : Ioo a b âˆª {b} = Ioc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a < b)"},
 {"type": "Ioc a b âˆª {a} = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b) : Ioc a b âˆª {a} = Icc a b := by rw [â† Icc_diff_left]; sorry",
  "name": "Ioc_union_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Icc_diff_left]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b) : Ioc a b âˆª {a} = Icc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b)"},
 {"type": "Ico a b âˆª {b} = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b) : Ico a b âˆª {b} = Icc a b := by simpa only [dual_Ioc]; sorry",
  "name": "Ico_union_right",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioc]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b) : Ico a b âˆª {b} = Icc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (hab : a â‰¤ b)"},
 {"type": "insert b (Ico a b) = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : insert b (Ico a b) = Icc a b := by rw [insert_eq]; sorry",
  "name": "Ico_insert_right",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : insert b (Ico a b) = Icc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b)"},
 {"type": "insert a (Ioc a b) = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : insert a (Ioc a b) = Icc a b := by rw [insert_eq]; sorry",
  "name": "Ioc_insert_left",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b) : insert a (Ioc a b) = Icc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a â‰¤ b)"},
 {"type": "insert a (Ioo a b) = Ico a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : insert a (Ioo a b) = Ico a b := by rw [insert_eq]; sorry",
  "name": "Ioo_insert_left",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : insert a (Ioo a b) = Ico a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b)"},
 {"type": "insert b (Ioo a b) = Ioc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : insert b (Ioo a b) = Ioc a b := by rw [insert_eq]; sorry",
  "name": "Ioo_insert_right",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b) : insert b (Ioo a b) = Ioc a b",
  "args": "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} (h : a < b)"},
 {"type": "s âˆˆ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set Î±))",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} {s : Set Î±}  (ho : Ioo a b âŠ† s)  (hc : s âŠ† Icc a b) : s âˆˆ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set Î±)) := by classical\n    by_cases ha : a âˆˆ s; sorry",
  "name": "mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset",
  "kind": "theorem",
  "first-tactic": "classical\n    by_cases ha : a âˆˆ s",
  "core-prompt":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} {s : Set Î±}  (ho : Ioo a b âŠ† s)  (hc : s âŠ† Icc a b) : s âˆˆ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set Î±))",
  "args":
  "{Î± Î² : Type _}  [PartialOrder Î±]  {a b c : Î±} {s : Set Î±}  (ho : Ioo a b âŠ† s)  (hc : s âŠ† Icc a b)"},
 {"type": "Icc a âŠ¤ = Ici a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±} : Icc a âŠ¤ = Ici a := by simp [â† Ici_inter_Iic]; sorry",
  "name": "Icc_top",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iic]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±} : Icc a âŠ¤ = Ici a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±}"},
 {"type": "Ioc a âŠ¤ = Ioi a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±} : Ioc a âŠ¤ = Ioi a := by simp [â† Ioi_inter_Iic]; sorry",
  "name": "Ioc_top",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iic]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±} : Ioc a âŠ¤ = Ioi a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [OrderTop Î±]  {a : Î±}"},
 {"type": "Icc âŠ¥ a = Iic a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±} : Icc âŠ¥ a = Iic a := by simp [â† Ici_inter_Iic]; sorry",
  "name": "Icc_bot",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iic]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±} : Icc âŠ¥ a = Iic a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±}"},
 {"type": "Ico âŠ¥ a = Iio a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±} : Ico âŠ¥ a = Iio a := by simp [â† Ici_inter_Iio]; sorry",
  "name": "Ico_bot",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iio]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±} : Ico âŠ¥ a = Iio a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [OrderBot Î±]  {a : Î±}"},
 {"type": "Icc (âŠ¥ : Î±) âŠ¤ = univ",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [PartialOrder Î±]  [BoundedOrder Î±] : Icc (âŠ¥ : Î±) âŠ¤ = univ := by simp; sorry",
  "name": "Icc_bot_top",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² : Type _} [PartialOrder Î±]  [BoundedOrder Î±] : Icc (âŠ¥ : Î±) âŠ¤ = univ",
  "args": "{Î± Î² : Type _} [PartialOrder Î±]  [BoundedOrder Î±]"},
 {"type": "Ici a \\ Ici b = Ico a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ici a \\ Ici b = Ico a b := by rw [diff_eq]; sorry",
  "name": "Ici_diff_Ici",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ici a \\ Ici b = Ico a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ici a \\ Ioi b = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ici a \\ Ioi b = Icc a b := by rw [diff_eq]; sorry",
  "name": "Ici_diff_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ici a \\ Ioi b = Icc a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioi a \\ Ioi b = Ioc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi a \\ Ioi b = Ioc a b := by rw [diff_eq]; sorry",
  "name": "Ioi_diff_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi a \\ Ioi b = Ioc a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioi a \\ Ici b = Ioo a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi a \\ Ici b = Ioo a b := by rw [diff_eq]; sorry",
  "name": "Ioi_diff_Ici",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi a \\ Ici b = Ioo a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Iic b \\ Iic a = Ioc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iic b \\ Iic a = Ioc a b := by rw [diff_eq]; sorry",
  "name": "Iic_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iic b \\ Iic a = Ioc a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Iio b \\ Iic a = Ioo a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio b \\ Iic a = Ioo a b := by rw [diff_eq]; sorry",
  "name": "Iio_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio b \\ Iic a = Ioo a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Iic b \\ Iio a = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iic b \\ Iio a = Icc a b := by rw [diff_eq]; sorry",
  "name": "Iic_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iic b \\ Iio a = Icc a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Iio b \\ Iio a = Ico a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio b \\ Iio a = Ico a b := by rw [diff_eq]; sorry",
  "name": "Iio_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio b \\ Iio a = Ico a b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc aâ‚ bâ‚ âŠ† Ioc aâ‚‚ bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚ âˆ§ aâ‚‚ â‰¤ aâ‚",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : aâ‚ < bâ‚) : Ioc aâ‚ bâ‚ âŠ† Ioc aâ‚‚ bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚ âˆ§ aâ‚‚ â‰¤ aâ‚ := by convert @Ico_subset_Ico_iff Î±áµ’áµˆ _ bâ‚ bâ‚‚ aâ‚ aâ‚‚ hâ‚; sorry",
  "name": "Ioc_subset_Ioc_iff",
  "kind": "theorem",
  "first-tactic": "convert @Ico_subset_Ico_iff Î±áµ’áµˆ _ bâ‚ bâ‚‚ aâ‚ aâ‚‚ hâ‚",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : aâ‚ < bâ‚) : Ioc aâ‚ bâ‚ âŠ† Ioc aâ‚‚ bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚ âˆ§ aâ‚‚ â‰¤ aâ‚",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : aâ‚ < bâ‚)"},
 {"type": "Ioi b âŠ† Ioi a â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi b âŠ† Ioi a â†” a â‰¤ b := by refine' âŸ¨fun h => _, fun h => Ioi_subset_Ioi hâŸ©; sorry",
  "name": "Ioi_subset_Ioi_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => Ioi_subset_Ioi hâŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioi b âŠ† Ioi a â†” a â‰¤ b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioi b âŠ† Ici a â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±] : Ioi b âŠ† Ici a â†” a â‰¤ b := by refine' âŸ¨fun h => _, fun h => Ioi_subset_Ici hâŸ©; sorry",
  "name": "Ioi_subset_Ici_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => Ioi_subset_Ici hâŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±] : Ioi b âŠ† Ici a â†” a â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±]"},
 {"type": "Iio a âŠ† Iio b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio a âŠ† Iio b â†” a â‰¤ b := by refine' âŸ¨fun h => _, fun h => Iio_subset_Iio hâŸ©; sorry",
  "name": "Iio_subset_Iio_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, fun h => Iio_subset_Iio hâŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Iio a âŠ† Iio b â†” a â‰¤ b",
  "args": "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Iio a âŠ† Iic b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±] : Iio a âŠ† Iic b â†” a â‰¤ b := by rw [â† diff_eq_empty]; sorry",
  "name": "Iio_subset_Iic_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† diff_eq_empty]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±] : Iio a âŠ† Iic b â†” a â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} [DenselyOrdered Î±]"},
 {"type": "Ioo a b âˆª Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Ioo a b âˆª Ioi c = Ioi (min a c) := by ext1 x; sorry",
  "name": "Ioo_union_Ioi'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Ioo a b âˆª Ioi c = Ioi (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)"},
 {"type": "Ioo a b âˆª Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c < max a b) : Ioo a b âˆª Ioi c = Ioi (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioo_union_Ioi",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c < max a b) : Ioo a b âˆª Ioi c = Ioi (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c < max a b)"},
 {"type": "Ico a b âˆª Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Ico a b âˆª Ici c = Ici (min a c) := by ext1 x; sorry",
  "name": "Ico_union_Ici'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Ico a b âˆª Ici c = Ici (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)"},
 {"type": "Ico a b âˆª Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Ico a b âˆª Ici c = Ici (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ico_union_Ici",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Ico a b âˆª Ici c = Ici (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b)"},
 {"type": "Ioc a b âˆª Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Ioc a b âˆª Ioi c = Ioi (min a c) := by ext1 x; sorry",
  "name": "Ioc_union_Ioi'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Ioc a b âˆª Ioi c = Ioi (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)"},
 {"type": "Ioc a b âˆª Ioi c = Ioi (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Ioc a b âˆª Ioi c = Ioi (min a c) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioc_union_Ioi",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Ioc a b âˆª Ioi c = Ioi (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b)"},
 {"type": "Icc a b âˆª Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Icc a b âˆª Ici c = Ici (min a c) := by ext1 x; sorry",
  "name": "Icc_union_Ici'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Icc a b âˆª Ici c = Ici (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)"},
 {"type": "Icc a b âˆª Ici c = Ici (min a c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Icc a b âˆª Ici c = Ici (min a c) := by cases' le_or_lt a b with hab hab; sorry",
  "name": "Icc_union_Ici",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b) : Icc a b âˆª Ici c = Ici (min a c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : c â‰¤ max a b)"},
 {"type": "Iio b âˆª Ico c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Iio b âˆª Ico c d = Iio (max b d) := by ext1 x; sorry",
  "name": "Iio_union_Ico'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Iio b âˆª Ico c d = Iio (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)"},
 {"type": "Iio b âˆª Ico c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b) : Iio b âˆª Ico c d = Iio (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iio_union_Ico",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b) : Iio b âˆª Ico c d = Iio (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b)"},
 {"type": "Iic b âˆª Ioc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Iic b âˆª Ioc c d = Iic (max b d) := by ext1 x; sorry",
  "name": "Iic_union_Ioc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Iic b âˆª Ioc c d = Iic (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)"},
 {"type": "Iic b âˆª Ioc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b) : Iic b âˆª Ioc c d = Iic (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iic_union_Ioc",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b) : Iic b âˆª Ioc c d = Iic (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b)"},
 {"type": "Iio b âˆª Ioo c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Iio b âˆª Ioo c d = Iio (max b d) := by ext x; sorry",
  "name": "Iio_union_Ioo'",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b) : Iio b âˆª Ioo c d = Iio (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)"},
 {"type": "Iio b âˆª Ioo c d = Iio (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b) : Iio b âˆª Ioo c d = Iio (max b d) := by cases' le_total c d with hcd hcd; sorry",
  "name": "Iio_union_Ioo",
  "kind": "theorem",
  "first-tactic": "cases' le_total c d with hcd hcd",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b) : Iio b âˆª Ioo c d = Iio (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d < b)"},
 {"type": "Iic b âˆª Icc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Iic b âˆª Icc c d = Iic (max b d) := by ext1 x; sorry",
  "name": "Iic_union_Icc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b) : Iic b âˆª Icc c d = Iic (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)"},
 {"type": "Iic b âˆª Icc c d = Iic (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b) : Iic b âˆª Icc c d = Iic (max b d) := by cases' le_or_lt c d with hcd hcd; sorry",
  "name": "Iic_union_Icc",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt c d with hcd hcd",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b) : Iic b âˆª Icc c d = Iic (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : min c d â‰¤ b)"},
 {"type": "Ico a b âˆª Ico c d = Ico (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Ico a b âˆª Ico c d = Ico (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ico_union_Ico'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Ico a b âˆª Ico c d = Ico (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d)"},
 {"type": "Ico a b âˆª Ico c d = Ico (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b) : Ico a b âˆª Ico c d = Ico (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ico_union_Ico",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b) : Ico a b âˆª Ico c d = Ico (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b)"},
 {"type": "Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ioc_union_Ioc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d)"},
 {"type": "Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b) : Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioc_union_Ioc",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b) : Ioc a b âˆª Ioc c d = Ioc (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b â‰¤ max c d)  (hâ‚‚ : min c d â‰¤ max a b)"},
 {"type": "Icc a b âˆª Icc c d = Icc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Icc a b âˆª Icc c d = Icc (min a c) (max b d) := by ext1 x; sorry",
  "name": "Icc_union_Icc'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d) : Icc a b âˆª Icc c d = Icc (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c â‰¤ b)  (hâ‚‚ : a â‰¤ d)"},
 {"type": "Icc a b âˆª Icc c d = Icc (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b) : Icc a b âˆª Icc c d = Icc (min a c) (max b d) := by cases' le_or_lt a b with hab hab; sorry",
  "name": "Icc_union_Icc",
  "kind": "theorem",
  "first-tactic": "cases' le_or_lt a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b) : Icc a b âˆª Icc c d = Icc (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b)"},
 {"type": "Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)  (hâ‚‚ : a < d) : Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d) := by ext1 x; sorry",
  "name": "Ioo_union_Ioo'",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)  (hâ‚‚ : a < d) : Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : c < b)  (hâ‚‚ : a < d)"},
 {"type": "Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b) : Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d) := by cases' le_total a b with hab hab; sorry",
  "name": "Ioo_union_Ioo",
  "kind": "theorem",
  "first-tactic": "cases' le_total a b with hab hab",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b) : Ioo a b âˆª Ioo c d = Ioo (min a c) (max b d)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (hâ‚ : min a b < max c d)  (hâ‚‚ : min c d < max a b)"},
 {"type": "Iic a âˆ© Iic b = Iic (a âŠ“ b)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [SemilatticeInf Î±] {a b : Î±} : Iic a âˆ© Iic b = Iic (a âŠ“ b) := by ext x; sorry",
  "name": "Iic_inter_Iic",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² : Type _}   [SemilatticeInf Î±] {a b : Î±} : Iic a âˆ© Iic b = Iic (a âŠ“ b)",
  "args": "{Î± Î² : Type _}   [SemilatticeInf Î±] {a b : Î±}"},
 {"type": "Ioc a b âˆ© Iic c = Ioc a (b âŠ“ c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [SemilatticeInf Î±] (a b c : Î±) : Ioc a b âˆ© Iic c = Ioc a (b âŠ“ c) := by rw [â† Ioi_inter_Iic]; sorry",
  "name": "Ioc_inter_Iic",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioi_inter_Iic]",
  "core-prompt":
  "{Î± Î² : Type _}   [SemilatticeInf Î±] (a b c : Î±) : Ioc a b âˆ© Iic c = Ioc a (b âŠ“ c)",
  "args": "{Î± Î² : Type _}   [SemilatticeInf Î±] (a b c : Î±)"},
 {"type": "Ici a âˆ© Ici b = Ici (a âŠ” b)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [SemilatticeSup Î±] {a b : Î±} : Ici a âˆ© Ici b = Ici (a âŠ” b) := by ext x; sorry",
  "name": "Ici_inter_Ici",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² : Type _}   [SemilatticeSup Î±] {a b : Î±} : Ici a âˆ© Ici b = Ici (a âŠ” b)",
  "args": "{Î± Î² : Type _}   [SemilatticeSup Î±] {a b : Î±}"},
 {"type": "Ico a b âˆ© Ici c = Ico (a âŠ” c) b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [SemilatticeSup Î±] (a b c : Î±) : Ico a b âˆ© Ici c = Ico (a âŠ” c) b := by rw [â† Ici_inter_Iio]; sorry",
  "name": "Ico_inter_Ici",
  "kind": "theorem",
  "first-tactic": "rw [â† Ici_inter_Iio]",
  "core-prompt":
  "{Î± Î² : Type _}   [SemilatticeSup Î±] (a b c : Î±) : Ico a b âˆ© Ici c = Ico (a âŠ” c) b",
  "args": "{Î± Î² : Type _}   [SemilatticeSup Î±] (a b c : Î±)"},
 {"type": "Icc aâ‚ bâ‚ âˆ© Icc aâ‚‚ bâ‚‚ = Icc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±} : Icc aâ‚ bâ‚ âˆ© Icc aâ‚‚ bâ‚‚ = Icc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚) := by simp only [Ici_inter_Iic.symm]; sorry",
  "name": "Icc_inter_Icc",
  "kind": "theorem",
  "first-tactic": "simp only [Ici_inter_Iic.symm]",
  "core-prompt":
  "{Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±} : Icc aâ‚ bâ‚ âˆ© Icc aâ‚‚ bâ‚‚ = Icc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "args": "{Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±}"},
 {"type": "Icc a b âˆ© Icc b c = {b}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c) : Icc a b âˆ© Icc b c = {b} := by rw [Icc_inter_Icc]; sorry",
  "name": "Icc_inter_Icc_eq_singleton",
  "kind": "theorem",
  "first-tactic": "rw [Icc_inter_Icc]",
  "core-prompt":
  "{Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c) : Icc a b âˆ© Icc b c = {b}",
  "args":
  "{Î± Î² : Type _}   [Lattice Î±]  {a b c aâ‚ aâ‚‚ bâ‚ bâ‚‚ : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c)"},
 {"type": "Ico aâ‚ bâ‚ âˆ© Ico aâ‚‚ bâ‚‚ = Ico (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ico aâ‚ bâ‚ âˆ© Ico aâ‚‚ bâ‚‚ = Ico (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚) := by simp only [Ici_inter_Iio.symm]; sorry",
  "name": "Ico_inter_Ico",
  "kind": "theorem",
  "first-tactic": "simp only [Ici_inter_Iio.symm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ico aâ‚ bâ‚ âˆ© Ico aâ‚‚ bâ‚‚ = Ico (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚) := by simp only [Ioi_inter_Iic.symm]; sorry",
  "name": "Ioc_inter_Ioc",
  "kind": "theorem",
  "first-tactic": "simp only [Ioi_inter_Iic.symm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioo aâ‚ bâ‚ âˆ© Ioo aâ‚‚ bâ‚‚ = Ioo (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioo aâ‚ bâ‚ âˆ© Ioo aâ‚‚ bâ‚‚ = Ioo (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚) := by simp only [Ioi_inter_Iio.symm]; sorry",
  "name": "Ioo_inter_Ioo",
  "kind": "theorem",
  "first-tactic": "simp only [Ioi_inter_Iio.symm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioo aâ‚ bâ‚ âˆ© Ioo aâ‚‚ bâ‚‚ = Ioo (aâ‚ âŠ” aâ‚‚) (bâ‚ âŠ“ bâ‚‚)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioo (max aâ‚ aâ‚‚) bâ‚",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚ â‰¤ bâ‚‚) : Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioo (max aâ‚ aâ‚‚) bâ‚ := by rw [inter_comm]; sorry",
  "name": "Ioo_inter_Ioc_of_left_le",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚ â‰¤ bâ‚‚) : Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioo (max aâ‚ aâ‚‚) bâ‚",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚ â‰¤ bâ‚‚)"},
 {"type": "Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (max aâ‚ aâ‚‚) bâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚‚ < bâ‚) : Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (max aâ‚ aâ‚‚) bâ‚‚ := by rw [inter_comm]; sorry",
  "name": "Ioo_inter_Ioc_of_right_lt",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚‚ < bâ‚) : Ioo aâ‚ bâ‚ âˆ© Ioc aâ‚‚ bâ‚‚ = Ioc (max aâ‚ aâ‚‚) bâ‚‚",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} (h : bâ‚‚ < bâ‚)"},
 {"type": "Ico a b \\ Iio c = Ico (max a c) b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ico a b \\ Iio c = Ico (max a c) b := by rw [diff_eq]; sorry",
  "name": "Ico_diff_Iio",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ico a b \\ Iio c = Ico (max a c) b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc a b âˆ© Ioi c = Ioc (a âŠ” c) b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆ© Ioi c = Ioc (a âŠ” c) b := by rw [â† Ioi_inter_Iic]; sorry",
  "name": "Ioc_inter_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [â† Ioi_inter_Iic]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆ© Ioi c = Ioc (a âŠ” c) b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc a b \\ Iic c = Ioc (max a c) b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b \\ Iic c = Ioc (max a c) b := by rw [diff_eq]; sorry",
  "name": "Ioc_diff_Iic",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b \\ Iic c = Ioc (max a c) b",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc a b âˆª Ioc a c = Ioc a (max b c)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc a c = Ioc a (max b c) := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_right",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc a c = Ioc a (max b c)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc a c âˆª Ioc b c = Ioc (min a b) c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a c âˆª Ioc b c = Ioc (min a b) c := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_left",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a c âˆª Ioc b c = Ioc (min a b) c",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Ioc a b âˆª Ioc b a = Ioc (min a b) (max a b)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc b a = Ioc (min a b) (max a b) := by rw [max_comm]; sorry",
  "name": "Ioc_union_Ioc_symm",
  "kind": "theorem",
  "first-tactic": "rw [max_comm]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc b a = Ioc (min a b) (max a b)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type":
  "Ioc a b âˆª Ioc b c âˆª Ioc c a = Ioc (min a (min b c)) (max a (max b c))",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc b c âˆª Ioc c a = Ioc (min a (min b c)) (max a (max b c)) := by rw [Ioc_union_Ioc]; sorry",
  "name": "Ioc_union_Ioc_union_Ioc_cycle",
  "kind": "theorem",
  "first-tactic": "rw [Ioc_union_Ioc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±} : Ioc a b âˆª Ioc b c âˆª Ioc c a = Ioc (min a (min b c)) (max a (max b c))",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c d : Î±}"},
 {"type": "Icc aâ‚ aâ‚‚ Ã—Ë¢ Icc bâ‚ bâ‚‚ = Icc (aâ‚, bâ‚) (aâ‚‚, bâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²) : Icc aâ‚ aâ‚‚ Ã—Ë¢ Icc bâ‚ bâ‚‚ = Icc (aâ‚, bâ‚) (aâ‚‚, bâ‚‚) := by ext âŸ¨x, yâŸ©; sorry",
  "name": "Icc_prod_Icc",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²) : Icc aâ‚ aâ‚‚ Ã—Ë¢ Icc bâ‚ bâ‚‚ = Icc (aâ‚, bâ‚) (aâ‚‚, bâ‚‚)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (aâ‚ aâ‚‚ : Î±)  (bâ‚ bâ‚‚ : Î²)"},
 {"type": "Icc a b = Icc a.1 b.1 Ã—Ë¢ Icc a.2 b.2",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (a b : Î± Ã— Î²) : Icc a b = Icc a.1 b.1 Ã—Ë¢ Icc a.2 b.2 := by simp; sorry",
  "name": "Icc_prod_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (a b : Î± Ã— Î²) : Icc a b = Icc a.1 b.1 Ã—Ë¢ Icc a.2 b.2",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²] (a b : Î± Ã— Î²)"},
 {"type": "Nonempty â†‘(Ico x (x + dx) \\ Ico y (y + dy))",
  "tactic-prompt":
  "theorem {Î± : Type _}  [LinearOrderedAddCommGroup Î±] {x dx y dy : Î±}  (h : dy < dx)  (hx : 0 < dx) : Nonempty â†‘(Ico x (x + dx) \\ Ico y (y + dy)) := by cases' lt_or_le x y with h' h'; sorry",
  "name": "nonempty_Ico_sdiff",
  "kind": "theorem",
  "first-tactic": "cases' lt_or_le x y with h' h'",
  "core-prompt":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±] {x dx y dy : Î±}  (h : dy < dx)  (hx : 0 < dx) : Nonempty â†‘(Ico x (x + dx) \\ Ico y (y + dy))",
  "args":
  "{Î± : Type _}  [LinearOrderedAddCommGroup Î±] {x dx y dy : Î±}  (h : dy < dx)  (hx : 0 < dx)"},
 {"type": "[[a, b]] = Icc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b) : [[a, b]] = Icc a b := by rw [interval]; sorry",
  "name": "interval_of_le",
  "kind": "theorem",
  "first-tactic": "rw [interval]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b) : [[a, b]] = Icc a b",
  "args": "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b)"},
 {"type": "[[a, b]] = Icc b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b â‰¤ a) : [[a, b]] = Icc b a := by rw [interval]; sorry",
  "name": "interval_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [interval]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b â‰¤ a) : [[a, b]] = Icc b a",
  "args": "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b â‰¤ a)"},
 {"type": "[[a, b]] = [[b, a]]",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±) : [[a, b]] = [[b, a]] := by simp_rw [interval]; sorry",
  "name": "interval_swap",
  "kind": "theorem",
  "first-tactic": "simp_rw [interval]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±) : [[a, b]] = [[b, a]]",
  "args": "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±)"},
 {"type": "[[a, a]] = {a}",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : [[a, a]] = {a} := by simp [interval]; sorry",
  "name": "interval_self",
  "kind": "theorem",
  "first-tactic": "simp [interval]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : [[a, a]] = {a}",
  "args": "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ [[a, c]] â†’ c âˆˆ [[a, b]] â†’ b = c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ [[a, c]] â†’ c âˆˆ [[a, b]] â†’ b = c := by simpa only [interval_swap a] using eq_of_mem_interval_of_mem_interval; sorry",
  "name": "eq_of_mem_interval_of_mem_interval'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [interval_swap a] using eq_of_mem_interval_of_mem_interval",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ [[a, c]] â†’ c âˆˆ [[a, b]] â†’ b = c",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Injective (interval a)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective (interval a) := by simpa only [interval_swap] using interval_injective_right a; sorry",
  "name": "interval_injective_left",
  "kind": "theorem",
  "first-tactic": "simpa only [interval_swap] using interval_injective_right a",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective (interval a)",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [DistribLattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±)"},
 {"type": "[[a, b]] = Icc a b âˆª Icc b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : [[a, b]] = Icc a b âˆª Icc b a := by rw [Icc_union_Icc']; sorry",
  "name": "interval_eq_union",
  "kind": "theorem",
  "first-tactic": "rw [Icc_union_Icc']",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : [[a, b]] = Icc a b âˆª Icc b a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ [[b, c]] â†” b â‰¤ a âˆ§ a â‰¤ c âˆ¨ c â‰¤ a âˆ§ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ [[b, c]] â†” b â‰¤ a âˆ§ a â‰¤ c âˆ¨ c â‰¤ a âˆ§ a â‰¤ b := by simp [interval_eq_union]; sorry",
  "name": "mem_interval",
  "kind": "theorem",
  "first-tactic": "simp [interval_eq_union]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ [[b, c]] â†” b â‰¤ a âˆ§ a â‰¤ c âˆ¨ c â‰¤ a âˆ§ a â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type":
  "Monotone f âˆ¨ Antitone f â†” âˆ€ a b c, c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]]",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Monotone f âˆ¨ Antitone f â†” âˆ€ a b c, c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]] := by constructor; sorry",
  "name": "monotone_or_antitone_iff_interval",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Monotone f âˆ¨ Antitone f â†” âˆ€ a b c, c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]]",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type":
  "MonotoneOn f s âˆ¨ AntitoneOn f s â†”\n      âˆ€ (a) (_ : a âˆˆ s) (b) (_ : b âˆˆ s) (c) (_ : c âˆˆ s), c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]]",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : MonotoneOn f s âˆ¨ AntitoneOn f s â†”\n      âˆ€ (a) (_ : a âˆˆ s) (b) (_ : b âˆˆ s) (c) (_ : c âˆˆ s), c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]] := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "monotoneOn_or_antitoneOn_iff_interval",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : MonotoneOn f s âˆ¨ AntitoneOn f s â†”\n      âˆ€ (a) (_ : a âˆˆ s) (b) (_ : b âˆˆ s) (c) (_ : c âˆˆ s), c âˆˆ [[a, b]] â†’ f c âˆˆ [[f a, f b]]",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "Î™ a b = Ioc a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b) : Î™ a b = Ioc a b := by simp [intervalOC]; sorry",
  "name": "intervalOC_of_le",
  "kind": "theorem",
  "first-tactic": "simp [intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b) : Î™ a b = Ioc a b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : a â‰¤ b)"},
 {"type": "Î™ a b = Ioc b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b < a) : Î™ a b = Ioc b a := by simp [intervalOC]; sorry",
  "name": "intervalOC_of_lt",
  "kind": "theorem",
  "first-tactic": "simp [intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b < a) : Î™ a b = Ioc b a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (h : b < a)"},
 {"type": "Î™ a b = Ioc a b âˆª Ioc b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Î™ a b = Ioc a b âˆª Ioc b a := by cases le_total a b; sorry",
  "name": "intervalOC_eq_union",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : Î™ a b = Ioc a b âˆª Ioc b a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Î™ b c â†” b < a âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ b c â†” b < a âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ a â‰¤ b := by rw [intervalOC_eq_union]; sorry",
  "name": "mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "rw [intervalOC_eq_union]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ b c â†” b < a âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ a â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆ‰ Î™ b c â†” a â‰¤ b âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ b < a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆ‰ Î™ b c â†” a â‰¤ b âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ b < a := by rw [intervalOC_eq_union]; sorry",
  "name": "not_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "rw [intervalOC_eq_union]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆ‰ Î™ b c â†” a â‰¤ b âˆ§ a â‰¤ c âˆ¨ c < a âˆ§ b < a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆˆ Î™ a b â†” b < a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ a b â†” b < a := by simp [mem_intervalOC]; sorry",
  "name": "left_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp [mem_intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ a b â†” b < a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Î™ a b â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Î™ a b â†” a < b := by simp [mem_intervalOC]; sorry",
  "name": "right_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp [mem_intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Î™ a b â†” a < b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "(âˆ€ x âˆˆ Î™ a b, P x) â†” (âˆ€ x âˆˆ Ioc a b, P x) âˆ§ âˆ€ x âˆˆ Ioc b a, P x",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} {P : Î± â†’ Prop} : (âˆ€ x âˆˆ Î™ a b, P x) â†” (âˆ€ x âˆˆ Ioc a b, P x) âˆ§ âˆ€ x âˆˆ Ioc b a, P x := by simp only [intervalOC_eq_union]; sorry",
  "name": "forall_intervalOC_iff",
  "kind": "theorem",
  "first-tactic": "simp only [intervalOC_eq_union]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} {P : Î± â†’ Prop} : (âˆ€ x âˆˆ Î™ a b, P x) â†” (âˆ€ x âˆˆ Ioc a b, P x) âˆ§ âˆ€ x âˆˆ Ioc b a, P x",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} {P : Î± â†’ Prop}"},
 {"type": "Î™ a b = Î™ b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±) : Î™ a b = Î™ b a := by simp only [intervalOC]; sorry",
  "name": "intervalOC_swap",
  "kind": "theorem",
  "first-tactic": "simp only [intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±) : Î™ a b = Î™ b a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a b : Î±)"},
 {"type": "a âˆˆ Î™ b c â†’ b âˆˆ Î™ a c â†’ a = b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ b c â†’ b âˆˆ Î™ a c â†’ a = b := by simp_rw [mem_intervalOC]; sorry",
  "name": "eq_of_mem_intervalOC_of_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : a âˆˆ Î™ b c â†’ b âˆˆ Î™ a c â†’ a = b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "b âˆˆ Î™ a c â†’ c âˆˆ Î™ a b â†’ b = c",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Î™ a c â†’ c âˆˆ Î™ a b â†’ b = c := by simpa only [intervalOC_swap a] using eq_of_mem_intervalOC_of_mem_intervalOC; sorry",
  "name": "eq_of_mem_intervalOC_of_mem_intervalOC'",
  "kind": "theorem",
  "first-tactic":
  "simpa only [intervalOC_swap a] using eq_of_mem_intervalOC_of_mem_intervalOC",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} : b âˆˆ Î™ a c â†’ c âˆˆ Î™ a b â†’ b = c",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}"},
 {"type": "a âˆ‰ Î™ b c â†’ b âˆ‰ Î™ a c â†’ a = b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (ha : a â‰¤ c)  (hb : b â‰¤ c) : a âˆ‰ Î™ b c â†’ b âˆ‰ Î™ a c â†’ a = b := by simp_rw [not_mem_intervalOC]; sorry",
  "name": "eq_of_not_mem_intervalOC_of_not_mem_intervalOC",
  "kind": "theorem",
  "first-tactic": "simp_rw [not_mem_intervalOC]",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (ha : a â‰¤ c)  (hb : b â‰¤ c) : a âˆ‰ Î™ b c â†’ b âˆ‰ Î™ a c â†’ a = b",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (ha : a â‰¤ c)  (hb : b â‰¤ c)"},
 {"type": "Injective fun b => Î™ b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective fun b => Î™ b a := by rintro b c h; sorry",
  "name": "intervalOC_injective_right",
  "kind": "theorem",
  "first-tactic": "rintro b c h",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective fun b => Î™ b a",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±)"},
 {"type": "Injective (Î™ a)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective (Î™ a) := by simpa only [intervalOC_swap] using intervalOC_injective_right a; sorry",
  "name": "intervalOC_injective_left",
  "kind": "theorem",
  "first-tactic":
  "simpa only [intervalOC_swap] using intervalOC_injective_right a",
  "core-prompt":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±) : Injective (Î™ a)",
  "args":
  "{Î± Î² : Type _}  [Lattice Î±]  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a aâ‚ aâ‚‚ b bâ‚ bâ‚‚ c x : Î±} (a : Î±)"},
 {"type": "projIcc a b h x = âŸ¨a, left_mem_Icc.2 hâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x â‰¤ a) : projIcc a b h x = âŸ¨a, left_mem_Icc.2 hâŸ© := by simp [projIcc]; sorry",
  "name": "projIcc_of_le_left",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x â‰¤ a) : projIcc a b h x = âŸ¨a, left_mem_Icc.2 hâŸ©",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x â‰¤ a)"},
 {"type": "projIcc a b h x = âŸ¨b, right_mem_Icc.2 hâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : b â‰¤ x) : projIcc a b h x = âŸ¨b, right_mem_Icc.2 hâŸ© := by simp [projIcc]; sorry",
  "name": "projIcc_of_right_le",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : b â‰¤ x) : projIcc a b h x = âŸ¨b, right_mem_Icc.2 hâŸ©",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : b â‰¤ x)"},
 {"type": "projIcc a b h.le x = âŸ¨a, left_mem_Icc.mpr h.leâŸ© â†” x â‰¤ a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b) : projIcc a b h.le x = âŸ¨a, left_mem_Icc.mpr h.leâŸ© â†” x â‰¤ a := by refine' âŸ¨fun h' => _, projIcc_of_le_left _âŸ©; sorry",
  "name": "projIcc_eq_left",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h' => _, projIcc_of_le_left _âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b) : projIcc a b h.le x = âŸ¨a, left_mem_Icc.mpr h.leâŸ© â†” x â‰¤ a",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b)"},
 {"type": "projIcc a b h.le x = âŸ¨b, right_mem_Icc.mpr h.leâŸ© â†” b â‰¤ x",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b) : projIcc a b h.le x = âŸ¨b, right_mem_Icc.mpr h.leâŸ© â†” b â‰¤ x := by refine' âŸ¨fun h' => _, projIcc_of_right_le _âŸ©; sorry",
  "name": "projIcc_eq_right",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h' => _, projIcc_of_right_le _âŸ©",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b) : projIcc a b h.le x = âŸ¨b, right_mem_Icc.mpr h.leâŸ© â†” b â‰¤ x",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (h : a < b)"},
 {"type": "projIcc a b h x = âŸ¨x, hxâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x âˆˆ Icc a b) : projIcc a b h x = âŸ¨x, hxâŸ© := by simp [projIcc]; sorry",
  "name": "projIcc_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [projIcc]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x âˆˆ Icc a b) : projIcc a b h x = âŸ¨x, hxâŸ©",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (hx : x âˆˆ Icc a b)"},
 {"type": "projIcc a b h x = x",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (x : Icc a b) : projIcc a b h x = x := by cases x; sorry",
  "name": "projIcc_val",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (x : Icc a b) : projIcc a b h x = x",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (x : Icc a b)"},
 {"type": "range (IccExtend h f) = range f",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (f : Icc a b â†’ Î²) : range (IccExtend h f) = range f := by simp only [IccExtend]; sorry",
  "name": "IccExtend_range",
  "kind": "theorem",
  "first-tactic": "simp only [IccExtend]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (f : Icc a b â†’ Î²) : range (IccExtend h f) = range f",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)  {x : Î±} (f : Icc a b â†’ Î²)"},
 {"type": "e â»Â¹' Iic b = Iic (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Iic b = Iic (e.symm b) := by ext x; sorry",
  "name": "preimage_Iic",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Iic b = Iic (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²)"},
 {"type": "e â»Â¹' Ici b = Ici (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Ici b = Ici (e.symm b) := by ext x; sorry",
  "name": "preimage_Ici",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Ici b = Ici (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²)"},
 {"type": "e â»Â¹' Iio b = Iio (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Iio b = Iio (e.symm b) := by ext x; sorry",
  "name": "preimage_Iio",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Iio b = Iio (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²)"},
 {"type": "e â»Â¹' Ioi b = Ioi (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Ioi b = Ioi (e.symm b) := by ext x; sorry",
  "name": "preimage_Ioi",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²) : e â»Â¹' Ioi b = Ioi (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (b : Î²)"},
 {"type": "e â»Â¹' Icc a b = Icc (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Icc a b = Icc (e.symm a) (e.symm b) := by simp [â† Ici_inter_Iic]; sorry",
  "name": "preimage_Icc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iic]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Icc a b = Icc (e.symm a) (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²)"},
 {"type": "e â»Â¹' Ico a b = Ico (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ico a b = Ico (e.symm a) (e.symm b) := by simp [â† Ici_inter_Iio]; sorry",
  "name": "preimage_Ico",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iio]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ico a b = Ico (e.symm a) (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²)"},
 {"type": "e â»Â¹' Ioc a b = Ioc (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ioc a b = Ioc (e.symm a) (e.symm b) := by simp [â† Ioi_inter_Iic]; sorry",
  "name": "preimage_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iic]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ioc a b = Ioc (e.symm a) (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²)"},
 {"type": "e â»Â¹' Ioo a b = Ioo (e.symm a) (e.symm b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ioo a b = Ioo (e.symm a) (e.symm b) := by simp [â† Ioi_inter_Iio]; sorry",
  "name": "preimage_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iio]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²) : e â»Â¹' Ioo a b = Ioo (e.symm a) (e.symm b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î²)"},
 {"type": "e '' Iic a = Iic (e a)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±) : e '' Iic a = Iic (e a) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Iic",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±) : e '' Iic a = Iic (e a)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±)"},
 {"type": "e '' Iio a = Iio (e a)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±) : e '' Iio a = Iio (e a) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Iio",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±) : e '' Iio a = Iio (e a)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a : Î±)"},
 {"type": "e '' Ioo a b = Ioo (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ioo a b = Ioo (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ioo a b = Ioo (e a) (e b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±)"},
 {"type": "e '' Ioc a b = Ioc (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ioc a b = Ioc (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ioc a b = Ioc (e a) (e b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±)"},
 {"type": "e '' Ico a b = Ico (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ico a b = Ico (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Ico",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Ico a b = Ico (e a) (e b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±)"},
 {"type": "e '' Icc a b = Icc (e a) (e b)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Icc a b = Icc (e a) (e b) := by rw [e.image_eq_preimage]; sorry",
  "name": "image_Icc",
  "kind": "theorem",
  "first-tactic": "rw [e.image_eq_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±) : e '' Icc a b = Icc (e a) (e b)",
  "args": "[Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  (a b : Î±)"},
 {"type": "range (some : Î± â†’ WithTop Î±) = Iio âŠ¤",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : range (some : Î± â†’ WithTop Î±) = Iio âŠ¤ := by ext x; sorry",
  "name": "range_coe",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : range (some : Î± â†’ WithTop Î±) = Iio âŠ¤",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Icc a b = Icc a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Icc a b = Icc a b := by simp [â† Ici_inter_Iic]; sorry",
  "name": "preimage_coe_Icc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Icc a b = Icc a b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Ico a b = Ico a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ico a b = Ico a b := by simp [â† Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ico a b = Ico a b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Ioc a b = Ioc a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioc a b = Ioc a b := by simp [â† Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioc a b = Ioc a b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Ioo a b = Ioo a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioo a b = Ioo a b := by simp [â† Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioo a b = Ioo a b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Iio âŠ¤ = univ",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Iio âŠ¤ = univ := by rw [â† range_coe]; sorry",
  "name": "preimage_coe_Iio_top",
  "kind": "theorem",
  "first-tactic": "rw [â† range_coe]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Iio âŠ¤ = univ",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Ico a âŠ¤ = Ici a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ico a âŠ¤ = Ici a := by simp [â† Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico_top",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ico a âŠ¤ = Ici a",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) â»Â¹' Ioo a âŠ¤ = Ioi a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioo a âŠ¤ = Ioi a := by simp [â† Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo_top",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) â»Â¹' Ioo a âŠ¤ = Ioi a",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Ioi a = Ioo (a : WithTop Î±) âŠ¤",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioi a = Ioo (a : WithTop Î±) âŠ¤ := by rw [â† preimage_coe_Ioi]; sorry",
  "name": "image_coe_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioi]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioi a = Ioo (a : WithTop Î±) âŠ¤",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Ici a = Ico (a : WithTop Î±) âŠ¤",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ici a = Ico (a : WithTop Î±) âŠ¤ := by rw [â† preimage_coe_Ici]; sorry",
  "name": "image_coe_Ici",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ici]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ici a = Ico (a : WithTop Î±) âŠ¤",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Iio a = Iio (a : WithTop Î±)",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Iio a = Iio (a : WithTop Î±) := by rw [â† preimage_coe_Iio]; sorry",
  "name": "image_coe_Iio",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Iio a = Iio (a : WithTop Î±)",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Iic a = Iic (a : WithTop Î±)",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Iic a = Iic (a : WithTop Î±) := by rw [â† preimage_coe_Iic]; sorry",
  "name": "image_coe_Iic",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Iic a = Iic (a : WithTop Î±)",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Icc a b = Icc (a : WithTop Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Icc a b = Icc (a : WithTop Î±) b := by rw [â† preimage_coe_Icc]; sorry",
  "name": "image_coe_Icc",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Icc]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Icc a b = Icc (a : WithTop Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Ico a b = Ico (a : WithTop Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ico a b = Ico (a : WithTop Î±) b := by rw [â† preimage_coe_Ico]; sorry",
  "name": "image_coe_Ico",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ico]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ico a b = Ico (a : WithTop Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Ioc a b = Ioc (a : WithTop Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioc a b = Ioc (a : WithTop Î±) b := by rw [â† preimage_coe_Ioc]; sorry",
  "name": "image_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioc]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioc a b = Ioc (a : WithTop Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithTop Î±) '' Ioo a b = Ioo (a : WithTop Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioo a b = Ioo (a : WithTop Î±) b := by rw [â† preimage_coe_Ioo]; sorry",
  "name": "image_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioo]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithTop Î±) '' Ioo a b = Ioo (a : WithTop Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Icc a b = Icc a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Icc a b = Icc a b := by simp [â† Ici_inter_Iic]; sorry",
  "name": "preimage_coe_Icc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Icc a b = Icc a b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ico a b = Ico a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ico a b = Ico a b := by simp [â† Ici_inter_Iio]; sorry",
  "name": "preimage_coe_Ico",
  "kind": "theorem",
  "first-tactic": "simp [â† Ici_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ico a b = Ico a b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ioc a b = Ioc a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioc a b = Ioc a b := by simp [â† Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioc a b = Ioc a b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ioo a b = Ioo a b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioo a b = Ioo a b := by simp [â† Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioo a b = Ioo a b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ioi âŠ¥ = univ",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioi âŠ¥ = univ := by rw [â† range_coe]; sorry",
  "name": "preimage_coe_Ioi_bot",
  "kind": "theorem",
  "first-tactic": "rw [â† range_coe]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioi âŠ¥ = univ",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ioc âŠ¥ a = Iic a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioc âŠ¥ a = Iic a := by simp [â† Ioi_inter_Iic]; sorry",
  "name": "preimage_coe_Ioc_bot",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioc âŠ¥ a = Iic a",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) â»Â¹' Ioo âŠ¥ a = Iio a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioo âŠ¥ a = Iio a := by simp [â† Ioi_inter_Iio]; sorry",
  "name": "preimage_coe_Ioo_bot",
  "kind": "theorem",
  "first-tactic": "simp [â† Ioi_inter_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) â»Â¹' Ioo âŠ¥ a = Iio a",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Iio a = Ioo (âŠ¥ : WithBot Î±) a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Iio a = Ioo (âŠ¥ : WithBot Î±) a := by rw [â† preimage_coe_Iio]; sorry",
  "name": "image_coe_Iio",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Iio]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Iio a = Ioo (âŠ¥ : WithBot Î±) a",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Iic a = Ioc (âŠ¥ : WithBot Î±) a",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Iic a = Ioc (âŠ¥ : WithBot Î±) a := by rw [â† preimage_coe_Iic]; sorry",
  "name": "image_coe_Iic",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Iic]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Iic a = Ioc (âŠ¥ : WithBot Î±) a",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Ioi a = Ioi (a : WithBot Î±)",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioi a = Ioi (a : WithBot Î±) := by rw [â† preimage_coe_Ioi]; sorry",
  "name": "image_coe_Ioi",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioi]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioi a = Ioi (a : WithBot Î±)",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Ici a = Ici (a : WithBot Î±)",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ici a = Ici (a : WithBot Î±) := by rw [â† preimage_coe_Ici]; sorry",
  "name": "image_coe_Ici",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ici]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ici a = Ici (a : WithBot Î±)",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Icc a b = Icc (a : WithBot Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Icc a b = Icc (a : WithBot Î±) b := by rw [â† preimage_coe_Icc]; sorry",
  "name": "image_coe_Icc",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Icc]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Icc a b = Icc (a : WithBot Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Ioc a b = Ioc (a : WithBot Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioc a b = Ioc (a : WithBot Î±) b := by rw [â† preimage_coe_Ioc]; sorry",
  "name": "image_coe_Ioc",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioc]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioc a b = Ioc (a : WithBot Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Ico a b = Ico (a : WithBot Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ico a b = Ico (a : WithBot Î±) b := by rw [â† preimage_coe_Ico]; sorry",
  "name": "image_coe_Ico",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ico]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ico a b = Ico (a : WithBot Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "(some : Î± â†’ WithBot Î±) '' Ioo a b = Ioo (a : WithBot Î±) b",
  "tactic-prompt":
  "theorem [PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioo a b = Ioo (a : WithBot Î±) b := by rw [â† preimage_coe_Ioo]; sorry",
  "name": "image_coe_Ioo",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_coe_Ioo]",
  "core-prompt":
  "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±} : (some : Î± â†’ WithBot Î±) '' Ioo a b = Ioo (a : WithBot Î±) b",
  "args": "[PartialOrder Î±]  {a b : Î±} [PartialOrder Î±]  {a b : Î±}"},
 {"type": "image2 f s t âŠ† image2 f s' t'",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hs : s âŠ† s')  (ht : t âŠ† t') : image2 f s t âŠ† image2 f s' t' := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hs : s âŠ† s')  (ht : t âŠ† t') : image2 f s t âŠ† image2 f s' t'",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hs : s âŠ† s')  (ht : t âŠ† t')"},
 {"type": "image2 (fun a b â†¦ f (a, b)) s t = f '' s Ã—Ë¢ t",
  "tactic-prompt":
  "lemma {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± Ã— Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 (fun a b â†¦ f (a, b)) s t = f '' s Ã—Ë¢ t := by simp [â†image_uncurry_prod]; sorry",
  "name": "image2_curry",
  "kind": "lemma",
  "first-tactic": "simp [â†image_uncurry_prod]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± Ã— Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 (fun a b â†¦ f (a, b)) s t = f '' s Ã—Ë¢ t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± Ã— Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²)"},
 {"type": "image2 f (s âˆª s') t = image2 f s t âˆª image2 f s' t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f (s âˆª s') t = image2 f s t âˆª image2 f s' t := by ext c; sorry",
  "name": "image2_union_left",
  "kind": "theorem",
  "first-tactic": "ext c",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f (s âˆª s') t = image2 f s t âˆª image2 f s' t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f s (t âˆª t') = image2 f s t âˆª image2 f s t'",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s (t âˆª t') = image2 f s t âˆª image2 f s t' := by ext c; sorry",
  "name": "image2_union_right",
  "kind": "theorem",
  "first-tactic": "ext c",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s (t âˆª t') = image2 f s t âˆª image2 f s t'",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f (s âˆ© s') t = image2 f s t âˆ© image2 f s' t",
  "tactic-prompt":
  "lemma {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f) : image2 f (s âˆ© s') t = image2 f s t âˆ© image2 f s' t := by simp_rw [â†image_uncurry_prod]; sorry",
  "name": "image2_inter_left",
  "kind": "lemma",
  "first-tactic": "simp_rw [â†image_uncurry_prod]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f) : image2 f (s âˆ© s') t = image2 f s t âˆ© image2 f s' t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f)"},
 {"type": "image2 f s (t âˆ© t') = image2 f s t âˆ© image2 f s t'",
  "tactic-prompt":
  "lemma {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f) : image2 f s (t âˆ© t') = image2 f s t âˆ© image2 f s t' := by simp_rw [â†image_uncurry_prod]; sorry",
  "name": "image2_inter_right",
  "kind": "lemma",
  "first-tactic": "simp_rw [â†image_uncurry_prod]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f) : image2 f s (t âˆ© t') = image2 f s t âˆ© image2 f s t'",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (hf : Injective2 f)"},
 {"type": "image2 f s t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ… := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "image2_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f (s âˆ© s') t âŠ† image2 f s t âˆ© image2 f s' t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f (s âˆ© s') t âŠ† image2 f s t âˆ© image2 f s' t := by rintro _ âŸ¨a, b, âŸ¨h1a, h2aâŸ©, hb, rflâŸ©; sorry",
  "name": "image2_inter_subset_left",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, âŸ¨h1a, h2aâŸ©, hb, rflâŸ©",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f (s âˆ© s') t âŠ† image2 f s t âˆ© image2 f s' t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f s (t âˆ© t') âŠ† image2 f s t âˆ© image2 f s t'",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s (t âˆ© t') âŠ† image2 f s t âˆ© image2 f s t' := by rintro _ âŸ¨a, b, ha, âŸ¨h1b, h2bâŸ©, rflâŸ©; sorry",
  "name": "image2_inter_subset_right",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, âŸ¨h1b, h2bâŸ©, rflâŸ©",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f s (t âˆ© t') âŠ† image2 f s t âˆ© image2 f s t'",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f {a} {b} = {f a b}",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f {a} {b} = {f a b} := by simp; sorry",
  "name": "image2_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} : image2 f {a} {b} = {f a b}",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´}"},
 {"type": "image2 f s t = image2 f' s t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b = f' a b) : image2 f s t = image2 f' s t := by ext; sorry",
  "name": "image2_congr",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b = f' a b) : image2 f s t = image2 f' s t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b = f' a b)"},
 {"type": "image3 g s t u = image3 g' s t u",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, âˆ€ c âˆˆ u, g a b c = g' a b c) : image3 g s t u = image3 g' s t u := by ext x; sorry",
  "name": "image3_congr",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, âˆ€ c âˆˆ u, g a b c = g' a b c) : image3 g s t u = image3 g' s t u",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, âˆ€ c âˆˆ u, g a b c = g' a b c)"},
 {"type": "image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î´ â†’ Î³ â†’ Îµ)  (g : Î± â†’ Î² â†’ Î´) : image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u := by ext; sorry",
  "name": "image2_image2_left",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î´ â†’ Î³ â†’ Îµ)  (g : Î± â†’ Î² â†’ Î´) : image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î´ â†’ Î³ â†’ Îµ)  (g : Î± â†’ Î² â†’ Î´)"},
 {"type": "image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î´ â†’ Îµ)  (g : Î² â†’ Î³ â†’ Î´) : image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u := by ext; sorry",
  "name": "image2_image2_right",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î´ â†’ Îµ)  (g : Î² â†’ Î³ â†’ Î´) : image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î´ â†’ Îµ)  (g : Î² â†’ Î³ â†’ Î´)"},
 {"type": "g '' image2 f s t = image2 (fun a b => g (f a b)) s t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´) : g '' image2 f s t = image2 (fun a b => g (f a b)) s t := by ext; sorry",
  "name": "image_image2",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´) : g '' image2 f s t = image2 (fun a b => g (f a b)) s t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´)"},
 {"type": "image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³) : image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t := by ext; sorry",
  "name": "image2_image_left",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³) : image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³)"},
 {"type": "image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t := by ext; sorry",
  "name": "image2_image_right",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³) : image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³)"},
 {"type": "image2 f s t = image2 (fun a b => f b a) t s",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 f s t = image2 (fun a b => f b a) t s := by ext; sorry",
  "name": "image2_swap",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 f s t = image2 (fun a b => f b a) t s",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²)"},
 {"type": "image2 (fun x _ => x) s t = s",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : t.Nonempty) : image2 (fun x _ => x) s t = s := by simp [nonempty_def.mp h]; sorry",
  "name": "image2_left",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_def.mp h]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : t.Nonempty) : image2 (fun x _ => x) s t = s",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : t.Nonempty)"},
 {"type": "image2 (fun _ y => y) s t = t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : s.Nonempty) : image2 (fun _ y => y) s t = t := by simp [nonempty_def.mp h]; sorry",
  "name": "image2_right",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_def.mp h]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : s.Nonempty) : image2 (fun _ y => y) s t = t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} (h : s.Nonempty)"},
 {"type": "image2 f (image2 g s t) u = image2 f' s (image2 g' t u)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c)) : image2 f (image2 g s t) u = image2 f' s (image2 g' t u) := by simp only [image2_image2_left]; sorry",
  "name": "image2_assoc",
  "kind": "theorem",
  "first-tactic": "simp only [image2_image2_left]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c)) : image2 f (image2 g s t) u = image2 f' s (image2 g' t u)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c))"},
 {"type": "image2 f s (image2 g t u) = image2 g' t (image2 f' s u)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c)) : image2 f s (image2 g t u) = image2 g' t (image2 f' s u) := by rw [image2_swap f']; sorry",
  "name": "image2_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap f']",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c)) : image2 f s (image2 g t u) = image2 g' t (image2 f' s u)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c))"},
 {"type": "image2 f (image2 g s t) u = image2 g' (image2 f' s u) t",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b) : image2 f (image2 g s t) u = image2 g' (image2 f' s u) t := by rw [image2_swap g]; sorry",
  "name": "image2_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap g]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b) : image2 f (image2 g s t) u = image2 g' (image2 f' s u) t",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b)"},
 {"type": "(image2 f s t).image g = image2 f' (s.image gâ‚) (t.image gâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b)) : (image2 f s t).image g = image2 f' (s.image gâ‚) (t.image gâ‚‚) := by simp_rw [image_image2]; sorry",
  "name": "image_image2_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_image2]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b)) : (image2 f s t).image g = image2 f' (s.image gâ‚) (t.image gâ‚‚)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b))"},
 {"type":
  "image2 f s (image2 g t u) âŠ† image2 g' (image2 fâ‚ s t) (image2 fâ‚‚ s u)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {fâ‚ : Î± â†’ Î² â†’ Î²'}      {fâ‚‚ : Î± â†’ Î³ â†’ Î³'}  {g' : Î²' â†’ Î³' â†’ Îµ}  (h_distrib : âˆ€ a b c, f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : image2 f s (image2 g t u) âŠ† image2 g' (image2 fâ‚ s t) (image2 fâ‚‚ s u) := by rintro _ âŸ¨a, _, ha, âŸ¨b, c, hb, hc, rflâŸ©, rflâŸ©; sorry",
  "name": "image2_distrib_subset_left",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, _, ha, âŸ¨b, c, hb, hc, rflâŸ©, rflâŸ©",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {fâ‚ : Î± â†’ Î² â†’ Î²'}      {fâ‚‚ : Î± â†’ Î³ â†’ Î³'}  {g' : Î²' â†’ Î³' â†’ Îµ}  (h_distrib : âˆ€ a b c, f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c)) : image2 f s (image2 g t u) âŠ† image2 g' (image2 fâ‚ s t) (image2 fâ‚‚ s u)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {fâ‚ : Î± â†’ Î² â†’ Î²'}      {fâ‚‚ : Î± â†’ Î³ â†’ Î³'}  {g' : Î²' â†’ Î³' â†’ Îµ}  (h_distrib : âˆ€ a b c, f a (g b c) = g' (fâ‚ a b) (fâ‚‚ a c))"},
 {"type":
  "image2 f (image2 g s t) u âŠ† image2 g' (image2 fâ‚ s u) (image2 fâ‚‚ t u)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {fâ‚ : Î± â†’ Î³ â†’ Î±'}      {fâ‚‚ : Î² â†’ Î³ â†’ Î²'}  {g' : Î±' â†’ Î²' â†’ Îµ}  (h_distrib : âˆ€ a b c, f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : image2 f (image2 g s t) u âŠ† image2 g' (image2 fâ‚ s u) (image2 fâ‚‚ t u) := by rintro _ âŸ¨_, c, âŸ¨a, b, ha, hb, rflâŸ©, hc, rflâŸ©; sorry",
  "name": "image2_distrib_subset_right",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨_, c, âŸ¨a, b, ha, hb, rflâŸ©, hc, rflâŸ©",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {fâ‚ : Î± â†’ Î³ â†’ Î±'}      {fâ‚‚ : Î² â†’ Î³ â†’ Î²'}  {g' : Î±' â†’ Î²' â†’ Îµ}  (h_distrib : âˆ€ a b c, f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) : image2 f (image2 g s t) u âŠ† image2 g' (image2 fâ‚ s u) (image2 fâ‚‚ t u)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {fâ‚ : Î± â†’ Î³ â†’ Î±'}      {fâ‚‚ : Î² â†’ Î³ â†’ Î²'}  {g' : Î±' â†’ Î²' â†’ Îµ}  (h_distrib : âˆ€ a b c, f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c))"},
 {"type": "(image2 f s t).image g = image2 f' (t.image gâ‚) (s.image gâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a)) : (image2 f s t).image g = image2 f' (t.image gâ‚) (s.image gâ‚‚) := by rw [image2_swap f]; sorry",
  "name": "image_image2_antidistrib",
  "kind": "theorem",
  "first-tactic": "rw [image2_swap f]",
  "core-prompt":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a)) : (image2 f s t).image g = image2 f' (t.image gâ‚) (s.image gâ‚‚)",
  "args":
  "{Î± Î±' Î² Î²' Î³ Î³' Î´ Î´' Îµ Îµ' : Type _}  {f f' : Î± â†’ Î² â†’ Î³}  {g g' : Î± â†’ Î² â†’ Î³ â†’ Î´} {s s' : Set Î±}  {t t' : Set Î²}  {u u' : Set Î³}  {a a' : Î±}  {b b' : Î²}  {c c' : Î³}  {d d' : Î´} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a))"},
 {"type": "x âˆˆ s â†” s.boolIndicator x = true",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set Î±) (x : Î±) : x âˆˆ s â†” s.boolIndicator x = true := by unfold boolIndicator; sorry",
  "name": "mem_iff_boolIndicator",
  "kind": "theorem",
  "first-tactic": "unfold boolIndicator",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±) (x : Î±) : x âˆˆ s â†” s.boolIndicator x = true",
  "args": "{Î± : Type _}  (s : Set Î±) (x : Î±)"},
 {"type": "x âˆ‰ s â†” s.boolIndicator x = false",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set Î±) (x : Î±) : x âˆ‰ s â†” s.boolIndicator x = false := by unfold boolIndicator; sorry",
  "name": "not_mem_iff_boolIndicator",
  "kind": "theorem",
  "first-tactic": "unfold boolIndicator",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±) (x : Î±) : x âˆ‰ s â†” s.boolIndicator x = false",
  "args": "{Î± : Type _}  (s : Set Î±) (x : Î±)"},
 {"type":
  "s.boolIndicator â»Â¹' t = (if true âˆˆ t then s else âˆ…) âˆª if false âˆˆ t then sá¶œ else âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set Î±) (t : Set Bool) : s.boolIndicator â»Â¹' t = (if true âˆˆ t then s else âˆ…) âˆª if false âˆˆ t then sá¶œ else âˆ… := by ext x; sorry",
  "name": "preimage_boolIndicator_eq_union",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±) (t : Set Bool) : s.boolIndicator â»Â¹' t = (if true âˆˆ t then s else âˆ…) âˆª if false âˆˆ t then sá¶œ else âˆ…",
  "args": "{Î± : Type _}  (s : Set Î±) (t : Set Bool)"},
 {"type":
  "s.boolIndicator â»Â¹' t = univ âˆ¨\n      s.boolIndicator â»Â¹' t = s âˆ¨ s.boolIndicator â»Â¹' t = sá¶œ âˆ¨ s.boolIndicator â»Â¹' t = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set Î±) (t : Set Bool) : s.boolIndicator â»Â¹' t = univ âˆ¨\n      s.boolIndicator â»Â¹' t = s âˆ¨ s.boolIndicator â»Â¹' t = sá¶œ âˆ¨ s.boolIndicator â»Â¹' t = âˆ… := by simp only [preimage_boolIndicator_eq_union]; sorry",
  "name": "preimage_boolIndicator",
  "kind": "theorem",
  "first-tactic": "simp only [preimage_boolIndicator_eq_union]",
  "core-prompt":
  "{Î± : Type _}  (s : Set Î±) (t : Set Bool) : s.boolIndicator â»Â¹' t = univ âˆ¨\n      s.boolIndicator â»Â¹' t = s âˆ¨ s.boolIndicator â»Â¹' t = sá¶œ âˆ¨ s.boolIndicator â»Â¹' t = âˆ…",
  "args": "{Î± : Type _}  (s : Set Î±) (t : Set Bool)"},
 {"type": "range (Sigma.mk i : Î± i â†’ Sigma Î±) = Sigma.fst â»Â¹' {i}",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (i : Î¹) : range (Sigma.mk i : Î± i â†’ Sigma Î±) = Sigma.fst â»Â¹' {i} := by apply Subset.antisymm; sorry",
  "name": "range_sigmaMk",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (i : Î¹) : range (Sigma.mk i : Î± i â†’ Sigma Î±) = Sigma.fst â»Â¹' {i}",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (i : Î¹)"},
 {"type": "Sigma.mk i â»Â¹' (Sigma.mk j '' s) = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (h : i â‰  j)  (s : Set (Î± j)) : Sigma.mk i â»Â¹' (Sigma.mk j '' s) = âˆ… := by ext x; sorry",
  "name": "preimage_image_sigmaMk_of_ne",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (h : i â‰  j)  (s : Set (Î± j)) : Sigma.mk i â»Â¹' (Sigma.mk j '' s) = âˆ…",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} (h : i â‰  j)  (s : Set (Î± j))"},
 {"type": "Sigma.mk i '' (g i â»Â¹' s) = Sigma.map f g â»Â¹' (Sigma.mk (f i) '' s)",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {Î² : Î¹' â†’ Type _}  {f : Î¹ â†’ Î¹'}  (hf : Function.Injective f)      (g : âˆ€ i, Î± i â†’ Î² (f i))  (i : Î¹)  (s : Set (Î² (f i))) : Sigma.mk i '' (g i â»Â¹' s) = Sigma.map f g â»Â¹' (Sigma.mk (f i) '' s) := by refine' (image_sigmaMk_preimage_sigmaMap_subset f g i s).antisymm _; sorry",
  "name": "image_sigmaMk_preimage_sigmaMap",
  "kind": "theorem",
  "first-tactic":
  "refine' (image_sigmaMk_preimage_sigmaMap_subset f g i s).antisymm _",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {Î² : Î¹' â†’ Type _}  {f : Î¹ â†’ Î¹'}  (hf : Function.Injective f)      (g : âˆ€ i, Î± i â†’ Î² (f i))  (i : Î¹)  (s : Set (Î² (f i))) : Sigma.mk i '' (g i â»Â¹' s) = Sigma.map f g â»Â¹' (Sigma.mk (f i) '' s)",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {Î² : Î¹' â†’ Type _}  {f : Î¹ â†’ Î¹'}  (hf : Function.Injective f)      (g : âˆ€ i, Î± i â†’ Î² (f i))  (i : Î¹)  (s : Set (Î² (f i)))"},
 {"type":
  "(s.Sigma fun i â†¦ ({a i} : Set (Î± i))) = (fun i â†¦ Sigma.mk i <| a i) '' s",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (s.Sigma fun i â†¦ ({a i} : Set (Î± i))) = (fun i â†¦ Sigma.mk i <| a i) '' s := by ext âŸ¨x, yâŸ©; sorry",
  "name": "sigma_singleton",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (s.Sigma fun i â†¦ ({a i} : Set (Î± i))) = (fun i â†¦ Sigma.mk i <| a i) '' s",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i}"},
 {"type": "(({i} : Set Î¹).Sigma fun i â†¦ ({a i} : Set (Î± i))) = {âŸ¨i, a iâŸ©}",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (({i} : Set Î¹).Sigma fun i â†¦ ({a i} : Set (Î± i))) = {âŸ¨i, a iâŸ©} := by rw [sigma_singleton]; sorry",
  "name": "singleton_sigma_singleton",
  "kind": "theorem",
  "first-tactic": "rw [sigma_singleton]",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (({i} : Set Î¹).Sigma fun i â†¦ ({a i} : Set (Î± i))) = {âŸ¨i, a iâŸ©}",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i}"},
 {"type": "sâ‚.Sigma tâ‚ âˆ© sâ‚‚.Sigma tâ‚‚ = (sâ‚ âˆ© sâ‚‚).Sigma fun i â†¦ tâ‚ i âˆ© tâ‚‚ i",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} : sâ‚.Sigma tâ‚ âˆ© sâ‚‚.Sigma tâ‚‚ = (sâ‚ âˆ© sâ‚‚).Sigma fun i â†¦ tâ‚ i âˆ© tâ‚‚ i := by ext âŸ¨x, yâŸ©; sorry",
  "name": "sigma_inter_sigma",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} : sâ‚.Sigma tâ‚ âˆ© sâ‚‚.Sigma tâ‚‚ = (sâ‚ âˆ© sâ‚‚).Sigma fun i â†¦ tâ‚ i âˆ© tâ‚‚ i",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i}"},
 {"type": "(insert i s).Sigma t = Sigma.mk i '' t i âˆª s.Sigma t",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} : (insert i s).Sigma t = Sigma.mk i '' t i âˆª s.Sigma t := by rw [insert_eq]; sorry",
  "name": "insert_sigma",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} : (insert i s).Sigma t = Sigma.mk i '' t i âˆª s.Sigma t",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i}"},
 {"type":
  "(s.Sigma fun i â†¦ insert (a i) (t i)) = (fun i â†¦ âŸ¨i, a iâŸ©) '' s âˆª s.Sigma t",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (s.Sigma fun i â†¦ insert (a i) (t i)) = (fun i â†¦ âŸ¨i, a iâŸ©) '' s âˆª s.Sigma t := by simp_rw [insert_eq]; sorry",
  "name": "sigma_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i} : (s.Sigma fun i â†¦ insert (a i) (t i)) = (fun i â†¦ âŸ¨i, a iâŸ©) '' s âˆª s.Sigma t",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} {a : âˆ€ i, Î± i}"},
 {"type": "Sigma.mk i â»Â¹' s.Sigma t = if i âˆˆ s then t i else âˆ…",
  "tactic-prompt":
  "theorem {Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} [DecidablePred (Â· âˆˆ s)] : Sigma.mk i â»Â¹' s.Sigma t = if i âˆˆ s then t i else âˆ… := by split_ifs; sorry",
  "name": "mk_preimage_sigma_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs",
  "core-prompt":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} [DecidablePred (Â· âˆˆ s)] : Sigma.mk i â»Â¹' s.Sigma t = if i âˆˆ s then t i else âˆ…",
  "args":
  "{Î¹ Î¹' : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}    {u : Set (Î£ i, Î± i)}  {x : Î£ i, Î± i}  {i j : Î¹}  {a : Î± i} [DecidablePred (Â· âˆˆ s)]"},
 {"type": "(âˆ€ a âˆˆ s, âˆ€ (b), p a b) â†” âˆ€ (b), âˆ€ a âˆˆ s, p a b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Î± â†’ Î² â†’ Prop} : (âˆ€ a âˆˆ s, âˆ€ (b), p a b) â†” âˆ€ (b), âˆ€ a âˆˆ s, p a b := by tauto; sorry",
  "name": "forall_in_swap",
  "kind": "theorem",
  "first-tactic": "tauto",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Î± â†’ Î² â†’ Prop} : (âˆ€ a âˆˆ s, âˆ€ (b), p a b) â†” âˆ€ (b), âˆ€ a âˆˆ s, p a b",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Î± â†’ Î² â†’ Prop}"},
 {"type": "Â¬s âŠ† t â†” âˆƒ a âˆˆ s, a âˆ‰ t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Â¬s âŠ† t â†” âˆƒ a âˆˆ s, a âˆ‰ t := by simp only [subset_def]; sorry",
  "name": "not_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Â¬s âŠ† t â†” âˆƒ a âˆˆ s, a âˆ‰ t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s âˆ© t).Nonempty â†” âˆƒ x âˆˆ s, x âˆˆ t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© t).Nonempty â†” âˆƒ x âˆˆ s, x âˆˆ t := by simp_rw [inter_nonempty]; sorry",
  "name": "inter_nonempty_iff_exists_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [inter_nonempty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© t).Nonempty â†” âˆƒ x âˆˆ s, x âˆˆ t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s âˆ© t).Nonempty â†” âˆƒ x âˆˆ t, x âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© t).Nonempty â†” âˆƒ x âˆˆ t, x âˆˆ s := by simp_rw [inter_nonempty]; sorry",
  "name": "inter_nonempty_iff_exists_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [inter_nonempty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© t).Nonempty â†” âˆƒ x âˆˆ t, x âˆˆ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "Â¬s.Nonempty â†” s = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±} : Â¬s.Nonempty â†” s = âˆ… := by simp only [Set.Nonempty]; sorry",
  "name": "not_nonempty_iff_eq_empty",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Nonempty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±} : Â¬s.Nonempty â†” s = âˆ…",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}"},
 {"type": "s.Nonempty â†’ s = univ",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±] : s.Nonempty â†’ s = univ := by rintro âŸ¨x, hxâŸ©; sorry",
  "name": "Nonempty.eq_univ",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨x, hxâŸ©",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±] : s.Nonempty â†’ s = univ",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±]"},
 {"type": "s â‰  univ â†” âˆƒ a, a âˆ‰ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  (s : Set Î±) : s â‰  univ â†” âˆƒ a, a âˆ‰ s := by rw [â† not_forall]; sorry",
  "name": "ne_univ_iff_exists_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [â† not_forall]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  (s : Set Î±) : s â‰  univ â†” âˆƒ a, a âˆ‰ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  (s : Set Î±)"},
 {"type": "Â¬s âŠ† t â†” âˆƒ x, x âˆˆ s âˆ§ x âˆ‰ t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  {s t : Set Î±} : Â¬s âŠ† t â†” âˆƒ x, x âˆˆ s âˆ§ x âˆ‰ t := by simp [subset_def]; sorry",
  "name": "not_subset_iff_exists_mem_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  {s t : Set Î±} : Â¬s âŠ† t â†” âˆƒ x, x âˆˆ s âˆ§ x âˆ‰ t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î± : Type _}  {s t : Set Î±}"},
 {"type": "s âˆª t = âˆ… â†” s = âˆ… âˆ§ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s âˆª t = âˆ… â†” s = âˆ… âˆ§ t = âˆ… := by simp only [â† subset_empty_iff]; sorry",
  "name": "union_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [â† subset_empty_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s âˆª t = âˆ… â†” s = âˆ… âˆ§ t = âˆ…",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±}"},
 {"type": "insert a s âŠ† t â†” a âˆˆ t âˆ§ s âŠ† t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : insert a s âŠ† t â†” a âˆˆ t âˆ§ s âŠ† t := by simp only [subset_def]; sorry",
  "name": "insert_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : insert a s âŠ† t â†” a âˆˆ t âˆ§ s âŠ† t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "insert a s âŠ† insert a t â†” s âŠ† t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (ha : a âˆ‰ s) : insert a s âŠ† insert a t â†” s âŠ† t := by refine' âŸ¨fun h x hx => _, insert_subset_insertâŸ©; sorry",
  "name": "insert_subset_insert_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h x hx => _, insert_subset_insertâŸ©",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (ha : a âˆ‰ s) : insert a s âŠ† insert a t â†” s âŠ† t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (ha : a âˆ‰ s)"},
 {"type": "s âŠ‚ t â†” âˆƒ (a : Î±) (_ : a âˆ‰ s), insert a s âŠ† t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s âŠ‚ t â†” âˆƒ (a : Î±) (_ : a âˆ‰ s), insert a s âŠ† t := by simp only [insert_subset]; sorry",
  "name": "ssubset_iff_insert",
  "kind": "theorem",
  "first-tactic": "simp only [insert_subset]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s âŠ‚ t â†” âˆƒ (a : Î±) (_ : a âˆ‰ s), insert a s âŠ† t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±}"},
 {"type": "(âˆƒ x âˆˆ insert a s, P x) â†” (P a âˆ¨ âˆƒ x âˆˆ s, P x)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {P : Î± â†’ Prop}  {a : Î±}  {s : Set Î±} : (âˆƒ x âˆˆ insert a s, P x) â†” (P a âˆ¨ âˆƒ x âˆˆ s, P x) := by simp [mem_insert_iff]; sorry",
  "name": "bex_insert_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_insert_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {P : Î± â†’ Prop}  {a : Î±}  {s : Set Î±} : (âˆƒ x âˆˆ insert a s, P x) â†” (P a âˆ¨ âˆƒ x âˆˆ s, P x)",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {P : Î± â†’ Prop}  {a : Î±}  {s : Set Î±}"},
 {"type": "({a} âˆ© s).Nonempty â†” a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : ({a} âˆ© s).Nonempty â†” a âˆˆ s := by simp only [Set.Nonempty]; sorry",
  "name": "singleton_inter_nonempty",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Nonempty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : ({a} âˆ© s).Nonempty â†” a âˆˆ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "(s âˆ© {a}).Nonempty â†” a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© {a}).Nonempty â†” a âˆˆ s := by rw [inter_comm]; sorry",
  "name": "inter_singleton_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (s âˆ© {a}).Nonempty â†” a âˆˆ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "s âˆ© {a} = âˆ… â†” a âˆ‰ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : s âˆ© {a} = âˆ… â†” a âˆ‰ s := by rw [inter_comm]; sorry",
  "name": "inter_singleton_eq_empty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : s âˆ© {a} = âˆ… â†” a âˆ‰ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "({x, y} : Set Î±) = {z, w} â†” x = z âˆ§ y = w âˆ¨ x = w âˆ§ y = z",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x y z w : Î±} : ({x, y} : Set Î±) = {z, w} â†” x = z âˆ§ y = w âˆ¨ x = w âˆ§ y = z := by simp only [Set.Subset.antisymm_iff]; sorry",
  "name": "pair_eq_pair_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Set.Subset.antisymm_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x y z w : Î±} : ({x, y} : Set Î±) = {z, w} â†” x = z âˆ§ y = w âˆ¨ x = w âˆ§ y = z",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x y z w : Î±}"},
 {"type": "{ x âˆˆ s | p x } = { x âˆˆ s | q x } â†” âˆ€ x âˆˆ s, p x â†” q x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = { x âˆˆ s | q x } â†” âˆ€ x âˆˆ s, p x â†” q x := by simp_rw [ext_iff]; sorry",
  "name": "sep_ext_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = { x âˆˆ s | q x } â†” âˆ€ x âˆˆ s, p x â†” q x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±}"},
 {"type": "{ x âˆˆ s | p x } = s â†” âˆ€ x âˆˆ s, p x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = s â†” âˆ€ x âˆˆ s, p x := by simp_rw [ext_iff]; sorry",
  "name": "sep_eq_self_iff_mem_true",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = s â†” âˆ€ x âˆˆ s, p x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±}"},
 {"type": "{ x âˆˆ s | p x } = âˆ… â†” âˆ€ x âˆˆ s, Â¬p x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = âˆ… â†” âˆ€ x âˆˆ s, Â¬p x := by simp_rw [ext_iff]; sorry",
  "name": "sep_eq_empty_iff_mem_false",
  "kind": "theorem",
  "first-tactic": "simp_rw [ext_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±} : { x âˆˆ s | p x } = âˆ… â†” âˆ€ x âˆˆ s, Â¬p x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  {p q : Î± â†’ Prop}  {x : Î±}"},
 {"type": "s âŠ† {x} â†” s = âˆ… âˆ¨ s = {x}",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±} : s âŠ† {x} â†” s = âˆ… âˆ¨ s = {x} := by obtain rfl | hs := s.eq_empty_or_nonempty; sorry",
  "name": "subset_singleton_iff_eq",
  "kind": "theorem",
  "first-tactic": "obtain rfl | hs := s.eq_empty_or_nonempty",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±} : s âŠ† {x} â†” s = âˆ… âˆ¨ s = {x}",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±}"},
 {"type": "s âŠ‚ {x} â†” s = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±} : s âŠ‚ {x} â†” s = âˆ… := by rw [ssubset_iff_subset_ne]; sorry",
  "name": "ssubset_singleton_iff",
  "kind": "theorem",
  "first-tactic": "rw [ssubset_iff_subset_ne]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±} : s âŠ‚ {x} â†” s = âˆ…",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}  {x : Î±}"},
 {"type": "Disjoint s t â†” âˆ€ â¦ƒaâ¦„, a âˆˆ t â†’ a âˆ‰ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Disjoint s t â†” âˆ€ â¦ƒaâ¦„, a âˆˆ t â†’ a âˆ‰ s := by rw [Disjoint.comm]; sorry",
  "name": "disjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [Disjoint.comm]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Disjoint s t â†” âˆ€ â¦ƒaâ¦„, a âˆˆ t â†’ a âˆ‰ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "sá¶œ âˆª s = univ",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±) : sá¶œ âˆª s = univ := by rw [union_comm]; sorry",
  "name": "compl_union_self",
  "kind": "theorem",
  "first-tactic": "rw [union_comm]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±) : sá¶œ âˆª s = univ",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±)"},
 {"type": "s \\ t = tá¶œ âˆ© s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s \\ t = tá¶œ âˆ© s := by rw [diff_eq]; sorry",
  "name": "diff_eq_compl_inter",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±} : s \\ t = tá¶œ âˆ© s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s t : Set Î±}"},
 {"type": "s \\ t âˆª s âˆ© t = s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s \\ t âˆª s âˆ© t = s := by rw [union_comm]; sorry",
  "name": "diff_union_inter",
  "kind": "theorem",
  "first-tactic": "rw [union_comm]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s \\ t âˆª s âˆ© t = s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±)"},
 {"type": "s \\ {x} âŠ† t â†” s âŠ† insert x t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x : Î±}  {s t : Set Î±} : s \\ {x} âŠ† t â†” s âŠ† insert x t := by rw [â† union_singleton]; sorry",
  "name": "diff_singleton_subset_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† union_singleton]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x : Î±}  {s t : Set Î±} : s \\ {x} âŠ† t â†” s âŠ† insert x t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {x : Î±}  {s t : Set Î±}"},
 {"type": "s âŠ† insert x (s \\ {x})",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (x : Î±)  (s : Set Î±) : s âŠ† insert x (s \\ {x}) := by rw [â† diff_singleton_subset_iff]; sorry",
  "name": "subset_insert_diff_singleton",
  "kind": "theorem",
  "first-tactic": "rw [â† diff_singleton_subset_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (x : Î±)  (s : Set Î±) : s âŠ† insert x (s \\ {x})",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (x : Î±)  (s : Set Î±)"},
 {"type": "insert a s \\ {a} = s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s) : insert a s \\ {a} = s := by ext x; sorry",
  "name": "insert_diff_self_of_not_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s) : insert a s \\ {a} = s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s)"},
 {"type": "insert a s \\ s = {a}",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s) : insert a s \\ s = {a} := by ext; sorry",
  "name": "insert_diff_eq_singleton",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s) : insert a s \\ s = {a}",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}  (h : a âˆ‰ s)"},
 {"type": "s âˆ© insert a t = insert a (s âˆ© t)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ s) : s âˆ© insert a t = insert a (s âˆ© t) := by rw [insert_inter_distrib]; sorry",
  "name": "inter_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_inter_distrib]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ s) : s âˆ© insert a t = insert a (s âˆ© t)",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ s)"},
 {"type": "insert a s âˆ© t = insert a (s âˆ© t)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ t) : insert a s âˆ© t = insert a (s âˆ© t) := by rw [insert_inter_distrib]; sorry",
  "name": "insert_inter_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_inter_distrib]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ t) : insert a s âˆ© t = insert a (s âˆ© t)",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (h : a âˆˆ t)"},
 {"type": "insert a (s \\ {a}) = insert a s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±} : insert a (s \\ {a}) = insert a s := by simp [insert_eq]; sorry",
  "name": "insert_diff_singleton",
  "kind": "theorem",
  "first-tactic": "simp [insert_eq]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±} : insert a (s \\ {a}) = insert a s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {a : Î±}  {s : Set Î±}"},
 {"type":
  "(x âˆˆ if h : p then s h else t h) â†” (âˆ€ h : p, x âˆˆ s h) âˆ§ âˆ€ h : Â¬p, x âˆˆ t h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p â†’ Set Î±)  (t : Â¬ p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then s h else t h) â†” (âˆ€ h : p, x âˆˆ s h) âˆ§ âˆ€ h : Â¬p, x âˆˆ t h := by split_ifs with hp; sorry",
  "name": "mem_dite",
  "kind": "theorem",
  "first-tactic": "split_ifs with hp",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p â†’ Set Î±)  (t : Â¬ p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then s h else t h) â†” (âˆ€ h : p, x âˆˆ s h) âˆ§ âˆ€ h : Â¬p, x âˆˆ t h",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (s : p â†’ Set Î±)  (t : Â¬ p â†’ Set Î±)  (x : Î±)"},
 {"type": "(x âˆˆ if h : p then t h else univ) â†” âˆ€ h : p, x âˆˆ t h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then t h else univ) â†” âˆ€ h : p, x âˆˆ t h := by simp [mem_dite]; sorry",
  "name": "mem_dite_univ_right",
  "kind": "theorem",
  "first-tactic": "simp [mem_dite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then t h else univ) â†” âˆ€ h : p, x âˆˆ t h",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±)"},
 {"type": "(x âˆˆ if h : p then univ else t h) â†” âˆ€ h : Â¬p, x âˆˆ t h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then univ else t h) â†” âˆ€ h : Â¬p, x âˆˆ t h := by simp [mem_dite]; sorry",
  "name": "mem_dite_univ_left",
  "kind": "theorem",
  "first-tactic": "simp [mem_dite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then univ else t h) â†” âˆ€ h : Â¬p, x âˆˆ t h",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±)"},
 {"type": "(x âˆˆ if h : p then t h else âˆ…) â†” âˆƒ h : p, x âˆˆ t h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then t h else âˆ…) â†” âˆƒ h : p, x âˆˆ t h := by simp only [mem_dite]; sorry",
  "name": "mem_dite_empty_right",
  "kind": "theorem",
  "first-tactic": "simp only [mem_dite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then t h else âˆ…) â†” âˆƒ h : p, x âˆˆ t h",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : p â†’ Set Î±)  (x : Î±)"},
 {"type": "(x âˆˆ if h : p then âˆ… else t h) â†” âˆƒ h : Â¬p, x âˆˆ t h",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then âˆ… else t h) â†” âˆƒ h : Â¬p, x âˆˆ t h := by simp only [mem_dite]; sorry",
  "name": "mem_dite_empty_left",
  "kind": "theorem",
  "first-tactic": "simp only [mem_dite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±) : (x âˆˆ if h : p then âˆ… else t h) â†” âˆƒ h : Â¬p, x âˆˆ t h",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (p : Prop)  [Decidable p]  (t : Â¬p â†’ Set Î±)  (x : Î±)"},
 {"type": "t.ite s s' âˆ© t = s âˆ© t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : t.ite s s' âˆ© t = s âˆ© t := by rw [Set.ite]; sorry",
  "name": "ite_inter_self",
  "kind": "theorem",
  "first-tactic": "rw [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : t.ite s s' âˆ© t = s âˆ© t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±)"},
 {"type": "tá¶œ.ite s s' = t.ite s' s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : tá¶œ.ite s s' = t.ite s' s := by rw [Set.ite]; sorry",
  "name": "ite_compl",
  "kind": "theorem",
  "first-tactic": "rw [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : tá¶œ.ite s s' = t.ite s' s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±)"},
 {"type": "t.ite s s' âˆ© tá¶œ = s' âˆ© tá¶œ",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : t.ite s s' âˆ© tá¶œ = s' âˆ© tá¶œ := by rw [â† ite_compl]; sorry",
  "name": "ite_inter_compl_self",
  "kind": "theorem",
  "first-tactic": "rw [â† ite_compl]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±) : t.ite s s' âˆ© tá¶œ = s' âˆ© tá¶œ",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s s' : Set Î±)"},
 {"type": "s.ite s t = s âˆª t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s.ite s t = s âˆª t := by simp [Set.ite]; sorry",
  "name": "ite_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s.ite s t = s âˆª t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±)"},
 {"type": "s.ite t s = t âˆ© s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s.ite t s = t âˆ© s := by simp [Set.ite]; sorry",
  "name": "ite_right",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±) : s.ite t s = t âˆ© s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s t : Set Î±)"},
 {"type": "Set.ite âˆ… s s' = s'",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±) : Set.ite âˆ… s s' = s' := by simp [Set.ite]; sorry",
  "name": "ite_empty",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±) : Set.ite âˆ… s s' = s'",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±)"},
 {"type": "Set.ite univ s s' = s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±) : Set.ite univ s s' = s := by simp [Set.ite]; sorry",
  "name": "ite_univ",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±) : Set.ite univ s s' = s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s s' : Set Î±)"},
 {"type": "t.ite âˆ… s = s \\ t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±) : t.ite âˆ… s = s \\ t := by simp [Set.ite]; sorry",
  "name": "ite_empty_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±) : t.ite âˆ… s = s \\ t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±)"},
 {"type": "t.ite s âˆ… = s âˆ© t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±) : t.ite s âˆ… = s âˆ© t := by simp [Set.ite]; sorry",
  "name": "ite_empty_right",
  "kind": "theorem",
  "first-tactic": "simp [Set.ite]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±) : t.ite s âˆ… = s âˆ© t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t s : Set Î±)"},
 {"type": "t.ite (sâ‚ âˆ© sâ‚‚) (sâ‚' âˆ© sâ‚‚') = t.ite sâ‚ sâ‚' âˆ© t.ite sâ‚‚ sâ‚‚'",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ sâ‚' sâ‚‚' : Set Î±) : t.ite (sâ‚ âˆ© sâ‚‚) (sâ‚' âˆ© sâ‚‚') = t.ite sâ‚ sâ‚' âˆ© t.ite sâ‚‚ sâ‚‚' := by ext x; sorry",
  "name": "ite_inter_inter",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ sâ‚' sâ‚‚' : Set Î±) : t.ite (sâ‚ âˆ© sâ‚‚) (sâ‚' âˆ© sâ‚‚') = t.ite sâ‚ sâ‚' âˆ© t.ite sâ‚‚ sâ‚‚'",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ sâ‚' sâ‚‚' : Set Î±)"},
 {"type": "t.ite (sâ‚ âˆ© s) (sâ‚‚ âˆ© s) = t.ite sâ‚ sâ‚‚ âˆ© s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ s : Set Î±) : t.ite (sâ‚ âˆ© s) (sâ‚‚ âˆ© s) = t.ite sâ‚ sâ‚‚ âˆ© s := by rw [ite_inter_inter]; sorry",
  "name": "ite_inter",
  "kind": "theorem",
  "first-tactic": "rw [ite_inter_inter]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ s : Set Î±) : t.ite (sâ‚ âˆ© s) (sâ‚‚ âˆ© s) = t.ite sâ‚ sâ‚‚ âˆ© s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t sâ‚ sâ‚‚ s : Set Î±)"},
 {"type": "t.ite sâ‚ sâ‚‚ âˆ© s = sâ‚ âˆ© s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t : Set Î±)  {sâ‚ sâ‚‚ s : Set Î±}  (h : sâ‚ âˆ© s = sâ‚‚ âˆ© s) : t.ite sâ‚ sâ‚‚ âˆ© s = sâ‚ âˆ© s := by rw [â† ite_inter]; sorry",
  "name": "ite_inter_of_inter_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† ite_inter]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t : Set Î±)  {sâ‚ sâ‚‚ s : Set Î±}  (h : sâ‚ âˆ© s = sâ‚‚ âˆ© s) : t.ite sâ‚ sâ‚‚ âˆ© s = sâ‚ âˆ© s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (t : Set Î±)  {sâ‚ sâ‚‚ s : Set Î±}  (h : sâ‚ âˆ© s = sâ‚‚ âˆ© s)"},
 {"type": "u âŠ† t.ite s s' â†” u âˆ© t âŠ† s âˆ§ u \\ t âŠ† s'",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {t s s' u : Set Î±} : u âŠ† t.ite s s' â†” u âˆ© t âŠ† s âˆ§ u \\ t âŠ† s' := by simp only [subset_def]; sorry",
  "name": "subset_ite",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {t s s' u : Set Î±} : u âŠ† t.ite s s' â†” u âˆ© t âŠ† s âˆ§ u \\ t âŠ† s'",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {t s s' u : Set Î±}"},
 {"type": "p s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Set Î± â†’ Prop}  (hs : s.Subsingleton)  (he : p âˆ…)      (hâ‚ : âˆ€ x, p {x}) : p s := by rcases hs.eq_empty_or_singleton with (rfl | âŸ¨x, rflâŸ©); sorry",
  "name": "Subsingleton.induction_on",
  "kind": "theorem",
  "first-tactic": "rcases hs.eq_empty_or_singleton with (rfl | âŸ¨x, rflâŸ©)",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Set Î± â†’ Prop}  (hs : s.Subsingleton)  (he : p âˆ…)      (hâ‚ : âˆ€ x, p {x}) : p s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {p : Set Î± â†’ Prop}  (hs : s.Subsingleton)  (he : p âˆ…)      (hâ‚ : âˆ€ x, p {x})"},
 {"type": "(âˆƒ a : Î±, s = {a}) â†” s.Nonempty âˆ§ s.Subsingleton",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (âˆƒ a : Î±, s = {a}) â†” s.Nonempty âˆ§ s.Subsingleton := by refine' âŸ¨_, fun h => _âŸ©; sorry",
  "name": "exists_eq_singleton_iff_nonempty_subsingleton",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, fun h => _âŸ©",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : (âˆƒ a : Î±, s = {a}) â†” s.Nonempty âˆ§ s.Subsingleton",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "Subsingleton s â†” s.Subsingleton",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±) : Subsingleton s â†” s.Subsingleton := by constructor; sorry",
  "name": "subsingleton_coe",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±) : Subsingleton s â†” s.Subsingleton",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later (s : Set Î±)"},
 {"type": "Subsingleton s",
  "tactic-prompt":
  "instance {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±]  {s : Set Î±} : Subsingleton s := by rw [s.subsingleton_coe]; sorry",
  "name": "subsingleton_coe_of_subsingleton",
  "kind": "instance",
  "first-tactic": "rw [s.subsingleton_coe]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±]  {s : Set Î±} : Subsingleton s",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later [Subsingleton Î±]  {s : Set Î±}"},
 {"type": "Nontrivial s â†” s.Nontrivial",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±} : Nontrivial s â†” s.Nontrivial := by rw [â† nontrivial_univ_iff]; sorry",
  "name": "nontrivial_coe_sort",
  "kind": "theorem",
  "first-tactic": "rw [â† nontrivial_univ_iff]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±} : Nontrivial s â†” s.Nontrivial",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {s : Set Î±}"},
 {"type": "Â¬s.Subsingleton â†” s.Nontrivial",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Â¬s.Subsingleton â†” s.Nontrivial := by simp_rw [Set.Subsingleton]; sorry",
  "name": "not_subsingleton_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [Set.Subsingleton]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later : Â¬s.Subsingleton â†” s.Nontrivial",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later"},
 {"type": "MonotoneOn f s â†”\n    Monotone fun a : s => f a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : MonotoneOn f s â†”\n    Monotone fun a : s => f a := by simp [Monotone]; sorry",
  "name": "monotoneOn_iff_monotone",
  "kind": "theorem",
  "first-tactic": "simp [Monotone]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : MonotoneOn f s â†”\n    Monotone fun a : s => f a",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "AntitoneOn f s â†”\n    Antitone fun a : s => f a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : AntitoneOn f s â†”\n    Antitone fun a : s => f a := by simp [Antitone]; sorry",
  "name": "antitoneOn_iff_antitone",
  "kind": "theorem",
  "first-tactic": "simp [Antitone]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : AntitoneOn f s â†”\n    Antitone fun a : s => f a",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "StrictMonoOn f s â†”\n    StrictMono fun a : s => f a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictMonoOn f s â†”\n    StrictMono fun a : s => f a := by simp [StrictMono]; sorry",
  "name": "strictMonoOn_iff_strictMono",
  "kind": "theorem",
  "first-tactic": "simp [StrictMono]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictMonoOn f s â†”\n    StrictMono fun a : s => f a",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type": "StrictAntiOn f s â†”\n    StrictAnti fun a : s => f a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictAntiOn f s â†”\n    StrictAnti fun a : s => f a := by simp [StrictAnti]; sorry",
  "name": "strictAntiOn_iff_strictAnti",
  "kind": "theorem",
  "first-tactic": "simp [StrictAnti]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas. : StrictAntiOn f s â†”\n    StrictAnti fun a : s => f a",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  -- Porting note: -- If we decide we want `Elem` to semireducible rather than reducible, we will need: --   instance : Preorder (â†‘s) := Subtype.instPreorderSubtype _ -- here, along with appropriate lemmas."},
 {"type":
  "Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a â‰¤ b âˆ§ b â‰¤ c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²} : Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a â‰¤ b âˆ§ b â‰¤ c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c) := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "not_monotoneOn_not_antitoneOn_iff_exists_le_le",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²} : Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a â‰¤ b âˆ§ b â‰¤ c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}"},
 {"type":
  "Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a < b âˆ§ b < c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²} : Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a < b âˆ§ b < c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c) := by simp [monotoneOn_iff_monotone]; sorry",
  "name": "not_monotoneOn_not_antitoneOn_iff_exists_lt_lt",
  "kind": "theorem",
  "first-tactic": "simp [monotoneOn_iff_monotone]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²} : Â¬MonotoneOn f s âˆ§ Â¬AntitoneOn f s â†”\n      âˆƒ (a : Î±) (_ : a âˆˆ s) (b : Î±) (_ : b âˆˆ s) (c : Î±) (_ : c âˆˆ s),\n        a < b âˆ§ b < c âˆ§ (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}"},
 {"type": "(f s).Nonempty â†” s.Nonempty",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {f : Set Î± â†’ Set Î²}  (hf : Injective f)  (h2 : f âˆ… = âˆ…)      {s : Set Î±} : (f s).Nonempty â†” s.Nonempty := by rw [nonempty_iff_ne_empty]; sorry",
  "name": "Injective.nonempty_apply_iff",
  "kind": "theorem",
  "first-tactic": "rw [nonempty_iff_ne_empty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {f : Set Î± â†’ Set Î²}  (hf : Injective f)  (h2 : f âˆ… = âˆ…)      {s : Set Î±} : (f s).Nonempty â†” s.Nonempty",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {f : Set Î± â†’ Set Î²}  (hf : Injective f)  (h2 : f âˆ… = âˆ…)      {s : Set Î±}"},
 {"type": "inclusion Subset.rfl x = x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (x : s) : inclusion Subset.rfl x = x := by cases x; sorry",
  "name": "inclusion_self",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (x : s) : inclusion Subset.rfl x = x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (x : s)"},
 {"type": "inclusion h âŸ¨x, mâŸ© = x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (h : s âŠ† t)  (x : t)  (m : (x : Î±) âˆˆ s) : inclusion h âŸ¨x, mâŸ© = x := by cases x; sorry",
  "name": "inclusion_right",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (h : s âŠ† t)  (x : t)  (m : (x : Î±) âˆˆ s) : inclusion h âŸ¨x, mâŸ© = x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (h : s âŠ† t)  (x : t)  (m : (x : Î±) âˆˆ s)"},
 {"type": "inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (hst : s âŠ† t)  (htu : t âŠ† u)  (x : s) : inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x := by cases x; sorry",
  "name": "inclusion_inclusion",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (hst : s âŠ† t)  (htu : t âŠ† u)  (x : s) : inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} (hst : s âŠ† t)  (htu : t âŠ† u)  (x : s)"},
 {"type": "s = t",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} {s t : Set Î±}  {h : s âŠ† t}      (h_surj : Function.Surjective (inclusion h)) : s = t := by refine' Set.Subset.antisymm h (fun x hx => _); sorry",
  "name": "eq_of_inclusion_surjective",
  "kind": "theorem",
  "first-tactic": "refine' Set.Subset.antisymm h (fun x hx => _)",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} {s t : Set Î±}  {h : s âŠ† t}      (h_surj : Function.Surjective (inclusion h)) : s = t",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²}  {Î± : Type _}  {s t u : Set Î±} {s t : Set Î±}  {h : s âŠ† t}      (h_surj : Function.Surjective (inclusion h))"},
 {"type": "Decidable (a âˆˆ { a | p a })",
  "tactic-prompt":
  "instance {Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  [Subsingleton Î±] {Î± : Type u}  (s t : Set Î±)  (a : Î±) (p : Î± â†’ Prop)  [Decidable (p a)] : Decidable (a âˆˆ { a | p a }) := by assumption; sorry",
  "name": "decidableSetOf",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  [Subsingleton Î±] {Î± : Type u}  (s t : Set Î±)  (a : Î±) (p : Î± â†’ Prop)  [Decidable (p a)] : Decidable (a âˆˆ { a | p a })",
  "args":
  "{Î± : Type _}  {s t : Set Î±} {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {a b : Î±}  {s t u : Set Î±}  -- Porting note: remove `noncomputable` later {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  [Subsingleton Î±] {Î± : Type u}  (s t : Set Î±)  (a : Î±) (p : Î± â†’ Prop)  [Decidable (p a)]"},
 {"type": "s.restrict f '' (Subtype.val â»Â¹' t) = f '' (t âˆ© s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (s t : Set Î±) : s.restrict f '' (Subtype.val â»Â¹' t) = f '' (t âˆ© s) := by rw [restrict_eq]; sorry",
  "name": "image_restrict",
  "kind": "theorem",
  "first-tactic": "rw [restrict_eq]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (s t : Set Î±) : s.restrict f '' (Subtype.val â»Â¹' t) = f '' (t âˆ© s)",
  "args": "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (s t : Set Î±)"},
 {"type": "(range f).restrict (extend f g g') = fun x => g x.coe_prop.choose",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose := by classical\n  exact restrict_dite _ _; sorry",
  "name": "restrict_extend_range",
  "kind": "theorem",
  "first-tactic": "classical\n  exact restrict_dite _ _",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³)"},
 {"type": "range fá¶œ.restrict (extend f g g') = g' âˆ˜ Subtype.val",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range fá¶œ.restrict (extend f g g') = g' âˆ˜ Subtype.val := by classical\n  exact restrict_dite_compl _ _; sorry",
  "name": "restrict_extend_compl_range",
  "kind": "theorem",
  "first-tactic": "classical\n  exact restrict_dite_compl _ _",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range fá¶œ.restrict (extend f g g') = g' âˆ˜ Subtype.val",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³)"},
 {"type": "range (extend f g g') âŠ† range g âˆª g' '' range fá¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range (extend f g g') âŠ† range g âˆª g' '' range fá¶œ := by classical\n  rintro _ âŸ¨y, rflâŸ©\n  rw [extend_def]\n  split_ifs with h\n  exacts[Or.inl (mem_range_self _), Or.inr (mem_image_of_mem _ h)]; sorry",
  "name": "range_extend_subset",
  "kind": "theorem",
  "first-tactic":
  "classical\n  rintro _ âŸ¨y, rflâŸ©\n  rw [extend_def]\n  split_ifs with h\n  exacts[Or.inl (mem_range_self _), Or.inr (mem_image_of_mem _ h)]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range (extend f g g') âŠ† range g âˆª g' '' range fá¶œ",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³)"},
 {"type": "range (extend f g g') = range g âˆª g' '' range fá¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î± â†’ Î²}  (hf : Injective f)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range (extend f g g') = range g âˆª g' '' range fá¶œ := by refine' (range_extend_subset _ _ _).antisymm _; sorry",
  "name": "range_extend",
  "kind": "theorem",
  "first-tactic": "refine' (range_extend_subset _ _ _).antisymm _",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î± â†’ Î²}  (hf : Injective f)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³) : range (extend f g g') = range g âˆª g' '' range fá¶œ",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î± â†’ Î²}  (hf : Injective f)  (g : Î± â†’ Î³)  (g' : Î² â†’ Î³)"},
 {"type": "Injective (codRestrict f s h) â†” Injective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î¹ â†’ Î±}  {s : Set Î±}  (h : âˆ€ x, f x âˆˆ s) : Injective (codRestrict f s h) â†” Injective f := by simp only [Injective]; sorry",
  "name": "injective_codRestrict",
  "kind": "theorem",
  "first-tactic": "simp only [Injective]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î¹ â†’ Î±}  {s : Set Î±}  (h : âˆ€ x, f x âˆˆ s) : Injective (codRestrict f s h) â†” Injective f",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {f : Î¹ â†’ Î±}  {s : Set Î±}  (h : âˆ€ x, f x âˆˆ s)"},
 {"type": "MonotoneOn fâ‚‚ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : MonotoneOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚) : MonotoneOn fâ‚‚ s := by intro a ha b hb hab; sorry",
  "name": "_root_.MonotoneOn.congr",
  "kind": "theorem",
  "first-tactic": "intro a ha b hb hab",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : MonotoneOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚) : MonotoneOn fâ‚‚ s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : MonotoneOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚)"},
 {"type": "StrictMonoOn fâ‚‚ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : StrictMonoOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚) : StrictMonoOn fâ‚‚ s := by intro a ha b hb hab; sorry",
  "name": "_root_.StrictMonoOn.congr",
  "kind": "theorem",
  "first-tactic": "intro a ha b hb hab",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : StrictMonoOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚) : StrictMonoOn fâ‚‚ s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Preorder Î±]  [Preorder Î²] (hâ‚ : StrictMonoOn fâ‚ s)  (h : s.EqOn fâ‚ fâ‚‚)"},
 {"type": "h.restrict f s s^[n] = (h.iterate n).restrict _ _ _",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î±}  {s : Set Î±}  (h : MapsTo f s s)  (n : â„•) : h.restrict f s s^[n] = (h.iterate n).restrict _ _ _ := by funext x; sorry",
  "name": "MapsTo.iterate_restrict",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î±}  {s : Set Î±}  (h : MapsTo f s s)  (n : â„•) : h.restrict f s s^[n] = (h.iterate n).restrict _ _ _",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î±}  {s : Set Î±}  (h : MapsTo f s s)  (n : â„•)"},
 {"type": "MapsTo f s (f '' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (s : Set Î±) : MapsTo f s (f '' s) := by rw [mapsTo']; sorry",
  "name": "mapsTo_image",
  "kind": "theorem",
  "first-tactic": "rw [mapsTo']",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (s : Set Î±) : MapsTo f s (f '' s)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (s : Set Î±)"},
 {"type": "MapsTo f (range g) s â†” MapsTo (f âˆ˜ g) univ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (g : Î³ â†’ Î±)  (s : Set Î²) : MapsTo f (range g) s â†” MapsTo (f âˆ˜ g) univ s := by rw [â† image_univ]; sorry",
  "name": "maps_range_to",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (g : Î³ â†’ Î±)  (s : Set Î²) : MapsTo f (range g) s â†” MapsTo (f âˆ˜ g) univ s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (f : Î± â†’ Î²)  (g : Î³ â†’ Î±)  (s : Set Î²)"},
 {"type": "range (t.restrictPreimage f) = Subtype.val â»Â¹' range f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : range (t.restrictPreimage f) = Subtype.val â»Â¹' range f := by delta Set.restrictPreimage; sorry",
  "name": "range_restrictPreimage",
  "kind": "theorem",
  "first-tactic": "delta Set.restrictPreimage",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : range (t.restrictPreimage f) = Subtype.val â»Â¹' range f",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}"},
 {"type":
  "InjOn f (sâ‚ âˆª sâ‚‚) â†” InjOn f sâ‚ âˆ§ InjOn f sâ‚‚ âˆ§ âˆ€ x âˆˆ sâ‚, âˆ€ y âˆˆ sâ‚‚, f x â‰  f y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Disjoint sâ‚ sâ‚‚) : InjOn f (sâ‚ âˆª sâ‚‚) â†” InjOn f sâ‚ âˆ§ InjOn f sâ‚‚ âˆ§ âˆ€ x âˆˆ sâ‚, âˆ€ y âˆˆ sâ‚‚, f x â‰  f y := by refine' âŸ¨fun H => âŸ¨H.mono <| subset_union_left _ _, H.mono <| subset_union_right _ _, _âŸ©, _âŸ©; sorry",
  "name": "injOn_union",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun H => âŸ¨H.mono <| subset_union_left _ _, H.mono <| subset_union_right _ _, _âŸ©, _âŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Disjoint sâ‚ sâ‚‚) : InjOn f (sâ‚ âˆª sâ‚‚) â†” InjOn f sâ‚ âˆ§ InjOn f sâ‚‚ âˆ§ âˆ€ x âˆˆ sâ‚, âˆ€ y âˆˆ sâ‚‚, f x â‰  f y",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Disjoint sâ‚ sâ‚‚)"},
 {"type": "Set.InjOn f (insert a s) â†” Set.InjOn f s âˆ§ f a âˆ‰ f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  (has : a âˆ‰ s) : Set.InjOn f (insert a s) â†” Set.InjOn f s âˆ§ f a âˆ‰ f '' s := by have : Disjoint s {a} := disjoint_iff_inf_le.mpr fun x âŸ¨hxs, (hxa : x = a)âŸ© => has (hxa â–¸ hxs); sorry",
  "name": "injOn_insert",
  "kind": "theorem",
  "first-tactic":
  "have : Disjoint s {a} := disjoint_iff_inf_le.mpr fun x âŸ¨hxs, (hxa : x = a)âŸ© => has (hxa â–¸ hxs)",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  (has : a âˆ‰ s) : Set.InjOn f (insert a s) â†” Set.InjOn f s âˆ§ f a âˆ‰ f '' s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  (has : a âˆ‰ s)"},
 {"type": "InjOn g (range f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Injective (g âˆ˜ f)) : InjOn g (range f) := by rintro _ âŸ¨x, rflâŸ© _ âŸ¨y, rflâŸ© H; sorry",
  "name": "_root_.Function.Injective.injOn_range",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨x, rflâŸ© _ âŸ¨y, rflâŸ© H",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Injective (g âˆ˜ f)) : InjOn g (range f)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : Injective (g âˆ˜ f))"},
 {"type": "Injective (h.restrict f s t) â†” InjOn f s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : MapsTo f s t) : Injective (h.restrict f s t) â†” InjOn f s := by rw [h.restrict_eq_codRestrict]; sorry",
  "name": "MapsTo.restrict_inj",
  "kind": "theorem",
  "first-tactic": "rw [h.restrict_eq_codRestrict]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : MapsTo f s t) : Injective (h.restrict f s t) â†” InjOn f s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} (h : MapsTo f s t)"},
 {"type": "(âˆƒ f : Î± â†’ Î², InjOn f s) â†” âˆƒ f : s â†’ Î², Injective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} [Nonempty Î²] : (âˆƒ f : Î± â†’ Î², InjOn f s) â†” âˆƒ f : s â†’ Î², Injective f := by classical\n  refine âŸ¨fun âŸ¨f, hfâŸ© => âŸ¨_, hf.injectiveâŸ©, fun âŸ¨f, hfâŸ© => ?_âŸ©\n  refine âŸ¨fun x => if h : x âˆˆ s then f âŸ¨x, hâŸ© else _root_.Nonempty.some â€¹_â€º, ?_âŸ©\n  refine injOn_iff_injective.2 ?_\n  rw [Set.restrict_dite]\n  exact hf; sorry",
  "name": "exists_injOn_iff_injective",
  "kind": "theorem",
  "first-tactic":
  "classical\n  refine âŸ¨fun âŸ¨f, hfâŸ© => âŸ¨_, hf.injectiveâŸ©, fun âŸ¨f, hfâŸ© => ?_âŸ©\n  refine âŸ¨fun x => if h : x âˆˆ s then f âŸ¨x, hâŸ© else _root_.Nonempty.some â€¹_â€º, ?_âŸ©\n  refine injOn_iff_injective.2 ?_\n  rw [Set.restrict_dite]\n  exact hf",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} [Nonempty Î²] : (âˆƒ f : Î± â†’ Î², InjOn f s) â†” âˆƒ f : s â†’ Î², Injective f",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} [Nonempty Î²]"},
 {"type": "SurjOn fâ‚‚ s t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (h : SurjOn fâ‚ s t)  (H : EqOn fâ‚ fâ‚‚ s) : SurjOn fâ‚‚ s t := by rwa [SurjOn]; sorry",
  "name": "SurjOn.congr",
  "kind": "theorem",
  "first-tactic": "rwa [SurjOn]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (h : SurjOn fâ‚ s t)  (H : EqOn fâ‚ fâ‚‚ s) : SurjOn fâ‚‚ s t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (h : SurjOn fâ‚ s t)  (H : EqOn fâ‚ fâ‚‚ s)"},
 {"type": "SurjOn f (sâ‚ âˆ© sâ‚‚) (tâ‚ âˆ© tâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hâ‚ : SurjOn f sâ‚ tâ‚)  (hâ‚‚ : SurjOn f sâ‚‚ tâ‚‚)  (h : InjOn f (sâ‚ âˆª sâ‚‚)) : SurjOn f (sâ‚ âˆ© sâ‚‚) (tâ‚ âˆ© tâ‚‚) := by intro y hy; sorry",
  "name": "SurjOn.inter_inter",
  "kind": "theorem",
  "first-tactic": "intro y hy",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hâ‚ : SurjOn f sâ‚ tâ‚)  (hâ‚‚ : SurjOn f sâ‚‚ tâ‚‚)  (h : InjOn f (sâ‚ âˆª sâ‚‚)) : SurjOn f (sâ‚ âˆ© sâ‚‚) (tâ‚ âˆ© tâ‚‚)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hâ‚ : SurjOn f sâ‚ tâ‚)  (hâ‚‚ : SurjOn f sâ‚‚ tâ‚‚)  (h : InjOn f (sâ‚ âˆª sâ‚‚))"},
 {"type": "Surjective f â†” SurjOn f univ univ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : Surjective f â†” SurjOn f univ univ := by simp [Surjective]; sorry",
  "name": "surjective_iff_surjOn_univ",
  "kind": "theorem",
  "first-tactic": "simp [Surjective]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : Surjective f â†” SurjOn f univ univ",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}"},
 {"type": "f '' s = t â†” s.SurjOn f t âˆ§ s.MapsTo f t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : f '' s = t â†” s.SurjOn f t âˆ§ s.MapsTo f t := by refine' âŸ¨_, fun h => h.1.image_eq_of_mapsTo h.2âŸ©; sorry",
  "name": "image_eq_iff_surjOn_mapsTo",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, fun h => h.1.image_eq_of_mapsTo h.2âŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²} : f '' s = t â†” s.SurjOn f t âˆ§ s.MapsTo f t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}"},
 {"type": "t.EqOn gâ‚ gâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : s.EqOn (gâ‚ âˆ˜ f) (gâ‚‚ âˆ˜ f))  (hf' : s.SurjOn f t) : t.EqOn gâ‚ gâ‚‚ := by intro b hb; sorry",
  "name": "EqOn.cancel_right",
  "kind": "theorem",
  "first-tactic": "intro b hb",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : s.EqOn (gâ‚ âˆ˜ f) (gâ‚‚ âˆ˜ f))  (hf' : s.SurjOn f t) : t.EqOn gâ‚ gâ‚‚",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : s.EqOn (gâ‚ âˆ˜ f) (gâ‚‚ âˆ˜ f))  (hf' : s.SurjOn f t)"},
 {"type": "f '' (sâ‚ âˆ© s) = f' â»Â¹' sâ‚ âˆ© f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f '' (sâ‚ âˆ© s) = f' â»Â¹' sâ‚ âˆ© f '' s := by apply Subset.antisymm; sorry",
  "name": "LeftInvOn.image_inter'",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f '' (sâ‚ âˆ© s) = f' â»Â¹' sâ‚ âˆ© f '' s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s)"},
 {"type": "f '' (sâ‚ âˆ© s) = f' â»Â¹' (sâ‚ âˆ© s) âˆ© f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f '' (sâ‚ âˆ© s) = f' â»Â¹' (sâ‚ âˆ© s) âˆ© f '' s := by rw [hf.image_inter']; sorry",
  "name": "LeftInvOn.image_inter",
  "kind": "theorem",
  "first-tactic": "rw [hf.image_inter']",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f '' (sâ‚ âˆ© s) = f' â»Â¹' (sâ‚ âˆ© s) âˆ© f '' s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s)"},
 {"type": "f' '' (f '' s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f' '' (f '' s) = s := by rw [Set.image_image]; sorry",
  "name": "LeftInvOn.image_image",
  "kind": "theorem",
  "first-tactic": "rw [Set.image_image]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s) : f' '' (f '' s) = s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  (hf : LeftInvOn f' f s)"},
 {"type": "invFunOn f s b âˆˆ s âˆ§ f (invFunOn f s b) = b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a âˆˆ s, f a = b) : invFunOn f s b âˆˆ s âˆ§ f (invFunOn f s b) = b := by rw [invFunOn]; sorry",
  "name": "invFunOn_pos",
  "kind": "theorem",
  "first-tactic": "rw [invFunOn]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a âˆˆ s, f a = b) : invFunOn f s b âˆˆ s âˆ§ f (invFunOn f s b) = b",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : âˆƒ a âˆˆ s, f a = b)"},
 {"type": "invFunOn f s b = Classical.choice â€¹Nonempty Î±â€º",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : Â¬âˆƒ a âˆˆ s, f a = b) : invFunOn f s b = Classical.choice â€¹Nonempty Î±â€º := by rw [invFunOn]; sorry",
  "name": "invFunOn_neg",
  "kind": "theorem",
  "first-tactic": "rw [invFunOn]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : Â¬âˆƒ a âˆˆ s, f a = b) : invFunOn f s b = Classical.choice â€¹Nonempty Î±â€º",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} (h : Â¬âˆƒ a âˆˆ s, f a = b)"},
 {"type": "InvOn (invFunOn f s) f (invFunOn f s '' t) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t) : InvOn (invFunOn f s) f (invFunOn f s '' t) t := by refine' âŸ¨_, h.rightInvOn_invFunOnâŸ©; sorry",
  "name": "SurjOn.invOn_invFunOn",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, h.rightInvOn_invFunOnâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t) : InvOn (invFunOn f s) f (invFunOn f s '' t) t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t)"},
 {"type": "BijOn f (invFunOn f s '' t) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t := by refine' h.invOn_invFunOn.bijOn _ (mapsTo_image _ _); sorry",
  "name": "SurjOn.bijOn_subset",
  "kind": "theorem",
  "first-tactic": "refine' h.invOn_invFunOn.bijOn _ (mapsTo_image _ _)",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Nonempty Î±]  (h : SurjOn f s t)"},
 {"type": "SurjOn f s t â†” âˆƒ (s' : _)(_ : s' âŠ† s), BijOn f s' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} : SurjOn f s t â†” âˆƒ (s' : _)(_ : s' âŠ† s), BijOn f s' t := by constructor; sorry",
  "name": "surjOn_iff_exists_bijOn_subset",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} : SurjOn f s t â†” âˆƒ (s' : _)(_ : s' âŠ† s), BijOn f s' t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²}"},
 {"type": "invFun f â»Â¹' s = f '' s âˆª range fá¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆˆ s) : invFun f â»Â¹' s = f '' s âˆª range fá¶œ := by ext x; sorry",
  "name": "preimage_invFun_of_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆˆ s) : invFun f â»Â¹' s = f '' s âˆª range fá¶œ",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆˆ s)"},
 {"type": "invFun f â»Â¹' s = f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆ‰ s) : invFun f â»Â¹' s = f '' s := by ext x; sorry",
  "name": "preimage_invFun_of_not_mem",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆ‰ s) : invFun f â»Â¹' s = f '' s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [n : Nonempty Î±]  {f : Î± â†’ Î²}  (hf : Injective f)  {s : Set Î±}      (h : Classical.choice n âˆ‰ s)"},
 {"type": "piecewise âˆ… f g = g",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (âˆ… : Set Î±))] : piecewise âˆ… f g = g := by ext i; sorry",
  "name": "piecewise_empty",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (âˆ… : Set Î±))] : piecewise âˆ… f g = g",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (âˆ… : Set Î±))]"},
 {"type": "piecewise Set.univ f g = f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (Set.univ : Set Î±))] : piecewise Set.univ f g = f := by ext i; sorry",
  "name": "piecewise_univ",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (Set.univ : Set Î±))] : piecewise Set.univ f g = f",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ i : Î±, Decidable (i âˆˆ (Set.univ : Set Î±))]"},
 {"type": "(insert j s).piecewise f g j = f j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) {j : Î±}  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g j = f j := by simp [piecewise]; sorry",
  "name": "piecewise_insert_self",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) {j : Î±}  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g j = f j",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) {j : Î±}  [âˆ€ i, Decidable (i âˆˆ insert j s)]"},
 {"type":
  "(insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [DecidableEq Î±]  (j : Î±)  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j) := by simp [piecewise]; sorry",
  "name": "piecewise_insert",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [DecidableEq Î±]  (j : Î±)  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [DecidableEq Î±]  (j : Î±)  [âˆ€ i, Decidable (i âˆˆ insert j s)]"},
 {"type": "piecewise {x} f g = Function.update g x (f x)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (x : Î±)  [âˆ€ y, Decidable (y âˆˆ ({x} : Set Î±))]  [DecidableEq Î±]      (f g : Î± â†’ Î²) : piecewise {x} f g = Function.update g x (f x) := by ext y; sorry",
  "name": "piecewise_singleton",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (x : Î±)  [âˆ€ y, Decidable (y âˆˆ ({x} : Set Î±))]  [DecidableEq Î±]      (f g : Î± â†’ Î²) : piecewise {x} f g = Function.update g x (f x)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (x : Î±)  [âˆ€ y, Decidable (y âˆˆ ({x} : Set Î±))]  [DecidableEq Î±]      (f g : Î± â†’ Î²)"},
 {"type": "s.piecewise fâ‚ fâ‚‚ â‰¤ s.piecewise gâ‚ gâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´ : Î± â†’ Type _}  [âˆ€ i, Preorder (Î´ i)]  {s : Set Î±}      [âˆ€ j, Decidable (j âˆˆ s)]  {fâ‚ fâ‚‚ gâ‚ gâ‚‚ : âˆ€ i, Î´ i}  (hâ‚ : âˆ€ i âˆˆ s, fâ‚ i â‰¤ gâ‚ i)      (hâ‚‚ : âˆ€ (i) (_ : i âˆ‰ s), fâ‚‚ i â‰¤ gâ‚‚ i) : s.piecewise fâ‚ fâ‚‚ â‰¤ s.piecewise gâ‚ gâ‚‚ := by apply piecewise_le; sorry",
  "name": "piecewise_le_piecewise",
  "kind": "theorem",
  "first-tactic": "apply piecewise_le",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´ : Î± â†’ Type _}  [âˆ€ i, Preorder (Î´ i)]  {s : Set Î±}      [âˆ€ j, Decidable (j âˆˆ s)]  {fâ‚ fâ‚‚ gâ‚ gâ‚‚ : âˆ€ i, Î´ i}  (hâ‚ : âˆ€ i âˆˆ s, fâ‚ i â‰¤ gâ‚ i)      (hâ‚‚ : âˆ€ (i) (_ : i âˆ‰ s), fâ‚‚ i â‰¤ gâ‚‚ i) : s.piecewise fâ‚ fâ‚‚ â‰¤ s.piecewise gâ‚ gâ‚‚",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´ : Î± â†’ Type _}  [âˆ€ i, Preorder (Î´ i)]  {s : Set Î±}      [âˆ€ j, Decidable (j âˆˆ s)]  {fâ‚ fâ‚‚ gâ‚ gâ‚‚ : âˆ€ i, Î´ i}  (hâ‚ : âˆ€ i âˆˆ s, fâ‚ i â‰¤ gâ‚ i)      (hâ‚‚ : âˆ€ (i) (_ : i âˆ‰ s), fâ‚‚ i â‰¤ gâ‚‚ i)"},
 {"type": "(insert j s).piecewise f g i = s.piecewise f g i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {i j : Î±}  (h : i â‰  j)  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g i = s.piecewise f g i := by simp [piecewise]; sorry",
  "name": "piecewise_insert_of_ne",
  "kind": "theorem",
  "first-tactic": "simp [piecewise]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {i j : Î±}  (h : i â‰  j)  [âˆ€ i, Decidable (i âˆˆ insert j s)] : (insert j s).piecewise f g i = s.piecewise f g i",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {i j : Î±}  (h : i â‰  j)  [âˆ€ i, Decidable (i âˆˆ insert j s)]"},
 {"type": "MapsTo (s.piecewise fâ‚ fâ‚‚) (s.ite sâ‚ sâ‚‚) (t.ite tâ‚ tâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {fâ‚ fâ‚‚ : Î± â†’ Î²}      [âˆ€ i, Decidable (i âˆˆ s)]  (hâ‚ : MapsTo fâ‚ (sâ‚ âˆ© s) (tâ‚ âˆ© t))      (hâ‚‚ : MapsTo fâ‚‚ (sâ‚‚ âˆ© sá¶œ) (tâ‚‚ âˆ© tá¶œ)) : MapsTo (s.piecewise fâ‚ fâ‚‚) (s.ite sâ‚ sâ‚‚) (t.ite tâ‚ tâ‚‚) := by refine' (hâ‚.congr _).union_union (hâ‚‚.congr _); sorry",
  "name": "MapsTo.piecewise_ite",
  "kind": "theorem",
  "first-tactic": "refine' (hâ‚.congr _).union_union (hâ‚‚.congr _)",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {fâ‚ fâ‚‚ : Î± â†’ Î²}      [âˆ€ i, Decidable (i âˆˆ s)]  (hâ‚ : MapsTo fâ‚ (sâ‚ âˆ© s) (tâ‚ âˆ© t))      (hâ‚‚ : MapsTo fâ‚‚ (sâ‚‚ âˆ© sá¶œ) (tâ‚‚ âˆ© tá¶œ)) : MapsTo (s.piecewise fâ‚ fâ‚‚) (s.ite sâ‚ sâ‚‚) (t.ite tâ‚ tâ‚‚)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {fâ‚ fâ‚‚ : Î± â†’ Î²}      [âˆ€ i, Decidable (i âˆˆ s)]  (hâ‚ : MapsTo fâ‚ (sâ‚ âˆ© s) (tâ‚ âˆ© t))      (hâ‚‚ : MapsTo fâ‚‚ (sâ‚‚ âˆ© sá¶œ) (tâ‚‚ âˆ© tá¶œ))"},
 {"type":
  "h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' : Î± â†’ Sort _}  (h : âˆ€ i, Î´ i â†’ Î´' i)  {x : Î±} : h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x := by by_cases hx : x âˆˆ s; sorry",
  "name": "apply_piecewise",
  "kind": "theorem",
  "first-tactic": "by_cases hx : x âˆˆ s",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' : Î± â†’ Sort _}  (h : âˆ€ i, Î´ i â†’ Î´' i)  {x : Î±} : h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' : Î± â†’ Sort _}  (h : âˆ€ i, Î´ i â†’ Î´' i)  {x : Î±}"},
 {"type":
  "h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' Î´'' : Î± â†’ Sort _}  (f' g' : âˆ€ i, Î´' i)  (h : âˆ€ i, Î´ i â†’ Î´' i â†’ Î´'' i)      {x : Î±} : h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x := by by_cases hx : x âˆˆ s; sorry",
  "name": "apply_piecewiseâ‚‚",
  "kind": "theorem",
  "first-tactic": "by_cases hx : x âˆˆ s",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' Î´'' : Î± â†’ Sort _}  (f' g' : âˆ€ i, Î´' i)  (h : âˆ€ i, Î´ i â†’ Î´' i â†’ Î´'' i)      {x : Î±} : h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î´' Î´'' : Î± â†’ Sort _}  (f' g' : âˆ€ i, Î´' i)  (h : âˆ€ i, Î´ i â†’ Î´' i â†’ Î´'' i)      {x : Î±}"},
 {"type": "s.piecewise f f = f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] : s.piecewise f f = f := by ext x; sorry",
  "name": "piecewise_same",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] : s.piecewise f f = f",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)]"},
 {"type": "range (s.piecewise f g) = f '' s âˆª g '' sá¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (f g : Î± â†’ Î²) : range (s.piecewise f g) = f '' s âˆª g '' sá¶œ := by ext y; sorry",
  "name": "range_piecewise",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (f g : Î± â†’ Î²) : range (s.piecewise f g) = f '' s âˆª g '' sá¶œ",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] (f g : Î± â†’ Î²)"},
 {"type":
  "Injective (s.piecewise f g) â†”\n      InjOn f s âˆ§ InjOn g (sá¶œ) âˆ§ âˆ€ x âˆˆ s, âˆ€ (y) (_ : y âˆ‰ s), f x â‰  g y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {f g : Î± â†’ Î²} : Injective (s.piecewise f g) â†”\n      InjOn f s âˆ§ InjOn g (sá¶œ) âˆ§ âˆ€ x âˆˆ s, âˆ€ (y) (_ : y âˆ‰ s), f x â‰  g y := by rw [injective_iff_injOn_univ]; sorry",
  "name": "injective_piecewise_iff",
  "kind": "theorem",
  "first-tactic": "rw [injective_iff_injOn_univ]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {f g : Î± â†’ Î²} : Injective (s.piecewise f g) â†”\n      InjOn f s âˆ§ InjOn g (sá¶œ) âˆ§ âˆ€ x âˆˆ s, âˆ€ (y) (_ : y âˆ‰ s), f x â‰  g y",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {f g : Î± â†’ Î²}"},
 {"type": "pi s (s'.piecewise t t') = pi (s âˆ© s') t âˆ© pi (s \\ s') t'",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s s' : Set Î¹)  (t t' : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s')] : pi s (s'.piecewise t t') = pi (s âˆ© s') t âˆ© pi (s \\ s') t' := by ext x; sorry",
  "name": "pi_piecewise",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s s' : Set Î¹)  (t t' : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s')] : pi s (s'.piecewise t t') = pi (s âˆ© s') t âˆ© pi (s \\ s') t'",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s s' : Set Î¹)  (t t' : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s')]"},
 {"type": "pi univ (s.piecewise t fun _ => univ) = pi s t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s)] : pi univ (s.piecewise t fun _ => univ) = pi s t := by simp; sorry",
  "name": "univ_pi_piecewise",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s)] : pi univ (s.piecewise t fun _ => univ) = pi s t",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i))      [âˆ€ x, Decidable (x âˆˆ s)]"},
 {"type": "StrictMono (s.restrict f) â†” StrictMonoOn f s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±} : StrictMono (s.restrict f) â†” StrictMonoOn f s := by simp [Set.restrict]; sorry",
  "name": "strictMono_restrict",
  "kind": "theorem",
  "first-tactic": "simp [Set.restrict]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±} : StrictMono (s.restrict f) â†” StrictMonoOn f s",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}"},
 {"type": "SurjOn fb (f '' s) (f '' t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t) := by rintro y âŸ¨x, hxt, rflâŸ©; sorry",
  "name": "surjOn_image",
  "kind": "theorem",
  "first-tactic": "rintro y âŸ¨x, hxt, rflâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : SurjOn fa s t)"},
 {"type": "SurjOn fb (range f) (range f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Surjective fa) : SurjOn fb (range f) (range f) := by rw [â† image_univ]; sorry",
  "name": "surjOn_range",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Surjective fa) : SurjOn fb (range f) (range f)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Surjective fa)"},
 {"type": "InjOn fb (f '' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s)) : InjOn fb (f '' s) := by rintro _ âŸ¨x, hx, rflâŸ© _ âŸ¨y, hy, rflâŸ© H; sorry",
  "name": "injOn_image",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨x, hx, rflâŸ© _ âŸ¨y, hy, rflâŸ© H",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s)) : InjOn fb (f '' s)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : InjOn fa s)  (hf : InjOn f (fa '' s))"},
 {"type": "InjOn fb (range f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa)) : InjOn fb (range f) := by rw [â† image_univ] at *; sorry",
  "name": "injOn_range",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ] at *",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa)) : InjOn fb (range f)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Injective fa)  (hf : InjOn f (range fa))"},
 {"type": "BijOn fb (range f) (range f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f) : BijOn fb (range f) (range f) := by rw [â† image_univ]; sorry",
  "name": "bijOn_range",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f) : BijOn fb (range f) (range f)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  (ha : Bijective fa)  (hf : Injective f)"},
 {"type": "InjOn fa (f â»Â¹' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  {s : Set Î²}  (hb : InjOn fb s)      (hf : InjOn f (f â»Â¹' s)) : InjOn fa (f â»Â¹' s) := by intro x hx y hy H; sorry",
  "name": "injOn_preimage",
  "kind": "theorem",
  "first-tactic": "intro x hx y hy H",
  "core-prompt":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  {s : Set Î²}  (hb : InjOn fb s)      (hf : InjOn f (f â»Â¹' s)) : InjOn fa (f â»Â¹' s)",
  "args":
  "{Î± Î² Î³ Î¹ : Type _}  {Ï€ : Î± â†’ Type _} {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {p : Set Î³}  {f fâ‚ fâ‚‚ fâ‚ƒ : Î± â†’ Î²}  {g gâ‚ gâ‚‚ : Î² â†’ Î³}    {f' fâ‚' fâ‚‚' : Î² â†’ Î±}  {g' : Î³ â†’ Î²}  [Nonempty Î±]  {s : Set Î±}  {f : Î± â†’ Î²}  {a : Î±}  {b : Î²} {s sâ‚ sâ‚‚ : Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²} {Î´ : Î± â†’ Sort y}  (s : Set Î±)  (f g : âˆ€ i, Î´ i) [âˆ€ j, Decidable (j âˆˆ s)] {fa : Î± â†’ Î±}  {fb : Î² â†’ Î²}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³}  {s t : Set Î±} (h : Semiconj f fa fb)  {s : Set Î²}  (hb : InjOn fb s)      (hf : InjOn f (f â»Â¹' s))"},
 {"type": "nâ‚ = nâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type _}  (sel : Set Î± â†’ Option Î±) {nâ‚ nâ‚‚ : â„•}  {a : Î±}  {s : Set Î±}  (h_sel : âˆ€ s a, sel s = some a â†’ a âˆˆ s)      (hâ‚ : enumerate sel s nâ‚ = some a)  (hâ‚‚ : enumerate sel s nâ‚‚ = some a) : nâ‚ = nâ‚‚ := by rcases le_total nâ‚ nâ‚‚ with (hn|hn); sorry",
  "name": "enumerate_inj",
  "kind": "theorem",
  "first-tactic": "rcases le_total nâ‚ nâ‚‚ with (hn|hn)",
  "core-prompt":
  "{Î± : Type _}  (sel : Set Î± â†’ Option Î±) {nâ‚ nâ‚‚ : â„•}  {a : Î±}  {s : Set Î±}  (h_sel : âˆ€ s a, sel s = some a â†’ a âˆˆ s)      (hâ‚ : enumerate sel s nâ‚ = some a)  (hâ‚‚ : enumerate sel s nâ‚‚ = some a) : nâ‚ = nâ‚‚",
  "args":
  "{Î± : Type _}  (sel : Set Î± â†’ Option Î±) {nâ‚ nâ‚‚ : â„•}  {a : Î±}  {s : Set Î±}  (h_sel : âˆ€ s a, sel s = some a â†’ a âˆˆ s)      (hâ‚ : enumerate sel s nâ‚ = some a)  (hâ‚‚ : enumerate sel s nâ‚‚ = some a)"},
 {"type": "(x âˆˆ â‹ƒ (i) (j), s i j) â†” âˆƒ i j, x âˆˆ s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³} : (x âˆˆ â‹ƒ (i) (j), s i j) â†” âˆƒ i j, x âˆˆ s i j := by simp_rw [mem_unionáµ¢]; sorry",
  "name": "mem_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³} : (x âˆˆ â‹ƒ (i) (j), s i j) â†” âˆƒ i j, x âˆˆ s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³}"},
 {"type": "(x âˆˆ â‹‚ (i) (j), s i j) â†” âˆ€ i j, x âˆˆ s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³} : (x âˆˆ â‹‚ (i) (j), s i j) â†” âˆ€ i j, x âˆˆ s i j := by simp_rw [mem_interáµ¢]; sorry",
  "name": "mem_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³} : (x âˆˆ â‹‚ (i) (j), s i j) â†” âˆ€ i j, x âˆˆ s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {x : Î³}  {s : âˆ€ i, Îº i â†’ Set Î³}"},
 {"type": "âˆƒ i âˆˆ t, x âˆˆ s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î²)      (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤)  (x : Î²) : âˆƒ i âˆˆ t, x âˆˆ s i := by have p : x âˆˆ âŠ¤ := Set.mem_univ x; sorry",
  "name": "exists_set_mem_of_union_eq_top",
  "kind": "theorem",
  "first-tactic": "have p : x âˆˆ âŠ¤ := Set.mem_univ x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î²)      (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤)  (x : Î²) : âˆƒ i âˆˆ t, x âˆˆ s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î²)      (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤)  (x : Î²)"},
 {"type": "t.Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î±)      (H : Nonempty Î±)  (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤) : t.Nonempty := by obtain âŸ¨x, m, -âŸ© := exists_set_mem_of_union_eq_top t s w H.some; sorry",
  "name": "nonempty_of_union_eq_top_of_nonempty",
  "kind": "theorem",
  "first-tactic":
  "obtain âŸ¨x, m, -âŸ© := exists_set_mem_of_union_eq_top t s w H.some",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î±)      (H : Nonempty Î±)  (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤) : t.Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  (t : Set Î¹)  (s : Î¹ â†’ Set Î±)      (H : Nonempty Î±)  (w : (â‹ƒ i âˆˆ t, s i) = âŠ¤)"},
 {"type": "(â‹ƒ (i) (j), s i j) âŠ† t â†” âˆ€ i j, s i j âŠ† t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î±} : (â‹ƒ (i) (j), s i j) âŠ† t â†” âˆ€ i j, s i j âŠ† t := by simp_rw [unionáµ¢_subset_iff]; sorry",
  "name": "unionáµ¢â‚‚_subset_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionáµ¢_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î±} : (â‹ƒ (i) (j), s i j) âŠ† t â†” âˆ€ i j, s i j âŠ† t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î±}"},
 {"type": "(s âŠ† â‹‚ (i) (j), t i j) â†” âˆ€ i j, s âŠ† t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î±} : (s âŠ† â‹‚ (i) (j), t i j) â†” âˆ€ i j, s âŠ† t i j := by simp_rw [subset_interáµ¢_iff]; sorry",
  "name": "subset_interáµ¢â‚‚_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [subset_interáµ¢_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î±} : (s âŠ† â‹‚ (i) (j), t i j) â†” âˆ€ i j, s âŠ† t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î±}"},
 {"type": "(â‹ƒ i, { x : Î± | P i x }) = { x : Î± | âˆƒ i, P i x }",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop) : (â‹ƒ i, { x : Î± | P i x }) = { x : Î± | âˆƒ i, P i x } := by ext; sorry",
  "name": "unionáµ¢_setOf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop) : (â‹ƒ i, { x : Î± | P i x }) = { x : Î± | âˆƒ i, P i x }",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop)"},
 {"type": "(â‹‚ i, { x : Î± | P i x }) = { x : Î± | âˆ€ i, P i x }",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop) : (â‹‚ i, { x : Î± | P i x }) = { x : Î± | âˆ€ i, P i x } := by ext; sorry",
  "name": "interáµ¢_setOf",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop) : (â‹‚ i, { x : Î± | P i x }) = { x : Î± | âˆ€ i, P i x }",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (P : Î¹ â†’ Î± â†’ Prop)"},
 {"type": "(â‹ƒ (i) (j), s i j)á¶œ = â‹‚ (i) (j), s i já¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±) : (â‹ƒ (i) (j), s i j)á¶œ = â‹‚ (i) (j), s i já¶œ := by simp_rw [compl_unionáµ¢]; sorry",
  "name": "compl_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [compl_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±) : (â‹ƒ (i) (j), s i j)á¶œ = â‹‚ (i) (j), s i já¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹‚ (i) (j), s i j)á¶œ = â‹ƒ (i) (j), s i já¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±) : (â‹‚ (i) (j), s i j)á¶œ = â‹ƒ (i) (j), s i já¶œ := by simp_rw [compl_interáµ¢]; sorry",
  "name": "compl_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [compl_interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±) : (â‹‚ (i) (j), s i j)á¶œ = â‹ƒ (i) (j), s i já¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹ƒ i, s i) = (â‹‚ i, s iá¶œ)á¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹ƒ i, s i) = (â‹‚ i, s iá¶œ)á¶œ := by simp only [compl_interáµ¢]; sorry",
  "name": "unionáµ¢_eq_compl_interáµ¢_compl",
  "kind": "theorem",
  "first-tactic": "simp only [compl_interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹ƒ i, s i) = (â‹‚ i, s iá¶œ)á¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²)"},
 {"type": "(â‹‚ i, s i) = (â‹ƒ i, s iá¶œ)á¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹‚ i, s i) = (â‹ƒ i, s iá¶œ)á¶œ := by simp only [compl_unionáµ¢]; sorry",
  "name": "interáµ¢_eq_compl_unionáµ¢_compl",
  "kind": "theorem",
  "first-tactic": "simp only [compl_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹‚ i, s i) = (â‹ƒ i, s iá¶œ)á¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²)"},
 {"type": "(s \\ â‹ƒ i, t i) = â‹‚ i, s \\ t i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  (s : Set Î²)  (t : Î¹ â†’ Set Î²) : (s \\ â‹ƒ i, t i) = â‹‚ i, s \\ t i := by rw [diff_eq]; sorry",
  "name": "diff_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  (s : Set Î²)  (t : Î¹ â†’ Set Î²) : (s \\ â‹ƒ i, t i) = â‹‚ i, s \\ t i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  (s : Set Î²)  (t : Î¹ â†’ Set Î²)"},
 {"type": "(s \\ â‹‚ i, t i) = â‹ƒ i, s \\ t i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î²)  (t : Î¹ â†’ Set Î²) : (s \\ â‹‚ i, t i) = â‹ƒ i, s \\ t i := by rw [diff_eq]; sorry",
  "name": "diff_interáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [diff_eq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î²)  (t : Î¹ â†’ Set Î²) : (s \\ â‹‚ i, t i) = â‹ƒ i, s \\ t i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î²)  (t : Î¹ â†’ Set Î²)"},
 {"type":
  "((fun x : âˆ€ i : Î¹, Î± i => x i) '' â‹‚ k, (fun x : âˆ€ j : Î¹, Î± j => x k) â»Â¹' v k) = v i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {v : âˆ€ i : Î¹, Set (Î± i)}      (hv : (pi univ v).Nonempty)  (i : Î¹) : ((fun x : âˆ€ i : Î¹, Î± i => x i) '' â‹‚ k, (fun x : âˆ€ j : Î¹, Î± j => x k) â»Â¹' v k) = v i := by classical\n    apply Subset.antisymm\n    Â· simp [interáµ¢_subset]\n    Â· intro y y_in\n      simp only [mem_image]; sorry",
  "name": "image_projection_prod",
  "kind": "theorem",
  "first-tactic":
  "classical\n    apply Subset.antisymm\n    Â· simp [interáµ¢_subset]\n    Â· intro y y_in\n      simp only [mem_image]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {v : âˆ€ i : Î¹, Set (Î± i)}      (hv : (pi univ v).Nonempty)  (i : Î¹) : ((fun x : âˆ€ i : Î¹, Î± i => x i) '' â‹‚ k, (fun x : âˆ€ j : Î¹, Î± j => x k) â»Â¹' v k) = v i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Î± : Î¹ â†’ Type _}  {v : âˆ€ i : Î¹, Set (Î± i)}      (hv : (pi univ v).Nonempty)  (i : Î¹)"},
 {"type": "(â‹ƒ i, s i).Nonempty â†” âˆƒ i, (s i).Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±} : (â‹ƒ i, s i).Nonempty â†” âˆƒ i, (s i).Nonempty := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±} : (â‹ƒ i, s i).Nonempty â†” âˆƒ i, (s i).Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±}"},
 {"type": "(â‹ƒ i âˆˆ t, s i).Nonempty â†” âˆƒ i âˆˆ t, (s i).Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±} {t : Set Î±}  {s : Î± â†’ Set Î²} : (â‹ƒ i âˆˆ t, s i).Nonempty â†” âˆƒ i âˆˆ t, (s i).Nonempty := by simp; sorry",
  "name": "nonempty_bunionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±} {t : Set Î±}  {s : Î± â†’ Set Î²} : (â‹ƒ i âˆˆ t, s i).Nonempty â†” âˆƒ i âˆˆ t, (s i).Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±} {t : Set Î±}  {s : Î± â†’ Set Î²}"},
 {"type":
  "(â‹ƒ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹ƒ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±) : (â‹ƒ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹ƒ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ© := by simp only [unionáµ¢_and]; sorry",
  "name": "bunionáµ¢_and",
  "kind": "theorem",
  "first-tactic": "simp only [unionáµ¢_and]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±) : (â‹ƒ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹ƒ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ©",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±)"},
 {"type":
  "(â‹ƒ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹ƒ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±) : (â‹ƒ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹ƒ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ© := by simp only [unionáµ¢_and]; sorry",
  "name": "bunionáµ¢_and'",
  "kind": "theorem",
  "first-tactic": "simp only [unionáµ¢_and]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±) : (â‹ƒ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹ƒ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ©",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±)"},
 {"type":
  "(â‹‚ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹‚ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±) : (â‹‚ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹‚ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ© := by simp only [interáµ¢_and]; sorry",
  "name": "binteráµ¢_and",
  "kind": "theorem",
  "first-tactic": "simp only [interáµ¢_and]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±) : (â‹‚ (x : Î¹) (y : Î¹') (h : p x âˆ§ q x y), s x y h) =\n      â‹‚ (x : Î¹) (hx : p x) (y : Î¹') (hy : q x y), s x y âŸ¨hx, hyâŸ©",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹ â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p x âˆ§ q x y â†’ Set Î±)"},
 {"type":
  "(â‹‚ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹‚ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ©",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±) : (â‹‚ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹‚ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ© := by simp only [interáµ¢_and]; sorry",
  "name": "binteráµ¢_and'",
  "kind": "theorem",
  "first-tactic": "simp only [interáµ¢_and]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±) : (â‹‚ (x : Î¹) (y : Î¹') (h : p y âˆ§ q x y), s x y h) =\n      â‹‚ (y : Î¹') (hy : p y) (x : Î¹) (hx : q x y), s x y âŸ¨hy, hxâŸ©",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (p : Î¹' â†’ Prop)  (q : Î¹ â†’ Î¹' â†’ Prop)  (s : âˆ€ x y, p y âˆ§ q x y â†’ Set Î±)"},
 {"type":
  "(â‹ƒ (x) (h), s x h) = s b (Or.inl rfl) âˆª â‹ƒ (x) (h : p x), s x (Or.inr h)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±} : (â‹ƒ (x) (h), s x h) = s b (Or.inl rfl) âˆª â‹ƒ (x) (h : p x), s x (Or.inr h) := by simp only [unionáµ¢_or]; sorry",
  "name": "unionáµ¢_unionáµ¢_eq_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [unionáµ¢_or]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±} : (â‹ƒ (x) (h), s x h) = s b (Or.inl rfl) âˆª â‹ƒ (x) (h : p x), s x (Or.inr h)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±}"},
 {"type":
  "(â‹‚ (x) (h), s x h) = s b (Or.inl rfl) âˆ© â‹‚ (x) (h : p x), s x (Or.inr h)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±} : (â‹‚ (x) (h), s x h) = s b (Or.inl rfl) âˆ© â‹‚ (x) (h : p x), s x (Or.inr h) := by simp only [interáµ¢_or]; sorry",
  "name": "interáµ¢_interáµ¢_eq_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [interáµ¢_or]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±} : (â‹‚ (x) (h), s x h) = s b (Or.inl rfl) âˆ© â‹‚ (x) (h : p x), s x (Or.inr h)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {b : Î²}  {p : Î² â†’ Prop}  {s : âˆ€ x : Î², x = b âˆ¨ p x â†’ Set Î±}"},
 {"type": "(â‹ƒ _h : s.Nonempty, s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±) : (â‹ƒ _h : s.Nonempty, s) = s := by rw [unionáµ¢_nonempty_index]; sorry",
  "name": "unionáµ¢_nonempty_self",
  "kind": "theorem",
  "first-tactic": "rw [unionáµ¢_nonempty_index]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±) : (â‹ƒ _h : s.Nonempty, s) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)"},
 {"type": "(â‹‚ x âˆˆ insert a s, t x) = t a âˆ© â‹‚ x âˆˆ s, t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²) : (â‹‚ x âˆˆ insert a s, t x) = t a âˆ© â‹‚ x âˆˆ s, t x := by simp; sorry",
  "name": "binteráµ¢_insert",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²) : (â‹‚ x âˆˆ insert a s, t x) = t a âˆ© â‹‚ x âˆˆ s, t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²)"},
 {"type": "(â‹‚ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆ© s b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²) : (â‹‚ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆ© s b := by rw [binteráµ¢_insert]; sorry",
  "name": "binteráµ¢_pair",
  "kind": "theorem",
  "first-tactic": "rw [binteráµ¢_insert]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²) : (â‹‚ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆ© s b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²)"},
 {"type": "(â‹‚ i âˆˆ s, f i âˆ© t) = (â‹‚ i âˆˆ s, f i) âˆ© t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±) : (â‹‚ i âˆˆ s, f i âˆ© t) = (â‹‚ i âˆˆ s, f i) âˆ© t := by haveI : Nonempty s := hs.to_subtype; sorry",
  "name": "binteráµ¢_inter",
  "kind": "theorem",
  "first-tactic": "haveI : Nonempty s := hs.to_subtype",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±) : (â‹‚ i âˆˆ s, f i âˆ© t) = (â‹‚ i âˆˆ s, f i) âˆ© t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±)"},
 {"type": "(â‹‚ i âˆˆ s, t âˆ© f i) = t âˆ© â‹‚ i âˆˆ s, f i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±) : (â‹‚ i âˆˆ s, t âˆ© f i) = t âˆ© â‹‚ i âˆˆ s, f i := by rw [inter_comm]; sorry",
  "name": "inter_binteráµ¢",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±) : (â‹‚ i âˆˆ s, t âˆ© f i) = t âˆ© â‹‚ i âˆˆ s, f i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ Î± : Type _}  {s : Set Î¹}  (hs : s.Nonempty)  (f : Î¹ â†’ Set Î±)  (t : Set Î±)"},
 {"type": "(â‹ƒ x âˆˆ insert a s, t x) = t a âˆª â‹ƒ x âˆˆ s, t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ insert a s, t x) = t a âˆª â‹ƒ x âˆˆ s, t x := by simp; sorry",
  "name": "bunionáµ¢_insert",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ insert a s, t x) = t a âˆª â‹ƒ x âˆˆ s, t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (s : Set Î±)  (t : Î± â†’ Set Î²)"},
 {"type": "(â‹ƒ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆª s b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆª s b := by simp; sorry",
  "name": "bunionáµ¢_pair",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ ({a, b} : Set Î±), s x) = s a âˆª s b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a b : Î±)  (s : Î± â†’ Set Î²)"},
 {"type": "(s âˆ© â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s âˆ© t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆ© â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s âˆ© t i j := by simp only [inter_unionáµ¢]; sorry",
  "name": "inter_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp only [inter_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆ© â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s âˆ© t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹ƒ (i) (j), s i j) âˆ© t = â‹ƒ (i) (j), s i j âˆ© t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹ƒ (i) (j), s i j) âˆ© t = â‹ƒ (i) (j), s i j âˆ© t := by simp_rw [unionáµ¢_inter]; sorry",
  "name": "unionáµ¢â‚‚_inter",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionáµ¢_inter]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹ƒ (i) (j), s i j) âˆ© t = â‹ƒ (i) (j), s i j âˆ© t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±)"},
 {"type": "(s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j := by simp_rw [union_interáµ¢]; sorry",
  "name": "union_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t := by simp_rw [interáµ¢_union]; sorry",
  "name": "interáµ¢â‚‚_union",
  "kind": "theorem",
  "first-tactic": "simp_rw [interáµ¢_union]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±)"},
 {"type": "(â‹ƒâ‚€S).Nonempty â†” âˆƒ s âˆˆ S, Set.Nonempty s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {S : Set (Set Î±)} : (â‹ƒâ‚€S).Nonempty â†” âˆƒ s âˆˆ S, Set.Nonempty s := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_unionâ‚›",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {S : Set (Set Î±)} : (â‹ƒâ‚€S).Nonempty â†” âˆƒ s âˆˆ S, Set.Nonempty s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {S : Set (Set Î±)}"},
 {"type": "(â‹ƒ i, f i) = univ â†” âˆ€ x, âˆƒ i, x âˆˆ f i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹ƒ i, f i) = univ â†” âˆ€ x, âˆƒ i, x âˆˆ f i := by simp only [eq_univ_iff_forall]; sorry",
  "name": "unionáµ¢_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_univ_iff_forall]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹ƒ i, f i) = univ â†” âˆ€ x, âˆƒ i, x âˆˆ f i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±}"},
 {"type": "(â‹ƒ (i) (j), s i j) = univ â†” âˆ€ a, âˆƒ i j, a âˆˆ s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹ƒ (i) (j), s i j) = univ â†” âˆ€ a, âˆƒ i j, a âˆˆ s i j := by simp only [unionáµ¢_eq_univ_iff]; sorry",
  "name": "unionáµ¢â‚‚_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [unionáµ¢_eq_univ_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹ƒ (i) (j), s i j) = univ â†” âˆ€ a, âˆƒ i j, a âˆˆ s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}"},
 {"type": "â‹ƒâ‚€c = univ â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆˆ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : â‹ƒâ‚€c = univ â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆˆ b := by simp only [eq_univ_iff_forall]; sorry",
  "name": "unionâ‚›_eq_univ_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_univ_iff_forall]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : â‹ƒâ‚€c = univ â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆˆ b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)}"},
 {"type": "(â‹‚ i, f i) = âˆ… â†” âˆ€ x, âˆƒ i, x âˆ‰ f i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹‚ i, f i) = âˆ… â†” âˆ€ x, âˆƒ i, x âˆ‰ f i := by simp [Set.eq_empty_iff_forall_not_mem]; sorry",
  "name": "interáµ¢_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Set.eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹‚ i, f i) = âˆ… â†” âˆ€ x, âˆƒ i, x âˆ‰ f i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±}"},
 {"type": "(â‹‚ (i) (j), s i j) = âˆ… â†” âˆ€ a, âˆƒ i j, a âˆ‰ s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹‚ (i) (j), s i j) = âˆ… â†” âˆ€ a, âˆƒ i j, a âˆ‰ s i j := by simp only [eq_empty_iff_forall_not_mem]; sorry",
  "name": "interáµ¢â‚‚_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹‚ (i) (j), s i j) = âˆ… â†” âˆ€ a, âˆƒ i j, a âˆ‰ s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}"},
 {"type": "â‹‚â‚€ c = âˆ… â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆ‰ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : â‹‚â‚€ c = âˆ… â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆ‰ b := by simp [Set.eq_empty_iff_forall_not_mem]; sorry",
  "name": "interâ‚›_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Set.eq_empty_iff_forall_not_mem]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : â‹‚â‚€ c = âˆ… â†” âˆ€ a, âˆƒ b âˆˆ c, a âˆ‰ b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)}"},
 {"type": "(â‹‚ i, f i).Nonempty â†” âˆƒ x, âˆ€ i, x âˆˆ f i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹‚ i, f i).Nonempty â†” âˆƒ x, âˆ€ i, x âˆˆ f i := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_interáµ¢",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±} : (â‹‚ i, f i).Nonempty â†” âˆƒ x, âˆ€ i, x âˆˆ f i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î¹ â†’ Set Î±}"},
 {"type": "(â‹‚ (i) (j), s i j).Nonempty â†” âˆƒ a, âˆ€ i j, a âˆˆ s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹‚ (i) (j), s i j).Nonempty â†” âˆƒ a, âˆ€ i j, a âˆˆ s i j := by simp; sorry",
  "name": "nonempty_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±} : (â‹‚ (i) (j), s i j).Nonempty â†” âˆƒ a, âˆ€ i j, a âˆˆ s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : âˆ€ i, Îº i â†’ Set Î±}"},
 {"type": "(â‹‚â‚€ c).Nonempty â†” âˆƒ a, âˆ€ b âˆˆ c, a âˆˆ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : (â‹‚â‚€ c).Nonempty â†” âˆƒ a, âˆ€ b âˆˆ c, a âˆˆ b := by simp [nonempty_iff_ne_empty]; sorry",
  "name": "nonempty_interâ‚›",
  "kind": "theorem",
  "first-tactic": "simp [nonempty_iff_ne_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)} : (â‹‚â‚€ c).Nonempty â†” âˆƒ a, âˆ€ b âˆˆ c, a âˆˆ b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {c : Set (Set Î±)}"},
 {"type": "â‹ƒâ‚€S = (â‹‚â‚€ (compl '' S))á¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : â‹ƒâ‚€S = (â‹‚â‚€ (compl '' S))á¶œ := by rw [â† compl_compl (â‹ƒâ‚€S)]; sorry",
  "name": "unionâ‚›_eq_compl_interâ‚›_compl",
  "kind": "theorem",
  "first-tactic": "rw [â† compl_compl (â‹ƒâ‚€S)]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : â‹ƒâ‚€S = (â‹‚â‚€ (compl '' S))á¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±))"},
 {"type": "(â‹‚â‚€ S)á¶œ = â‹ƒâ‚€(compl '' S)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : (â‹‚â‚€ S)á¶œ = â‹ƒâ‚€(compl '' S) := by rw [unionâ‚›_eq_compl_interâ‚›_compl]; sorry",
  "name": "compl_interâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [unionâ‚›_eq_compl_interâ‚›_compl]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : (â‹‚â‚€ S)á¶œ = â‹ƒâ‚€(compl '' S)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±))"},
 {"type": "â‹‚â‚€ S = (â‹ƒâ‚€(compl '' S))á¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : â‹‚â‚€ S = (â‹ƒâ‚€(compl '' S))á¶œ := by rw [â† compl_compl (â‹‚â‚€ S)]; sorry",
  "name": "interâ‚›_eq_compl_unionâ‚›_compl",
  "kind": "theorem",
  "first-tactic": "rw [â† compl_compl (â‹‚â‚€ S)]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±)) : â‹‚â‚€ S = (â‹ƒâ‚€(compl '' S))á¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (S : Set (Set Î±))"},
 {"type": "(â‹ƒ i, s i) = range fun a : Î£i, s i => a.2",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î± â†’ Set Î²) : (â‹ƒ i, s i) = range fun a : Î£i, s i => a.2 := by simp [Set.ext_iff]; sorry",
  "name": "unionáµ¢_eq_range_sigma",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î± â†’ Set Î²) : (â‹ƒ i, s i) = range fun a : Î£i, s i => a.2",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î± â†’ Set Î²)"},
 {"type": "(â‹ƒ i, s i) = range fun a : Î£'i, s i => a.2",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹ƒ i, s i) = range fun a : Î£'i, s i => a.2 := by simp [Set.ext_iff]; sorry",
  "name": "unionáµ¢_eq_range_psigma",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²) : (â‹ƒ i, s i) = range fun a : Î£'i, s i => a.2",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î²)"},
 {"type": "(â‹ƒ i, Sigma.mk i '' (Sigma.mk i â»Â¹' s)) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Ïƒ : Î¹ â†’ Type _}  (s : Set (Sigma Ïƒ)) : (â‹ƒ i, Sigma.mk i '' (Sigma.mk i â»Â¹' s)) = s := by ext x; sorry",
  "name": "unionáµ¢_image_preimage_sigma_mk_eq_self",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Ïƒ : Î¹ â†’ Type _}  (s : Set (Sigma Ïƒ)) : (â‹ƒ i, Sigma.mk i '' (Sigma.mk i â»Â¹' s)) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Type _}  {Ïƒ : Î¹ â†’ Type _}  (s : Set (Sigma Ïƒ))"},
 {"type": "(â‹ƒ x : Î±, {f x}) = range f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (f : Î± â†’ Î²) : (â‹ƒ x : Î±, {f x}) = range f := by ext x; sorry",
  "name": "unionáµ¢_singleton_eq_range",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (f : Î± â†’ Î²) : (â‹ƒ x : Î±, {f x}) = range f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (f : Î± â†’ Î²)"},
 {"type": "(â‹ƒ x, {x} : Set Î±) = univ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (Î± : Type _) : (â‹ƒ x, {x} : Set Î±) = univ := by simp [Set.ext_iff]; sorry",
  "name": "unionáµ¢_of_singleton",
  "kind": "theorem",
  "first-tactic": "simp [Set.ext_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (Î± : Type _) : (â‹ƒ x, {x} : Set Î±) = univ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (Î± : Type _)"},
 {"type": "(â‹ƒ i : s, ({(i : Î±)} : Set Î±)) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±) : (â‹ƒ i : s, ({(i : Î±)} : Set Î±)) = s := by simp; sorry",
  "name": "unionáµ¢_of_singleton_coe",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±) : (â‹ƒ i : s, ({(i : Î±)} : Set Î±)) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)"},
 {"type": "â‹ƒâ‚€s = â‹ƒ (i : Set Î±) (_h : i âˆˆ s), i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹ƒâ‚€s = â‹ƒ (i : Set Î±) (_h : i âˆˆ s), i := by rw [â† unionâ‚›_image]; sorry",
  "name": "unionâ‚›_eq_bunionáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [â† unionâ‚›_image]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹ƒâ‚€s = â‹ƒ (i : Set Î±) (_h : i âˆˆ s), i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)}"},
 {"type": "â‹‚â‚€ s = â‹‚ (i : Set Î±) (_h : i âˆˆ s), i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹‚â‚€ s = â‹‚ (i : Set Î±) (_h : i âˆˆ s), i := by rw [â† interâ‚›_image]; sorry",
  "name": "interâ‚›_eq_binteráµ¢",
  "kind": "theorem",
  "first-tactic": "rw [â† interâ‚›_image]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹‚â‚€ s = â‹‚ (i : Set Î±) (_h : i âˆˆ s), i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)}"},
 {"type": "â‹ƒâ‚€s = â‹ƒ i : s, i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹ƒâ‚€s = â‹ƒ i : s, i := by simp only [â† unionâ‚›_range]; sorry",
  "name": "unionâ‚›_eq_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [â† unionâ‚›_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹ƒâ‚€s = â‹ƒ i : s, i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)}"},
 {"type": "â‹‚â‚€ s = â‹‚ i : s, i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹‚â‚€ s = â‹‚ i : s, i := by simp only [â† interâ‚›_range]; sorry",
  "name": "interâ‚›_eq_interáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [â† interâ‚›_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)} : â‹‚â‚€ s = â‹‚ i : s, i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set (Set Î±)}"},
 {"type": "(â‹ƒ x âˆˆ â‹ƒ i, s i, t x) = â‹ƒ (i) (x âˆˆ s i), t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ â‹ƒ i, s i, t x) = â‹ƒ (i) (x âˆˆ s i), t x := by simp [@unionáµ¢_comm _ Î¹]; sorry",
  "name": "bunionáµ¢_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp [@unionáµ¢_comm _ Î¹]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²) : (â‹ƒ x âˆˆ â‹ƒ i, s i, t x) = â‹ƒ (i) (x âˆˆ s i), t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²)"},
 {"type": "(â‹‚ x âˆˆ â‹ƒ i, s i, t x) = â‹‚ (i) (x âˆˆ s i), t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²) : (â‹‚ x âˆˆ â‹ƒ i, s i, t x) = â‹‚ (i) (x âˆˆ s i), t x := by simp [@interáµ¢_comm _ Î¹]; sorry",
  "name": "binteráµ¢_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp [@interáµ¢_comm _ Î¹]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²) : (â‹‚ x âˆˆ â‹ƒ i, s i, t x) = â‹‚ (i) (x âˆˆ s i), t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set Î±)  (t : Î± â†’ Set Î²)"},
 {"type": "(â‹ƒâ‚€â‹ƒ i, s i) = â‹ƒ i, â‹ƒâ‚€s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±)) : (â‹ƒâ‚€â‹ƒ i, s i) = â‹ƒ i, â‹ƒâ‚€s i := by simp only [unionâ‚›_eq_bunionáµ¢]; sorry",
  "name": "unionâ‚›_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [unionâ‚›_eq_bunionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±)) : (â‹ƒâ‚€â‹ƒ i, s i) = â‹ƒ i, â‹ƒâ‚€s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±))"},
 {"type": "(â‹‚â‚€ â‹ƒ i, s i) = â‹‚ i, â‹‚â‚€ s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±)) : (â‹‚â‚€ â‹ƒ i, s i) = â‹‚ i, â‹‚â‚€ s i := by simp only [interâ‚›_eq_binteráµ¢]; sorry",
  "name": "interâ‚›_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [interâ‚›_eq_binteráµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±)) : (â‹‚â‚€ â‹ƒ i, s i) = â‹‚ i, â‹‚â‚€ s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Î¹ â†’ Set (Set Î±))"},
 {"type": "(â‹ƒ y : Î², range fun s : C => (f s y).val) = â‹ƒâ‚€C",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (C : Set (Set Î±))  {f : âˆ€ s : C, Î² â†’ (s : Type _)}      (hf : âˆ€ s : C, Surjective (f s)) : (â‹ƒ y : Î², range fun s : C => (f s y).val) = â‹ƒâ‚€C := by ext x; sorry",
  "name": "unionáµ¢_range_eq_unionâ‚›",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (C : Set (Set Î±))  {f : âˆ€ s : C, Î² â†’ (s : Type _)}      (hf : âˆ€ s : C, Surjective (f s)) : (â‹ƒ y : Î², range fun s : C => (f s y).val) = â‹ƒâ‚€C",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î± Î² : Type _}  (C : Set (Set Î±))  {f : âˆ€ s : C, Î² â†’ (s : Type _)}      (hf : âˆ€ s : C, Surjective (f s))"},
 {"type": "(â‹ƒ y : Î², range fun x : Î¹ => (f x y).val) = â‹ƒ x, C x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (C : Î¹ â†’ Set Î±)  {f : âˆ€ x : Î¹, Î² â†’ C x}      (hf : âˆ€ x : Î¹, Surjective (f x)) : (â‹ƒ y : Î², range fun x : Î¹ => (f x y).val) = â‹ƒ x, C x := by ext x; sorry",
  "name": "unionáµ¢_range_eq_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (C : Î¹ â†’ Set Î±)  {f : âˆ€ x : Î¹, Î² â†’ C x}      (hf : âˆ€ x : Î¹, Surjective (f x)) : (â‹ƒ y : Î², range fun x : Î¹ => (f x y).val) = â‹ƒ x, C x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (C : Î¹ â†’ Set Î±)  {f : âˆ€ x : Î¹, Î² â†’ C x}      (hf : âˆ€ x : Î¹, Surjective (f x))"},
 {"type": "(s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j := by simp_rw [union_distrib_interáµ¢_left]; sorry",
  "name": "union_distrib_interáµ¢â‚‚_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_distrib_interáµ¢_left]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±) : (s âˆª â‹‚ (i) (j), t i j) = â‹‚ (i) (j), s âˆª t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t := by simp_rw [union_distrib_interáµ¢_right]; sorry",
  "name": "union_distrib_interáµ¢â‚‚_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [union_distrib_interáµ¢_right]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±) : (â‹‚ (i) (j), s i j) âˆª t = â‹‚ (i) (j), s i j âˆª t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î±)"},
 {"type": "f '' â‹‚â‚€ S âŠ† â‹‚ s âˆˆ S, f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (S : Set (Set Î±))  (f : Î± â†’ Î²) : f '' â‹‚â‚€ S âŠ† â‹‚ s âˆˆ S, f '' s := by rw [interâ‚›_eq_binteráµ¢]; sorry",
  "name": "image_interâ‚›_subset",
  "kind": "theorem",
  "first-tactic": "rw [interâ‚›_eq_binteráµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (S : Set (Set Î±))  (f : Î± â†’ Î²) : f '' â‹‚â‚€ S âŠ† â‹‚ s âˆˆ S, f '' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (S : Set (Set Î±))  (f : Î± â†’ Î²)"},
 {"type": "Injective f â†” âˆ€ i, Injective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Injective f â†” âˆ€ i, Injective ((U i).restrictPreimage f) := by refine' âŸ¨fun H i => (U i).restrictPreimage_injective H, fun H x y e => _âŸ©; sorry",
  "name": "injective_iff_injective_of_unionáµ¢_eq_univ",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun H i => (U i).restrictPreimage_injective H, fun H x y e => _âŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Injective f â†” âˆ€ i, Injective ((U i).restrictPreimage f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ)"},
 {"type": "Surjective f â†” âˆ€ i, Surjective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Surjective f â†” âˆ€ i, Surjective ((U i).restrictPreimage f) := by refine' âŸ¨fun H i => (U i).restrictPreimage_surjective H, fun H x => _âŸ©; sorry",
  "name": "surjective_iff_surjective_of_unionáµ¢_eq_univ",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun H i => (U i).restrictPreimage_surjective H, fun H x => _âŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Surjective f â†” âˆ€ i, Surjective ((U i).restrictPreimage f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ)"},
 {"type": "Bijective f â†” âˆ€ i, Bijective ((U i).restrictPreimage f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Bijective f â†” âˆ€ i, Bijective ((U i).restrictPreimage f) := by rw [Bijective]; sorry",
  "name": "bijective_iff_bijective_of_unionáµ¢_eq_univ",
  "kind": "theorem",
  "first-tactic": "rw [Bijective]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ) : Bijective f â†” âˆ€ i, Bijective ((U i).restrictPreimage f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (s : Set Î²)  {f : Î± â†’ Î²}  {U : Î¹ â†’ Set Î²}  (hU : unionáµ¢ U = univ)"},
 {"type": "f '' (s âˆ© t) = f '' s âˆ© f '' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  {s t u : Set Î±}  (hf : InjOn f u)  (hs : s âŠ† u)  (ht : t âŠ† u) : f '' (s âˆ© t) = f '' s âˆ© f '' t := by apply Subset.antisymm (image_inter_subset _ _ _); sorry",
  "name": "InjOn.image_inter",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm (image_inter_subset _ _ _)",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  {s t u : Set Î±}  (hf : InjOn f u)  (hs : s âŠ† u)  (ht : t âŠ† u) : f '' (s âˆ© t) = f '' s âˆ© f '' t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  {s t u : Set Î±}  (hf : InjOn f u)  (hs : s âŠ† u)  (ht : t âŠ† u)"},
 {"type": "(f '' â‹‚ i, s i) = â‹‚ i, f '' s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ i, s i)) : (f '' â‹‚ i, s i) = â‹‚ i, f '' s i := by inhabit Î¹; sorry",
  "name": "InjOn.image_interáµ¢_eq",
  "kind": "theorem",
  "first-tactic": "inhabit Î¹",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ i, s i)) : (f '' â‹‚ i, s i) = â‹‚ i, f '' s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ i, s i))"},
 {"type": "(f '' â‹‚ (i) (hi), s i hi) = â‹‚ (i) (hi), f '' s i hi",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {p : Î¹ â†’ Prop}  {s : âˆ€ (i) (_ : p i), Set Î±}  (hp : âˆƒ i, p i)      {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ (i) (hi), s i hi)) : (f '' â‹‚ (i) (hi), s i hi) = â‹‚ (i) (hi), f '' s i hi := by simp only [interáµ¢]; sorry",
  "name": "InjOn.image_binteráµ¢_eq",
  "kind": "theorem",
  "first-tactic": "simp only [interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {p : Î¹ â†’ Prop}  {s : âˆ€ (i) (_ : p i), Set Î±}  (hp : âˆƒ i, p i)      {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ (i) (hi), s i hi)) : (f '' â‹‚ (i) (hi), s i hi) = â‹‚ (i) (hi), f '' s i hi",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {p : Î¹ â†’ Prop}  {s : âˆ€ (i) (_ : p i), Set Î±}  (hp : âˆƒ i, p i)      {f : Î± â†’ Î²}  (h : InjOn f (â‹ƒ (i) (hi), s i hi))"},
 {"type": "(f '' â‹‚ i, s i) = â‹‚ i, f '' s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : Î¹ â†’ Set Î±) : (f '' â‹‚ i, s i) = â‹‚ i, f '' s i := by cases isEmpty_or_nonempty Î¹; sorry",
  "name": "image_interáµ¢",
  "kind": "theorem",
  "first-tactic": "cases isEmpty_or_nonempty Î¹",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : Î¹ â†’ Set Î±) : (f '' â‹‚ i, s i) = â‹‚ i, f '' s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : Î¹ â†’ Set Î±)"},
 {"type": "(f '' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f '' s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : âˆ€ i, Îº i â†’ Set Î±) : (f '' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f '' s i j := by simp_rw [image_interáµ¢ hf]; sorry",
  "name": "image_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_interáµ¢ hf]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : âˆ€ i, Îº i â†’ Set Î±) : (f '' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f '' s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {f : Î± â†’ Î²}  (hf : Bijective f)  (s : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "InjOn f (â‹ƒ i, s i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±}  (hs : Directed (Â· âŠ† Â·) s)  {f : Î± â†’ Î²}      (hf : âˆ€ i, InjOn f (s i)) : InjOn f (â‹ƒ i, s i) := by intro x hx y hy hxy; sorry",
  "name": "inj_on_unionáµ¢_of_directed",
  "kind": "theorem",
  "first-tactic": "intro x hx y hy hxy",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±}  (hs : Directed (Â· âŠ† Â·) s)  {f : Î± â†’ Î²}      (hf : âˆ€ i, InjOn f (s i)) : InjOn f (â‹ƒ i, s i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  {s : Î¹ â†’ Set Î±}  (hs : Directed (Â· âŠ† Â·) s)  {f : Î± â†’ Î²}      (hf : âˆ€ i, InjOn f (s i))"},
 {"type": "SurjOn f (â‹‚ i, s i) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²}      (H : âˆ€ i, SurjOn f (s i) t)  (Hinj : InjOn f (â‹ƒ i, s i)) : SurjOn f (â‹‚ i, s i) t := by intro y hy; sorry",
  "name": "surjOn_interáµ¢",
  "kind": "theorem",
  "first-tactic": "intro y hy",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²}      (H : âˆ€ i, SurjOn f (s i) t)  (Hinj : InjOn f (â‹ƒ i, s i)) : SurjOn f (â‹‚ i, s i) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [Nonempty Î¹]  {s : Î¹ â†’ Set Î±}  {t : Set Î²}  {f : Î± â†’ Î²}      (H : âˆ€ i, SurjOn f (s i) t)  (Hinj : InjOn f (â‹ƒ i, s i))"},
 {"type": "(f '' â‹ƒ i, s i) = â‹ƒ i, f '' s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î±} : (f '' â‹ƒ i, s i) = â‹ƒ i, f '' s i := by ext1 x; sorry",
  "name": "image_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "ext1 x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î±} : (f '' â‹ƒ i, s i) = â‹ƒ i, f '' s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î±}"},
 {"type": "(f '' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f '' s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : âˆ€ i, Îº i â†’ Set Î±) : (f '' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f '' s i j := by simp_rw [image_unionáµ¢]; sorry",
  "name": "image_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [image_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : âˆ€ i, Îº i â†’ Set Î±) : (f '' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f '' s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : âˆ€ i, Îº i â†’ Set Î±)"},
 {"type": "(â‹ƒ (x) (y) (_h : f y = x), g x) = â‹ƒ y, g (f y)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²} : (â‹ƒ (x) (y) (_h : f y = x), g x) = â‹ƒ y, g (f y) := by simpa using bunionáµ¢_range; sorry",
  "name": "unionáµ¢_unionáµ¢_eq'",
  "kind": "theorem",
  "first-tactic": "simpa using bunionáµ¢_range",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²} : (â‹ƒ (x) (y) (_h : f y = x), g x) = â‹ƒ y, g (f y)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²}"},
 {"type": "(â‹‚ (x) (y) (_h : f y = x), g x) = â‹‚ y, g (f y)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²} : (â‹‚ (x) (y) (_h : f y = x), g x) = â‹‚ y, g (f y) := by simpa using binteráµ¢_range; sorry",
  "name": "interáµ¢_interáµ¢_eq'",
  "kind": "theorem",
  "first-tactic": "simpa using binteráµ¢_range",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²} : (â‹‚ (x) (y) (_h : f y = x), g x) = â‹‚ y, g (f y)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î¹ â†’ Î±}  {g : Î± â†’ Set Î²}"},
 {"type": "(f â»Â¹' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f â»Â¹' s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²} : (f â»Â¹' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f â»Â¹' s i j := by simp_rw [preimage_unionáµ¢]; sorry",
  "name": "preimage_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [preimage_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²} : (f â»Â¹' â‹ƒ (i) (j), s i j) = â‹ƒ (i) (j), f â»Â¹' s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²}"},
 {"type": "f â»Â¹' â‹ƒâ‚€s = â‹ƒ t âˆˆ s, f â»Â¹' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)} : f â»Â¹' â‹ƒâ‚€s = â‹ƒ t âˆˆ s, f â»Â¹' t := by rw [unionâ‚›_eq_bunionáµ¢]; sorry",
  "name": "preimage_unionâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [unionâ‚›_eq_bunionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)} : f â»Â¹' â‹ƒâ‚€s = â‹ƒ t âˆˆ s, f â»Â¹' t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)}"},
 {"type": "(f â»Â¹' â‹‚ i, s i) = â‹‚ i, f â»Â¹' s i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î²} : (f â»Â¹' â‹‚ i, s i) = â‹‚ i, f â»Â¹' s i := by ext; sorry",
  "name": "preimage_interáµ¢",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î²} : (f â»Â¹' â‹‚ i, s i) = â‹‚ i, f â»Â¹' s i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Î¹ â†’ Set Î²}"},
 {"type": "(f â»Â¹' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f â»Â¹' s i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²} : (f â»Â¹' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f â»Â¹' s i j := by simp_rw [preimage_interáµ¢]; sorry",
  "name": "preimage_interáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [preimage_interáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²} : (f â»Â¹' â‹‚ (i) (j), s i j) = â‹‚ (i) (j), f â»Â¹' s i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : âˆ€ i, Îº i â†’ Set Î²}"},
 {"type": "f â»Â¹' â‹‚â‚€ s = â‹‚ t âˆˆ s, f â»Â¹' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)} : f â»Â¹' â‹‚â‚€ s = â‹‚ t âˆˆ s, f â»Â¹' t := by rw [interâ‚›_eq_binteráµ¢]; sorry",
  "name": "preimage_interâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [interâ‚›_eq_binteráµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)} : f â»Â¹' â‹‚â‚€ s = â‹‚ t âˆˆ s, f â»Â¹' t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set (Set Î²)}"},
 {"type": "(â‹ƒ y âˆˆ s, f â»Â¹' {y}) = f â»Â¹' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : Set Î²) : (â‹ƒ y âˆˆ s, f â»Â¹' {y}) = f â»Â¹' s := by rw [â† preimage_unionáµ¢â‚‚]; sorry",
  "name": "bunionáµ¢_preimage_singleton",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_unionáµ¢â‚‚]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : Set Î²) : (â‹ƒ y âˆˆ s, f â»Â¹' {y}) = f â»Â¹' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)  (s : Set Î²)"},
 {"type": "(â‹ƒ y âˆˆ range f, f â»Â¹' {y}) = univ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²) : (â‹ƒ y âˆˆ range f, f â»Â¹' {y}) = univ := by rw [bunionáµ¢_preimage_singleton]; sorry",
  "name": "bunionáµ¢_range_preimage_singleton",
  "kind": "theorem",
  "first-tactic": "rw [bunionáµ¢_preimage_singleton]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²) : (â‹ƒ y âˆˆ range f, f â»Â¹' {y}) = univ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (f : Î± â†’ Î²)"},
 {"type": "(s Ã—Ë¢ â‹ƒ i, t i) = â‹ƒ i, s Ã—Ë¢ t i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : Î¹ â†’ Set Î²} : (s Ã—Ë¢ â‹ƒ i, t i) = â‹ƒ i, s Ã—Ë¢ t i := by ext; sorry",
  "name": "prod_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : Î¹ â†’ Set Î²} : (s Ã—Ë¢ â‹ƒ i, t i) = â‹ƒ i, s Ã—Ë¢ t i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : Î¹ â†’ Set Î²}"},
 {"type": "(s Ã—Ë¢ â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s Ã—Ë¢ t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î²} : (s Ã—Ë¢ â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s Ã—Ë¢ t i j := by simp_rw [prod_unionáµ¢]; sorry",
  "name": "prod_unionáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [prod_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î²} : (s Ã—Ë¢ â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), s Ã—Ë¢ t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {t : âˆ€ i, Îº i â†’ Set Î²}"},
 {"type": "s Ã—Ë¢ â‹ƒâ‚€C = â‹ƒâ‚€((fun t => s Ã—Ë¢ t) '' C)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {C : Set (Set Î²)} : s Ã—Ë¢ â‹ƒâ‚€C = â‹ƒâ‚€((fun t => s Ã—Ë¢ t) '' C) := by simp_rw [unionâ‚›_eq_bunionáµ¢]; sorry",
  "name": "prod_unionâ‚›",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionâ‚›_eq_bunionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {C : Set (Set Î²)} : s Ã—Ë¢ â‹ƒâ‚€C = â‹ƒâ‚€((fun t => s Ã—Ë¢ t) '' C)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Set Î±}  {C : Set (Set Î²)}"},
 {"type": "(â‹ƒ i, s i) Ã—Ë¢ t = â‹ƒ i, s i Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Î¹ â†’ Set Î±}  {t : Set Î²} : (â‹ƒ i, s i) Ã—Ë¢ t = â‹ƒ i, s i Ã—Ë¢ t := by ext; sorry",
  "name": "unionáµ¢_prod_const",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Î¹ â†’ Set Î±}  {t : Set Î²} : (â‹ƒ i, s i) Ã—Ë¢ t = â‹ƒ i, s i Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : Î¹ â†’ Set Î±}  {t : Set Î²}"},
 {"type": "(â‹ƒ (i) (j), s i j) Ã—Ë¢ t = â‹ƒ (i) (j), s i j Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î²} : (â‹ƒ (i) (j), s i j) Ã—Ë¢ t = â‹ƒ (i) (j), s i j Ã—Ë¢ t := by simp_rw [unionáµ¢_prod_const]; sorry",
  "name": "unionáµ¢â‚‚_prod_const",
  "kind": "theorem",
  "first-tactic": "simp_rw [unionáµ¢_prod_const]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î²} : (â‹ƒ (i) (j), s i j) Ã—Ë¢ t = â‹ƒ (i) (j), s i j Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s : âˆ€ i, Îº i â†’ Set Î±}  {t : Set Î²}"},
 {"type": "â‹ƒâ‚€C Ã—Ë¢ t = â‹ƒâ‚€((fun s : Set Î± => s Ã—Ë¢ t) '' C)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {C : Set (Set Î±)}  {t : Set Î²} : â‹ƒâ‚€C Ã—Ë¢ t = â‹ƒâ‚€((fun s : Set Î± => s Ã—Ë¢ t) '' C) := by simp only [unionâ‚›_eq_bunionáµ¢]; sorry",
  "name": "unionâ‚›_prod_const",
  "kind": "theorem",
  "first-tactic": "simp only [unionâ‚›_eq_bunionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {C : Set (Set Î±)}  {t : Set Î²} : â‹ƒâ‚€C Ã—Ë¢ t = â‹ƒâ‚€((fun s : Set Î± => s Ã—Ë¢ t) '' C)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {C : Set (Set Î±)}  {t : Set Î²}"},
 {"type": "(â‹ƒ x, s x Ã—Ë¢ t x) = (â‹ƒ x, s x) Ã—Ë¢ â‹ƒ x, t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [SemilatticeSup Î±]  {s : Î± â†’ Set Î²}  {t : Î± â†’ Set Î³}  (hs : Monotone s)      (ht : Monotone t) : (â‹ƒ x, s x Ã—Ë¢ t x) = (â‹ƒ x, s x) Ã—Ë¢ â‹ƒ x, t x := by ext âŸ¨z, wâŸ©; sorry",
  "name": "unionáµ¢_prod_of_monotone",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨z, wâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [SemilatticeSup Î±]  {s : Î± â†’ Set Î²}  {t : Î± â†’ Set Î³}  (hs : Monotone s)      (ht : Monotone t) : (â‹ƒ x, s x Ã—Ë¢ t x) = (â‹ƒ x, s x) Ã—Ë¢ â‹ƒ x, t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [SemilatticeSup Î±]  {s : Î± â†’ Set Î²}  {t : Î± â†’ Set Î³}  (hs : Monotone s)      (ht : Monotone t)"},
 {"type": "â‹‚â‚€ S Ã—Ë¢ â‹‚â‚€ T = â‹‚ r âˆˆ S Ã—Ë¢ T, r.1 Ã—Ë¢ r.2",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  {T : Set (Set Î²)}  (hS : S.Nonempty)  (hT : T.Nonempty) : â‹‚â‚€ S Ã—Ë¢ â‹‚â‚€ T = â‹‚ r âˆˆ S Ã—Ë¢ T, r.1 Ã—Ë¢ r.2 := by obtain âŸ¨sâ‚, hâ‚âŸ© := hS; sorry",
  "name": "interâ‚›_prod_interâ‚›",
  "kind": "theorem",
  "first-tactic": "obtain âŸ¨sâ‚, hâ‚âŸ© := hS",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  {T : Set (Set Î²)}  (hS : S.Nonempty)  (hT : T.Nonempty) : â‹‚â‚€ S Ã—Ë¢ â‹‚â‚€ T = â‹‚ r âˆˆ S Ã—Ë¢ T, r.1 Ã—Ë¢ r.2",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  {T : Set (Set Î²)}  (hS : S.Nonempty)  (hT : T.Nonempty)"},
 {"type": "â‹‚â‚€ S Ã—Ë¢ t = â‹‚ s âˆˆ S, s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  (hS : S.Nonempty)  (t : Set Î²) : â‹‚â‚€ S Ã—Ë¢ t = â‹‚ s âˆˆ S, s Ã—Ë¢ t := by rw [â† interâ‚›_singleton t]; sorry",
  "name": "interâ‚›_prod",
  "kind": "theorem",
  "first-tactic": "rw [â† interâ‚›_singleton t]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  (hS : S.Nonempty)  (t : Set Î²) : â‹‚â‚€ S Ã—Ë¢ t = â‹‚ s âˆˆ S, s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {S : Set (Set Î±)}  (hS : S.Nonempty)  (t : Set Î²)"},
 {"type": "s Ã—Ë¢ â‹‚â‚€ T = â‹‚ t âˆˆ T, s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {T : Set (Set Î²)}  (hT : T.Nonempty)  (s : Set Î±) : s Ã—Ë¢ â‹‚â‚€ T = â‹‚ t âˆˆ T, s Ã—Ë¢ t := by rw [â† interâ‚›_singleton s]; sorry",
  "name": "prod_interâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [â† interâ‚›_singleton s]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {T : Set (Set Î²)}  (hT : T.Nonempty)  (s : Set Î±) : s Ã—Ë¢ â‹‚â‚€ T = â‹‚ t âˆˆ T, s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {T : Set (Set Î²)}  (hT : T.Nonempty)  (s : Set Î±)"},
 {"type": "(â‹ƒ a âˆˆ s, f a '' t) = image2 f s t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : (â‹ƒ a âˆˆ s, f a '' t) = image2 f s t := by ext y; sorry",
  "name": "unionáµ¢_image_left",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : (â‹ƒ a âˆˆ s, f a '' t) = image2 f s t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²}"},
 {"type": "(â‹ƒ b âˆˆ t, (fun a => f a b) '' s) = image2 f s t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : (â‹ƒ b âˆˆ t, (fun a => f a b) '' s) = image2 f s t := by ext y; sorry",
  "name": "unionáµ¢_image_right",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : (â‹ƒ b âˆˆ t, (fun a => f a b) '' s) = image2 f s t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²}"},
 {"type": "image2 f (â‹ƒ i, s i) t = â‹ƒ i, image2 f (s i) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²) : image2 f (â‹ƒ i, s i) t = â‹ƒ i, image2 f (s i) t := by simp only [â† image_prod]; sorry",
  "name": "image2_unionáµ¢_left",
  "kind": "theorem",
  "first-tactic": "simp only [â† image_prod]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²) : image2 f (â‹ƒ i, s i) t = â‹ƒ i, image2 f (s i) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²)"},
 {"type": "image2 f s (â‹ƒ i, t i) = â‹ƒ i, image2 f s (t i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²) : image2 f s (â‹ƒ i, t i) = â‹ƒ i, image2 f s (t i) := by simp only [â† image_prod]; sorry",
  "name": "image2_unionáµ¢_right",
  "kind": "theorem",
  "first-tactic": "simp only [â† image_prod]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²) : image2 f s (â‹ƒ i, t i) = â‹ƒ i, image2 f s (t i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²)"},
 {"type": "image2 f (â‹ƒ (i) (j), s i j) t = â‹ƒ (i) (j), image2 f (s i j) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²) : image2 f (â‹ƒ (i) (j), s i j) t = â‹ƒ (i) (j), image2 f (s i j) t := by simp_rw [image2_unionáµ¢_left]; sorry",
  "name": "image2_unionáµ¢â‚‚_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_unionáµ¢_left]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²) : image2 f (â‹ƒ (i) (j), s i j) t = â‹ƒ (i) (j), image2 f (s i j) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²)"},
 {"type": "image2 f s (â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), image2 f s (t i j)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²) : image2 f s (â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), image2 f s (t i j) := by simp_rw [image2_unionáµ¢_right]; sorry",
  "name": "image2_unionáµ¢â‚‚_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_unionáµ¢_right]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²) : image2 f s (â‹ƒ (i) (j), t i j) = â‹ƒ (i) (j), image2 f s (t i j)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²)"},
 {"type": "image2 f (â‹‚ i, s i) t âŠ† â‹‚ i, image2 f (s i) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²) : image2 f (â‹‚ i, s i) t âŠ† â‹‚ i, image2 f (s i) t := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interáµ¢_subset_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²) : image2 f (â‹‚ i, s i) t âŠ† â‹‚ i, image2 f (s i) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Î¹ â†’ Set Î±)  (t : Set Î²)"},
 {"type": "image2 f s (â‹‚ i, t i) âŠ† â‹‚ i, image2 f s (t i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²) : image2 f s (â‹‚ i, t i) âŠ† â‹‚ i, image2 f s (t i) := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interáµ¢_subset_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²) : image2 f s (â‹‚ i, t i) âŠ† â‹‚ i, image2 f s (t i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Î¹ â†’ Set Î²)"},
 {"type": "image2 f (â‹‚ (i) (j), s i j) t âŠ† â‹‚ (i) (j), image2 f (s i j) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²) : image2 f (â‹‚ (i) (j), s i j) t âŠ† â‹‚ (i) (j), image2 f (s i j) t := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interáµ¢â‚‚_subset_left",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²) : image2 f (â‹‚ (i) (j), s i j) t âŠ† â‹‚ (i) (j), image2 f (s i j) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : âˆ€ i, Îº i â†’ Set Î±)  (t : Set Î²)"},
 {"type": "image2 f s (â‹‚ (i) (j), t i j) âŠ† â‹‚ (i) (j), image2 f s (t i j)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²) : image2 f s (â‹‚ (i) (j), t i j) âŠ† â‹‚ (i) (j), image2 f s (t i j) := by simp_rw [image2_subset_iff]; sorry",
  "name": "image2_interáµ¢â‚‚_subset_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [image2_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²) : image2 f s (â‹‚ (i) (j), t i j) âŠ† â‹‚ (i) (j), image2 f s (t i j)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : âˆ€ i, Îº i â†’ Set Î²)"},
 {"type": "image2 f s t = â‹ƒ (i âˆˆ s) (j âˆˆ t), {f i j}",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Set Î²) : image2 f s t = â‹ƒ (i âˆˆ s) (j âˆˆ t), {f i j} := by simp_rw [â† image_eq_unionáµ¢]; sorry",
  "name": "image2_eq_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† image_eq_unionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Set Î²) : image2 f s t = â‹ƒ (i âˆˆ s) (j âˆˆ t), {f i j}",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} (s : Set Î±)  (t : Set Î²)"},
 {"type": "s Ã—Ë¢ t = â‹ƒ a âˆˆ s, (fun b => (a, b)) '' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = â‹ƒ a âˆˆ s, (fun b => (a, b)) '' t := by rw [unionáµ¢_image_left]; sorry",
  "name": "prod_eq_bunionáµ¢_left",
  "kind": "theorem",
  "first-tactic": "rw [unionáµ¢_image_left]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = â‹ƒ a âˆˆ s, (fun b => (a, b)) '' t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²}"},
 {"type": "s Ã—Ë¢ t = â‹ƒ b âˆˆ t, (fun a => (a, b)) '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = â‹ƒ b âˆˆ t, (fun a => (a, b)) '' s := by rw [unionáµ¢_image_right]; sorry",
  "name": "prod_eq_bunionáµ¢_right",
  "kind": "theorem",
  "first-tactic": "rw [unionáµ¢_image_right]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = â‹ƒ b âˆˆ t, (fun a => (a, b)) '' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  {s : Set Î±}  {t : Set Î²}"},
 {"type": "seq s (seq t u) = seq (seq ((Â· âˆ˜ Â·) '' s) t) u",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set (Î² â†’ Î³)}  {t : Set (Î± â†’ Î²)}  {u : Set Î±} : seq s (seq t u) = seq (seq ((Â· âˆ˜ Â·) '' s) t) u := by refine' Set.ext fun c => Iff.intro _ _; sorry",
  "name": "seq_seq",
  "kind": "theorem",
  "first-tactic": "refine' Set.ext fun c => Iff.intro _ _",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set (Î² â†’ Î³)}  {t : Set (Î± â†’ Î²)}  {u : Set Î±} : seq s (seq t u) = seq (seq ((Â· âˆ˜ Â·) '' s) t) u",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set (Î² â†’ Î³)}  {t : Set (Î± â†’ Î²)}  {u : Set Î±}"},
 {"type": "f '' seq s t = seq ((Â· âˆ˜ Â·) f '' s) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {f : Î² â†’ Î³}  {s : Set (Î± â†’ Î²)}  {t : Set Î±} : f '' seq s t = seq ((Â· âˆ˜ Â·) f '' s) t := by rw [â† singleton_seq]; sorry",
  "name": "image_seq",
  "kind": "theorem",
  "first-tactic": "rw [â† singleton_seq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {f : Î² â†’ Î³}  {s : Set (Î± â†’ Î²)}  {t : Set Î±} : f '' seq s t = seq ((Â· âˆ˜ Â·) f '' s) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {f : Î² â†’ Î³}  {s : Set (Î± â†’ Î²)}  {t : Set Î±}"},
 {"type": "s Ã—Ë¢ t = (Prod.mk '' s).seq t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = (Prod.mk '' s).seq t := by ext âŸ¨a, bâŸ©; sorry",
  "name": "prod_eq_seq",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨a, bâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set Î±}  {t : Set Î²} : s Ã—Ë¢ t = (Prod.mk '' s).seq t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {s : Set Î±}  {t : Set Î²}"},
 {"type": "(Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (s : Set Î±)  (t : Set Î²) : (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s := by rw [â† prod_eq_seq]; sorry",
  "name": "prod_image_seq_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† prod_eq_seq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (s : Set Î±)  (t : Set Î²) : (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (s : Set Î±)  (t : Set Î²)"},
 {"type": "image2 f s t = seq (f '' s) t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 f s t = seq (f '' s) t := by ext; sorry",
  "name": "image2_eq_seq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²) : image2 f s t = seq (f '' s) t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    (f : Î± â†’ Î² â†’ Î³)  (s : Set Î±)  (t : Set Î²)"},
 {"type": "pi i s = â‹‚ a âˆˆ i, eval a â»Â¹' s a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s : âˆ€ a, Set (Ï€ a)) : pi i s = â‹‚ a âˆˆ i, eval a â»Â¹' s a := by ext; sorry",
  "name": "pi_def",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s : âˆ€ a, Set (Ï€ a)) : pi i s = â‹‚ a âˆˆ i, eval a â»Â¹' s a",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s : âˆ€ a, Set (Ï€ a))"},
 {"type": "pi univ t = â‹‚ i, eval i â»Â¹' t i",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Set (Ï€ i)) : pi univ t = â‹‚ i, eval i â»Â¹' t i := by simp only [pi_def]; sorry",
  "name": "univ_pi_eq_interáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [pi_def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Set (Ï€ i)) : pi univ t = â‹‚ i, eval i â»Â¹' t i",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Set (Ï€ i))"},
 {"type": "pi i s \\ pi i t âŠ† â‹ƒ a âˆˆ i, eval a â»Â¹' (s a \\ t a)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s t : âˆ€ a, Set (Ï€ a)) : pi i s \\ pi i t âŠ† â‹ƒ a âˆˆ i, eval a â»Â¹' (s a \\ t a) := by refine' diff_subset_comm.2 fun x hx a ha => _; sorry",
  "name": "pi_diff_pi_subset",
  "kind": "theorem",
  "first-tactic": "refine' diff_subset_comm.2 fun x hx a ha => _",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s t : âˆ€ a, Set (Ï€ a)) : pi i s \\ pi i t âŠ† â‹ƒ a âˆˆ i, eval a â»Â¹' (s a \\ t a)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (i : Set Î±)  (s t : âˆ€ a, Set (Ï€ a))"},
 {"type":
  "(â‹ƒ x : Î± â†’ Î¹, pi univ fun i => t i (x i)) = pi univ fun i => â‹ƒ j : Î¹, t i j",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Î¹ â†’ Set (Ï€ i)) : (â‹ƒ x : Î± â†’ Î¹, pi univ fun i => t i (x i)) = pi univ fun i => â‹ƒ j : Î¹, t i j := by ext; sorry",
  "name": "unionáµ¢_univ_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Î¹ â†’ Set (Ï€ i)) : (â‹ƒ x : Î± â†’ Î¹, pi univ fun i => t i (x i)) = pi univ fun i => â‹ƒ j : Î¹, t i j",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}    {Ï€ : Î± â†’ Type _} (t : âˆ€ i, Î¹ â†’ Set (Ï€ i))"},
 {"type": "Disjoint s t â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, x â‰  y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} : Disjoint s t â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, x â‰  y := by simp only [Ne.def]; sorry",
  "name": "disjoint_iff_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} : Disjoint s t â†” âˆ€ x âˆˆ s, âˆ€ y âˆˆ t, x â‰  y",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}"},
 {"type": "Disjoint {a} s â†” a âˆ‰ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±} : Disjoint {a} s â†” a âˆ‰ s := by simp [Set.disjoint_iff]; sorry",
  "name": "disjoint_singleton_left",
  "kind": "theorem",
  "first-tactic": "simp [Set.disjoint_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±} : Disjoint {a} s â†” a âˆ‰ s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±}"},
 {"type": "Disjoint s {a} â†” a âˆ‰ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±} : Disjoint s {a} â†” a âˆ‰ s := by rw [Disjoint.comm]; sorry",
  "name": "disjoint_singleton_right",
  "kind": "theorem",
  "first-tactic": "rw [Disjoint.comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±} : Disjoint s {a} â†” a âˆ‰ s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a : Î±}  {s : Set Î±}"},
 {"type": "Disjoint ({a} : Set Î±) {b} â†” a â‰  b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a b : Î±} : Disjoint ({a} : Set Î±) {b} â†” a â‰  b := by rw [disjoint_singleton_left]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_singleton_left]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a b : Î±} : Disjoint ({a} : Set Î±) {b} â†” a â‰  b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {a b : Î±}"},
 {"type": "Disjoint s t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (hf : Surjective f)  {s t : Set Î²}      (h : Disjoint (f â»Â¹' s) (f â»Â¹' t)) : Disjoint s t := by rw [disjoint_iff_inter_eq_empty]; sorry",
  "name": "_root_.Disjoint.of_preimage",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inter_eq_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (hf : Surjective f)  {s t : Set Î²}      (h : Disjoint (f â»Â¹' s) (f â»Â¹' t)) : Disjoint s t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   (hf : Surjective f)  {s t : Set Î²}      (h : Disjoint (f â»Â¹' s) (f â»Â¹' t))"},
 {"type": "f â»Â¹' s = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set Î²}  (h : Disjoint s (range f)) : f â»Â¹' s = âˆ… := by simpa using h.preimage f; sorry",
  "name": "preimage_eq_empty",
  "kind": "theorem",
  "first-tactic": "simpa using h.preimage f",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set Î²}  (h : Disjoint s (range f)) : f â»Â¹' s = âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {f : Î± â†’ Î²}  {s : Set Î²}  (h : Disjoint s (range f))"},
 {"type": "Disjoint (f '' s) (f '' t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s t u : Set Î±}  {f : Î± â†’ Î²}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s âŠ† u)  (ht : t âŠ† u) : Disjoint (f '' s) (f '' t) := by rw [disjoint_iff_inter_eq_empty] at hâŠ¢; sorry",
  "name": "_root_.Disjoint.image",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inter_eq_empty] at hâŠ¢",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s t u : Set Î±}  {f : Î± â†’ Î²}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s âŠ† u)  (ht : t âŠ† u) : Disjoint (f '' s) (f '' t)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   {s t u : Set Î±}  {f : Î± â†’ Î²}  (h : Disjoint s t)  (hf : InjOn f u)      (hs : s âŠ† u)  (ht : t âŠ† u)"},
 {"type": "Ici (â¨† (i) (j), f i j) = â‹‚ (i) (j), Ici (f i j)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±) : Ici (â¨† (i) (j), f i j) = â‹‚ (i) (j), Ici (f i j) := by simp_rw [Ici_supáµ¢]; sorry",
  "name": "Ici_supáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [Ici_supáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±) : Ici (â¨† (i) (j), f i j) = â‹‚ (i) (j), Ici (f i j)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±)"},
 {"type": "Iic (â¨… (i) (j), f i j) = â‹‚ (i) (j), Iic (f i j)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±) : Iic (â¨… (i) (j), f i j) = â‹‚ (i) (j), Iic (f i j) := by simp_rw [Iic_infáµ¢]; sorry",
  "name": "Iic_infáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [Iic_infáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±) : Iic (â¨… (i) (j), f i j) = â‹‚ (i) (j), Iic (f i j)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (f : âˆ€ i, Îº i â†’ Î±)"},
 {"type": "Ici (supâ‚› s) = â‹‚ a âˆˆ s, Ici a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±) : Ici (supâ‚› s) = â‹‚ a âˆˆ s, Ici a := by rw [supâ‚›_eq_supáµ¢]; sorry",
  "name": "Ici_supâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±) : Ici (supâ‚› s) = â‹‚ a âˆˆ s, Ici a",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±)"},
 {"type": "Iic (infâ‚› s) = â‹‚ a âˆˆ s, Iic a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±) : Iic (infâ‚› s) = â‹‚ a âˆˆ s, Iic a := by rw [infâ‚›_eq_infáµ¢]; sorry",
  "name": "Iic_infâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [infâ‚›_eq_infáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±) : Iic (infâ‚› s) = â‹‚ a âˆˆ s, Iic a",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (s : Set Î±)"},
 {"type": "((â‹ƒ x âˆˆ sâ‚, t x) \\ â‹ƒ x âˆˆ sâ‚‚, t x) âŠ† â‹ƒ x âˆˆ sâ‚ \\ sâ‚‚, t x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) (sâ‚ sâ‚‚ : Set Î±) : ((â‹ƒ x âˆˆ sâ‚, t x) \\ â‹ƒ x âˆˆ sâ‚‚, t x) âŠ† â‹ƒ x âˆˆ sâ‚ \\ sâ‚‚, t x := by simp only [diff_subset_iff]; sorry",
  "name": "bunionáµ¢_diff_bunionáµ¢_subset",
  "kind": "theorem",
  "first-tactic": "simp only [diff_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) (sâ‚ sâ‚‚ : Set Î±) : ((â‹ƒ x âˆˆ sâ‚, t x) \\ â‹ƒ x âˆˆ sâ‚‚, t x) âŠ† â‹ƒ x âˆˆ sâ‚ \\ sâ‚‚, t x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) (sâ‚ sâ‚‚ : Set Î±)"},
 {"type": "(â¨† a âˆˆ â‹ƒ i, s i, f a) = â¨† (i) (a âˆˆ s i), f a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Î¹ â†’ Set Î±)  (f : Î± â†’ Î²) : (â¨† a âˆˆ â‹ƒ i, s i, f a) = â¨† (i) (a âˆˆ s i), f a := by rw [supáµ¢_comm]; sorry",
  "name": "supáµ¢_unionáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Î¹ â†’ Set Î±)  (f : Î± â†’ Î²) : (â¨† a âˆˆ â‹ƒ i, s i, f a) = â¨† (i) (a âˆˆ s i), f a",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Î¹ â†’ Set Î±)  (f : Î± â†’ Î²)"},
 {"type": "supâ‚› (â‹ƒâ‚€s) = â¨† t âˆˆ s, supâ‚› t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Set (Set Î²)) : supâ‚› (â‹ƒâ‚€s) = â¨† t âˆˆ s, supâ‚› t := by simp only [unionâ‚›_eq_bunionáµ¢]; sorry",
  "name": "supâ‚›_unionâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [unionâ‚›_eq_bunionáµ¢]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Set (Set Î²)) : supâ‚› (â‹ƒâ‚€s) = â¨† t âˆˆ s, supâ‚› t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ Î¹' Î¹â‚‚ : Sort _}  {Îº Îºâ‚ Îºâ‚‚ : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}   [CompleteLattice Î±] (t : Î± â†’ Set Î²) [CompleteLattice Î²] (s : Set (Set Î²))"},
 {"type": "(âˆƒ x âˆˆ s Ã—Ë¢ t, p x) â†” âˆƒ x âˆˆ s, âˆƒ y âˆˆ t, p (x, y)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {p : Î± Ã— Î² â†’ Prop} : (âˆƒ x âˆˆ s Ã—Ë¢ t, p x) â†” âˆƒ x âˆˆ s, âˆƒ y âˆˆ t, p (x, y) := by simp [and_assoc]; sorry",
  "name": "exists_prod_set",
  "kind": "theorem",
  "first-tactic": "simp [and_assoc]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {p : Î± Ã— Î² â†’ Prop} : (âˆƒ x âˆˆ s Ã—Ë¢ t, p x) â†” âˆƒ x âˆˆ s, âˆƒ y âˆˆ t, p (x, y)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {p : Î± Ã— Î² â†’ Prop}"},
 {"type": "s Ã—Ë¢ (âˆ… : Set Î²) = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (âˆ… : Set Î²) = âˆ… := by ext; sorry",
  "name": "prod_empty",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (âˆ… : Set Î²) = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "(âˆ… : Set Î±) Ã—Ë¢ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (âˆ… : Set Î±) Ã—Ë¢ t = âˆ… := by ext; sorry",
  "name": "empty_prod",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (âˆ… : Set Î±) Ã—Ë¢ t = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "@univ Î± Ã—Ë¢ @univ Î² = univ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : @univ Î± Ã—Ë¢ @univ Î² = univ := by ext; sorry",
  "name": "univ_prod_univ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : @univ Î± Ã—Ë¢ @univ Î² = univ",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "(univ : Set Î±) Ã—Ë¢ t = Prod.snd â»Â¹' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {t : Set Î²} : (univ : Set Î±) Ã—Ë¢ t = Prod.snd â»Â¹' t := by simp [prod_eq]; sorry",
  "name": "univ_prod",
  "kind": "theorem",
  "first-tactic": "simp [prod_eq]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {t : Set Î²} : (univ : Set Î±) Ã—Ë¢ t = Prod.snd â»Â¹' t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {t : Set Î²}"},
 {"type": "s Ã—Ë¢ (univ : Set Î²) = Prod.fst â»Â¹' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {s : Set Î±} : s Ã—Ë¢ (univ : Set Î²) = Prod.fst â»Â¹' s := by simp [prod_eq]; sorry",
  "name": "prod_univ",
  "kind": "theorem",
  "first-tactic": "simp [prod_eq]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {s : Set Î±} : s Ã—Ë¢ (univ : Set Î²) = Prod.fst â»Â¹' s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {s : Set Î±}"},
 {"type": "({a} : Set Î±) Ã—Ë¢ t = Prod.mk a '' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : ({a} : Set Î±) Ã—Ë¢ t = Prod.mk a '' t := by ext âŸ¨x, yâŸ©; sorry",
  "name": "singleton_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : ({a} : Set Î±) Ã—Ë¢ t = Prod.mk a '' t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ ({b} : Set Î²) = (fun a => (a, b)) '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ ({b} : Set Î²) = (fun a => (a, b)) '' s := by ext âŸ¨x, yâŸ©; sorry",
  "name": "prod_singleton",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ ({b} : Set Î²) = (fun a => (a, b)) '' s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "({a} : Set Î±) Ã—Ë¢ ({b} : Set Î²) = {(a, b)}",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : ({a} : Set Î±) Ã—Ë¢ ({b} : Set Î²) = {(a, b)} := by simp; sorry",
  "name": "singleton_prod_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : ({a} : Set Î±) Ã—Ë¢ ({b} : Set Î²) = {(a, b)}",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "(sâ‚ âˆª sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆª sâ‚‚ Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (sâ‚ âˆª sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆª sâ‚‚ Ã—Ë¢ t := by ext âŸ¨x, yâŸ©; sorry",
  "name": "union_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (sâ‚ âˆª sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆª sâ‚‚ Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ (tâ‚ âˆª tâ‚‚) = s Ã—Ë¢ tâ‚ âˆª s Ã—Ë¢ tâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (tâ‚ âˆª tâ‚‚) = s Ã—Ë¢ tâ‚ âˆª s Ã—Ë¢ tâ‚‚ := by ext âŸ¨x, yâŸ©; sorry",
  "name": "prod_union",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (tâ‚ âˆª tâ‚‚) = s Ã—Ë¢ tâ‚ âˆª s Ã—Ë¢ tâ‚‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "(sâ‚ âˆ© sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆ© sâ‚‚ Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆ© sâ‚‚ Ã—Ë¢ t := by ext âŸ¨x, yâŸ©; sorry",
  "name": "inter_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ t = sâ‚ Ã—Ë¢ t âˆ© sâ‚‚ Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) = s Ã—Ë¢ tâ‚ âˆ© s Ã—Ë¢ tâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) = s Ã—Ë¢ tâ‚ âˆ© s Ã—Ë¢ tâ‚‚ := by ext âŸ¨x, yâŸ©; sorry",
  "name": "prod_inter",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) = s Ã—Ë¢ tâ‚ âˆ© s Ã—Ë¢ tâ‚‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "sâ‚ Ã—Ë¢ tâ‚ âˆ© sâ‚‚ Ã—Ë¢ tâ‚‚ = (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ (tâ‚ âˆ© tâ‚‚)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : sâ‚ Ã—Ë¢ tâ‚ âˆ© sâ‚‚ Ã—Ë¢ tâ‚‚ = (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ (tâ‚ âˆ© tâ‚‚) := by ext âŸ¨x, yâŸ©; sorry",
  "name": "prod_inter_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : sâ‚ Ã—Ë¢ tâ‚ âˆ© sâ‚‚ Ã—Ë¢ tâ‚‚ = (sâ‚ âˆ© sâ‚‚) Ã—Ë¢ (tâ‚ âˆ© tâ‚‚)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "Disjoint (sâ‚ Ã—Ë¢ tâ‚) (sâ‚‚ Ã—Ë¢ tâ‚‚) â†” Disjoint sâ‚ sâ‚‚ âˆ¨ Disjoint tâ‚ tâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : Disjoint (sâ‚ Ã—Ë¢ tâ‚) (sâ‚‚ Ã—Ë¢ tâ‚‚) â†” Disjoint sâ‚ sâ‚‚ âˆ¨ Disjoint tâ‚ tâ‚‚ := by simp_rw [disjoint_left]; sorry",
  "name": "disjoint_prod",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_left]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : Disjoint (sâ‚ Ã—Ë¢ tâ‚) (sâ‚‚ Ã—Ë¢ tâ‚‚) â†” Disjoint sâ‚ sâ‚‚ âˆ¨ Disjoint tâ‚ tâ‚‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "insert a s Ã—Ë¢ t = Prod.mk a '' t âˆª s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : insert a s Ã—Ë¢ t = Prod.mk a '' t âˆª s Ã—Ë¢ t := by ext âŸ¨x, yâŸ©; sorry",
  "name": "insert_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : insert a s Ã—Ë¢ t = Prod.mk a '' t âˆª s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ insert b t = (fun a => (a, b)) '' s âˆª s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ insert b t = (fun a => (a, b)) '' s âˆª s Ã—Ë¢ t := by ext âŸ¨x, yâŸ©; sorry",
  "name": "prod_insert",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ insert b t = (fun a => (a, b)) '' s âˆª s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "(fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t) : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = s := by ext a; sorry",
  "name": "mk_preimage_prod_left",
  "kind": "theorem",
  "first-tactic": "ext a",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t) : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t)"},
 {"type": "Prod.mk a â»Â¹' s Ã—Ë¢ t = t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s) : Prod.mk a â»Â¹' s Ã—Ë¢ t = t := by ext b; sorry",
  "name": "mk_preimage_prod_right",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s) : Prod.mk a â»Â¹' s Ã—Ë¢ t = t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s)"},
 {"type": "(fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆ‰ t) : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = âˆ… := by ext a; sorry",
  "name": "mk_preimage_prod_left_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext a",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆ‰ t) : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆ‰ t)"},
 {"type": "Prod.mk a â»Â¹' s Ã—Ë¢ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆ‰ s) : Prod.mk a â»Â¹' s Ã—Ë¢ t = âˆ… := by ext b; sorry",
  "name": "mk_preimage_prod_right_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext b",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆ‰ s) : Prod.mk a â»Â¹' s Ã—Ë¢ t = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆ‰ s)"},
 {"type": "(fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then s else âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)] : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then s else âˆ… := by split_ifs with h; sorry",
  "name": "mk_preimage_prod_left_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)] : (fun a => (a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then s else âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)]"},
 {"type": "Prod.mk a â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then t else âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)] : Prod.mk a â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then t else âˆ… := by split_ifs with h; sorry",
  "name": "mk_preimage_prod_right_eq_if",
  "kind": "theorem",
  "first-tactic": "split_ifs with h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)] : Prod.mk a â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then t else âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)]"},
 {"type": "(fun a => (f a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then f â»Â¹' s else âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)]  (f : Î³ â†’ Î±) : (fun a => (f a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then f â»Â¹' s else âˆ… := by rw [â† mk_preimage_prod_left_eq_if]; sorry",
  "name": "mk_preimage_prod_left_fn_eq_if",
  "kind": "theorem",
  "first-tactic": "rw [â† mk_preimage_prod_left_eq_if]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)]  (f : Î³ â†’ Î±) : (fun a => (f a, b)) â»Â¹' s Ã—Ë¢ t = if b âˆˆ t then f â»Â¹' s else âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ t)]  (f : Î³ â†’ Î±)"},
 {"type": "(fun b => (a, g b)) â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then g â»Â¹' t else âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)]  (g : Î´ â†’ Î²) : (fun b => (a, g b)) â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then g â»Â¹' t else âˆ… := by rw [â† mk_preimage_prod_right_eq_if]; sorry",
  "name": "mk_preimage_prod_right_fn_eq_if",
  "kind": "theorem",
  "first-tactic": "rw [â† mk_preimage_prod_right_eq_if]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)]  (g : Î´ â†’ Î²) : (fun b => (a, g b)) â»Â¹' s Ã—Ë¢ t = if a âˆˆ s then g â»Â¹' t else âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} [DecidablePred (Â· âˆˆ s)]  (g : Î´ â†’ Î²)"},
 {"type": "Prod.swap â»Â¹' s Ã—Ë¢ t = t Ã—Ë¢ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²) : Prod.swap â»Â¹' s Ã—Ë¢ t = t Ã—Ë¢ s := by ext âŸ¨x, yâŸ©; sorry",
  "name": "preimage_swap_prod",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²) : Prod.swap â»Â¹' s Ã—Ë¢ t = t Ã—Ë¢ s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²)"},
 {"type": "Prod.swap '' s Ã—Ë¢ t = t Ã—Ë¢ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²) : Prod.swap '' s Ã—Ë¢ t = t Ã—Ë¢ s := by rw [image_swap_eq_preimage_swap]; sorry",
  "name": "image_swap_prod",
  "kind": "theorem",
  "first-tactic": "rw [image_swap_eq_preimage_swap]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²) : Prod.swap '' s Ã—Ë¢ t = t Ã—Ë¢ s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (s : Set Î±)  (t : Set Î²)"},
 {"type": "(range fun x => (f x, g x)) âŠ† range f Ã—Ë¢ range g",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³) : (range fun x => (f x, g x)) âŠ† range f Ã—Ë¢ range g := by have : (fun x => (f x, g x)) = Prod.map f g âˆ˜ fun x => (x, x) := funext fun x => rfl; sorry",
  "name": "range_pair_subset",
  "kind": "theorem",
  "first-tactic":
  "have : (fun x => (f x, g x)) = Prod.map f g âˆ˜ fun x => (x, x) := funext fun x => rfl",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³) : (range fun x => (f x, g x)) âŠ† range f Ã—Ë¢ range g",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)"},
 {"type": "s Ã—Ë¢ t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ… := by simp only [not_nonempty_iff_eq_empty.symm]; sorry",
  "name": "prod_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp only [not_nonempty_iff_eq_empty.symm]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t = âˆ… â†” s = âˆ… âˆ¨ t = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ t âŠ† f â»Â¹' W â†” âˆ€ a b, a âˆˆ s â†’ b âˆˆ t â†’ f (a, b) âˆˆ W",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {W : Set Î³}  {f : Î± Ã— Î² â†’ Î³} : s Ã—Ë¢ t âŠ† f â»Â¹' W â†” âˆ€ a b, a âˆˆ s â†’ b âˆˆ t â†’ f (a, b) âˆˆ W := by simp [subset_def]; sorry",
  "name": "prod_sub_preimage_iff",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {W : Set Î³}  {f : Î± Ã— Î² â†’ Î³} : s Ã—Ë¢ t âŠ† f â»Â¹' W â†” âˆ€ a b, a âˆˆ s â†’ b âˆˆ t â†’ f (a, b) âˆˆ W",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {W : Set Î³}  {f : Î± Ã— Î² â†’ Î³}"},
 {"type": "(fun x => (f x, g x)) '' s âŠ† (f '' s) Ã—Ë¢ (g '' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {f : Î± â†’ Î²}  {g : Î± â†’ Î³}  {s : Set Î±} : (fun x => (f x, g x)) '' s âŠ† (f '' s) Ã—Ë¢ (g '' s) := by rintro _ âŸ¨x, hx, rflâŸ©; sorry",
  "name": "image_prod_mk_subset_prod",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨x, hx, rflâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {f : Î± â†’ Î²}  {g : Î± â†’ Î³}  {s : Set Î±} : (fun x => (f x, g x)) '' s âŠ† (f '' s) Ã—Ë¢ (g '' s)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} {f : Î± â†’ Î²}  {g : Î± â†’ Î³}  {s : Set Î±}"},
 {"type": "(fun a => (a, b)) '' s âŠ† s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t) : (fun a => (a, b)) '' s âŠ† s Ã—Ë¢ t := by rintro _ âŸ¨a, ha, rflâŸ©; sorry",
  "name": "image_prod_mk_subset_prod_left",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, ha, rflâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t) : (fun a => (a, b)) '' s âŠ† s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (hb : b âˆˆ t)"},
 {"type": "Prod.mk a '' t âŠ† s Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s) : Prod.mk a '' t âŠ† s Ã—Ë¢ t := by rintro _ âŸ¨b, hb, rflâŸ©; sorry",
  "name": "image_prod_mk_subset_prod_right",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨b, hb, rflâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s) : Prod.mk a '' t âŠ† s Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ha : a âˆˆ s)"},
 {"type": "s Ã—Ë¢ t \\ sâ‚ Ã—Ë¢ tâ‚ = s Ã—Ë¢ (t \\ tâ‚) âˆª (s \\ sâ‚) Ã—Ë¢ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t \\ sâ‚ Ã—Ë¢ tâ‚ = s Ã—Ë¢ (t \\ tâ‚) âˆª (s \\ sâ‚) Ã—Ë¢ t := by ext x; sorry",
  "name": "prod_diff_prod",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t \\ sâ‚ Ã—Ë¢ tâ‚ = s Ã—Ë¢ (t \\ tâ‚) âˆª (s \\ sâ‚) Ã—Ë¢ t",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ… := by cases' (s Ã—Ë¢ t).eq_empty_or_nonempty with h h; sorry",
  "name": "prod_subset_prod_iff",
  "kind": "theorem",
  "first-tactic": "cases' (s Ã—Ë¢ t).eq_empty_or_nonempty with h h",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t âŠ† sâ‚ Ã—Ë¢ tâ‚ â†” s âŠ† sâ‚ âˆ§ t âŠ† tâ‚ âˆ¨ s = âˆ… âˆ¨ t = âˆ…",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (h : (s Ã—Ë¢ t).Nonempty) : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚ := by constructor; sorry",
  "name": "prod_eq_prod_iff_of_nonempty",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (h : (s Ã—Ë¢ t).Nonempty) : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (h : (s Ã—Ë¢ t).Nonempty)"},
 {"type":
  "s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚ âˆ¨ (s = âˆ… âˆ¨ t = âˆ…) âˆ§ (sâ‚ = âˆ… âˆ¨ tâ‚ = âˆ…)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚ âˆ¨ (s = âˆ… âˆ¨ t = âˆ…) âˆ§ (sâ‚ = âˆ… âˆ¨ tâ‚ = âˆ…) := by symm; sorry",
  "name": "prod_eq_prod_iff",
  "kind": "theorem",
  "first-tactic": "symm",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ tâ‚ â†” s = sâ‚ âˆ§ t = tâ‚ âˆ¨ (s = âˆ… âˆ¨ t = âˆ…) âˆ§ (sâ‚ = âˆ… âˆ¨ tâ‚ = âˆ…)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²}"},
 {"type": "s Ã—Ë¢ t = sâ‚ Ã—Ë¢ t â†” s = sâ‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ht : t.Nonempty) : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ t â†” s = sâ‚ := by simp_rw [prod_eq_prod_iff]; sorry",
  "name": "prod_eq_iff_eq",
  "kind": "theorem",
  "first-tactic": "simp_rw [prod_eq_prod_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ht : t.Nonempty) : s Ã—Ë¢ t = sâ‚ Ã—Ë¢ t â†” s = sâ‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {s sâ‚ sâ‚‚ : Set Î±}  {t tâ‚ tâ‚‚ : Set Î²}  {a : Î±}  {b : Î²} (ht : t.Nonempty)"},
 {"type": "(x, x) âˆˆ diagonal Î±",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} (x : Î±) : (x, x) âˆˆ diagonal Î± := by simp [diagonal]; sorry",
  "name": "mem_diagonal",
  "kind": "theorem",
  "first-tactic": "simp [diagonal]",
  "core-prompt": "{Î± : Type _}  {s t : Set Î±} (x : Î±) : (x, x) âˆˆ diagonal Î±",
  "args": "{Î± : Type _}  {s t : Set Î±} (x : Î±)"},
 {"type":
  "Prod.map (fun x : s => (x : Î±)) (fun x : s => (x : Î±)) â»Â¹' diagonal Î± = diagonal s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} (s : Set Î±) : Prod.map (fun x : s => (x : Î±)) (fun x : s => (x : Î±)) â»Â¹' diagonal Î± = diagonal s := by ext âŸ¨âŸ¨x, hxâŸ©, âŸ¨y, hyâŸ©âŸ©; sorry",
  "name": "preimage_coe_coe_diagonal",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨âŸ¨x, hxâŸ©, âŸ¨y, hyâŸ©âŸ©",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} (s : Set Î±) : Prod.map (fun x : s => (x : Î±)) (fun x : s => (x : Î±)) â»Â¹' diagonal Î± = diagonal s",
  "args": "{Î± : Type _}  {s t : Set Î±} (s : Set Î±)"},
 {"type": "(range fun x => (x, x)) = diagonal Î±",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±} : (range fun x => (x, x)) = diagonal Î± := by ext âŸ¨x, yâŸ©; sorry",
  "name": "range_diag",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±} : (range fun x => (x, x)) = diagonal Î±",
  "args": "{Î± : Type _}  {s t : Set Î±}"},
 {"type": "s.offDiag.Nonempty â†” s.Nontrivial",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : s.offDiag.Nonempty â†” s.Nontrivial := by simp [offDiag]; sorry",
  "name": "offDiag_nonempty",
  "kind": "theorem",
  "first-tactic": "simp [offDiag]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : s.offDiag.Nonempty â†” s.Nontrivial",
  "args": "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±}"},
 {"type": "s.offDiag = âˆ… â†” s.Subsingleton",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : s.offDiag = âˆ… â†” s.Subsingleton := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "offDiag_eq_empty",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : s.offDiag = âˆ… â†” s.Subsingleton",
  "args": "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±}"},
 {"type": "(âˆ… : Set Î±).offDiag = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : (âˆ… : Set Î±).offDiag = âˆ… := by simp; sorry",
  "name": "offDiag_empty",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} : (âˆ… : Set Î±).offDiag = âˆ…",
  "args": "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±}"},
 {"type": "({a} : Set Î±).offDiag = âˆ…",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (a : Î±) : ({a} : Set Î±).offDiag = âˆ… := by simp; sorry",
  "name": "offDiag_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (a : Î±) : ({a} : Set Î±).offDiag = âˆ…",
  "args": "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (a : Î±)"},
 {"type": "(s âˆª t).offDiag = s.offDiag âˆª t.offDiag âˆª s Ã—Ë¢ t âˆª t Ã—Ë¢ s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (h : Disjoint s t) : (s âˆª t).offDiag = s.offDiag âˆª t.offDiag âˆª s Ã—Ë¢ t âˆª t Ã—Ë¢ s := by ext x; sorry",
  "name": "offDiag_union",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (h : Disjoint s t) : (s âˆª t).offDiag = s.offDiag âˆª t.offDiag âˆª s Ã—Ë¢ t âˆª t Ã—Ë¢ s",
  "args":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (h : Disjoint s t)"},
 {"type": "(insert a s).offDiag = s.offDiag âˆª {a} Ã—Ë¢ s âˆª s Ã—Ë¢ {a}",
  "tactic-prompt":
  "theorem {Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (ha : a âˆ‰ s) : (insert a s).offDiag = s.offDiag âˆª {a} Ã—Ë¢ s âˆª s Ã—Ë¢ {a} := by rw [insert_eq]; sorry",
  "name": "offDiag_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (ha : a âˆ‰ s) : (insert a s).offDiag = s.offDiag âˆª {a} Ã—Ë¢ s âˆª s Ã—Ë¢ {a}",
  "args": "{Î± : Type _}  {s t : Set Î±}  {x : Î± Ã— Î±}  {a : Î±} (ha : a âˆ‰ s)"},
 {"type": "f âˆˆ pi univ t â†” âˆ€ i, f i âˆˆ t i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {f : âˆ€ i, Î± i} : f âˆˆ pi univ t â†” âˆ€ i, f i âˆˆ t i := by simp; sorry",
  "name": "mem_univ_pi",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {f : âˆ€ i, Î± i} : f âˆˆ pi univ t â†” âˆ€ i, f i âˆˆ t i",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {f : âˆ€ i, Î± i}"},
 {"type": "pi âˆ… s = univ",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : âˆ€ i, Set (Î± i)) : pi âˆ… s = univ := by ext; sorry",
  "name": "empty_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : âˆ€ i, Set (Î± i)) : pi âˆ… s = univ",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : âˆ€ i, Set (Î± i))"},
 {"type": "s.pi t = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (hs : i âˆˆ s)  (ht : t i = âˆ…) : s.pi t = âˆ… := by ext f; sorry",
  "name": "pi_eq_empty",
  "kind": "theorem",
  "first-tactic": "ext f",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (hs : i âˆˆ s)  (ht : t i = âˆ…) : s.pi t = âˆ…",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (hs : i âˆˆ s)  (ht : t i = âˆ…)"},
 {"type": "(s.pi t).Nonempty â†” âˆ€ i, âˆƒ x, i âˆˆ s â†’ x âˆˆ t i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (s.pi t).Nonempty â†” âˆ€ i, âˆƒ x, i âˆˆ s â†’ x âˆˆ t i := by simp [Classical.skolem]; sorry",
  "name": "pi_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Classical.skolem]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (s.pi t).Nonempty â†” âˆ€ i, âˆƒ x, i âˆˆ s â†’ x âˆˆ t i",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "(pi univ t).Nonempty â†” âˆ€ i, (t i).Nonempty",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (pi univ t).Nonempty â†” âˆ€ i, (t i).Nonempty := by simp [Classical.skolem]; sorry",
  "name": "univ_pi_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "simp [Classical.skolem]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (pi univ t).Nonempty â†” âˆ€ i, (t i).Nonempty",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "s.pi t = âˆ… â†” âˆƒ i, IsEmpty (Î± i) âˆ¨ i âˆˆ s âˆ§ t i = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : s.pi t = âˆ… â†” âˆƒ i, IsEmpty (Î± i) âˆ¨ i âˆˆ s âˆ§ t i = âˆ… := by rw [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "pi_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : s.pi t = âˆ… â†” âˆƒ i, IsEmpty (Î± i) âˆ¨ i âˆˆ s âˆ§ t i = âˆ…",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "pi univ t = âˆ… â†” âˆƒ i, t i = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi univ t = âˆ… â†” âˆƒ i, t i = âˆ… := by simp [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "univ_pi_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "simp [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi univ t = âˆ… â†” âˆƒ i, t i = âˆ…",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "Disjoint (pi univ tâ‚) (pi univ tâ‚‚) â†” âˆƒ i, Disjoint (tâ‚ i) (tâ‚‚ i)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : Disjoint (pi univ tâ‚) (pi univ tâ‚‚) â†” âˆƒ i, Disjoint (tâ‚ i) (tâ‚‚ i) := by simp only [disjoint_iff_inter_eq_empty]; sorry",
  "name": "disjoint_univ_pi",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff_inter_eq_empty]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : Disjoint (pi univ tâ‚) (pi univ tâ‚‚) â†” âˆƒ i, Disjoint (tâ‚ i) (tâ‚‚ i)",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type":
  "(range fun g : âˆ€ i, Î± i => fun i => f i (g i)) = pi univ fun i => range (f i)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (f : âˆ€ i, Î± i â†’ Î² i) : (range fun g : âˆ€ i, Î± i => fun i => f i (g i)) = pi univ fun i => range (f i) := by refine Subset.antisymm ?_ fun x hx => ?_; sorry",
  "name": "range_dcomp",
  "kind": "theorem",
  "first-tactic": "refine Subset.antisymm ?_ fun x hx => ?_",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (f : âˆ€ i, Î± i â†’ Î² i) : (range fun g : âˆ€ i, Î± i => fun i => f i (g i)) = pi univ fun i => range (f i)",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (f : âˆ€ i, Î± i â†’ Î² i)"},
 {"type": "pi (insert i s) t = eval i â»Â¹' t i âˆ© pi s t",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i)) : pi (insert i s) t = eval i â»Â¹' t i âˆ© pi s t := by ext; sorry",
  "name": "insert_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i)) : pi (insert i s) t = eval i â»Â¹' t i âˆ© pi s t",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (s : Set Î¹)  (t : âˆ€ i, Set (Î± i))"},
 {"type": "pi {i} t = eval i â»Â¹' t i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (t : âˆ€ i, Set (Î± i)) : pi {i} t = eval i â»Â¹' t i := by ext; sorry",
  "name": "singleton_pi",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (t : âˆ€ i, Set (Î± i)) : pi {i} t = eval i â»Â¹' t i",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (i : Î¹)  (t : âˆ€ i, Set (Î± i))"},
 {"type":
  "(pi s fun i => if p i then tâ‚ i else tâ‚‚ i) =\n      pi ({ i âˆˆ s | p i }) tâ‚ âˆ© pi ({ i âˆˆ s | Â¬p i }) tâ‚‚",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {p : Î¹ â†’ Prop}  [h : DecidablePred p]  (s : Set Î¹)  (tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)) : (pi s fun i => if p i then tâ‚ i else tâ‚‚ i) =\n      pi ({ i âˆˆ s | p i }) tâ‚ âˆ© pi ({ i âˆˆ s | Â¬p i }) tâ‚‚ := by ext f; sorry",
  "name": "pi_if",
  "kind": "theorem",
  "first-tactic": "ext f",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {p : Î¹ â†’ Prop}  [h : DecidablePred p]  (s : Set Î¹)  (tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)) : (pi s fun i => if p i then tâ‚ i else tâ‚‚ i) =\n      pi ({ i âˆˆ s | p i }) tâ‚ âˆ© pi ({ i âˆˆ s | Â¬p i }) tâ‚‚",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} {p : Î¹ â†’ Prop}  [h : DecidablePred p]  (s : Set Î¹)  (tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i))"},
 {"type": "(sâ‚ âˆª sâ‚‚).pi t = sâ‚.pi t âˆ© sâ‚‚.pi t",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (sâ‚ âˆª sâ‚‚).pi t = sâ‚.pi t âˆ© sâ‚‚.pi t := by simp [pi]; sorry",
  "name": "union_pi",
  "kind": "theorem",
  "first-tactic": "simp [pi]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : (sâ‚ âˆª sâ‚‚).pi t = sâ‚.pi t âˆ© sâ‚‚.pi t",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "pi s t âˆ© pi (sá¶œ) t = pi univ t",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹) : pi s t âˆ© pi (sá¶œ) t = pi univ t := by rw [â† union_pi]; sorry",
  "name": "pi_inter_compl",
  "kind": "theorem",
  "first-tactic": "rw [â† union_pi]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹) : pi s t âˆ© pi (sá¶œ) t = pi univ t",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹)"},
 {"type":
  "(pi univ fun j => t j (update f i a j)) = { x | x i âˆˆ t i a } âˆ© pi ({i}á¶œ) fun j => t j (f j)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {Î² : âˆ€ _, Type _}  (i : Î¹)  (f : âˆ€ j, Î± j)  (a : Î± i)      (t : âˆ€ j, Î± j â†’ Set (Î² j)) : (pi univ fun j => t j (update f i a j)) = { x | x i âˆˆ t i a } âˆ© pi ({i}á¶œ) fun j => t j (f j) := by rw [compl_eq_univ_diff]; sorry",
  "name": "univ_pi_update",
  "kind": "theorem",
  "first-tactic": "rw [compl_eq_univ_diff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {Î² : âˆ€ _, Type _}  (i : Î¹)  (f : âˆ€ j, Î± j)  (a : Î± i)      (t : âˆ€ j, Î± j â†’ Set (Î² j)) : (pi univ fun j => t j (update f i a j)) = { x | x i âˆˆ t i a } âˆ© pi ({i}á¶œ) fun j => t j (f j)",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {Î² : âˆ€ _, Type _}  (i : Î¹)  (f : âˆ€ j, Î± j)  (a : Î± i)      (t : âˆ€ j, Î± j â†’ Set (Î² j))"},
 {"type":
  "pi univ (update (fun j : Î¹ => (univ : Set (Î± j))) i s) = eval i â»Â¹' s",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  (i : Î¹)  (s : Set (Î± i)) : pi univ (update (fun j : Î¹ => (univ : Set (Î± j))) i s) = eval i â»Â¹' s := by rw [univ_pi_update i (fun j => (univ : Set (Î± j))) s fun j t => t]; sorry",
  "name": "univ_pi_update_univ",
  "kind": "theorem",
  "first-tactic":
  "rw [univ_pi_update i (fun j => (univ : Set (Î± j))) s fun j t => t]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  (i : Î¹)  (s : Set (Î± i)) : pi univ (update (fun j : Î¹ => (univ : Set (Î± j))) i s) = eval i â»Â¹' s",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  (i : Î¹)  (s : Set (Î± i))"},
 {"type": "t i âŠ† eval i '' s.pi t",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (ht : (s.pi t).Nonempty)  (i : Î¹) : t i âŠ† eval i '' s.pi t := by classical\n  obtain âŸ¨f, hfâŸ© := ht\n  refine' fun y hy => âŸ¨update f i y, fun j hj => _, update_same _ _ _âŸ©\n  obtain rfl | hji := eq_or_ne j i; sorry",
  "name": "subset_eval_image_pi",
  "kind": "theorem",
  "first-tactic":
  "classical\n  obtain âŸ¨f, hfâŸ© := ht\n  refine' fun y hy => âŸ¨update f i y, fun j hj => _, update_same _ _ _âŸ©\n  obtain rfl | hji := eq_or_ne j i",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (ht : (s.pi t).Nonempty)  (i : Î¹) : t i âŠ† eval i '' s.pi t",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (ht : (s.pi t).Nonempty)  (i : Î¹)"},
 {"type": "pi s tâ‚ âŠ† pi s tâ‚‚ â†” (âˆ€ i âˆˆ s, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ pi s tâ‚ = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi s tâ‚ âŠ† pi s tâ‚‚ â†” (âˆ€ i âˆˆ s, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ pi s tâ‚ = âˆ… := by refine'\n    âŸ¨fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm â–¸ empty_subset _âŸ©; sorry",
  "name": "pi_subset_pi_iff",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm â–¸ empty_subset _âŸ©",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi s tâ‚ âŠ† pi s tâ‚‚ â†” (âˆ€ i âˆˆ s, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ pi s tâ‚ = âˆ…",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "pi univ tâ‚ âŠ† pi univ tâ‚‚ â†” (âˆ€ i, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ âˆƒ i, tâ‚ i = âˆ…",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi univ tâ‚ âŠ† pi univ tâ‚‚ â†” (âˆ€ i, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ âˆƒ i, tâ‚ i = âˆ… := by simp [pi_subset_pi_iff]; sorry",
  "name": "univ_pi_subset_univ_pi_iff",
  "kind": "theorem",
  "first-tactic": "simp [pi_subset_pi_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} : pi univ tâ‚ âŠ† pi univ tâ‚‚ â†” (âˆ€ i, tâ‚ i âŠ† tâ‚‚ i) âˆ¨ âˆƒ i, tâ‚ i = âˆ…",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹}"},
 {"type": "eval i â»Â¹' s = pi univ (update (fun i => univ) i s)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)} : eval i â»Â¹' s = pi univ (update (fun i => univ) i s) := by ext x; sorry",
  "name": "eval_preimage",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)} : eval i â»Â¹' s = pi univ (update (fun i => univ) i s)",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)}"},
 {"type": "eval i â»Â¹' s = pi {i} (update (fun i => univ) i s)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)} : eval i â»Â¹' s = pi {i} (update (fun i => univ) i s) := by ext; sorry",
  "name": "eval_preimage'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)} : eval i â»Â¹' s = pi {i} (update (fun i => univ) i s)",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {s : Set (Î± i)}"},
 {"type": "update f i â»Â¹' s.pi t = t i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {f : âˆ€ i, Î± i}  (hi : i âˆˆ s)      (hf : âˆ€ j âˆˆ s, j â‰  i â†’ f j âˆˆ t j) : update f i â»Â¹' s.pi t = t i := by ext x; sorry",
  "name": "update_preimage_pi",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {f : âˆ€ i, Î± i}  (hi : i âˆˆ s)      (hf : âˆ€ j âˆˆ s, j â‰  i â†’ f j âˆˆ t j) : update f i â»Â¹' s.pi t = t i",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} [DecidableEq Î¹]  {f : âˆ€ i, Î± i}  (hi : i âˆˆ s)      (hf : âˆ€ j âˆˆ s, j â‰  i â†’ f j âˆˆ t j)"},
 {"type": "(pi univ fun i => if i âˆˆ s then t i else univ) = s.pi t",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹)  [DecidablePred (Â· âˆˆ s)]  (t : âˆ€ i, Set (Î± i)) : (pi univ fun i => if i âˆˆ s then t i else univ) = s.pi t := by ext; sorry",
  "name": "univ_pi_ite",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹)  [DecidablePred (Â· âˆˆ s)]  (t : âˆ€ i, Set (Î± i)) : (pi univ fun i => if i âˆˆ s then t i else univ) = s.pi t",
  "args":
  "{Î¹ : Type _}  {Î± Î² : Î¹ â†’ Type _}  {s sâ‚ sâ‚‚ : Set Î¹}  {t tâ‚ tâ‚‚ : âˆ€ i, Set (Î± i)}  {i : Î¹} (s : Set Î¹)  [DecidablePred (Â· âˆˆ s)]  (t : âˆ€ i, Set (Î± i))"},
 {"type": "op a âˆˆ s.op â†” a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type _} {s : Set Î±}  {a : Î±} : op a âˆˆ s.op â†” a âˆˆ s := by rfl; sorry",
  "name": "op_mem_op",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Type _} {s : Set Î±}  {a : Î±} : op a âˆˆ s.op â†” a âˆˆ s",
  "args": "{Î± : Type _} {s : Set Î±}  {a : Î±}"},
 {"type": "unop a âˆˆ s.unop â†” a âˆˆ s",
  "tactic-prompt":
  "theorem {Î± : Type _} {s : Set Î±áµ’áµ–}  {a : Î±áµ’áµ–} : unop a âˆˆ s.unop â†” a âˆˆ s := by rfl; sorry",
  "name": "unop_mem_unop",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{Î± : Type _} {s : Set Î±áµ’áµ–}  {a : Î±áµ’áµ–} : unop a âˆˆ s.unop â†” a âˆˆ s",
  "args": "{Î± : Type _} {s : Set Î±áµ’áµ–}  {a : Î±áµ’áµ–}"},
 {"type": "f â»Â¹' s = g â»Â¹' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f g : Î± â†’ Î²}  {s : Set Î²}  (h : âˆ€ x : Î±, f x = g x) : f â»Â¹' s = g â»Â¹' s := by congr with x; sorry",
  "name": "preimage_congr",
  "kind": "theorem",
  "first-tactic": "congr with x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f g : Î± â†’ Î²}  {s : Set Î²}  (h : âˆ€ x : Î±, f x = g x) : f â»Â¹' s = g â»Â¹' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f g : Î± â†’ Î²}  {s : Set Î²}  (h : âˆ€ x : Î±, f x = g x)"},
 {"type": "(fun _ : Î± => b) â»Â¹' s = if b âˆˆ s then univ else âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} (b : Î²)  (s : Set Î²)  [Decidable (b âˆˆ s)] : (fun _ : Î± => b) â»Â¹' s = if b âˆˆ s then univ else âˆ… := by split_ifs with hb; sorry",
  "name": "preimage_const",
  "kind": "theorem",
  "first-tactic": "split_ifs with hb",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} (b : Î²)  (s : Set Î²)  [Decidable (b âˆˆ s)] : (fun _ : Î± => b) â»Â¹' s = if b âˆˆ s then univ else âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} (b : Î²)  (s : Set Î²)  [Decidable (b âˆˆ s)]"},
 {"type": "Set.preimage (f^[n]) = Set.preimage f^[n]",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f : Î± â†’ Î±}  {n : â„•} : Set.preimage (f^[n]) = Set.preimage f^[n] := by induction' n with n ih; sorry",
  "name": "preimage_iterate_eq",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f : Î± â†’ Î±}  {n : â„•} : Set.preimage (f^[n]) = Set.preimage f^[n]",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {f : Î± â†’ Î±}  {n : â„•}"},
 {"type": "(fun x : s => (x : Î±)) â»Â¹' u = ((fun x : s => (x : Î±)) â»Â¹' v)á¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {Î± : Type _}  {s u v : Set Î±}  (hsuv : s âŠ† u âˆª v)      (H : s âˆ© (u âˆ© v) = âˆ…) : (fun x : s => (x : Î±)) â»Â¹' u = ((fun x : s => (x : Î±)) â»Â¹' v)á¶œ := by ext âŸ¨x, x_in_sâŸ©; sorry",
  "name": "preimage_subtype_coe_eq_compl",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, x_in_sâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {Î± : Type _}  {s u v : Set Î±}  (hsuv : s âŠ† u âˆª v)      (H : s âˆ© (u âˆ© v) = âˆ…) : (fun x : s => (x : Î±)) â»Â¹' u = ((fun x : s => (x : Î±)) â»Â¹' v)á¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {g : Î² â†’ Î³} {Î± : Type _}  {s u v : Set Î±}  (hsuv : s âŠ† u âˆª v)      (H : s âˆ© (u âˆ© v) = âˆ…)"},
 {"type": "(âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ x âˆˆ s, p (f x)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop} : (âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ x âˆˆ s, p (f x) := by simp; sorry",
  "name": "ball_image_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop} : (âˆ€ y âˆˆ f '' s, p y) â†” âˆ€ x âˆˆ s, p (f x)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop}"},
 {"type": "(âˆƒ y âˆˆ f '' s, p y) â†” âˆƒ x âˆˆ s, p (f x)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop} : (âˆƒ y âˆˆ f '' s, p y) â†” âˆƒ x âˆˆ s, p (f x) := by simp; sorry",
  "name": "bex_image_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop} : (âˆƒ y âˆˆ f '' s, p y) â†” âˆƒ x âˆˆ s, p (f x)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {p : Î² â†’ Prop}"},
 {"type": "f '' s = g '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : Î± â†’ Î²}  {s : Set Î±}  (h : âˆ€ a âˆˆ s, f a = g a) : f '' s = g '' s := by ext x; sorry",
  "name": "image_congr",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : Î± â†’ Î²}  {s : Set Î±}  (h : âˆ€ a âˆˆ s, f a = g a) : f '' s = g '' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f g : Î± â†’ Î²}  {s : Set Î±}  (h : âˆ€ a âˆˆ s, f a = g a)"},
 {"type": "f '' a âŠ† f '' b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set Î±}  (f : Î± â†’ Î²)  (h : a âŠ† b) : f '' a âŠ† f '' b := by simp only [subset_def]; sorry",
  "name": "image_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set Î±}  (f : Î± â†’ Î²)  (h : a âŠ† b) : f '' a âŠ† f '' b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {a b : Set Î±}  (f : Î± â†’ Î²)  (h : a âŠ† b)"},
 {"type": "f '' âˆ… = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²) : f '' âˆ… = âˆ… := by ext; sorry",
  "name": "image_empty",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²) : f '' âˆ… = âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)"},
 {"type": "f '' {a} = {f a}",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±} : f '' {a} = {f a} := by ext; sorry",
  "name": "image_singleton",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±} : f '' {a} = {f a}",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±}"},
 {"type": "t âˆˆ HasCompl.compl '' S â†” tá¶œ âˆˆ S",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (t : Î±)  (S : Set Î±) : t âˆˆ HasCompl.compl '' S â†” tá¶œ âˆˆ S := by simp [â† preimage_compl_eq_image_compl]; sorry",
  "name": "mem_compl_image",
  "kind": "theorem",
  "first-tactic": "simp [â† preimage_compl_eq_image_compl]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (t : Î±)  (S : Set Î±) : t âˆˆ HasCompl.compl '' S â†” tá¶œ âˆˆ S",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (t : Î±)  (S : Set Î±)"},
 {"type": "(fun x => x) '' s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±) : (fun x => x) '' s = s := by ext; sorry",
  "name": "image_id'",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±) : (fun x => x) '' s = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±)"},
 {"type": "id '' s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±) : id '' s = s := by simp; sorry",
  "name": "image_id",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±) : id '' s = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (s : Set Î±)"},
 {"type": "HasCompl.compl '' (HasCompl.compl '' S) = S",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (S : Set Î±) : HasCompl.compl '' (HasCompl.compl '' S) = S := by rw [â† image_comp]; sorry",
  "name": "compl_compl_image",
  "kind": "theorem",
  "first-tactic": "rw [â† image_comp]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (S : Set Î±) : HasCompl.compl '' (HasCompl.compl '' S) = S",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` [BooleanAlgebra Î±]  (S : Set Î±)"},
 {"type": "f '' insert a s = insert (f a) (f '' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±}  {s : Set Î±} : f '' insert a s = insert (f a) (f '' s) := by ext; sorry",
  "name": "image_insert_eq",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±}  {s : Set Î±} : f '' insert a s = insert (f a) (f '' s)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {a : Î±}  {s : Set Î±}"},
 {"type": "f '' {a, b} = {f a, f b}",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (a b : Î±) : f '' {a, b} = {f a, f b} := by simp only [image_insert_eq]; sorry",
  "name": "image_pair",
  "kind": "theorem",
  "first-tactic": "simp only [image_insert_eq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (a b : Î±) : f '' {a, b} = {f a, f b}",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (a b : Î±)"},
 {"type": "b âˆˆ f '' s â†” g b âˆˆ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {g : Î² â†’ Î±}  {b : Î²}  {s : Set Î±}  (hâ‚ : LeftInverse g f)      (hâ‚‚ : RightInverse g f) : b âˆˆ f '' s â†” g b âˆˆ s := by rw [image_eq_preimage_of_inverse hâ‚ hâ‚‚]; sorry",
  "name": "mem_image_iff_of_inverse",
  "kind": "theorem",
  "first-tactic": "rw [image_eq_preimage_of_inverse hâ‚ hâ‚‚]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {g : Î² â†’ Î±}  {b : Î²}  {s : Set Î±}  (hâ‚ : LeftInverse g f)      (hâ‚‚ : RightInverse g f) : b âˆˆ f '' s â†” g b âˆˆ s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {g : Î² â†’ Î±}  {b : Î²}  {s : Set Î±}  (hâ‚ : LeftInverse g f)      (hâ‚‚ : RightInverse g f)"},
 {"type": "f '' s \\ f '' t âŠ† f '' (s \\ t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s t : Set Î±) : f '' s \\ f '' t âŠ† f '' (s \\ t) := by rw [diff_subset_iff]; sorry",
  "name": "subset_image_diff",
  "kind": "theorem",
  "first-tactic": "rw [diff_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s t : Set Î±) : f '' s \\ f '' t âŠ† f '' (s \\ t)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s t : Set Î±)"},
 {"type": "f '' s âˆ† t = (f '' s) âˆ† (f '' t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set Î±) : f '' s âˆ† t = (f '' s) âˆ† (f '' t) := by simp_rw [Set.symmDiff_def]; sorry",
  "name": "image_symm_diff",
  "kind": "theorem",
  "first-tactic": "simp_rw [Set.symmDiff_def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set Î±) : f '' s âˆ† t = (f '' s) âˆ† (f '' t)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (hf : Injective f)  (s t : Set Î±)"},
 {"type": "f '' (s âˆ© f â»Â¹' t) = f '' s âˆ© t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²) : f '' (s âˆ© f â»Â¹' t) = f '' s âˆ© t := by apply Subset.antisymm; sorry",
  "name": "image_inter_preimage",
  "kind": "theorem",
  "first-tactic": "apply Subset.antisymm",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²) : f '' (s âˆ© f â»Â¹' t) = f '' s âˆ© t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²)"},
 {"type": "f '' (f â»Â¹' t âˆ© s) = t âˆ© f '' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²) : f '' (f â»Â¹' t âˆ© s) = t âˆ© f '' s := by simp only [inter_comm]; sorry",
  "name": "image_preimage_inter",
  "kind": "theorem",
  "first-tactic": "simp only [inter_comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²) : f '' (f â»Â¹' t âˆ© s) = t âˆ© f '' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` (f : Î± â†’ Î²)  (s : Set Î±)  (t : Set Î²)"},
 {"type": "(f '' s âˆ© t).Nonempty â†” (s âˆ© f â»Â¹' t).Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²} : (f '' s âˆ© t).Nonempty â†” (s âˆ© f â»Â¹' t).Nonempty := by rw [â† image_inter_preimage]; sorry",
  "name": "image_inter_nonempty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† image_inter_preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²} : (f '' s âˆ© t).Nonempty â†” (s âˆ© f â»Â¹' t).Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²}"},
 {"type": "f '' (s \\ f â»Â¹' t) = f '' s \\ t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²} : f '' (s \\ f â»Â¹' t) = f '' s \\ t := by simp_rw [diff_eq]; sorry",
  "name": "image_diff_preimage",
  "kind": "theorem",
  "first-tactic": "simp_rw [diff_eq]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²} : f '' (s \\ f â»Â¹' t) = f '' s \\ t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  {s : Set Î±}  {t : Set Î²}"},
 {"type": "f '' s âŠ† f '' t â†” s âŠ† t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  (hf : Injective f) : f '' s âŠ† f '' t â†” s âŠ† t := by refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _; sorry",
  "name": "image_subset_image_iff",
  "kind": "theorem",
  "first-tactic": "refine' Iff.symm <| (Iff.intro (image_subset f)) fun h => _",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  (hf : Injective f) : f '' s âŠ† f '' t â†” s âŠ† t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {f : Î± â†’ Î²}  (hf : Injective f)"},
 {"type": "Ïƒ '' s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set Î±}  {Ïƒ : Equiv.Perm Î±}  (hs : { a : Î± | Ïƒ a â‰  a } âŠ† s) : Ïƒ '' s = s := by ext i; sorry",
  "name": "image_perm",
  "kind": "theorem",
  "first-tactic": "ext i",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set Î±}  {Ïƒ : Equiv.Perm Î±}  (hs : { a : Î± | Ïƒ a â‰  a } âŠ† s) : Ïƒ '' s = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î± â†’ Î²}  {s t : Set Î±}  -- Porting note: `Set.image` is already defined in `Init.Set` {s : Set Î±}  {Ïƒ : Equiv.Perm Î±}  (hs : { a : Î± | Ïƒ a â‰  a } âŠ† s)"},
 {"type": "(âˆ€ a âˆˆ range f, p a) â†” âˆ€ i, p (f i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆ€ a âˆˆ range f, p a) â†” âˆ€ i, p (f i) := by simp; sorry",
  "name": "forall_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆ€ a âˆˆ range f, p a) â†” âˆ€ i, p (f i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}"},
 {"type": "(âˆƒ a âˆˆ range f, p a) â†” âˆƒ i, p (f i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆƒ a âˆˆ range f, p a) â†” âˆƒ i, p (f i) := by simp; sorry",
  "name": "exists_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆƒ a âˆˆ range f, p a) â†” âˆƒ i, p (f i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}"},
 {"type": "(âˆƒ a, a âˆˆ range f âˆ§ p a) â†” âˆƒ i, p (f i)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆƒ a, a âˆˆ range f âˆ§ p a) â†” âˆƒ i, p (f i) := by simpa only [exists_prop] using exists_range_iff; sorry",
  "name": "exists_range_iff'",
  "kind": "theorem",
  "first-tactic": "simpa only [exists_prop] using exists_range_iff",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop} : (âˆƒ a, a âˆˆ range f âˆ§ p a) â†” âˆƒ i, p (f i)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}"},
 {"type": "f '' univ = range f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²} : f '' univ = range f := by ext; sorry",
  "name": "image_univ",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²} : f '' univ = range f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}"},
 {"type": "range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î²) : range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b := by rw [â† range_subset_iff]; sorry",
  "name": "range_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† range_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î²) : range f = s â†” (âˆ€ a, f a âˆˆ s) âˆ§ âˆ€ b âˆˆ s, âˆƒ a, f a = b",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î²)"},
 {"type": "range (g âˆ˜ f) âŠ† range g",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (g : Î² â†’ Î³) : range (g âˆ˜ f) âŠ† range g := by rw [range_comp]; sorry",
  "name": "range_comp_subset_range",
  "kind": "theorem",
  "first-tactic": "rw [range_comp]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (g : Î² â†’ Î³) : range (g âˆ˜ f) âŠ† range g",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (g : Î² â†’ Î³)"},
 {"type": "range f = âˆ… â†” IsEmpty Î¹",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±} : range f = âˆ… â†” IsEmpty Î¹ := by rw [â† not_nonempty_iff]; sorry",
  "name": "range_eq_empty_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±} : range f = âˆ… â†” IsEmpty Î¹",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±}"},
 {"type": "f '' s âˆª f '' sá¶œ = range f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²) : f '' s âˆª f '' sá¶œ = range f := by rw [â† image_union]; sorry",
  "name": "image_union_image_compl_eq_range",
  "kind": "theorem",
  "first-tactic": "rw [â† image_union]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²) : f '' s âˆª f '' sá¶œ = range f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)"},
 {"type": "insert (f x) (f '' {x}á¶œ) = range f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (x : Î±) : insert (f x) (f '' {x}á¶œ) = range f := by ext y; sorry",
  "name": "insert_image_compl_eq_range",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (x : Î±) : insert (f x) (f '' {x}á¶œ) = range f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (x : Î±)"},
 {"type": "f '' (f â»Â¹' s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}  (hs : s âŠ† range f) : f '' (f â»Â¹' s) = s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "image_preimage_eq_of_subset",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}  (hs : s âŠ† range f) : f '' (f â»Â¹' s) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}  (hs : s âŠ† range f)"},
 {"type": "(âˆƒ (s : _) (_ : s âŠ† range f), p s) â†” âˆƒ s, p (f '' s)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {p : Set Î² â†’ Prop} : (âˆƒ (s : _) (_ : s âŠ† range f), p s) â†” âˆƒ s, p (f '' s) := by simp; sorry",
  "name": "exists_subset_range_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {p : Set Î² â†’ Prop} : (âˆƒ (s : _) (_ : s âŠ† range f), p s) â†” âˆƒ s, p (f '' s)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {p : Set Î² â†’ Prop}"},
 {"type": "f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f) : f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t := by constructor; sorry",
  "name": "preimage_subset_preimage_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f) : f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f)"},
 {"type": "f â»Â¹' s = f â»Â¹' t â†” s = t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f)  (ht : t âŠ† range f) : f â»Â¹' s = f â»Â¹' t â†” s = t := by constructor; sorry",
  "name": "preimage_eq_preimage'",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f)  (ht : t âŠ† range f) : f â»Â¹' s = f â»Â¹' t â†” s = t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {s t : Set Î±}  {f : Î² â†’ Î±}  (hs : s âŠ† range f)  (ht : t âŠ† range f)"},
 {"type": "f â»Â¹' (range f âˆ© s) = f â»Â¹' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f â»Â¹' (range f âˆ© s) = f â»Â¹' s := by rw [inter_comm]; sorry",
  "name": "preimage_range_inter",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f â»Â¹' (range f âˆ© s) = f â»Â¹' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}"},
 {"type": "f â»Â¹' (f '' (f â»Â¹' s)) = f â»Â¹' s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f â»Â¹' (f '' (f â»Â¹' s)) = f â»Â¹' s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "preimage_image_preimage",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f â»Â¹' (f '' (f â»Â¹' s)) = f â»Â¹' s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}"},
 {"type": "Sum.inl â»Â¹' (@Sum.inr Î± Î² '' s) = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î²) : Sum.inl â»Â¹' (@Sum.inr Î± Î² '' s) = âˆ… := by ext; sorry",
  "name": "preimage_inl_image_inr",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î²) : Sum.inl â»Â¹' (@Sum.inr Î± Î² '' s) = âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î²)"},
 {"type": "Sum.inr â»Â¹' (@Sum.inl Î± Î² '' s) = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î±) : Sum.inr â»Â¹' (@Sum.inl Î± Î² '' s) = âˆ… := by ext; sorry",
  "name": "preimage_inr_image_inl",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î±) : Sum.inr â»Â¹' (@Sum.inl Î± Î² '' s) = âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set Î±)"},
 {"type": "Sum.inl â»Â¹' range (Sum.inr : Î² â†’ Sum Î± Î²) = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} : Sum.inl â»Â¹' range (Sum.inr : Î² â†’ Sum Î± Î²) = âˆ… := by rw [â† image_univ]; sorry",
  "name": "preimage_inl_range_inr",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} : Sum.inl â»Â¹' range (Sum.inr : Î² â†’ Sum Î± Î²) = âˆ…",
  "args": "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±}"},
 {"type": "Sum.inr â»Â¹' range (Sum.inl : Î± â†’ Sum Î± Î²) = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} : Sum.inr â»Â¹' range (Sum.inl : Î± â†’ Sum Î± Î²) = âˆ… := by rw [â† image_univ]; sorry",
  "name": "preimage_inr_range_inl",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} : Sum.inr â»Â¹' range (Sum.inl : Î± â†’ Sum Î± Î²) = âˆ…",
  "args": "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±}"},
 {"type": "Sum.inl '' (Sum.inl â»Â¹' s) âˆª Sum.inr '' (Sum.inr â»Â¹' s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set (Sum Î± Î²)) : Sum.inl '' (Sum.inl â»Â¹' s) âˆª Sum.inr '' (Sum.inr â»Â¹' s) = s := by rw [image_preimage_eq_inter_range]; sorry",
  "name": "image_preimage_inl_union_image_preimage_inr",
  "kind": "theorem",
  "first-tactic": "rw [image_preimage_eq_inter_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set (Sum Î± Î²)) : Sum.inl '' (Sum.inl â»Â¹' s) âˆª Sum.inr '' (Sum.inr â»Â¹' s) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (s : Set (Sum Î± Î²))"},
 {"type":
  "range (Subtype.map f h) = (fun x : Subtype q => (x : Î²)) â»Â¹' (f '' { x | p x })",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â†’ Î²)  (h : âˆ€ x, p x â†’ q (f x)) : range (Subtype.map f h) = (fun x : Subtype q => (x : Î²)) â»Â¹' (f '' { x | p x }) := by ext âŸ¨x, hxâŸ©; sorry",
  "name": "range_subtype_map",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, hxâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â†’ Î²)  (h : âˆ€ x, p x â†’ q (f x)) : range (Subtype.map f h) = (fun x : Subtype q => (x : Î²)) â»Â¹' (f '' { x | p x })",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  (f : Î± â†’ Î²)  (h : âˆ€ x, p x â†’ q (f x))"},
 {"type": "range f âŠ† {x} â†” f = const Î¹ x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±}  {x : Î±} : range f âŠ† {x} â†” f = const Î¹ x := by simp [range_subset_iff]; sorry",
  "name": "range_subset_singleton",
  "kind": "theorem",
  "first-tactic": "simp [range_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±}  {x : Î±} : range f âŠ† {x} â†” f = const Î¹ x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î¹ â†’ Î±}  {x : Î±}"},
 {"type": "f '' (f â»Â¹' s)á¶œ = range f \\ s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f '' (f â»Â¹' s)á¶œ = range f \\ s := by rw [compl_eq_univ_diff]; sorry",
  "name": "image_compl_preimage",
  "kind": "theorem",
  "first-tactic": "rw [compl_eq_univ_diff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²} : f '' (f â»Â¹' s)á¶œ = range f \\ s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {f : Î± â†’ Î²}  {s : Set Î²}"},
 {"type": "f '' s = range fun x : s => f x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î±) : f '' s = range fun x : s => f x := by ext; sorry",
  "name": "image_eq_range",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î±) : f '' s = range fun x : s => f x",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (f : Î± â†’ Î²)  (s : Set Î±)"},
 {"type": "range (if p then f else g) âŠ† range f âˆª range g",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Prop}  [Decidable p]  {f g : Î± â†’ Î²} : range (if p then f else g) âŠ† range f âˆª range g := by by_cases h : p; sorry",
  "name": "range_ite_subset'",
  "kind": "theorem",
  "first-tactic": "by_cases h : p",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Prop}  [Decidable p]  {f g : Î± â†’ Î²} : range (if p then f else g) âŠ† range f âˆª range g",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Prop}  [Decidable p]  {f g : Î± â†’ Î²}"},
 {"type": "(range fun x => if p x then f x else g x) âŠ† range f âˆª range g",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  [DecidablePred p]  {f g : Î± â†’ Î²} : (range fun x => if p x then f x else g x) âŠ† range f âˆª range g := by rw [range_subset_iff]; sorry",
  "name": "range_ite_subset",
  "kind": "theorem",
  "first-tactic": "rw [range_subset_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  [DecidablePred p]  {f g : Î± â†’ Î²} : (range fun x => if p x then f x else g x) âŠ† range f âˆª range g",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} {p : Î± â†’ Prop}  [DecidablePred p]  {f g : Î± â†’ Î²}"},
 {"type": "range f = {f default}",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} [h : Unique Î¹] : range f = {f default} := by ext x; sorry",
  "name": "range_unique",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} [h : Unique Î¹] : range f = {f default}",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} [h : Unique Î¹]"},
 {"type": "range (inclusion h) = { x : t | (x : Î±) âˆˆ s }",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (h : s âŠ† t) : range (inclusion h) = { x : t | (x : Î±) âˆˆ s } := by ext âŸ¨x, hxâŸ©; sorry",
  "name": "range_inclusion",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, hxâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (h : s âŠ† t) : range (inclusion h) = { x : t | (x : Î±) âˆˆ s }",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±} (h : s âŠ† t)"},
 {"type": "f âˆ˜ rangeSplitting f = (fun x : â†¥(range f) => (x : Î²))",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±}  (f : Î± â†’ Î²) : f âˆ˜ rangeSplitting f = (fun x : â†¥(range f) => (x : Î²)) := by ext; sorry",
  "name": "comp_rangeSplitting",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±}  (f : Î± â†’ Î²) : f âˆ˜ rangeSplitting f = (fun x : â†¥(range f) => (x : Î²))",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {f : Î¹ â†’ Î±}  {s t : Set Î±}  (f : Î± â†’ Î²)"},
 {"type": "(f â»Â¹' s).Nontrivial",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {s : Set Î±} {s : Set Î²}  (hs : s.Nontrivial)  {f : Î± â†’ Î²}      (hf : Function.Surjective f) : (f â»Â¹' s).Nontrivial := by rcases hs with âŸ¨fx, hx, fy, hy, hxyâŸ©; sorry",
  "name": "Nontrivial.preimage",
  "kind": "theorem",
  "first-tactic": "rcases hs with âŸ¨fx, hx, fy, hy, hxyâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {s : Set Î±} {s : Set Î²}  (hs : s.Nontrivial)  {f : Î± â†’ Î²}      (hf : Function.Surjective f) : (f â»Â¹' s).Nontrivial",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _}  {s : Set Î±} {s : Set Î²}  (hs : s.Nontrivial)  {f : Î± â†’ Î²}      (hf : Function.Surjective f)"},
 {"type": "Surjective (preimage f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f) : Surjective (preimage f) := by intro s; sorry",
  "name": "Injective.preimage_surjective",
  "kind": "theorem",
  "first-tactic": "intro s",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f) : Surjective (preimage f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f)"},
 {"type": "Surjective (image f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f) : Surjective (image f) := by intro s; sorry",
  "name": "Surjective.image_surjective",
  "kind": "theorem",
  "first-tactic": "intro s",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f) : Surjective (image f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f)"},
 {"type": "(f â»Â¹' s).Nonempty â†” s.Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f)  {s : Set Î²} : (f â»Â¹' s).Nonempty â†” s.Nonempty := by rw [â† nonempty_image_iff]; sorry",
  "name": "Surjective.nonempty_preimage",
  "kind": "theorem",
  "first-tactic": "rw [â† nonempty_image_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f)  {s : Set Î²} : (f â»Â¹' s).Nonempty â†” s.Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Surjective f)  {s : Set Î²}"},
 {"type": "Injective (image f)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f) : Injective (image f) := by intro s t h; sorry",
  "name": "Injective.image_injective",
  "kind": "theorem",
  "first-tactic": "intro s t h",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f) : Injective (image f)",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f)"},
 {"type": "f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {s t : Set Î²}  (hf : Surjective f) : f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t := by apply Set.preimage_subset_preimage_iff; sorry",
  "name": "Surjective.preimage_subset_preimage_iff",
  "kind": "theorem",
  "first-tactic": "apply Set.preimage_subset_preimage_iff",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {s t : Set Î²}  (hf : Surjective f) : f â»Â¹' s âŠ† f â»Â¹' t â†” s âŠ† t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {s t : Set Î²}  (hf : Surjective f)"},
 {"type": "(f '' s)á¶œ = f '' sá¶œ âˆª range fá¶œ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (s : Set Î±) : (f '' s)á¶œ = f '' sá¶œ âˆª range fá¶œ := by ext y; sorry",
  "name": "Injective.compl_image_eq",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (s : Set Î±) : (f '' s)á¶œ = f '' sá¶œ âˆª range fá¶œ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (s : Set Î±)"},
 {"type": "g '' (f '' s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±) : g '' (f '' s) = s := by rw [â† image_comp]; sorry",
  "name": "LeftInverse.image_image",
  "kind": "theorem",
  "first-tactic": "rw [â† image_comp]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±) : g '' (f '' s) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±)"},
 {"type": "f â»Â¹' (g â»Â¹' s) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±) : f â»Â¹' (g â»Â¹' s) = s := by rw [â† preimage_comp]; sorry",
  "name": "LeftInverse.preimage_preimage",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_comp]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±) : f â»Â¹' (g â»Â¹' s) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {g : Î² â†’ Î±}  (h : LeftInverse g f)  (s : Set Î±)"},
 {"type": "(fun x : s => (x : Î±)) '' { x : â†¥s | â†‘x âˆˆ t } = t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±}  (h : t âŠ† s) : (fun x : s => (x : Î±)) '' { x : â†¥s | â†‘x âˆˆ t } = t := by ext x; sorry",
  "name": "coe_image_of_subset",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±}  (h : t âŠ† s) : (fun x : s => (x : Î±)) '' { x : â†¥s | â†‘x âˆˆ t } = t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±}  (h : t âŠ† s)"},
 {"type": "range (fun x : s => (x : Î±)) = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s : Set Î±} : range (fun x : s => (x : Î±)) = s := by rw [â† Set.image_univ]; sorry",
  "name": "range_coe",
  "kind": "theorem",
  "first-tactic": "rw [â† Set.image_univ]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s : Set Î±} : range (fun x : s => (x : Î±)) = s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s : Set Î±}"},
 {"type": "(fun x : s => (x : Î±)) â»Â¹' s = univ",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s : Set Î±) : (fun x : s => (x : Î±)) â»Â¹' s = univ := by rw [â† preimage_range]; sorry",
  "name": "coe_preimage_self",
  "kind": "theorem",
  "first-tactic": "rw [â† preimage_range]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s : Set Î±) : (fun x : s => (x : Î±)) â»Â¹' s = univ",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s : Set Î±)"},
 {"type":
  "(fun x : s => (x : Î±)) â»Â¹' t = (fun x : s => (x : Î±)) â»Â¹' u â†” t âˆ© s = u âˆ© s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t u : Set Î±} : (fun x : s => (x : Î±)) â»Â¹' t = (fun x : s => (x : Î±)) â»Â¹' u â†” t âˆ© s = u âˆ© s := by rw [â† image_preimage_coe]; sorry",
  "name": "preimage_coe_eq_preimage_coe_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† image_preimage_coe]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t u : Set Î±} : (fun x : s => (x : Î±)) â»Â¹' t = (fun x : s => (x : Î±)) â»Â¹' u â†” t âˆ© s = u âˆ© s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t u : Set Î±}"},
 {"type": "(fun x : s => (x : Î±)) â»Â¹' (t âˆ© s) = (fun x : s => (x : Î±)) â»Â¹' t",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s t : Set Î±) : (fun x : s => (x : Î±)) â»Â¹' (t âˆ© s) = (fun x : s => (x : Î±)) â»Â¹' t := by rw [preimage_coe_eq_preimage_coe_iff]; sorry",
  "name": "preimage_coe_inter_self",
  "kind": "theorem",
  "first-tactic": "rw [preimage_coe_eq_preimage_coe_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s t : Set Î±) : (fun x : s => (x : Î±)) â»Â¹' (t âˆ© s) = (fun x : s => (x : Î±)) â»Â¹' t",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} (s t : Set Î±)"},
 {"type":
  "(âˆƒ s : Set t, p ((fun x : t => (x : Î±)) '' s)) â†” âˆƒ s : Set Î±, s âŠ† t âˆ§ p s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {t : Set Î±}  (p : Set Î± â†’ Prop) : (âˆƒ s : Set t, p ((fun x : t => (x : Î±)) '' s)) â†” âˆƒ s : Set Î±, s âŠ† t âˆ§ p s := by constructor; sorry",
  "name": "exists_set_subtype",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {t : Set Î±}  (p : Set Î± â†’ Prop) : (âˆƒ s : Set t, p ((fun x : t => (x : Î±)) '' s)) â†” âˆƒ s : Set Î±, s âŠ† t âˆ§ p s",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {t : Set Î±}  (p : Set Î± â†’ Prop)"},
 {"type": "((fun x : s => (x : Î±)) â»Â¹' t).Nonempty â†” (s âˆ© t).Nonempty",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±} : ((fun x : s => (x : Î±)) â»Â¹' t).Nonempty â†” (s âˆ© t).Nonempty := by rw [inter_comm]; sorry",
  "name": "preimage_coe_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [inter_comm]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±} : ((fun x : s => (x : Î±)) â»Â¹' t).Nonempty â†” (s âˆ© t).Nonempty",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±}"},
 {"type": "(fun x : s => (x : Î±)) â»Â¹' t = âˆ… â†” s âˆ© t = âˆ…",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±} : (fun x : s => (x : Î±)) â»Â¹' t = âˆ… â†” s âˆ© t = âˆ… := by simp [â† not_nonempty_iff_eq_empty]; sorry",
  "name": "preimage_coe_eq_empty",
  "kind": "theorem",
  "first-tactic": "simp [â† not_nonempty_iff_eq_empty]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±} : (fun x : s => (x : Î±)) â»Â¹' t = âˆ… â†” s âˆ© t = âˆ…",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _} {s t : Set Î±}"},
 {"type": "Injective (preimage f) â†” Surjective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Injective (preimage f) â†” Surjective f := by refine' âŸ¨fun h y => _, Surjective.preimage_injectiveâŸ©; sorry",
  "name": "preimage_injective",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h y => _, Surjective.preimage_injectiveâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Injective (preimage f) â†” Surjective f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²}"},
 {"type": "Surjective (preimage f) â†” Injective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Surjective (preimage f) â†” Injective f := by refine' âŸ¨fun h x x' hx => _, Injective.preimage_surjectiveâŸ©; sorry",
  "name": "preimage_surjective",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h x x' hx => _, Injective.preimage_surjectiveâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Surjective (preimage f) â†” Injective f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²}"},
 {"type": "Surjective (image f) â†” Surjective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Surjective (image f) â†” Surjective f := by refine' âŸ¨fun h y => _, Surjective.image_surjectiveâŸ©; sorry",
  "name": "image_surjective",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h y => _, Surjective.image_surjectiveâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Surjective (image f) â†” Surjective f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²}"},
 {"type": "Injective (image f) â†” Injective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Injective (image f) â†” Injective f := by refine' âŸ¨fun h x x' hx => _, Injective.image_injectiveâŸ©; sorry",
  "name": "image_injective",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h x x' hx => _, Injective.image_injectiveâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²} : Injective (image f) â†” Injective f",
  "args":
  "{Î± Î² Î³ : Type _}  {Î¹ : Sort _} {Î¹ : Sort _}  {Î± : Type _}  {Î² : Type _}  {f : Î± â†’ Î²} {Î± : Type _}  {Î± : Type u}  {Î² : Type v}  {f : Î± â†’ Î²}"},
 {"type": "a.val = b.val â†’ a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val â†’ a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val â†’ a = b",
  "args": "{a b : Fin n}"},
 {"type": "(âŸ¨(a : â„•), hâŸ© : Fin n) = a",
  "tactic-prompt":
  "theorem (a : Fin n)  (h : (a : â„•) < n) : (âŸ¨(a : â„•), hâŸ© : Fin n) = a := by cases a; sorry",
  "name": "Fin.eta",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Fin n)  (h : (a : â„•) < n) : (âŸ¨(a : â„•), hâŸ© : Fin n) = a",
  "args": "(a : Fin n)  (h : (a : â„•) < n)"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat']; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat']",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n := by by_cases n <= a.val + b.val; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic": "by_cases n <= a.val + b.val",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedMul a b).isSome = true â†” a.val * b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true â†” a.val * b.val < n := by simp only [checkedMul]; sorry",
  "name": "Fin.checked_mul_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedMul]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true â†” a.val * b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedSub a b).isSome = true â†” b.val <= a.val",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true â†” b.val <= a.val := by simp only [checkedSub]; sorry",
  "name": "Fin.checked_sub_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedSub]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true â†” b.val <= a.val",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "âˆ€ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : âˆ€ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : âˆ€ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a â‰¤ b â†’ b â‰¤ a â†’ a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(mulSingle i x : I â†’ Î²) i' = (mulSingle i' x : I â†’ Î²) i",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] [One Î²]  (i : I)  (x : Î²)  (i' : I) : (mulSingle i x : I â†’ Î²) i' = (mulSingle i' x : I â†’ Î²) i := by simp [mulSingle_apply]; sorry",
  "name": "mulSingle_comm",
  "kind": "theorem",
  "first-tactic": "simp [mulSingle_apply]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] [One Î²]  (i : I)  (x : Î²)  (i' : I) : (mulSingle i x : I â†’ Î²) i' = (mulSingle i' x : I â†’ Î²) i",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] [One Î²]  (i : I)  (x : Î²)  (i' : I)"},
 {"type": "f' j (mulSingle i x j) = mulSingle i (f' i x) j",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i)  (hf' : âˆ€ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I) : f' j (mulSingle i x j) = mulSingle i (f' i x) j := by simpa only [Pi.one_apply]; sorry",
  "name": "apply_mulSingle",
  "kind": "theorem",
  "first-tactic": "simpa only [Pi.one_apply]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i)  (hf' : âˆ€ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I) : f' j (mulSingle i x j) = mulSingle i (f' i x) j",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i)  (hf' : âˆ€ i, f' i 1 = 1)  (i : I)  (x : f i)  (j : I)"},
 {"type": "f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i â†’ h i)  (hf' : âˆ€ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I) : f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j := by by_cases h : j = i; sorry",
  "name": "apply_mulSingleâ‚‚",
  "kind": "theorem",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i â†’ h i)  (hf' : âˆ€ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I) : f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [DecidableEq I] [âˆ€ i, One (f i)]  [âˆ€ i, One (g i)]  [âˆ€ i, One (h i)] (f' : âˆ€ i, f i â†’ g i â†’ h i)  (hf' : âˆ€ i, f' i 1 1 = 1)  (i : I)      (x : f i)  (y : g i)  (j : I)"},
 {"type":
  "Function.extend f (gâ‚ * gâ‚‚) (eâ‚ * eâ‚‚) = Function.extend f gâ‚ eâ‚ * Function.extend f gâ‚‚ eâ‚‚",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Mul Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³) : Function.extend f (gâ‚ * gâ‚‚) (eâ‚ * eâ‚‚) = Function.extend f gâ‚ eâ‚ * Function.extend f gâ‚‚ eâ‚‚ := by classical\n  funext x\n  simp only [not_exists]; sorry",
  "name": "extend_mul",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp only [not_exists]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Mul Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³) : Function.extend f (gâ‚ * gâ‚‚) (eâ‚ * eâ‚‚) = Function.extend f gâ‚ eâ‚ * Function.extend f gâ‚‚ eâ‚‚",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Mul Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³)"},
 {"type": "Function.extend f gâ»Â¹ eâ»Â¹ = (Function.extend f g e)â»Â¹",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Inv Î³]  (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e : Î² â†’ Î³) : Function.extend f gâ»Â¹ eâ»Â¹ = (Function.extend f g e)â»Â¹ := by classical\n  funext x\n  simp only [not_exists]; sorry",
  "name": "extend_inv",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp only [not_exists]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Inv Î³]  (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e : Î² â†’ Î³) : Function.extend f gâ»Â¹ eâ»Â¹ = (Function.extend f g e)â»Â¹",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Inv Î³]  (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e : Î² â†’ Î³)"},
 {"type":
  "Function.extend f (gâ‚ / gâ‚‚) (eâ‚ / eâ‚‚) = Function.extend f gâ‚ eâ‚ / Function.extend f gâ‚‚ eâ‚‚",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Div Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³) : Function.extend f (gâ‚ / gâ‚‚) (eâ‚ / eâ‚‚) = Function.extend f gâ‚ eâ‚ / Function.extend f gâ‚‚ eâ‚‚ := by classical\n  funext x\n  simp [Function.extend_def]; sorry",
  "name": "extend_div",
  "kind": "theorem",
  "first-tactic": "classical\n  funext x\n  simp [Function.extend_def]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Div Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³) : Function.extend f (gâ‚ / gâ‚‚) (eâ‚ / eâ‚‚) = Function.extend f gâ‚ eâ‚ / Function.extend f gâ‚‚ eâ‚‚",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I)  [Div Î³]  (f : Î± â†’ Î²)  (gâ‚ gâ‚‚ : Î± â†’ Î³)  (eâ‚ eâ‚‚ : Î² â†’ Î³)"},
 {"type":
  "Sum.elim (Pi.mulSingle i c) (1 : Î² â†’ Î³) = Pi.mulSingle (Sum.inl i) c",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î±)  (c : Î³) : Sum.elim (Pi.mulSingle i c) (1 : Î² â†’ Î³) = Pi.mulSingle (Sum.inl i) c := by simp only [Pi.mulSingle]; sorry",
  "name": "elim_mulSingle_one",
  "kind": "theorem",
  "first-tactic": "simp only [Pi.mulSingle]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î±)  (c : Î³) : Sum.elim (Pi.mulSingle i c) (1 : Î² â†’ Î³) = Pi.mulSingle (Sum.inl i) c",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î±)  (c : Î³)"},
 {"type":
  "Sum.elim (1 : Î± â†’ Î³) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î²)  (c : Î³) : Sum.elim (1 : Î± â†’ Î³) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c := by simp only [Pi.mulSingle]; sorry",
  "name": "elim_one_mulSingle",
  "kind": "theorem",
  "first-tactic": "simp only [Pi.mulSingle]",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î²)  (c : Î³) : Sum.elim (1 : Î± â†’ Î³) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [DecidableEq Î±]  [DecidableEq Î²]  [One Î³]  (i : Î²)  (c : Î³)"},
 {"type": "Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Mul Î³] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b' := by ext x; sorry",
  "name": "elim_mul_mul",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Mul Î³] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Mul Î³]"},
 {"type": "Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'",
  "tactic-prompt":
  "theorem {I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Div Î³] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b' := by ext x; sorry",
  "name": "elim_div_div",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Div Î³] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'",
  "args":
  "{I : Type u}  -- The indexing type {Î± Î² Î³ : Type _}  -- The families of types already equipped with instances {f : I â†’ Type vâ‚}  {g : I â†’ Type vâ‚‚}  {h : I â†’ Type vâ‚ƒ} (x y : âˆ€ i, f i)  (i : I) (a a' : Î± â†’ Î³)  (b b' : Î² â†’ Î³) [Div Î³]"},
 {"type": "toLex x < toLex (update x i a) â†” x i < a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex x < toLex (update x i a) â†” x i < a := by refine' âŸ¨_, fun h => toLex_strictMono <| lt_update_self_iff.2 hâŸ©; sorry",
  "name": "lt_toLex_update_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨_, fun h => toLex_strictMono <| lt_update_self_iff.2 hâŸ©",
  "core-prompt":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex x < toLex (update x i a) â†” x i < a",
  "args":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i}"},
 {"type": "toLex (update x i a) < toLex x â†” a < x i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex (update x i a) < toLex x â†” a < x i := by refine' âŸ¨_, fun h => toLex_strictMono <| update_lt_self_iff.2 hâŸ©; sorry",
  "name": "toLex_update_lt_self_iff",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨_, fun h => toLex_strictMono <| update_lt_self_iff.2 hâŸ©",
  "core-prompt":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex (update x i a) < toLex x â†” a < x i",
  "args":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i}"},
 {"type": "toLex x â‰¤ toLex (update x i a) â†” x i â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex x â‰¤ toLex (update x i a) â†” x i â‰¤ a := by simp_rw [le_iff_lt_or_eq]; sorry",
  "name": "le_toLex_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_iff_lt_or_eq]",
  "core-prompt":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex x â‰¤ toLex (update x i a) â†” x i â‰¤ a",
  "args":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i}"},
 {"type": "toLex (update x i a) â‰¤ toLex x â†” a â‰¤ x i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex (update x i a) â‰¤ toLex x â†” a â‰¤ x i := by simp_rw [le_iff_lt_or_eq]; sorry",
  "name": "toLex_update_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_iff_lt_or_eq]",
  "core-prompt":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i} : toLex (update x i a) â‰¤ toLex x â†” a â‰¤ x i",
  "args":
  "{Î¹ : Type _}  {Î² : Î¹ â†’ Type _}  (r : Î¹ â†’ Î¹ â†’ Prop)  (s : âˆ€ {i}, Î² i â†’ Î² i â†’ Prop)  [LinearOrder Î¹]  [IsWellOrder Î¹ (Â· < Â·)]  [âˆ€ i, PartialOrder (Î² i)]  {x y : âˆ€ i, Î² i}  {i : Î¹}    {a : Î² i}"},
 {"type": "inv (inv r) = r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : inv (inv r) = r := by ext (x y); sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : inv (inv r) = r",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "r.inv.codom = r.dom",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.inv.codom = r.dom := by ext (x y); sorry",
  "name": "codom_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.inv.codom = r.dom",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "r.inv.dom = r.codom",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.inv.dom = r.codom := by ext (x y); sorry",
  "name": "dom_inv",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.inv.dom = r.codom",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "(r â€¢ s) â€¢ t = r â€¢ (s â€¢ t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³)  (t : Rel Î³ Î´) : (r â€¢ s) â€¢ t = r â€¢ (s â€¢ t) := by unfold comp; sorry",
  "name": "comp_assoc",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³)  (t : Rel Î³ Î´) : (r â€¢ s) â€¢ t = r â€¢ (s â€¢ t)",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³)  (t : Rel Î³ Î´)"},
 {"type": "r â€¢ @Eq Î² = r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²) : r â€¢ @Eq Î² = r := by unfold comp; sorry",
  "name": "comp_right_id",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²) : r â€¢ @Eq Î² = r",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)"},
 {"type": "@Eq Î± â€¢ r = r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²) : @Eq Î± â€¢ r = r := by unfold comp; sorry",
  "name": "comp_left_id",
  "kind": "theorem",
  "first-tactic": "unfold comp",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²) : @Eq Î± â€¢ r = r",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)"},
 {"type": "inv (@Eq Î±) = @Eq Î±",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : inv (@Eq Î±) = @Eq Î± := by ext (x y); sorry",
  "name": "inv_id",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : inv (@Eq Î±) = @Eq Î±",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "inv (r â€¢ s) = inv s â€¢ inv r",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³) : inv (r â€¢ s) = inv s â€¢ inv r := by ext (x z); sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "ext (x z)",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³) : inv (r â€¢ s) = inv s â€¢ inv r",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (r : Rel Î± Î²)  (s : Rel Î² Î³)"},
 {"type": "image (@Eq Î±) s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : image (@Eq Î±) s = s := by ext x; sorry",
  "name": "image_id",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : image (@Eq Î±) s = s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±)"},
 {"type": "image (r â€¢ s) t = image s (image r t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î±) : image (r â€¢ s) t = image s (image r t) := by ext z; sorry",
  "name": "image_comp",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î±) : image (r â€¢ s) t = image s (image r t)",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î±)"},
 {"type": "r.image Set.univ = r.codom",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.image Set.univ = r.codom := by ext y; sorry",
  "name": "image_univ",
  "kind": "theorem",
  "first-tactic": "ext y",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.image Set.univ = r.codom",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "preimage (@Eq Î±) s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : preimage (@Eq Î±) s = s := by simp only [preimage]; sorry",
  "name": "preimage_id",
  "kind": "theorem",
  "first-tactic": "simp only [preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : preimage (@Eq Î±) s = s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±)"},
 {"type": "preimage (r â€¢ s) t = preimage r (preimage s t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³) : preimage (r â€¢ s) t = preimage r (preimage s t) := by simp only [preimage]; sorry",
  "name": "preimage_comp",
  "kind": "theorem",
  "first-tactic": "simp only [preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³) : preimage (r â€¢ s) t = preimage r (preimage s t)",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³)"},
 {"type": "r.preimage Set.univ = r.dom",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.preimage Set.univ = r.dom := by rw [preimage]; sorry",
  "name": "preimage_univ",
  "kind": "theorem",
  "first-tactic": "rw [preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. : r.preimage Set.univ = r.dom",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems."},
 {"type": "core (@Eq Î±) s = s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : core (@Eq Î±) s = s := by simp [core]; sorry",
  "name": "core_id",
  "kind": "theorem",
  "first-tactic": "simp [core]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±) : core (@Eq Î±) s = s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Set Î±)"},
 {"type": "core (r â€¢ s) t = core r (core s t)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³) : core (r â€¢ s) t = core r (core s t) := by ext x; sorry",
  "name": "core_comp",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³) : core (r â€¢ s) t = core r (core s t)",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (s : Rel Î² Î³)  (t : Set Î³)"},
 {"type": "f '' s = (Function.graph f).image s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î±) : f '' s = (Function.graph f).image s := by simp [Set.image]; sorry",
  "name": "image_eq",
  "kind": "theorem",
  "first-tactic": "simp [Set.image]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î±) : f '' s = (Function.graph f).image s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î±)"},
 {"type": "f â»Â¹' s = (Function.graph f).preimage s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²) : f â»Â¹' s = (Function.graph f).preimage s := by simp [Set.preimage]; sorry",
  "name": "preimage_eq",
  "kind": "theorem",
  "first-tactic": "simp [Set.preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²) : f â»Â¹' s = (Function.graph f).preimage s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²)"},
 {"type": "f â»Â¹' s = (Function.graph f).core s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²) : f â»Â¹' s = (Function.graph f).core s := by simp [Set.preimage]; sorry",
  "name": "preimage_eq_core",
  "kind": "theorem",
  "first-tactic": "simp [Set.preimage]",
  "core-prompt":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²) : f â»Â¹' s = (Function.graph f).core s",
  "args":
  "{Î± Î² Î³ : Type _} (r : Rel Î± Î²)  -- Porting note: required for later theorems. (f : Î± â†’ Î²)  (s : Set Î²)"},
 {"type": "âŸ¦xâŸ§ = y â†” x â‰ˆ Quotient.out y",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Î±}  {y : Quotient s} : âŸ¦xâŸ§ = y â†” x â‰ˆ Quotient.out y := by refine' Iff.trans _ Quotient.eq; sorry",
  "name": "Quotient.mk_eq_iff_out",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ Quotient.eq",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Î±}  {y : Quotient s} : âŸ¦xâŸ§ = y â†” x â‰ˆ Quotient.out y",
  "args":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Î±}  {y : Quotient s}"},
 {"type": "x = âŸ¦yâŸ§ â†” Quotient.out x â‰ˆ y",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Quotient s}  {y : Î±} : x = âŸ¦yâŸ§ â†” Quotient.out x â‰ˆ y := by refine' Iff.trans _ Quotient.eq; sorry",
  "name": "Quotient.eq_mk_iff_out",
  "kind": "theorem",
  "first-tactic": "refine' Iff.trans _ Quotient.eq",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Quotient s}  {y : Î±} : x = âŸ¦yâŸ§ â†” Quotient.out x â‰ˆ y",
  "args":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] [s : Setoid Î±]  {x : Quotient s}  {y : Î±}"},
 {"type": "x.out â‰ˆ y.out â†” x = y",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] {s : Setoid Î±}  {x y : Quotient s} : x.out â‰ˆ y.out â†” x = y := by rw [â† Quotient.eq_mk_iff_out]; sorry",
  "name": "Quotient.out_equiv_out",
  "kind": "theorem",
  "first-tactic": "rw [â† Quotient.eq_mk_iff_out]",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] {s : Setoid Î±}  {x y : Quotient s} : x.out â‰ˆ y.out â†” x = y",
  "args":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³] {s : Setoid Î±}  {x y : Quotient s}"},
 {"type": "p f",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³]  {Î¹ : Type _}  {Î± : Î¹ â†’ Sort _}  [s : âˆ€ i, Setoid (Î± i)]      {p : (âˆ€ i, Quotient (s i)) â†’ Prop}  (f : âˆ€ i, Quotient (s i))      (h : âˆ€ a : âˆ€ i, Î± i, p fun i â†¦ âŸ¦a iâŸ§) : p f := by rw [â† (funext fun i â†¦ Quotient.out_eq (f i) : (fun i â†¦ âŸ¦(f i).outâŸ§) = f)]; sorry",
  "name": "Quotient.induction_on_pi",
  "kind": "theorem",
  "first-tactic":
  "rw [â† (funext fun i â†¦ Quotient.out_eq (f i) : (fun i â†¦ âŸ¦(f i).outâŸ§) = f)]",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³]  {Î¹ : Type _}  {Î± : Î¹ â†’ Sort _}  [s : âˆ€ i, Setoid (Î± i)]      {p : (âˆ€ i, Quotient (s i)) â†’ Prop}  (f : âˆ€ i, Quotient (s i))      (h : âˆ€ a : âˆ€ i, Î± i, p fun i â†¦ âŸ¦a iâŸ§) : p f",
  "args":
  "{Î± : Sort _}  {Î² : Sort _} {ra : Î± â†’ Î± â†’ Prop}  {rb : Î² â†’ Î² â†’ Prop}  {Ï† : Quot ra â†’ Quot rb â†’ Sort _}  -- mathport name: mk {Î³ : Sort _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  -- Porting note: used to be an Alias of `quot.lift_beta`. {t : Î³ â†’ Î³ â†’ Prop} [sa : Setoid Î±]  [sb : Setoid Î²] {Ï† : Quotient sa â†’ Quotient sb â†’ Sort _} {Î³ : Sort _}  [sc : Setoid Î³]  {Î¹ : Type _}  {Î± : Î¹ â†’ Sort _}  [s : âˆ€ i, Setoid (Î± i)]      {p : (âˆ€ i, Quotient (s i)) â†’ Prop}  (f : âˆ€ i, Quotient (s i))      (h : âˆ€ a : âˆ€ i, Î± i, p fun i â†¦ âŸ¦a iâŸ§)"},
 {"type": "DecidableEq (Vector Î± n)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} [DecidableEq Î±] : DecidableEq (Vector Î± n) := by unfold Vector; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold Vector",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} [DecidableEq Î±] : DecidableEq (Vector Î± n)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} [DecidableEq Î±]"},
 {"type": "toList (cons a v) = a :: toList v",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} (a : Î±)  (v : Vector Î± n) : toList (cons a v) = a :: toList v := by cases v; sorry",
  "name": "toList_cons",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} (a : Î±)  (v : Vector Î± n) : toList (cons a v) = a :: toList v",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} (a : Î±)  (v : Vector Î± n)"},
 {"type": "toList (append v w) = toList v ++ toList w",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± n)  (w : Vector Î± m) : toList (append v w) = toList v ++ toList w := by cases v; sorry",
  "name": "toList_append",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± n)  (w : Vector Î± m) : toList (append v w) = toList v ++ toList w",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± n)  (w : Vector Î± m)"},
 {"type": "toList (drop n v) = List.drop n (toList v)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m) : toList (drop n v) = List.drop n (toList v) := by cases v; sorry",
  "name": "toList_drop",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m) : toList (drop n v) = List.drop n (toList v)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m)"},
 {"type": "toList (take n v) = List.take n (toList v)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m) : toList (take n v) = List.take n (toList v) := by cases v; sorry",
  "name": "toList_take",
  "kind": "theorem",
  "first-tactic": "cases v",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m) : toList (take n v) = List.take n (toList v)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Ï† : Type w} {n : â„•} {n m : â„•}  (v : Vector Î± m)"},
 {"type": "(replicate n c).length = n",
  "tactic-prompt":
  "lemma (n : â„•)  (c : Char) : (replicate n c).length = n := by simp only [String.length]; sorry",
  "name": "length_replicate",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(n : â„•)  (c : Char) : (replicate n c).length = n",
  "args": "(n : â„•)  (c : Char)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Function.Injective (Prod.mk a : Î² â†’ Î± Ã— Î²)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (a : Î±) : Function.Injective (Prod.mk a : Î² â†’ Î± Ã— Î²) := by intro bâ‚ bâ‚‚ h; sorry",
  "name": "mk.inj_left",
  "kind": "theorem",
  "first-tactic": "intro bâ‚ bâ‚‚ h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (a : Î±) : Function.Injective (Prod.mk a : Î² â†’ Î± Ã— Î²)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (a : Î±)"},
 {"type": "Function.Injective (fun a â†¦ Prod.mk a b : Î± â†’ Î± Ã— Î²)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (b : Î²) : Function.Injective (fun a â†¦ Prod.mk a b : Î± â†’ Î± Ã— Î²) := by intro bâ‚ bâ‚‚ h; sorry",
  "name": "mk.inj_right",
  "kind": "theorem",
  "first-tactic": "intro bâ‚ bâ‚‚ h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (b : Î²) : Function.Injective (fun a â†¦ Prod.mk a b : Î± â†’ Î± Ã— Î²)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Î± Î² : Type _}  (b : Î²)"},
 {"type": "p = q â†” p.1 = q.1 âˆ§ p.2 = q.2",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²} : p = q â†” p.1 = q.1 âˆ§ p.2 = q.2 := by rw [â† @mk.eta _ _ p]; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† @mk.eta _ _ p]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²} : p = q â†” p.1 = q.1 âˆ§ p.2 = q.2",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²}"},
 {"type": "@Monotone _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @Monotone _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²) := by rintro âŸ¨aâ‚, bâ‚âŸ© âŸ¨aâ‚‚, bâ‚‚âŸ© âŸ¨ha, hbâŸ©; sorry",
  "name": "toLex_mono",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨aâ‚, bâ‚âŸ© âŸ¨aâ‚‚, bâ‚‚âŸ© âŸ¨ha, hbâŸ©",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @Monotone _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²)",
  "args":
  "{Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30"},
 {"type": "@StrictMono _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @StrictMono _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²) := by rintro âŸ¨aâ‚, bâ‚âŸ© âŸ¨aâ‚‚, bâ‚‚âŸ© h; sorry",
  "name": "toLex_strictMono",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨aâ‚, bâ‚âŸ© âŸ¨aâ‚‚, bâ‚‚âŸ© h",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30 : @StrictMono _ _ _ (Prod.Lex.preorder Î± Î²) (toLex : Î± Ã— Î² â†’ Î± Ã—â‚— Î²)",
  "args":
  "{Î± Î² Î³ : Type _}  [PartialOrder Î±]  [Preorder Î²]  -- porting note: type class search sees right through the type synonrm for `Î± Ã—â‚— Î²` and uses the -- `Preorder` structure for `Î± Ã— Î²` instead -- This is hopefully the same problems as in https://github.com/leanprover/lean4/issues/1891 -- and will be fixed in nightly-2022-11-30"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "Char.ofNat c.toNat = c",
  "tactic-prompt":
  "theorem {c : Char}  (h : isValidCharNat c.toNat) : Char.ofNat c.toNat = c := by rw [Char.ofNat]; sorry",
  "name": "Char.ofNat_toNat",
  "kind": "theorem",
  "first-tactic": "rw [Char.ofNat]",
  "core-prompt":
  "{c : Char}  (h : isValidCharNat c.toNat) : Char.ofNat c.toNat = c",
  "args": "{c : Char}  (h : isValidCharNat c.toNat)"},
 {"type": "(decide Â¬p) = !(decide p)",
  "tactic-prompt":
  "theorem (p : Prop)  [Decidable p] : (decide Â¬p) = !(decide p) := by by_cases p; sorry",
  "name": "decide_not",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt": "(p : Prop)  [Decidable p] : (decide Â¬p) = !(decide p)",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "decide (p âˆ§ q) = (p && q)",
  "tactic-prompt":
  "theorem (p q : Prop)  [Decidable p]  [Decidable q] : decide (p âˆ§ q) = (p && q) := by by_cases p; sorry",
  "name": "decide_and",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : decide (p âˆ§ q) = (p && q)",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "decide (p âˆ¨ q) = (p || q)",
  "tactic-prompt":
  "theorem (p q : Prop)  [Decidable p]  [Decidable q] : decide (p âˆ¨ q) = (p || q) := by by_cases p; sorry",
  "name": "decide_or",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : decide (p âˆ¨ q) = (p || q)",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "b = false âˆ¨ b = true",
  "tactic-prompt":
  "theorem (b : Bool) : b = false âˆ¨ b = true := by cases b; sorry",
  "name": "dichotomy",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : b = false âˆ¨ b = true",
  "args": "(b : Bool)"},
 {"type": "âˆ€ {a b : Bool}, (a â†” b) â†” a = b",
  "tactic-prompt":
  "theorem  : âˆ€ {a b : Bool}, (a â†” b) â†” a = b := by decide; sorry",
  "name": "coe_bool_iff",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, (a â†” b) â†” a = b",
  "args": ""},
 {"type": "âˆ€ {a : Bool}, a â‰  false â†’ a = true",
  "tactic-prompt":
  "theorem  : âˆ€ {a : Bool}, a â‰  false â†’ a = true := by decide; sorry",
  "name": "eq_true_of_ne_false",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a : Bool}, a â‰  false â†’ a = true",
  "args": ""},
 {"type": "âˆ€ {a : Bool}, a â‰  true â†’ a = false",
  "tactic-prompt":
  "theorem  : âˆ€ {a : Bool}, a â‰  true â†’ a = false := by decide; sorry",
  "name": "eq_false_of_ne_true",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a : Bool}, a â‰  true â†’ a = false",
  "args": ""},
 {"type": "âˆ€ a b, (a || b) = (b || a)",
  "tactic-prompt": "theorem  : âˆ€ a b, (a || b) = (b || a) := by decide; sorry",
  "name": "or_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b, (a || b) = (b || a)",
  "args": ""},
 {"type": "âˆ€ a b c, (a || (b || c)) = (b || (a || c))",
  "tactic-prompt":
  "theorem  : âˆ€ a b c, (a || (b || c)) = (b || (a || c)) := by decide; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b c, (a || (b || c)) = (b || (a || c))",
  "args": ""},
 {"type": "a || b",
  "tactic-prompt":
  "theorem {a b : Bool}  (H : a) : a || b := by simp [H]; sorry",
  "name": "or_inl",
  "kind": "theorem",
  "first-tactic": "simp [H]",
  "core-prompt": "{a b : Bool}  (H : a) : a || b",
  "args": "{a b : Bool}  (H : a)"},
 {"type": "a || b",
  "tactic-prompt":
  "theorem {a b : Bool}  (H : b) : a || b := by cases a; sorry",
  "name": "or_inr",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Bool}  (H : b) : a || b",
  "args": "{a b : Bool}  (H : b)"},
 {"type": "âˆ€ a b, (a && b) = (b && a)",
  "tactic-prompt": "theorem  : âˆ€ a b, (a && b) = (b && a) := by decide; sorry",
  "name": "and_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b, (a && b) = (b && a)",
  "args": ""},
 {"type": "âˆ€ a b c, (a && (b && c)) = (b && (a && c))",
  "tactic-prompt":
  "theorem  : âˆ€ a b c, (a && (b && c)) = (b && (a && c)) := by decide; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b c, (a && (b && c)) = (b && (a && c))",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, a && b â†’ a",
  "tactic-prompt": "theorem  : âˆ€ {a b : Bool}, a && b â†’ a := by decide; sorry",
  "name": "and_elim_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, a && b â†’ a",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, a â†’ b â†’ a && b",
  "tactic-prompt":
  "theorem  : âˆ€ {a b : Bool}, a â†’ b â†’ a && b := by decide; sorry",
  "name": "and_intro",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, a â†’ b â†’ a && b",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, a && b â†’ b",
  "tactic-prompt": "theorem  : âˆ€ {a b : Bool}, a && b â†’ b := by decide; sorry",
  "name": "and_elim_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, a && b â†’ b",
  "args": ""},
 {"type": "(a && (b || c)) = (a && b || a && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && (b || c)) = (a && b || a && c) := by cases a; sorry",
  "name": "and_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && (b || c)) = (a && b || a && c)",
  "args": "(a b c : Bool)"},
 {"type": "((a || b) && c) = (a && c || b && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : ((a || b) && c) = (a && c || b && c) := by cases a; sorry",
  "name": "and_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : ((a || b) && c) = (a && c || b && c)",
  "args": "(a b c : Bool)"},
 {"type": "(a || b && c) = ((a || b) && (a || c))",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a || b && c) = ((a || b) && (a || c)) := by cases a; sorry",
  "name": "or_and_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a || b && c) = ((a || b) && (a || c))",
  "args": "(a b c : Bool)"},
 {"type": "(a && b || c) = ((a || c) && (b || c))",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && b || c) = ((a || c) && (b || c)) := by cases a; sorry",
  "name": "or_and_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && b || c) = ((a || c) && (b || c))",
  "args": "(a b c : Bool)"},
 {"type": "âˆ€ {a b : Bool}, a = !b â†” a â‰  b",
  "tactic-prompt":
  "lemma  : âˆ€ {a b : Bool}, a = !b â†” a â‰  b := by decide; sorry",
  "name": "eq_not_iff",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, a = !b â†” a â‰  b",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, !a = b â†” a â‰  b",
  "tactic-prompt":
  "lemma  : âˆ€ {a b : Bool}, !a = b â†” a â‰  b := by decide; sorry",
  "name": "not_eq_iff",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, !a = b â†” a â‰  b",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, Â¬a = !b â†” a = b",
  "tactic-prompt":
  "theorem  : âˆ€ {a b : Bool}, Â¬a = !b â†” a = b := by decide; sorry",
  "name": "not_eq_not",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, Â¬a = !b â†” a = b",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, Â¬(!a) = b â†” a = b",
  "tactic-prompt":
  "theorem  : âˆ€ {a b : Bool}, Â¬(!a) = b â†” a = b := by decide; sorry",
  "name": "not_not_eq",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, Â¬(!a) = b â†” a = b",
  "args": ""},
 {"type": "âˆ€ b : Bool, !b â‰  b",
  "tactic-prompt": "lemma  : âˆ€ b : Bool, !b â‰  b := by decide; sorry",
  "name": "not_ne_self",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ b : Bool, !b â‰  b",
  "args": ""},
 {"type": "âˆ€ b : Bool, b â‰  !b",
  "tactic-prompt": "lemma  : âˆ€ b : Bool, b â‰  !b := by decide; sorry",
  "name": "self_ne_not",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ b : Bool, b â‰  !b",
  "args": ""},
 {"type": "âˆ€ a b, a = b âˆ¨ a = !b",
  "tactic-prompt": "lemma  : âˆ€ a b, a = b âˆ¨ a = !b := by decide; sorry",
  "name": "eq_or_eq_not",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b, a = b âˆ¨ a = !b",
  "args": ""},
 {"type": "âˆ€ {b : Bool}, !b â†” Â¬b",
  "tactic-prompt": "theorem  : âˆ€ {b : Bool}, !b â†” Â¬b := by simp; sorry",
  "name": "not_iff_not",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : âˆ€ {b : Bool}, !b â†” Â¬b",
  "args": ""},
 {"type": "!a = false â†’ a = true",
  "tactic-prompt":
  "theorem {a : Bool} : !a = false â†’ a = true := by cases a; sorry",
  "name": "eq_true_of_not_eq_false'",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a : Bool} : !a = false â†’ a = true",
  "args": "{a : Bool}"},
 {"type": "!a = true â†’ a = false",
  "tactic-prompt":
  "theorem {a : Bool} : !a = true â†’ a = false := by cases a; sorry",
  "name": "eq_false_of_not_eq_true'",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "{a : Bool} : !a = true â†’ a = false",
  "args": "{a : Bool}"},
 {"type": "âˆ€ x, (x && !x) = false",
  "tactic-prompt": "theorem  : âˆ€ x, (x && !x) = false := by decide; sorry",
  "name": "and_not_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x, (x && !x) = false",
  "args": ""},
 {"type": "âˆ€ x, (!x && x) = false",
  "tactic-prompt": "theorem  : âˆ€ x, (!x && x) = false := by decide; sorry",
  "name": "not_and_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x, (!x && x) = false",
  "args": ""},
 {"type": "âˆ€ x, (x || !x) = true",
  "tactic-prompt": "theorem  : âˆ€ x, (x || !x) = true := by decide; sorry",
  "name": "or_not_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x, (x || !x) = true",
  "args": ""},
 {"type": "âˆ€ x, (!x || x) = true",
  "tactic-prompt": "theorem  : âˆ€ x, (!x || x) = true := by decide; sorry",
  "name": "not_or_self",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x, (!x || x) = true",
  "args": ""},
 {"type": "âˆ€ a b, xor a b = xor b a",
  "tactic-prompt": "theorem  : âˆ€ a b, xor a b = xor b a := by decide; sorry",
  "name": "xor_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b, xor a b = xor b a",
  "args": ""},
 {"type": "âˆ€ a b c, xor (xor a b) c = xor a (xor b c)",
  "tactic-prompt":
  "theorem  : âˆ€ a b c, xor (xor a b) c = xor a (xor b c) := by decide; sorry",
  "name": "xor_assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b c, xor (xor a b) c = xor a (xor b c)",
  "args": ""},
 {"type": "âˆ€ a b c, xor a (xor b c) = xor b (xor a c)",
  "tactic-prompt":
  "theorem  : âˆ€ a b c, xor a (xor b c) = xor b (xor a c) := by decide; sorry",
  "name": "xor_left_comm",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b c, xor a (xor b c) = xor b (xor a c)",
  "args": ""},
 {"type": "âˆ€ a, xor (!a) a = true",
  "tactic-prompt": "theorem  : âˆ€ a, xor (!a) a = true := by decide; sorry",
  "name": "xor_not_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a, xor (!a) a = true",
  "args": ""},
 {"type": "âˆ€ a, xor a (!a) = true",
  "tactic-prompt": "theorem  : âˆ€ a, xor a (!a) = true := by decide; sorry",
  "name": "xor_not_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a, xor a (!a) = true",
  "args": ""},
 {"type": "âˆ€ a b, xor (!a) (!b) = xor a b",
  "tactic-prompt":
  "theorem  : âˆ€ a b, xor (!a) (!b) = xor a b := by decide; sorry",
  "name": "xor_not_not",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b, xor (!a) (!b) = xor a b",
  "args": ""},
 {"type": "âˆ€ a, xor false a = a",
  "tactic-prompt": "theorem  : âˆ€ a, xor false a = a := by decide; sorry",
  "name": "xor_false_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a, xor false a = a",
  "args": ""},
 {"type": "âˆ€ a, xor a false = a",
  "tactic-prompt": "theorem  : âˆ€ a, xor a false = a := by decide; sorry",
  "name": "xor_false_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a, xor a false = a",
  "args": ""},
 {"type": "(a && xor b c) = xor (a && b) (a && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (a && xor b c) = xor (a && b) (a && c) := by cases a; sorry",
  "name": "and_xor_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (a && xor b c) = xor (a && b) (a && c)",
  "args": "(a b c : Bool)"},
 {"type": "(xor a b && c) = xor (a && c) (b && c)",
  "tactic-prompt":
  "theorem (a b c : Bool) : (xor a b && c) = xor (a && c) (b && c) := by cases a; sorry",
  "name": "and_xor_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Bool) : (xor a b && c) = xor (a && c) (b && c)",
  "args": "(a b c : Bool)"},
 {"type": "âˆ€ {x y : Bool}, xor x y = true â†” x â‰  y",
  "tactic-prompt":
  "theorem  : âˆ€ {x y : Bool}, xor x y = true â†” x â‰  y := by decide; sorry",
  "name": "xor_iff_ne",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {x y : Bool}, xor x y = true â†” x â‰  y",
  "args": ""},
 {"type": "âˆ€ a b : Bool, !(a && b) = (!a || !b)",
  "tactic-prompt":
  "theorem  : âˆ€ a b : Bool, !(a && b) = (!a || !b) := by decide; sorry",
  "name": "not_and",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b : Bool, !(a && b) = (!a || !b)",
  "args": ""},
 {"type": "âˆ€ a b : Bool, !(a || b) = (!a && !b)",
  "tactic-prompt":
  "theorem  : âˆ€ a b : Bool, !(a || b) = (!a && !b) := by decide; sorry",
  "name": "not_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ a b : Bool, !(a || b) = (!a && !b)",
  "args": ""},
 {"type": "âˆ€ {a b : Bool}, !a = !b â†’ a = b",
  "tactic-prompt":
  "theorem  : âˆ€ {a b : Bool}, !a = !b â†’ a = b := by decide; sorry",
  "name": "not_inj",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {a b : Bool}, !a = !b â†’ a = b",
  "args": ""},
 {"type": "âˆ€ {x y : Bool}, x < y â†” x = false âˆ§ y = true",
  "tactic-prompt":
  "theorem  : âˆ€ {x y : Bool}, x < y â†” x = false âˆ§ y = true := by decide; sorry",
  "name": "lt_iff",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {x y : Bool}, x < y â†” x = false âˆ§ y = true",
  "args": ""},
 {"type": "âˆ€ {x y : Bool}, x â‰¤ y â†” x â†’ y",
  "tactic-prompt":
  "theorem  : âˆ€ {x y : Bool}, x â‰¤ y â†” x â†’ y := by decide; sorry",
  "name": "le_iff_imp",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {x y : Bool}, x â‰¤ y â†” x â†’ y",
  "args": ""},
 {"type": "âˆ€ x y : Bool, (x && y) â‰¤ x",
  "tactic-prompt": "theorem  : âˆ€ x y : Bool, (x && y) â‰¤ x := by decide; sorry",
  "name": "and_le_left",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y : Bool, (x && y) â‰¤ x",
  "args": ""},
 {"type": "âˆ€ x y : Bool, (x && y) â‰¤ y",
  "tactic-prompt": "theorem  : âˆ€ x y : Bool, (x && y) â‰¤ y := by decide; sorry",
  "name": "and_le_right",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y : Bool, (x && y) â‰¤ y",
  "args": ""},
 {"type": "âˆ€ {x y z : Bool}, x â‰¤ y â†’ x â‰¤ z â†’ x â‰¤ (y && z)",
  "tactic-prompt":
  "theorem  : âˆ€ {x y z : Bool}, x â‰¤ y â†’ x â‰¤ z â†’ x â‰¤ (y && z) := by decide; sorry",
  "name": "le_and",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {x y z : Bool}, x â‰¤ y â†’ x â‰¤ z â†’ x â‰¤ (y && z)",
  "args": ""},
 {"type": "âˆ€ x y : Bool, x â‰¤ (x || y)",
  "tactic-prompt": "theorem  : âˆ€ x y : Bool, x â‰¤ (x || y) := by decide; sorry",
  "name": "left_le_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y : Bool, x â‰¤ (x || y)",
  "args": ""},
 {"type": "âˆ€ x y : Bool, y â‰¤ (x || y)",
  "tactic-prompt": "theorem  : âˆ€ x y : Bool, y â‰¤ (x || y) := by decide; sorry",
  "name": "right_le_or",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y : Bool, y â‰¤ (x || y)",
  "args": ""},
 {"type": "âˆ€ {x y z}, x â‰¤ z â†’ y â‰¤ z â†’ (x || y) â‰¤ z",
  "tactic-prompt":
  "theorem  : âˆ€ {x y z}, x â‰¤ z â†’ y â‰¤ z â†’ (x || y) â‰¤ z := by decide; sorry",
  "name": "or_le",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ {x y z}, x â‰¤ z â†’ y â‰¤ z â†’ (x || y) â‰¤ z",
  "args": ""},
 {"type": "ofNat n â‰¤ ofNat m",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : n â‰¤ m) : ofNat n â‰¤ ofNat m := by simp only [ofNat]; sorry",
  "name": "ofNat_le_ofNat",
  "kind": "theorem",
  "first-tactic": "simp only [ofNat]",
  "core-prompt": "{n m : Nat}  (h : n â‰¤ m) : ofNat n â‰¤ ofNat m",
  "args": "{n m : Nat}  (h : n â‰¤ m)"},
 {"type": "toNat bâ‚€ â‰¤ toNat bâ‚",
  "tactic-prompt":
  "theorem {bâ‚€ bâ‚ : Bool}  (h : bâ‚€ â‰¤ bâ‚) : toNat bâ‚€ â‰¤ toNat bâ‚ := by cases h; sorry",
  "name": "toNat_le_toNat",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{bâ‚€ bâ‚ : Bool}  (h : bâ‚€ â‰¤ bâ‚) : toNat bâ‚€ â‰¤ toNat bâ‚",
  "args": "{bâ‚€ bâ‚ : Bool}  (h : bâ‚€ â‰¤ bâ‚)"},
 {"type": "ofNat (toNat b) = b",
  "tactic-prompt":
  "theorem (b : Bool) : ofNat (toNat b) = b := by cases b; sorry",
  "name": "ofNat_toNat",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Bool) : ofNat (toNat b) = b",
  "args": "(b : Bool)"},
 {"type": "f (f (f x)) = f x",
  "tactic-prompt":
  "theorem (f : Bool â†’ Bool)  (x : Bool) : f (f (f x)) = f x := by cases x; sorry",
  "name": "apply_apply_apply",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(f : Bool â†’ Bool)  (x : Bool) : f (f (f x)) = f x",
  "args": "(f : Bool â†’ Bool)  (x : Bool)"},
 {"type": "range f = {f false, f true}",
  "tactic-prompt":
  "theorem {Î± : Type _}  (f : Bool â†’ Î±) : range f = {f false, f true} := by rw [â† image_univ]; sorry",
  "name": "range_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† image_univ]",
  "core-prompt": "{Î± : Type _}  (f : Bool â†’ Î±) : range f = {f false, f true}",
  "args": "{Î± : Type _}  (f : Bool â†’ Î±)"},
 {"type": "Decidable (Chain R a l)",
  "tactic-prompt":
  "instance {Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (a : Î±)  (l : List Î±) : Decidable (Chain R a l) := by induction l generalizing a with\n  | nil => simp only [List.Chain.nil]; infer_instance\n  | cons a as ih => haveI := ih; simp only [List.chain_cons]; infer_instance; sorry",
  "name": "decidableChain",
  "kind": "instance",
  "first-tactic":
  "induction l generalizing a with\n  | nil => simp only [List.Chain.nil]; infer_instance\n  | cons a as ih => haveI := ih; simp only [List.chain_cons]; infer_instance",
  "core-prompt":
  "{Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (a : Î±)  (l : List Î±) : Decidable (Chain R a l)",
  "args":
  "{Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (a : Î±)  (l : List Î±)"},
 {"type": "Decidable (Chain' R l)",
  "tactic-prompt":
  "instance {Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (l : List Î±) : Decidable (Chain' R l) := by cases l; sorry",
  "name": "decidableChain'",
  "kind": "instance",
  "first-tactic": "cases l",
  "core-prompt":
  "{Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (l : List Î±) : Decidable (Chain' R l)",
  "args":
  "{Î± Î² Î³ Î´ Îµ Î¶ : Type _}  {m : Type v â†’ Type w}  [Monad m]  [DecidableRel R]  (l : List Î±)"},
 {"type": "(get k [] : Î±) = default",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {k : â„•} : (get k [] : Î±) = default := by cases k; sorry",
  "name": "get_nil",
  "kind": "theorem",
  "first-tactic": "cases k",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {k : â„•} : (get k [] : Î±) = default",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {k : â„•}"},
 {"type": "f default = default â†’ get n (as.map f) = f (get n as)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {f : Î± â†’ Î²}  {n : â„•}  {as : List Î±} : f default = default â†’ get n (as.map f) = f (get n as) := by intro h1; sorry",
  "name": "get_map'",
  "kind": "theorem",
  "first-tactic": "intro h1",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {f : Î± â†’ Î²}  {n : â„•}  {as : List Î±} : f default = default â†’ get n (as.map f) = f (get n as)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {f : Î± â†’ Î²}  {n : â„•}  {as : List Î±}"},
 {"type": "p default â†’ (âˆ€ x âˆˆ as, p x) â†’ âˆ€ n, p (get n as)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {as : List Î±}  {p : Î± â†’ Prop} : p default â†’ (âˆ€ x âˆˆ as, p x) â†’ âˆ€ n, p (get n as) := by intro h1 h2 n; sorry",
  "name": "forall_val_of_forall_mem",
  "kind": "theorem",
  "first-tactic": "intro h1 h2 n",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {as : List Î±}  {p : Î± â†’ Prop} : p default â†’ (âˆ€ x âˆˆ as, p x) â†’ âˆ€ n, p (get n as)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] {as : List Î±}  {p : Î± â†’ Prop}"},
 {"type": "as1 = as2 â†’ Equiv as1 as2",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] : as1 = as2 â†’ Equiv as1 as2 := by intro h1; sorry",
  "name": "equiv_of_eq",
  "kind": "theorem",
  "first-tactic": "intro h1",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] : as1 = as2 â†’ Equiv as1 as2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²]"},
 {"type": "@get Î± âŸ¨0âŸ© k (neg as) = -@get Î± âŸ¨0âŸ© k as",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [AddGroup Î±]  {k : â„•}  {as : List Î±} : @get Î± âŸ¨0âŸ© k (neg as) = -@get Î± âŸ¨0âŸ© k as := by unfold neg; sorry",
  "name": "get_neg",
  "kind": "theorem",
  "first-tactic": "unfold neg",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [AddGroup Î±]  {k : â„•}  {as : List Î±} : @get Î± âŸ¨0âŸ© k (neg as) = -@get Î± âŸ¨0âŸ© k as",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [AddGroup Î±]  {k : â„•}  {as : List Î±}"},
 {"type": "(neg as).length = as.length",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Neg Î±]  (as : List Î±) : (neg as).length = as.length := by simp only [neg]; sorry",
  "name": "length_neg",
  "kind": "theorem",
  "first-tactic": "simp only [neg]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Neg Î±]  (as : List Î±) : (neg as).length = as.length",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Neg Î±]  (as : List Î±)"},
 {"type": "@get Î± âŸ¨0âŸ© k (add xs ys) = @get Î± âŸ¨0âŸ© k xs + @get Î± âŸ¨0âŸ© k ys",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  {k : â„•}  {xs ys : List Î±} : @get Î± âŸ¨0âŸ© k (add xs ys) = @get Î± âŸ¨0âŸ© k xs + @get Î± âŸ¨0âŸ© k ys := by apply @get_pointwise _ _ _ âŸ¨0âŸ© âŸ¨0âŸ© âŸ¨0âŸ©; sorry",
  "name": "get_add",
  "kind": "theorem",
  "first-tactic": "apply @get_pointwise _ _ _ âŸ¨0âŸ© âŸ¨0âŸ© âŸ¨0âŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  {k : â„•}  {xs ys : List Î±} : @get Î± âŸ¨0âŸ© k (add xs ys) = @get Î± âŸ¨0âŸ© k xs + @get Î± âŸ¨0âŸ© k ys",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  {k : â„•}  {xs ys : List Î±}"},
 {"type": "add [] as = as",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±) : add [] as = as := by rw [add]; sorry",
  "name": "nil_add",
  "kind": "theorem",
  "first-tactic": "rw [add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±) : add [] as = as",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±)"},
 {"type": "add as [] = as",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±) : add as [] = as := by rw [add]; sorry",
  "name": "add_nil",
  "kind": "theorem",
  "first-tactic": "rw [add]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±) : add as [] = as",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (as : List Î±)"},
 {"type": "add (as.map f) (as.map g) = as.map fun x â†¦ f x + g x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (f g : Î± â†’ Î±)  {as : List Î±} : add (as.map f) (as.map g) = as.map fun x â†¦ f x + g x := by apply @eq_of_equiv _ (âŸ¨0âŸ© : Inhabited Î±); sorry",
  "name": "map_add_map",
  "kind": "theorem",
  "first-tactic": "apply @eq_of_equiv _ (âŸ¨0âŸ© : Inhabited Î±)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (f g : Î± â†’ Î±)  {as : List Î±} : add (as.map f) (as.map g) = as.map fun x â†¦ f x + g x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddMonoid Î±]  (f g : Î± â†’ Î±)  {as : List Î±}"},
 {"type": "@get Î± âŸ¨0âŸ© k (sub xs ys) = @get Î± âŸ¨0âŸ© k xs - @get Î± âŸ¨0âŸ© k ys",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddGroup Î±]  {k : â„•}  {xs ys : List Î±} : @get Î± âŸ¨0âŸ© k (sub xs ys) = @get Î± âŸ¨0âŸ© k xs - @get Î± âŸ¨0âŸ© k ys := by apply @get_pointwise _ _ _ âŸ¨0âŸ© âŸ¨0âŸ© âŸ¨0âŸ©; sorry",
  "name": "get_sub",
  "kind": "theorem",
  "first-tactic": "apply @get_pointwise _ _ _ âŸ¨0âŸ© âŸ¨0âŸ© âŸ¨0âŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddGroup Î±]  {k : â„•}  {xs ys : List Î±} : @get Î± âŸ¨0âŸ© k (sub xs ys) = @get Î± âŸ¨0âŸ© k xs - @get Î± âŸ¨0âŸ© k ys",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type u}  [AddGroup Î±]  {k : â„•}  {xs ys : List Î±}"},
 {"type": "sub [] as = neg as",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±) : sub [] as = neg as := by rw [sub]; sorry",
  "name": "nil_sub",
  "kind": "theorem",
  "first-tactic": "rw [sub]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±) : sub [] as = neg as",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±)"},
 {"type": "sub as [] = as",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±) : sub as [] = as := by rw [sub]; sorry",
  "name": "sub_nil",
  "kind": "theorem",
  "first-tactic": "rw [sub]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±) : sub as [] = as",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w} {a : Î±} {as as1 as2 as3 : List Î±} [Inhabited Î±]  [Inhabited Î²] [Inhabited Î±]  [Inhabited Î²]  -- pointwise {Î± : Type}  [AddGroup Î±]  (as : List Î±)"},
 {"type": "m âˆˆ range n â†” m < n",
  "tactic-prompt":
  "theorem {m n : â„•} : m âˆˆ range n â†” m < n := by simp only [range_eq_range']; sorry",
  "name": "mem_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "{m n : â„•} : m âˆˆ range n â†” m < n",
  "args": "{m n : â„•}"},
 {"type": "Nodup (range n)",
  "tactic-prompt":
  "theorem (n : â„•) : Nodup (range n) := by simp only [range_eq_range']; sorry",
  "name": "nodup_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "(n : â„•) : Nodup (range n)",
  "args": "(n : â„•)"},
 {"type": "âˆƒ s t : List Î±, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ s t : List Î±, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_split",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ s t : List Î±, l = s ++ a :: t",
  "args": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î±",
  "tactic-prompt":
  "lemma  : Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î± := by constructor; sorry",
  "name": "length_injective_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": " : Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î±",
  "args": ""},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©",
  "core-prompt":
  "{Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j)"},
 {"type": "(x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "tactic-prompt":
  "theorem (xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²) : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²) : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "args": "(xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²)"},
 {"type": "l.attach.map Subtype.val = l",
  "tactic-prompt":
  "theorem (l : List Î±) : l.attach.map Subtype.val = l := by rw [attach]; sorry",
  "name": "attach_map_val",
  "kind": "theorem",
  "first-tactic": "rw [attach]",
  "core-prompt": "(l : List Î±) : l.attach.map Subtype.val = l",
  "args": "(l : List Î±)"},
 {"type": "lâ‚‚ ~ lâ‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚‚ ~ lâ‚ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚‚ ~ lâ‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "lâ‚ âŠ† lâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚ âŠ† lâ‚‚ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚ âŠ† lâ‚‚",
  "args": "{Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚",
  "tactic-prompt":
  "theorem {a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±} : lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚ := by generalize eâ‚ : lâ‚ ++ a :: râ‚ = sâ‚; sorry",
  "name": "perm_inv_core",
  "kind": "theorem",
  "first-tactic": "generalize eâ‚ : lâ‚ ++ a :: râ‚ = sâ‚",
  "core-prompt":
  "{a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±} : lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚",
  "args": "{a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±}"},
 {"type": "length lâ‚ = length lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : length lâ‚ = length lâ‚‚ := by induction p; sorry",
  "name": "Perm.length_eq",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : length lâ‚ = length lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚)",
  "tactic-prompt":
  "theorem {R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R) : âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚) := by suffices âˆ€ {lâ‚ lâ‚‚}, lâ‚ ~ lâ‚‚ â†’ Pairwise R lâ‚ â†’ Pairwise R lâ‚‚ from\n    fun lâ‚ lâ‚‚ p â†¦ âŸ¨this p, this p.symmâŸ©; sorry",
  "name": "Perm.pairwise_iff",
  "kind": "theorem",
  "first-tactic":
  "suffices âˆ€ {lâ‚ lâ‚‚}, lâ‚ ~ lâ‚‚ â†’ Pairwise R lâ‚ â†’ Pairwise R lâ‚‚ from\n    fun lâ‚ lâ‚‚ p â†¦ âŸ¨this p, this p.symmâŸ©",
  "core-prompt":
  "{R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R) : âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚)",
  "args": "{R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R)"},
 {"type": "Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±} : Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚) := by have : âˆ€ lâ‚ lâ‚‚ : List Î±, (âˆ€ x : Î±, x âˆˆ lâ‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚‚ â†’ R x y) â†’\n    âˆ€ x : Î±, x âˆˆ lâ‚‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚ â†’ R x y := fun lâ‚ lâ‚‚ a x xm y ym â†¦ s (a y ym x xm); sorry",
  "name": "pairwise_append_comm",
  "kind": "theorem",
  "first-tactic":
  "have : âˆ€ lâ‚ lâ‚‚ : List Î±, (âˆ€ x : Î±, x âˆˆ lâ‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚‚ â†’ R x y) â†’\n    âˆ€ x : Î±, x âˆˆ lâ‚‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚ â†’ R x y := fun lâ‚ lâ‚‚ a x xm y ym â†¦ s (a y ym x xm)",
  "core-prompt":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±} : Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚)",
  "args":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "Pairwise S l",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l) : Pairwise S l := by induction p; sorry",
  "name": "Pairwise.imp_of_mem",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l) : Pairwise S l",
  "args":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l)"},
 {"type": "b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±} : b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±} : b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}"},
 {"type": "b âˆˆ as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as) : b âˆˆ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as) : b âˆˆ as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as)"},
 {"type": "card as â‰¤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±) : card as â‰¤ card (a :: as) := by cases Decidable.em (a âˆˆ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a âˆˆ as)",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±) : card as â‰¤ card (a :: as)",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±)"},
 {"type": "card (as.insert a) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (as.insert a) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (as.insert a) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as)"},
 {"type": "card (as.insert a) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (as.insert a) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (as.insert a) = card as + 1",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as)"},
 {"type": "card (as.map f) â‰¤ card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±) : card (as.map f) â‰¤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±) : card (as.map f) â‰¤ card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±)"},
 {"type": "inj_on f as â†’  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±} : inj_on f as â†’  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±} : inj_on f as â†’  card (as.map f) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs)]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic": "rw [card_eq_of_equiv (union_equiv_append as bs)]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs)"},
 {"type": "Lex (Â· â‰  Â·) lâ‚ lâ‚‚ â†” lâ‚ â‰  lâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u} {lâ‚ lâ‚‚ : List Î±}  (H : length lâ‚ â‰¤ length lâ‚‚) : Lex (Â· â‰  Â·) lâ‚ lâ‚‚ â†” lâ‚ â‰  lâ‚‚ := by classical\n  exact Decidable.List.Lex.ne_iff H; sorry",
  "name": "ne_iff",
  "kind": "theorem",
  "first-tactic": "classical\n  exact Decidable.List.Lex.ne_iff H",
  "core-prompt":
  "{Î± : Type u} {lâ‚ lâ‚‚ : List Î±}  (H : length lâ‚ â‰¤ length lâ‚‚) : Lex (Â· â‰  Â·) lâ‚ lâ‚‚ â†” lâ‚ â‰  lâ‚‚",
  "args": "{Î± : Type u} {lâ‚ lâ‚‚ : List Î±}  (H : length lâ‚ â‰¤ length lâ‚‚)"},
 {"type": "Chain S b l",
  "tactic-prompt":
  "theorem {R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l) : Chain S b l := by induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    Â· exact Hab r\n    Â· exact ih (@HRS _); sorry",
  "name": "Chain.imp'",
  "kind": "theorem",
  "first-tactic":
  "induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    Â· exact Hab r\n    Â· exact ih (@HRS _)",
  "core-prompt":
  "{R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l) : Chain S b l",
  "args":
  "{R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l)"},
 {"type": "Chain R a l",
  "tactic-prompt":
  "theorem (p : Pairwise R (a :: l)) : Chain R a l := by rcases pairwise_cons.1 p with âŸ¨r,p'âŸ©; sorry",
  "name": "Pairwise.chain",
  "kind": "theorem",
  "first-tactic": "rcases pairwise_cons.1 p with âŸ¨r,p'âŸ©",
  "core-prompt": "(p : Pairwise R (a :: l)) : Chain R a l",
  "args": "(p : Pairwise R (a :: l))"},
 {"type": "a âˆˆ some b â†” b = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±} : a âˆˆ some b â†” b = a := by simp; sorry",
  "name": "mem_some_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±} : a âˆˆ some b â†” b = a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±}"},
 {"type": "a âˆˆ toList o â†” a âˆˆ o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±} : a âˆˆ toList o â†” a âˆˆ o := by cases o; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±} : a âˆˆ toList o â†” a âˆˆ o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±}"},
 {"type": "mapâ‚‚ f a b = f <$> a <*> b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {Î± Î² Î³ : Type _}  (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²) : mapâ‚‚ f a b = f <$> a <*> b := by cases a; sorry",
  "name": "mapâ‚‚_def",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {Î± Î² Î³ : Type _}  (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²) : mapâ‚‚ f a b = f <$> a <*> b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {Î± Î² Î³ : Type _}  (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²)"},
 {"type": "mapâ‚‚ f a none = none",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±) : mapâ‚‚ f a none = none := by cases a; sorry",
  "name": "mapâ‚‚_none_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±) : mapâ‚‚ f a none = none",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)"},
 {"type": "mapâ‚‚ f a b = a.map fun a => f a b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Î²) : mapâ‚‚ f a b = a.map fun a => f a b := by cases a; sorry",
  "name": "mapâ‚‚_coe_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Î²) : mapâ‚‚ f a b = a.map fun a => f a b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Î²)"},
 {"type": "c âˆˆ mapâ‚‚ f a b â†” âˆƒ a' b', a' âˆˆ a âˆ§ b' âˆˆ b âˆ§ f a' b' = c",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {c : Î³} : c âˆˆ mapâ‚‚ f a b â†” âˆƒ a' b', a' âˆˆ a âˆ§ b' âˆˆ b âˆ§ f a' b' = c := by simp [mapâ‚‚]; sorry",
  "name": "mem_mapâ‚‚_iff",
  "kind": "theorem",
  "first-tactic": "simp [mapâ‚‚]",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {c : Î³} : c âˆˆ mapâ‚‚ f a b â†” âˆƒ a' b', a' âˆˆ a âˆ§ b' âˆˆ b âˆ§ f a' b' = c",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {c : Î³}"},
 {"type": "mapâ‚‚ f a b = none â†” a = none âˆ¨ b = none",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} : mapâ‚‚ f a b = none â†” a = none âˆ¨ b = none := by cases a; sorry",
  "name": "mapâ‚‚_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} : mapâ‚‚ f a b = none â†” a = none âˆ¨ b = none",
  "args": "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³}"},
 {"type": "mapâ‚‚ f a b = mapâ‚‚ (fun a b => f b a) b a",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²) : mapâ‚‚ f a b = mapâ‚‚ (fun a b => f b a) b a := by cases a; sorry",
  "name": "mapâ‚‚_swap",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²) : mapâ‚‚ f a b = mapâ‚‚ (fun a b => f b a) b a",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (a : Option Î±)  (b : Option Î²)"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ (fun a b => g (f a b)) a b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´) : (mapâ‚‚ f a b).map g = mapâ‚‚ (fun a b => g (f a b)) a b := by cases a; sorry",
  "name": "map_mapâ‚‚",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´) : (mapâ‚‚ f a b).map g = mapâ‚‚ (fun a b => g (f a b)) a b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (g : Î³ â†’ Î´)"},
 {"type": "mapâ‚‚ f (a.map g) b = mapâ‚‚ (fun a b => f (g a) b) a b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³) : mapâ‚‚ f (a.map g) b = mapâ‚‚ (fun a b => f (g a) b) a b := by cases a; sorry",
  "name": "mapâ‚‚_map_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³) : mapâ‚‚ f (a.map g) b = mapâ‚‚ (fun a b => f (g a) b) a b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î³ â†’ Î² â†’ Î´)  (g : Î± â†’ Î³)"},
 {"type": "mapâ‚‚ f a (b.map g) = mapâ‚‚ (fun a b => f a (g b)) a b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³) : mapâ‚‚ f a (b.map g) = mapâ‚‚ (fun a b => f a (g b)) a b := by cases b; sorry",
  "name": "mapâ‚‚_map_right",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³) : mapâ‚‚ f a (b.map g) = mapâ‚‚ (fun a b => f a (g b)) a b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î³ â†’ Î´)  (g : Î² â†’ Î³)"},
 {"type": "x.map (uncurry f) = mapâ‚‚ f (x.map Prod.fst) (x.map Prod.snd)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (x : Option (Î± Ã— Î²)) : x.map (uncurry f) = mapâ‚‚ f (x.map Prod.fst) (x.map Prod.snd) := by cases x; sorry",
  "name": "map_uncurry",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (x : Option (Î± Ã— Î²)) : x.map (uncurry f) = mapâ‚‚ f (x.map Prod.fst) (x.map Prod.snd)",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} (f : Î± â†’ Î² â†’ Î³)  (x : Option (Î± Ã— Î²))"},
 {"type": "mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ f' a (mapâ‚‚ g' b c)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c)) : mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ f' a (mapâ‚‚ g' b c) := by cases a; sorry",
  "name": "mapâ‚‚_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c)) : mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ f' a (mapâ‚‚ g' b c)",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Îµ' â†’ Îµ}  {g' : Î² â†’ Î³ â†’ Îµ'}      (h_assoc : âˆ€ a b c, f (g a b) c = f' a (g' b c))"},
 {"type": "mapâ‚‚ f a b = mapâ‚‚ g b a",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î² â†’ Î± â†’ Î³}  (h_comm : âˆ€ a b, f a b = g b a) : mapâ‚‚ f a b = mapâ‚‚ g b a := by cases a; sorry",
  "name": "mapâ‚‚_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î² â†’ Î± â†’ Î³}  (h_comm : âˆ€ a b, f a b = g b a) : mapâ‚‚ f a b = mapâ‚‚ g b a",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î² â†’ Î± â†’ Î³}  (h_comm : âˆ€ a b, f a b = g b a)"},
 {"type": "mapâ‚‚ f a (mapâ‚‚ g b c) = mapâ‚‚ g' b (mapâ‚‚ f' a c)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c)) : mapâ‚‚ f a (mapâ‚‚ g b c) = mapâ‚‚ g' b (mapâ‚‚ f' a c) := by cases a; sorry",
  "name": "mapâ‚‚_left_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c)) : mapâ‚‚ f a (mapâ‚‚ g b c) = mapâ‚‚ g' b (mapâ‚‚ f' a c)",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î´ â†’ Îµ}  {g : Î² â†’ Î³ â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î² â†’ Î´' â†’ Îµ}      (h_left_comm : âˆ€ a b c, f a (g b c) = g' b (f' a c))"},
 {"type": "mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ g' (mapâ‚‚ f' a c) b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b) : mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ g' (mapâ‚‚ f' a c) b := by cases a; sorry",
  "name": "mapâ‚‚_right_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b) : mapâ‚‚ f (mapâ‚‚ g a b) c = mapâ‚‚ g' (mapâ‚‚ f' a c) b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î´ â†’ Î³ â†’ Îµ}  {g : Î± â†’ Î² â†’ Î´}  {f' : Î± â†’ Î³ â†’ Î´'}  {g' : Î´' â†’ Î² â†’ Îµ}      (h_right_comm : âˆ€ a b c, f (g a b) c = g' (f' a c) b)"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map gâ‚) (b.map gâ‚‚)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map gâ‚) (b.map gâ‚‚) := by cases a; sorry",
  "name": "map_mapâ‚‚_distrib",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map gâ‚) (b.map gâ‚‚)",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î²' â†’ Î´}  {gâ‚ : Î± â†’ Î±'}  {gâ‚‚ : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' (gâ‚ a) (gâ‚‚ b))"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map g') b",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î² â†’ Î´}  {g' : Î± â†’ Î±'}      (h_distrib : âˆ€ a b, g (f a b) = f' (g' a) b) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map g') b := by cases a; sorry",
  "name": "map_mapâ‚‚_distrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î² â†’ Î´}  {g' : Î± â†’ Î±'}      (h_distrib : âˆ€ a b, g (f a b) = f' (g' a) b) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (a.map g') b",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î±' â†’ Î² â†’ Î´}  {g' : Î± â†’ Î±'}      (h_distrib : âˆ€ a b, g (f a b) = f' (g' a) b)"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' a (b.map g')",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î± â†’ Î²' â†’ Î´}  {g' : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' a (g' b)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' a (b.map g') := by cases a; sorry",
  "name": "map_mapâ‚‚_distrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î± â†’ Î²' â†’ Î´}  {g' : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' a (g' b)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' a (b.map g')",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î± â†’ Î²' â†’ Î´}  {g' : Î² â†’ Î²'}      (h_distrib : âˆ€ a b, g (f a b) = f' a (g' b))"},
 {"type": "mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' a b).map g'",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_comm : âˆ€ a b, f (g a) b = g' (f' a b)) : mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' a b).map g' := by cases a; sorry",
  "name": "mapâ‚‚_map_left_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_comm : âˆ€ a b, f (g a) b = g' (f' a b)) : mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' a b).map g'",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_comm : âˆ€ a b, f (g a) b = g' (f' a b))"},
 {"type": "mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' a b).map g'",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_comm : âˆ€ a b, f a (g b) = g' (f' a b)) : mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' a b).map g' := by cases a; sorry",
  "name": "map_mapâ‚‚_right_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_comm : âˆ€ a b, f a (g b) = g' (f' a b)) : mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' a b).map g'",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î± â†’ Î² â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_comm : âˆ€ a b, f a (g b) = g' (f' a b))"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map gâ‚) (a.map gâ‚‚)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map gâ‚) (a.map gâ‚‚) := by cases a; sorry",
  "name": "map_mapâ‚‚_antidistrib",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map gâ‚) (a.map gâ‚‚)",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î±' â†’ Î´}  {gâ‚ : Î² â†’ Î²'}  {gâ‚‚ : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (gâ‚ b) (gâ‚‚ a))"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map g') a",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î± â†’ Î´}  {g' : Î² â†’ Î²'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (g' b) a) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map g') a := by cases a; sorry",
  "name": "map_mapâ‚‚_antidistrib_left",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î± â†’ Î´}  {g' : Î² â†’ Î²'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (g' b) a) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' (b.map g') a",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î²' â†’ Î± â†’ Î´}  {g' : Î² â†’ Î²'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' (g' b) a)"},
 {"type": "(mapâ‚‚ f a b).map g = mapâ‚‚ f' b (a.map g')",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î² â†’ Î±' â†’ Î´}  {g' : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' b (g' a)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' b (a.map g') := by cases a; sorry",
  "name": "map_mapâ‚‚_antidistrib_right",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î² â†’ Î±' â†’ Î´}  {g' : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' b (g' a)) : (mapâ‚‚ f a b).map g = mapâ‚‚ f' b (a.map g')",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {g : Î³ â†’ Î´}  {f' : Î² â†’ Î±' â†’ Î´}  {g' : Î± â†’ Î±'}      (h_antidistrib : âˆ€ a b, g (f a b) = f' b (g' a))"},
 {"type": "mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' b a).map g'",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_anticomm : âˆ€ a b, f (g a) b = g' (f' b a)) : mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' b a).map g' := by cases a; sorry",
  "name": "mapâ‚‚_map_left_anticomm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_anticomm : âˆ€ a b, f (g a) b = g' (f' b a)) : mapâ‚‚ f (a.map g) b = (mapâ‚‚ f' b a).map g'",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î±' â†’ Î² â†’ Î³}  {g : Î± â†’ Î±'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_left_anticomm : âˆ€ a b, f (g a) b = g' (f' b a))"},
 {"type": "mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' b a).map g'",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_anticomm : âˆ€ a b, f a (g b) = g' (f' b a)) : mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' b a).map g' := by cases a; sorry",
  "name": "map_mapâ‚‚_right_anticomm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_anticomm : âˆ€ a b, f a (g b) = g' (f' b a)) : mapâ‚‚ f a (b.map g) = (mapâ‚‚ f' b a).map g'",
  "args":
  "{f : Î± â†’ Î² â†’ Î³}  {a : Option Î±}  {b : Option Î²}  {c : Option Î³} {f : Î± â†’ Î²' â†’ Î³}  {g : Î² â†’ Î²'}  {f' : Î² â†’ Î± â†’ Î´}  {g' : Î´ â†’ Î³}      (h_right_anticomm : âˆ€ a b, f a (g b) = g' (f' b a))"},
 {"type": "x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {x : Option Î±}  {f : Î± â†’ Option Î²}  {b : Î²} : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b := by cases x; sorry",
  "name": "bind_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {x : Option Î±}  {f : Î± â†’ Option Î²}  {b : Î²} : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "args": "{Î± Î² Î³ Î´ : Type _} {x : Option Î±}  {f : Î± â†’ Option Î²}  {b : Î²}"},
 {"type": "o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none'",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "args": "{Î± Î² Î³ Î´ : Type _} {o : Option Î±}  {f : Î± â†’ Option Î²}"},
 {"type": "(Option.map fâ‚ a).map gâ‚ = (Option.map fâ‚‚ a).map gâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î± â†’ Î³}  {gâ‚ : Î² â†’ Î´}  {gâ‚‚ : Î³ â†’ Î´}  (h : gâ‚ âˆ˜ fâ‚ = gâ‚‚ âˆ˜ fâ‚‚)    (a : Î±) : (Option.map fâ‚ a).map gâ‚ = (Option.map fâ‚‚ a).map gâ‚‚ := by rw [map_map]; sorry",
  "name": "map_comm",
  "kind": "theorem",
  "first-tactic": "rw [map_map]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î± â†’ Î³}  {gâ‚ : Î² â†’ Î´}  {gâ‚‚ : Î³ â†’ Î´}  (h : gâ‚ âˆ˜ fâ‚ = gâ‚‚ âˆ˜ fâ‚‚)    (a : Î±) : (Option.map fâ‚ a).map gâ‚ = (Option.map fâ‚‚ a).map gâ‚‚",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î± â†’ Î³}  {gâ‚ : Î² â†’ Î´}  {gâ‚‚ : Î³ â†’ Î´}  (h : gâ‚ âˆ˜ fâ‚ = gâ‚‚ âˆ˜ fâ‚‚)    (a : Î±)"},
 {"type": "(x.pbind fun a _ â†¦ f a) = x.bind f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Option Î²)  (x : Option Î±) : (x.pbind fun a _ â†¦ f a) = x.bind f := by cases x; sorry",
  "name": "pbind_eq_bind",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Option Î²)  (x : Option Î±) : (x.pbind fun a _ â†¦ f a) = x.bind f",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Option Î²)  (x : Option Î±)"},
 {"type": "Option.map f (x.bind g) = x.bind fun a â†¦ Option.map f (g a)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : Î± â†’ Option Î²) : Option.map f (x.bind g) = x.bind fun a â†¦ Option.map f (g a) := by cases x; sorry",
  "name": "map_bind'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : Î± â†’ Option Î²) : Option.map f (x.bind g) = x.bind fun a â†¦ Option.map f (g a)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : Î± â†’ Option Î²)"},
 {"type": "Option.map f (x.pbind g) = x.pbind fun a H â†¦ Option.map f (g a H)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : âˆ€ a, a âˆˆ x â†’ Option Î²) : Option.map f (x.pbind g) = x.pbind fun a H â†¦ Option.map f (g a H) := by cases x; sorry",
  "name": "map_pbind",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : âˆ€ a, a âˆˆ x â†’ Option Î²) : Option.map f (x.pbind g) = x.pbind fun a H â†¦ Option.map f (g a H)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î² â†’ Î³)  (x : Option Î±)  (g : âˆ€ a, a âˆˆ x â†’ Option Î²)"},
 {"type":
  "pbind (Option.map f x) g = x.pbind fun a h â†¦ g (f a) (mem_map_of_mem _ h)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Î²)  (x : Option Î±)  (g : âˆ€ b : Î², b âˆˆ x.map f â†’ Option Î³) : pbind (Option.map f x) g = x.pbind fun a h â†¦ g (f a) (mem_map_of_mem _ h) := by cases x; sorry",
  "name": "pbind_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Î²)  (x : Option Î±)  (g : âˆ€ b : Î², b âˆˆ x.map f â†’ Option Î³) : pbind (Option.map f x) g = x.pbind fun a h â†¦ g (f a) (mem_map_of_mem _ h)",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] (f : Î± â†’ Î²)  (x : Option Î±)  (g : âˆ€ b : Î², b âˆˆ x.map f â†’ Option Î³)"},
 {"type": "f a (h a ha) âˆˆ pmap f x h",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : Î±}  (h : âˆ€ a âˆˆ x, p a)  (ha : a âˆˆ x) : f a (h a ha) âˆˆ pmap f x h := by rw [mem_def] at ha âŠ¢; sorry",
  "name": "mem_pmem",
  "kind": "theorem",
  "first-tactic": "rw [mem_def] at ha âŠ¢",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : Î±}  (h : âˆ€ a âˆˆ x, p a)  (ha : a âˆˆ x) : f a (h a ha) âˆˆ pmap f x h",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {a : Î±}  (h : âˆ€ a âˆˆ x, p a)  (ha : a âˆˆ x)"},
 {"type": "x.pbind f = none â†” x = none",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}      (h' : âˆ€ a (H : a âˆˆ x), f a H = none â†’ x = none) : x.pbind f = none â†” x = none := by cases x; sorry",
  "name": "pbind_eq_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}      (h' : âˆ€ a (H : a âˆˆ x), f a H = none â†’ x = none) : x.pbind f = none â†” x = none",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}      (h' : âˆ€ a (H : a âˆˆ x), f a H = none â†’ x = none)"},
 {"type": "x.pbind f = some y â†” âˆƒ (z : Î±) (H : z âˆˆ x), f z H = some y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}  {y : Î²} : x.pbind f = some y â†” âˆƒ (z : Î±) (H : z âˆˆ x), f z H = some y := by rcases x with (_|x); sorry",
  "name": "pbind_eq_some",
  "kind": "theorem",
  "first-tactic": "rcases x with (_|x)",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}  {y : Î²} : x.pbind f = some y â†” âˆƒ (z : Î±) (H : z âˆˆ x), f z H = some y",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {p : Î± â†’ Prop}  (f : âˆ€ a : Î±, p a â†’ Î²)  (x : Option Î±)  -- Porting note: Can't simp tag this anymore because `pbind` simplifies -- @[simp] {f : âˆ€ a : Î±, a âˆˆ x â†’ Option Î²}  {y : Î²}"},
 {"type": "none.orElse (fun _ â†¦ x) = x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} (x : Option Î±) : none.orElse (fun _ â†¦ x) = x := by cases x; sorry",
  "name": "none_orElse'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} (x : Option Î±) : none.orElse (fun _ â†¦ x) = x",
  "args": "{Î± Î² Î³ Î´ : Type _} (x : Option Î±)"},
 {"type": "x.orElse (fun _ â†¦ none) = x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} (x : Option Î±) : x.orElse (fun _ â†¦ none) = x := by cases x; sorry",
  "name": "orElse_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} (x : Option Î±) : x.orElse (fun _ â†¦ none) = x",
  "args": "{Î± Î² Î³ Î´ : Type _} (x : Option Î±)"},
 {"type": "o.getD default = o.iget",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} [Inhabited Î±]  (o : Option Î±) : o.getD default = o.iget := by cases o; sorry",
  "name": "getD_default_eq_iget",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} [Inhabited Î±]  (o : Option Î±) : o.getD default = o.iget",
  "args": "{Î± Î² Î³ Î´ : Type _} [Inhabited Î±]  (o : Option Î±)"},
 {"type": "casesOn' o (f none) (f âˆ˜ (fun a â†¦ â†‘a)) = f o",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} (f : Option Î± â†’ Î²)  (o : Option Î±) : casesOn' o (f none) (f âˆ˜ (fun a â†¦ â†‘a)) = f o := by cases o; sorry",
  "name": "casesOn'_none_coe",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} (f : Option Î± â†’ Î²)  (o : Option Î±) : casesOn' o (f none) (f âˆ˜ (fun a â†¦ â†‘a)) = f o",
  "args": "{Î± Î² Î³ Î´ : Type _} (f : Option Î± â†’ Î²)  (o : Option Î±)"},
 {"type": "(o <|> o') = some x â†” o = some x âˆ¨ o = none âˆ§ o' = some x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} (o o' : Option Î±)  (x : Î±) : (o <|> o') = some x â†” o = some x âˆ¨ o = none âˆ§ o' = some x := by cases o; sorry",
  "name": "orElse_eq_some",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} (o o' : Option Î±)  (x : Î±) : (o <|> o') = some x â†” o = some x âˆ¨ o = none âˆ§ o' = some x",
  "args": "{Î± Î² Î³ Î´ : Type _} (o o' : Option Î±)  (x : Î±)"},
 {"type": "(o <|> o') = none â†” o = none âˆ§ o' = none",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} (o o' : Option Î±) : (o <|> o') = none â†” o = none âˆ§ o' = none := by cases o; sorry",
  "name": "orElse_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} (o o' : Option Î±) : (o <|> o') = none â†” o = none âˆ§ o' = none",
  "args": "{Î± Î² Î³ Î´ : Type _} (o o' : Option Î±)"},
 {"type": "p < q â†” p â‰¤ q âˆ§ âˆƒ x âˆˆ q, x âˆ‰ p",
  "tactic-prompt":
  "theorem {A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A) : p < q â†” p â‰¤ q âˆ§ âˆƒ x âˆˆ q, x âˆ‰ p := by rw [lt_iff_le_not_le]; sorry",
  "name": "lt_iff_le_and_exists",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_not_le]",
  "core-prompt":
  "{A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A) : p < q â†” p â‰¤ q âˆ§ âˆƒ x âˆˆ q, x âˆ‰ p",
  "args": "{A : Type _}  {B : Type _}  [i : SetLike A B] (p q : A)"},
 {"type": "Acc (Prod.GameAdd rÎ± rÎ²) (a, b)",
  "tactic-prompt":
  "theorem (rÎ± : Î± â†’ Î± â†’ Prop)  (rÎ² : Î² â†’ Î² â†’ Prop) (ha : Acc rÎ± a)  (hb : Acc rÎ² b) : Acc (Prod.GameAdd rÎ± rÎ²) (a, b) := by induction' ha with a _ iha generalizing b; sorry",
  "name": "Acc.prod_gameAdd",
  "kind": "theorem",
  "first-tactic": "induction' ha with a _ iha generalizing b",
  "core-prompt":
  "(rÎ± : Î± â†’ Î± â†’ Prop)  (rÎ² : Î² â†’ Î² â†’ Prop) (ha : Acc rÎ± a)  (hb : Acc rÎ² b) : Acc (Prod.GameAdd rÎ± rÎ²) (a, b)",
  "args":
  "(rÎ± : Î± â†’ Î± â†’ Prop)  (rÎ² : Î² â†’ Î² â†’ Prop) (ha : Acc rÎ± a)  (hb : Acc rÎ² b)"},
 {"type": "Injective f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  {f : Î± â†’ Î²}  (h : âˆ€ x y, x < y â†’ f x â‰  f y) : Injective f := by intro x y hf; sorry",
  "name": "injective_of_lt_imp_ne",
  "kind": "theorem",
  "first-tactic": "intro x y hf",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  {f : Î± â†’ Î²}  (h : âˆ€ x y, x < y â†’ f x â‰  f y) : Injective f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  {f : Î± â†’ Î²}  (h : âˆ€ x y, x < y â†’ f x â‰  f y)"},
 {"type": "StrictMono fun x â†¦ if p x then f x else g x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±]  [Preorder Î²]  {f g : Î± â†’ Î²}  {a : Î±} (hf : StrictMono f)  (hg : StrictMono g)  {p : Î± â†’ Prop}      [DecidablePred p]      (hp : âˆ€ â¦ƒx yâ¦„, x < y â†’ p y â†’ p x)  (hfg : âˆ€ â¦ƒx yâ¦„, p x â†’ Â¬p y â†’ x < y â†’ f x < g y) : StrictMono fun x â†¦ if p x then f x else g x := by intro x y h; sorry",
  "name": "StrictMono.ite'",
  "kind": "theorem",
  "first-tactic": "intro x y h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±]  [Preorder Î²]  {f g : Î± â†’ Î²}  {a : Î±} (hf : StrictMono f)  (hg : StrictMono g)  {p : Î± â†’ Prop}      [DecidablePred p]      (hp : âˆ€ â¦ƒx yâ¦„, x < y â†’ p y â†’ p x)  (hfg : âˆ€ â¦ƒx yâ¦„, p x â†’ Â¬p y â†’ x < y â†’ f x < g y) : StrictMono fun x â†¦ if p x then f x else g x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±]  [Preorder Î²]  {f g : Î± â†’ Î²}  {a : Î±} (hf : StrictMono f)  (hg : StrictMono g)  {p : Î± â†’ Prop}      [DecidablePred p]      (hp : âˆ€ â¦ƒx yâ¦„, x < y â†’ p y â†’ p x)  (hfg : âˆ€ â¦ƒx yâ¦„, p x â†’ Â¬p y â†’ x < y â†’ f x < g y)"},
 {"type": "f a < f b â†” a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±} (hf : StrictMonoOn f s)  {a b : Î±}  (ha : a âˆˆ s)  (hb : b âˆˆ s) : f a < f b â†” a < b := by rw [lt_iff_le_not_le]; sorry",
  "name": "StrictMonoOn.lt_iff_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_le_not_le]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±} (hf : StrictMonoOn f s)  {a b : Î±}  (ha : a âˆˆ s)  (hb : b âˆˆ s) : f a < f b â†” a < b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s : Set Î±} (hf : StrictMonoOn f s)  {a b : Î±}  (ha : a âˆˆ s)  (hb : b âˆˆ s)"},
 {"type":
  "Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a â‰¤ b âˆ§ b â‰¤ c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±} : Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a â‰¤ b âˆ§ b â‰¤ c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c) := by simp_rw [Monotone]; sorry",
  "name": "not_monotone_not_antitone_iff_exists_le_le",
  "kind": "lemma",
  "first-tactic": "simp_rw [Monotone]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±} : Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a â‰¤ b âˆ§ b â‰¤ c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±}"},
 {"type":
  "Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a < b âˆ§ b < c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±} : Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a < b âˆ§ b < c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c) := by simp_rw [not_monotone_not_antitone_iff_exists_le_le]; sorry",
  "name": "not_monotone_not_antitone_iff_exists_lt_lt",
  "kind": "lemma",
  "first-tactic": "simp_rw [not_monotone_not_antitone_iff_exists_le_le]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±} : Â¬ Monotone f âˆ§ Â¬ Antitone f â†” âˆƒ a b c, a < b âˆ§ b < c âˆ§\n    (f a < f b âˆ§ f c < f b âˆ¨ f b < f a âˆ§ f b < f c)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [LinearOrder Î±] [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {x y : Î±}"},
 {"type": "âˆƒ f : â„• â†’ Î±, StrictMono f âˆ§ f 0 = a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] [NoMaxOrder Î±]  (a : Î±) : âˆƒ f : â„• â†’ Î±, StrictMono f âˆ§ f 0 = a := by choose g hg using fun x : Î± â†¦ exists_gt x; sorry",
  "name": "exists_strictMono'",
  "kind": "theorem",
  "first-tactic": "choose g hg using fun x : Î± â†¦ exists_gt x",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] [NoMaxOrder Î±]  (a : Î±) : âˆƒ f : â„• â†’ Î±, StrictMono f âˆ§ f 0 = a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] [NoMaxOrder Î±]  (a : Î±)"},
 {"type": "âˆƒ f : â„¤ â†’ Î±, StrictMono f",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] : âˆƒ f : â„¤ â†’ Î±, StrictMono f := by inhabit Î±; sorry",
  "name": "exists_strictMono",
  "kind": "theorem",
  "first-tactic": "inhabit Î±",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] : âˆƒ f : â„¤ â†’ Î±, StrictMono f",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±]"},
 {"type": "f a â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Monotone f)  (n : â„•)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„•) : f a â‰  x := by rintro rfl; sorry",
  "name": "Monotone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Monotone f)  (n : â„•)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„•) : f a â‰  x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Monotone f)  (n : â„•)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„•)"},
 {"type": "f a â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Antitone f)  (n : â„•)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„•) : f a â‰  x := by rintro rfl; sorry",
  "name": "Antitone.ne_of_lt_of_lt_nat",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Antitone f)  (n : â„•)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„•) : f a â‰  x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„• â†’ Î±}  (hf : Antitone f)  (n : â„•)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„•)"},
 {"type": "f a â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Monotone f)  (n : â„¤)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„¤) : f a â‰  x := by rintro rfl; sorry",
  "name": "Monotone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Monotone f)  (n : â„¤)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„¤) : f a â‰  x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Monotone f)  (n : â„¤)  {x : Î±}  (h1 : f n < x)      (h2 : x < f (n + 1))  (a : â„¤)"},
 {"type": "f a â‰  x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Antitone f)  (n : â„¤)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„¤) : f a â‰  x := by rintro rfl; sorry",
  "name": "Antitone.ne_of_lt_of_lt_int",
  "kind": "theorem",
  "first-tactic": "rintro rfl",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Antitone f)  (n : â„¤)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„¤) : f a â‰  x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  [Preorder Î²]  [Preorder Î±] {f : â„¤ â†’ Î±}  (hf : Antitone f)  (n : â„¤)  {x : Î±}      (h1 : f (n + 1) < x)  (h2 : x < f n)  (a : â„¤)"},
 {"type": "StrictMono f",
  "tactic-prompt":
  "theorem {G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : StrictMonoOn f (Ici 0)) : StrictMono f := by refine' StrictMonoOn.Iic_union_Ici (fun x hx y hy hxy => neg_lt_neg_iff.1 _) hâ‚‚; sorry",
  "name": "strictMono_of_odd_strictMono_on_nonneg",
  "kind": "theorem",
  "first-tactic":
  "refine' StrictMonoOn.Iic_union_Ici (fun x hx y hy hxy => neg_lt_neg_iff.1 _) hâ‚‚",
  "core-prompt":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : StrictMonoOn f (Ici 0)) : StrictMono f",
  "args":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : StrictMonoOn f (Ici 0))"},
 {"type": "Monotone f",
  "tactic-prompt":
  "theorem {G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : MonotoneOn f (Ici 0)) : Monotone f := by refine' MonotoneOn.Iic_union_Ici (fun x hx y hy hxy => neg_le_neg_iff.1 _) hâ‚‚; sorry",
  "name": "monotone_of_odd_of_monotone_on_nonneg",
  "kind": "theorem",
  "first-tactic":
  "refine' MonotoneOn.Iic_union_Ici (fun x hx y hy hxy => neg_le_neg_iff.1 _) hâ‚‚",
  "core-prompt":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : MonotoneOn f (Ici 0)) : Monotone f",
  "args":
  "{G H : Type _}  [LinearOrderedAddCommGroup G]  [OrderedAddCommGroup H] {f : G â†’ H}  (hâ‚ : âˆ€ x, f (-x) = -f x)      (hâ‚‚ : MonotoneOn f (Ici 0))"},
 {"type": "StrictMonoOn f (s âˆª t)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : StrictMonoOn f s)      (hâ‚‚ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : StrictMonoOn f (s âˆª t) := by have A : âˆ€ x, x âˆˆ s âˆª t â†’ x â‰¤ c â†’ x âˆˆ s := by\n    intro x hx hxc\n    cases hx\n    Â· assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    Â· exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim; sorry",
  "name": "StrictMonoOn.union",
  "kind": "theorem",
  "first-tactic":
  "have A : âˆ€ x, x âˆˆ s âˆª t â†’ x â‰¤ c â†’ x âˆˆ s := by\n    intro x hx hxc\n    cases hx\n    Â· assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    Â· exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : StrictMonoOn f s)      (hâ‚‚ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : StrictMonoOn f (s âˆª t)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : StrictMonoOn f s)      (hâ‚‚ : StrictMonoOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c)"},
 {"type": "StrictMono f",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : StrictMonoOn f (Iic a))      (hâ‚‚ : StrictMonoOn f (Ici a)) : StrictMono f := by rw [â† strictMonoOn_univ]; sorry",
  "name": "StrictMonoOn.Iic_union_Ici",
  "kind": "theorem",
  "first-tactic": "rw [â† strictMonoOn_univ]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : StrictMonoOn f (Iic a))      (hâ‚‚ : StrictMonoOn f (Ici a)) : StrictMono f",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : StrictMonoOn f (Iic a))      (hâ‚‚ : StrictMonoOn f (Ici a))"},
 {"type": "MonotoneOn f (s âˆª t)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : MonotoneOn f s)      (hâ‚‚ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : MonotoneOn f (s âˆª t) := by have A : âˆ€ x, x âˆˆ s âˆª t â†’ x â‰¤ c â†’ x âˆˆ s := by\n    intro x hx hxc\n    cases hx\n    Â· assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    Â· exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim; sorry",
  "name": "MonotoneOn.union_right",
  "kind": "theorem",
  "first-tactic":
  "have A : âˆ€ x, x âˆˆ s âˆª t â†’ x â‰¤ c â†’ x âˆˆ s := by\n    intro x hx hxc\n    cases hx\n    Â· assumption\n    rcases eq_or_lt_of_le hxc with (rfl | h'x)\n    Â· exact hs.1\n    exact (lt_irrefl _ (h'x.trans_le (ht.2 (by assumption)))).elim",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : MonotoneOn f s)      (hâ‚‚ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c) : MonotoneOn f (s âˆª t)",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} {s t : Set Î±}  {c : Î±}  (hâ‚ : MonotoneOn f s)      (hâ‚‚ : MonotoneOn f t)  (hs : IsGreatest s c)  (ht : IsLeast t c)"},
 {"type": "Monotone f",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : MonotoneOn f (Iic a))  (hâ‚‚ : MonotoneOn f (Ici a)) : Monotone f := by rw [â† monotoneOn_univ]; sorry",
  "name": "MonotoneOn.Iic_union_Ici",
  "kind": "theorem",
  "first-tactic": "rw [â† monotoneOn_univ]",
  "core-prompt":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : MonotoneOn f (Iic a))  (hâ‚‚ : MonotoneOn f (Ici a)) : Monotone f",
  "args":
  "{Î± Î² : Type _}  [LinearOrder Î±]  [Preorder Î²]  {a : Î±}  {f : Î± â†’ Î²} (hâ‚ : MonotoneOn f (Iic a))  (hâ‚‚ : MonotoneOn f (Ici a))"},
 {"type": "x n â‰¤ y n",
  "tactic-prompt":
  "theorem [Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 â‰¤ y 0)  (hx : âˆ€ k < n, x (k + 1) â‰¤ f (x k))      (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n â‰¤ y n := by induction' n with n ihn; sorry",
  "name": "seq_le_seq",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 â‰¤ y 0)  (hx : âˆ€ k < n, x (k + 1) â‰¤ f (x k))      (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n â‰¤ y n",
  "args":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 â‰¤ y 0)  (hx : âˆ€ k < n, x (k + 1) â‰¤ f (x k))      (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1))"},
 {"type": "x n < y n",
  "tactic-prompt":
  "theorem [Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  {n : â„•}  (hn : 0 < n)  (hâ‚€ : x 0 â‰¤ y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n < y n := by induction' n with n ihn; sorry",
  "name": "seq_pos_lt_seq_of_lt_of_le",
  "kind": "theorem",
  "first-tactic": "induction' n with n ihn",
  "core-prompt":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  {n : â„•}  (hn : 0 < n)  (hâ‚€ : x 0 â‰¤ y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n < y n",
  "args":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  {n : â„•}  (hn : 0 < n)  (hâ‚€ : x 0 â‰¤ y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1))"},
 {"type": "x n < y n",
  "tactic-prompt":
  "theorem [Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 < y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n < y n := by cases n; sorry",
  "name": "seq_lt_seq_of_lt_of_le",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 < y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1)) : x n < y n",
  "args":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} (hf : Monotone f)  (n : â„•)  (hâ‚€ : x 0 < y 0)      (hx : âˆ€ k < n, x (k + 1) < f (x k))  (hy : âˆ€ k < n, f (y k) â‰¤ y (k + 1))"},
 {"type": "id â‰¤ f^[n]",
  "tactic-prompt":
  "theorem [Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} {g : Î² â†’ Î²}  {h : Î² â†’ Î±}  [Preorder Î±]  {f : Î± â†’ Î±} (h : id â‰¤ f)  (n : â„•) : id â‰¤ f^[n] := by simpa only [iterate_id] using monotone_id.iterate_le_of_le h n; sorry",
  "name": "id_le_iterate_of_id_le",
  "kind": "theorem",
  "first-tactic":
  "simpa only [iterate_id] using monotone_id.iterate_le_of_le h n",
  "core-prompt":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} {g : Î² â†’ Î²}  {h : Î² â†’ Î±}  [Preorder Î±]  {f : Î± â†’ Î±} (h : id â‰¤ f)  (n : â„•) : id â‰¤ f^[n]",
  "args":
  "[Preorder Î±]  {f : Î± â†’ Î±}  {x y : â„• â†’ Î±} {g : Î² â†’ Î²}  {h : Î² â†’ Î±}  [Preorder Î±]  {f : Î± â†’ Î±} (h : id â‰¤ f)  (n : â„•)"},
 {"type": "DirectedOn r (f '' s) â†” DirectedOn (f â»Â¹'o r) s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) {s : Set Î²}  {f : Î² â†’ Î±} : DirectedOn r (f '' s) â†” DirectedOn (f â»Â¹'o r) s := by simp only [DirectedOn]; sorry",
  "name": "directedOn_image",
  "kind": "theorem",
  "first-tactic": "simp only [DirectedOn]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) {s : Set Î²}  {f : Î² â†’ Î±} : DirectedOn r (f '' s) â†” DirectedOn (f â»Â¹'o r) s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) {s : Set Î²}  {f : Î² â†’ Î±}"},
 {"type": "Directed (Â· â‰¤ Â·) (Function.extend e f âŠ¥)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [Preorder Î±]  [OrderBot Î±]  {e : Î¹ â†’ Î²}  {f : Î¹ â†’ Î±}      (hf : Directed (Â· â‰¤ Â·) f)  (he : Function.Injective e) : Directed (Â· â‰¤ Â·) (Function.extend e f âŠ¥) := by intro a b; sorry",
  "name": "Directed.extend_bot",
  "kind": "theorem",
  "first-tactic": "intro a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [Preorder Î±]  [OrderBot Î±]  {e : Î¹ â†’ Î²}  {f : Î¹ â†’ Î±}      (hf : Directed (Â· â‰¤ Â·) f)  (he : Function.Injective e) : Directed (Â· â‰¤ Â·) (Function.extend e f âŠ¥)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [Preorder Î±]  [OrderBot Î±]  {e : Î¹ â†’ Î²}  {f : Î¹ â†’ Î±}      (hf : Directed (Â· â‰¤ Â·) f)  (he : Function.Injective e)"},
 {"type": "Directed r id",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [IsDirected Î± r] : Directed r id := by convert directed_of r; sorry",
  "name": "directed_id",
  "kind": "theorem",
  "first-tactic": "convert directed_of r",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [IsDirected Î± r] : Directed r id",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [IsDirected Î± r]"},
 {"type": "IsDirected Î±áµ’áµˆ (Â· â‰¥ Â·)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¤ Â·)] : IsDirected Î±áµ’áµˆ (Â· â‰¥ Â·) := by assumption; sorry",
  "name": "OrderDual.isDirected_ge",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¤ Â·)] : IsDirected Î±áµ’áµˆ (Â· â‰¥ Â·)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¤ Â·)]"},
 {"type": "IsDirected Î±áµ’áµˆ (Â· â‰¤ Â·)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¥ Â·)] : IsDirected Î±áµ’áµˆ (Â· â‰¤ Â·) := by assumption; sorry",
  "name": "OrderDual.isDirected_le",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¥ Â·)] : IsDirected Î±áµ’áµˆ (Â· â‰¤ Â·)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop) [LE Î±]  [IsDirected Î± (Â· â‰¥ Â·)]"},
 {"type": "âˆƒ a b : Î², a < b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop)  [Preorder Î±]  {a : Î±} [IsDirected Î² (Â· â‰¥ Â·)]  [Nontrivial Î²] : âˆƒ a b : Î², a < b := by rcases exists_pair_ne Î² with âŸ¨a, b, hneâŸ©; sorry",
  "name": "exists_lt_of_directed_ge",
  "kind": "theorem",
  "first-tactic": "rcases exists_pair_ne Î² with âŸ¨a, b, hneâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop)  [Preorder Î±]  {a : Î±} [IsDirected Î² (Â· â‰¥ Â·)]  [Nontrivial Î²] : âˆƒ a b : Î², a < b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  (r r' s : Î± â†’ Î± â†’ Prop)  [Preorder Î±]  {a : Î±} [IsDirected Î² (Â· â‰¥ Â·)]  [Nontrivial Î²]"},
 {"type": "a â‰¤ supáµ¢ s â†” âˆ€ b, (âˆ€ i, s i â‰¤ b) â†’ a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeSup Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±} : a â‰¤ supáµ¢ s â†” âˆ€ b, (âˆ€ i, s i â‰¤ b) â†’ a â‰¤ b := by simp [supáµ¢]; sorry",
  "name": "le_supáµ¢_iff",
  "kind": "theorem",
  "first-tactic": "simp [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeSup Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±} : a â‰¤ supáµ¢ s â†” âˆ€ b, (âˆ€ i, s i â‰¤ b) â†’ a â‰¤ b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeSup Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±}"},
 {"type": "infáµ¢ s â‰¤ a â†” âˆ€ b, (âˆ€ i, b â‰¤ s i) â†’ b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeInf Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±} : infáµ¢ s â‰¤ a â†” âˆ€ b, (âˆ€ i, b â‰¤ s i) â†’ b â‰¤ a := by simp [infáµ¢]; sorry",
  "name": "infáµ¢_le_iff",
  "kind": "theorem",
  "first-tactic": "simp [infáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeInf Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±} : infáµ¢ s â‰¤ a â†” âˆ€ b, (âˆ€ i, b â‰¤ s i) â†’ b â‰¤ a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteSemilatticeInf Î±]  {s t : Set Î±}  {a b : Î±}  -- --@[ematch] Porting note: attribute removed {s : Î¹ â†’ Î±}"},
 {"type": "s = {âŠ¥}",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLattice Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±}  (h_sup : supâ‚› s = âŠ¥)      (hne : s.Nonempty) : s = {âŠ¥} := by rw [Set.eq_singleton_iff_nonempty_unique_mem]; sorry",
  "name": "eq_singleton_bot_of_supâ‚›_eq_bot_of_nonempty",
  "kind": "theorem",
  "first-tactic": "rw [Set.eq_singleton_iff_nonempty_unique_mem]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLattice Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±}  (h_sup : supâ‚› s = âŠ¥)      (hne : s.Nonempty) : s = {âŠ¥}",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLattice Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±}  (h_sup : supâ‚› s = âŠ¥)      (hne : s.Nonempty)"},
 {"type": "supâ‚› s = â¨† a : s, (a : Î±)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (s : Set Î±) : supâ‚› s = â¨† a : s, (a : Î±) := by rw [supáµ¢]; sorry",
  "name": "supâ‚›_eq_supáµ¢'",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (s : Set Î±) : supâ‚› s = â¨† a : s, (a : Î±)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (s : Set Î±)"},
 {"type": "(â¨† x, g (f x)) = â¨† y, g y",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {f : Î¹ â†’ Î¹'}  (hf : Surjective f)  (g : Î¹' â†’ Î±) : (â¨† x, g (f x)) = â¨† y, g y := by simp [supáµ¢]; sorry",
  "name": "Function.Surjective.supáµ¢_comp",
  "kind": "theorem",
  "first-tactic": "simp [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {f : Î¹ â†’ Î¹'}  (hf : Surjective f)  (g : Î¹' â†’ Î±) : (â¨† x, g (f x)) = â¨† y, g y",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {f : Î¹ â†’ Î¹'}  (hf : Surjective f)  (g : Î¹' â†’ Î±)"},
 {"type": "(â¨† x, f x) = â¨† y, g y",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {g : Î¹' â†’ Î±}  (h : Î¹ â†’ Î¹')  (h1 : Surjective h)      (h2 : âˆ€ x, g (h x) = f x) : (â¨† x, f x) = â¨† y, g y := by convert h1.supáµ¢_comp g; sorry",
  "name": "Function.Surjective.supáµ¢_congr",
  "kind": "theorem",
  "first-tactic": "convert h1.supáµ¢_comp g",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {g : Î¹' â†’ Î±}  (h : Î¹ â†’ Î¹')  (h1 : Surjective h)      (h2 : âˆ€ x, g (h x) = f x) : (â¨† x, f x) = â¨† y, g y",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {g : Î¹' â†’ Î±}  (h : Î¹ â†’ Î¹')  (h1 : Surjective h)      (h2 : âˆ€ x, g (h x) = f x)"},
 {"type": "supáµ¢ fâ‚ = supáµ¢ fâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {p q : Prop}  {fâ‚ : p â†’ Î±}  {fâ‚‚ : q â†’ Î±}  (pq : p â†” q)      (f : âˆ€ x, fâ‚ (pq.mpr x) = fâ‚‚ x) : supáµ¢ fâ‚ = supáµ¢ fâ‚‚ := by obtain rfl := propext pq; sorry",
  "name": "supáµ¢_congr_Prop",
  "kind": "theorem",
  "first-tactic": "obtain rfl := propext pq",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {p q : Prop}  {fâ‚ : p â†’ Î±}  {fâ‚‚ : q â†’ Î±}  (pq : p â†” q)      (f : âˆ€ x, fâ‚ (pq.mpr x) = fâ‚‚ x) : supáµ¢ fâ‚ = supáµ¢ fâ‚‚",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {p q : Prop}  {fâ‚ : p â†’ Î±}  {fâ‚‚ : q â†’ Î±}  (pq : p â†” q)      (f : âˆ€ x, fâ‚ (pq.mpr x) = fâ‚‚ x)"},
 {"type": "(â¨† b : range f, g b) = â¨† i, g (f i)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (g : Î² â†’ Î±)  (f : Î¹ â†’ Î²) : (â¨† b : range f, g b) = â¨† i, g (f i) := by rw [supáµ¢]; sorry",
  "name": "supáµ¢_range'",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (g : Î² â†’ Î±)  (f : Î¹ â†’ Î²) : (â¨† b : range f, g b) = â¨† i, g (f i)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} (g : Î² â†’ Î±)  (f : Î¹ â†’ Î²)"},
 {"type": "supâ‚› (f '' s) = â¨† a : s, f a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {s : Set Î²}  {f : Î² â†’ Î±} : supâ‚› (f '' s) = â¨† a : s, f a := by rw [supáµ¢]; sorry",
  "name": "supâ‚›_image'",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {s : Set Î²}  {f : Î² â†’ Î±} : supâ‚› (f '' s) = â¨† a : s, f a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [SupSet Î±]  {f g : Î¹ â†’ Î±} {s : Set Î²}  {f : Î² â†’ Î±}"},
 {"type": "(â¨† (i) (j), f i j) â‰¤ a â†” âˆ€ i j, f i j â‰¤ a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨† (i) (j), f i j) â‰¤ a â†” âˆ€ i j, f i j â‰¤ a := by simp_rw [supáµ¢_le_iff]; sorry",
  "name": "supáµ¢â‚‚_le_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [supáµ¢_le_iff]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨† (i) (j), f i j) â‰¤ a â†” âˆ€ i j, f i j â‰¤ a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "(a â‰¤ â¨… (i) (j), f i j) â†” âˆ€ i j, a â‰¤ f i j",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (a â‰¤ â¨… (i) (j), f i j) â†” âˆ€ i j, a â‰¤ f i j := by simp_rw [le_infáµ¢_iff]; sorry",
  "name": "le_infáµ¢â‚‚_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [le_infáµ¢_iff]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (a â‰¤ â¨… (i) (j), f i j) â†” âˆ€ i j, a â‰¤ f i j",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "(â¨† a âˆˆ s, f a) â‰¤ f (supâ‚› s)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Monotone f) : (â¨† a âˆˆ s, f a) â‰¤ f (supâ‚› s) := by rw [supâ‚›_eq_supáµ¢]; sorry",
  "name": "Monotone.le_map_supâ‚›",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Monotone f) : (â¨† a âˆˆ s, f a) â‰¤ f (supâ‚› s)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Monotone f)"},
 {"type": "f (supâ‚› s) = â¨† a âˆˆ s, f a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  (f : Î± â‰ƒo Î²)  (s : Set Î±) : f (supâ‚› s) = â¨† a âˆˆ s, f a := by simp only [supâ‚›_eq_supáµ¢]; sorry",
  "name": "OrderIso.map_supâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  (f : Î± â‰ƒo Î²)  (s : Set Î±) : f (supâ‚› s) = â¨† a âˆˆ s, f a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  (f : Î± â‰ƒo Î²)  (s : Set Î±)"},
 {"type": "f (supâ‚› s) â‰¤ â¨… a âˆˆ s, f a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Antitone f) : f (supâ‚› s) â‰¤ â¨… a âˆˆ s, f a := by rw [supâ‚›_eq_supáµ¢]; sorry",
  "name": "Antitone.map_supâ‚›_le",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Antitone f) : f (supâ‚› s) â‰¤ â¨… a âˆˆ s, f a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [CompleteLattice Î²]  {s : Set Î±}  {f : Î± â†’ Î²}  (hf : Antitone f)"},
 {"type": "(â¨† _b : Î¹, a) = a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty Î¹] : (â¨† _b : Î¹, a) = a := by rw [supáµ¢]; sorry",
  "name": "supáµ¢_const",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty Î¹] : (â¨† _b : Î¹, a) = a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed [Nonempty Î¹]"},
 {"type": "(â¨† (i) (j), f i j) = âŠ¥ â†” âˆ€ i j, f i j = âŠ¥",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨† (i) (j), f i j) = âŠ¥ â†” âˆ€ i j, f i j = âŠ¥ := by simp; sorry",
  "name": "supáµ¢â‚‚_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨† (i) (j), f i j) = âŠ¥ â†” âˆ€ i j, f i j = âŠ¥",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "(â¨… (i) (j), f i j) = âŠ¤ â†” âˆ€ i j, f i j = âŠ¤",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨… (i) (j), f i j) = âŠ¤ â†” âˆ€ i j, f i j = âŠ¤ := by simp; sorry",
  "name": "infáµ¢â‚‚_eq_top",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±} : (â¨… (i) (j), f i j) = âŠ¤ â†” âˆ€ i j, f i j = âŠ¤",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "(â¨† h : p, a h) = if h : p then a h else âŠ¥",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p â†’ Î±) : (â¨† h : p, a h) = if h : p then a h else âŠ¥ := by by_cases p; sorry",
  "name": "supáµ¢_eq_dif",
  "kind": "theorem",
  "first-tactic": "by_cases p",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p â†’ Î±) : (â¨† h : p, a h) = if h : p then a h else âŠ¥",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {p : Prop}  [Decidable p]  (a : p â†’ Î±)"},
 {"type":
  "(â¨† (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨† (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±) : (â¨† (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨† (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚ := by simp only [@supáµ¢_comm _ (Îºâ‚ _)]; sorry",
  "name": "supáµ¢â‚‚_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@supáµ¢_comm _ (Îºâ‚ _)]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±) : (â¨† (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨† (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±)"},
 {"type":
  "(â¨… (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨… (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±) : (â¨… (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨… (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚ := by simp only [@infáµ¢_comm _ (Îºâ‚ _)]; sorry",
  "name": "infáµ¢â‚‚_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@infáµ¢_comm _ (Îºâ‚ _)]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±) : (â¨… (iâ‚) (jâ‚) (iâ‚‚) (jâ‚‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚) = â¨… (iâ‚‚) (jâ‚‚) (iâ‚) (jâ‚), f iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  [CompleteLinearOrder Î±]  {s t : Set Î±}  {a b : Î±}  [CompleteLattice Î±]  {f g s t : Î¹ â†’ Î±}  {a b : Î±}  -- TODO: this declaration gives error when starting smt state ----@[ematch] Porting note: attribute removed {Î¹â‚ Î¹â‚‚ : Sort _}  {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}      (f : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Î±)"},
 {"type": "(â¨† i âˆˆ s, a) = a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Sort _}  {a : Î±}  {s : Set Î¹}  (hs : s.Nonempty) : (â¨† i âˆˆ s, a) = a := by haveI : Nonempty s := Set.nonempty_coe_sort.mpr hs; sorry",
  "name": "bsupáµ¢_const",
  "kind": "theorem",
  "first-tactic": "haveI : Nonempty s := Set.nonempty_coe_sort.mpr hs",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Sort _}  {a : Î±}  {s : Set Î¹}  (hs : s.Nonempty) : (â¨† i âˆˆ s, a) = a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {Î¹ : Sort _}  {a : Î±}  {s : Set Î¹}  (hs : s.Nonempty)"},
 {"type": "(â¨† x, f x) âŠ” a = â¨† x, f x âŠ” a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (â¨† x, f x) âŠ” a = â¨† x, f x âŠ” a := by rw [supáµ¢_sup_eq]; sorry",
  "name": "supáµ¢_sup",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_sup_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (â¨† x, f x) âŠ” a = â¨† x, f x âŠ” a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±}"},
 {"type": "(â¨… x, f x) âŠ“ a = â¨… x, f x âŠ“ a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (â¨… x, f x) âŠ“ a = â¨… x, f x âŠ“ a := by rw [infáµ¢_inf_eq]; sorry",
  "name": "infáµ¢_inf",
  "kind": "theorem",
  "first-tactic": "rw [infáµ¢_inf_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (â¨… x, f x) âŠ“ a = â¨… x, f x âŠ“ a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±}"},
 {"type": "(a âŠ” â¨† x, f x) = â¨† x, a âŠ” f x",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (a âŠ” â¨† x, f x) = â¨† x, a âŠ” f x := by rw [supáµ¢_sup_eq]; sorry",
  "name": "sup_supáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_sup_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (a âŠ” â¨† x, f x) = â¨† x, a âŠ” f x",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±}"},
 {"type": "(a âŠ“ â¨… x, f x) = â¨… x, a âŠ“ f x",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (a âŠ“ â¨… x, f x) = â¨… x, a âŠ“ f x := by rw [infáµ¢_inf_eq]; sorry",
  "name": "inf_infáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [infáµ¢_inf_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±} : (a âŠ“ â¨… x, f x) = â¨… x, a âŠ“ f x",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} [Nonempty Î¹]  {f : Î¹ â†’ Î±}  {a : Î±}"},
 {"type": "(â¨† (i) (h : p i), f i h) âŠ” a = â¨† (i) (h : p i), f i h âŠ” a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i) : (â¨† (i) (h : p i), f i h) âŠ” a = â¨† (i) (h : p i), f i h âŠ” a := by haveI : Nonempty { i // p i } :=\n      let âŸ¨i, hiâŸ© := h\n      âŸ¨âŸ¨i, hiâŸ©âŸ©; sorry",
  "name": "bsupáµ¢_sup",
  "kind": "theorem",
  "first-tactic":
  "haveI : Nonempty { i // p i } :=\n      let âŸ¨i, hiâŸ© := h\n      âŸ¨âŸ¨i, hiâŸ©âŸ©",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i) : (â¨† (i) (h : p i), f i h) âŠ” a = â¨† (i) (h : p i), f i h âŠ” a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i)"},
 {"type": "(a âŠ” â¨† (i) (h : p i), f i h) = â¨† (i) (h : p i), a âŠ” f i h",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i) : (a âŠ” â¨† (i) (h : p i), f i h) = â¨† (i) (h : p i), a âŠ” f i h := by simpa only [sup_comm] using @bsupáµ¢_sup Î± _ _ p _ _ h; sorry",
  "name": "sup_bsupáµ¢",
  "kind": "theorem",
  "first-tactic": "simpa only [sup_comm] using @bsupáµ¢_sup Î± _ _ p _ _ h",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i) : (a âŠ” â¨† (i) (h : p i), f i h) = â¨† (i) (h : p i), a âŠ” f i h",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {p : Î¹ â†’ Prop}  {f : âˆ€ i, p i â†’ Î±}  {a : Î±}  (h : âˆƒ i, p i)"},
 {"type": "supáµ¢ s = âŠ¥",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±} : supáµ¢ s = âŠ¥ := by simp; sorry",
  "name": "supáµ¢_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±} : supáµ¢ s = âŠ¥",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±}"},
 {"type": "infáµ¢ s = âŠ¤",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±} : infáµ¢ s = âŠ¤ := by simp; sorry",
  "name": "infáµ¢_false",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±} : infáµ¢ s = âŠ¤",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : False â†’ Î±}"},
 {"type":
  "(â¨† i, if h : p i then f i h else g i h) = (â¨† (i) (h : p i), f i h) âŠ” â¨† (i) (h : Â¬p i), g i h",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (p : Î¹ â†’ Prop)  [DecidablePred p] (f : âˆ€ i, p i â†’ Î±)  (g : âˆ€ i, Â¬p i â†’ Î±) : (â¨† i, if h : p i then f i h else g i h) = (â¨† (i) (h : p i), f i h) âŠ” â¨† (i) (h : Â¬p i), g i h := by rw [â† supáµ¢_sup_eq]; sorry",
  "name": "supáµ¢_dite",
  "kind": "theorem",
  "first-tactic": "rw [â† supáµ¢_sup_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (p : Î¹ â†’ Prop)  [DecidablePred p] (f : âˆ€ i, p i â†’ Î±)  (g : âˆ€ i, Â¬p i â†’ Î±) : (â¨† i, if h : p i then f i h else g i h) = (â¨† (i) (h : p i), f i h) âŠ” â¨† (i) (h : Â¬p i), g i h",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _}  (p : Î¹ â†’ Prop)  [DecidablePred p] (f : âˆ€ i, p i â†’ Î±)  (g : âˆ€ i, Â¬p i â†’ Î±)"},
 {"type": "(â¨† b âˆˆ range f, g b) = â¨† i, g (f i)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {g : Î² â†’ Î±}  {f : Î¹ â†’ Î²} : (â¨† b âˆˆ range f, g b) = â¨† i, g (f i) := by rw [â† supáµ¢_subtype'']; sorry",
  "name": "supáµ¢_range",
  "kind": "theorem",
  "first-tactic": "rw [â† supáµ¢_subtype'']",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {g : Î² â†’ Î±}  {f : Î¹ â†’ Î²} : (â¨† b âˆˆ range f, g b) = â¨† i, g (f i)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {g : Î² â†’ Î±}  {f : Î¹ â†’ Î²}"},
 {"type": "supâ‚› (f '' s) = â¨† a âˆˆ s, f a",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : supâ‚› (f '' s) = â¨† a âˆˆ s, f a := by rw [â† supáµ¢_subtype'']; sorry",
  "name": "supâ‚›_image",
  "kind": "theorem",
  "first-tactic": "rw [â† supáµ¢_subtype'']",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : supâ‚› (f '' s) = â¨† a âˆˆ s, f a",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±}"},
 {"type": "(â¨† x âˆˆ (âˆ… : Set Î²), f x) = âŠ¥",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨† x âˆˆ (âˆ… : Set Î²), f x) = âŠ¥ := by simp; sorry",
  "name": "supáµ¢_emptyset",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨† x âˆˆ (âˆ… : Set Î²), f x) = âŠ¥",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}"},
 {"type": "(â¨… x âˆˆ (âˆ… : Set Î²), f x) = âŠ¤",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨… x âˆˆ (âˆ… : Set Î²), f x) = âŠ¤ := by simp; sorry",
  "name": "infáµ¢_emptyset",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨… x âˆˆ (âˆ… : Set Î²), f x) = âŠ¤",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}"},
 {"type": "(â¨† x âˆˆ (univ : Set Î²), f x) = â¨† x, f x",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨† x âˆˆ (univ : Set Î²), f x) = â¨† x, f x := by simp; sorry",
  "name": "supáµ¢_univ",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨† x âˆˆ (univ : Set Î²), f x) = â¨† x, f x",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}"},
 {"type": "(â¨… x âˆˆ (univ : Set Î²), f x) = â¨… x, f x",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨… x âˆˆ (univ : Set Î²), f x) = â¨… x, f x := by simp; sorry",
  "name": "infáµ¢_univ",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±} : (â¨… x âˆˆ (univ : Set Î²), f x) = â¨… x, f x",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}"},
 {"type": "(â¨† x âˆˆ s âˆª t, f x) = (â¨† x âˆˆ s, f x) âŠ” â¨† x âˆˆ t, f x",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {s t : Set Î²} : (â¨† x âˆˆ s âˆª t, f x) = (â¨† x âˆˆ s, f x) âŠ” â¨† x âˆˆ t, f x := by simp_rw [mem_union]; sorry",
  "name": "supáµ¢_union",
  "kind": "theorem",
  "first-tactic": "simp_rw [mem_union]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {s t : Set Î²} : (â¨† x âˆˆ s âˆª t, f x) = (â¨† x âˆˆ s, f x) âŠ” â¨† x âˆˆ t, f x",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {s t : Set Î²}"},
 {"type": "(â¨† i, f i) = (â¨† (i) (_h : p i), f i) âŠ” â¨† (i) (_h : Â¬p i), f i",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (p : Î² â†’ Prop) : (â¨† i, f i) = (â¨† (i) (_h : p i), f i) âŠ” â¨† (i) (_h : Â¬p i), f i := by simpa [Classical.em] using @supáµ¢_union _ _ _ f { i | p i } { i | Â¬p i }; sorry",
  "name": "supáµ¢_split",
  "kind": "theorem",
  "first-tactic":
  "simpa [Classical.em] using @supáµ¢_union _ _ _ f { i | p i } { i | Â¬p i }",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (p : Î² â†’ Prop) : (â¨† i, f i) = (â¨† (i) (_h : p i), f i) âŠ” â¨† (i) (_h : Â¬p i), f i",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (p : Î² â†’ Prop)"},
 {"type": "(â¨† i, f i) = f iâ‚€ âŠ” â¨† (i) (_h : i â‰  iâ‚€), f i",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (iâ‚€ : Î²) : (â¨† i, f i) = f iâ‚€ âŠ” â¨† (i) (_h : i â‰  iâ‚€), f i := by convert supáµ¢_split f (fun i => i = iâ‚€); sorry",
  "name": "supáµ¢_split_single",
  "kind": "theorem",
  "first-tactic": "convert supáµ¢_split f (fun i => i = iâ‚€)",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (iâ‚€ : Î²) : (â¨† i, f i) = f iâ‚€ âŠ” â¨† (i) (_h : i â‰  iâ‚€), f i",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î² â†’ Î±)  (iâ‚€ : Î²)"},
 {"type": "(â¨† x âˆˆ (singleton b : Set Î²), f x) = f b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²} : (â¨† x âˆˆ (singleton b : Set Î²), f x) = f b := by simp; sorry",
  "name": "supáµ¢_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²} : (â¨† x âˆˆ (singleton b : Set Î²), f x) = f b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²}"},
 {"type": "(â¨… x âˆˆ (singleton b : Set Î²), f x) = f b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²} : (â¨… x âˆˆ (singleton b : Set Î²), f x) = f b := by simp; sorry",
  "name": "infáµ¢_singleton",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²} : (â¨… x âˆˆ (singleton b : Set Î²), f x) = f b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {b : Î²}"},
 {"type": "(â¨† x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ” f b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²} : (â¨† x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ” f b := by rw [supáµ¢_insert]; sorry",
  "name": "supáµ¢_pair",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_insert]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²} : (â¨† x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ” f b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²}"},
 {"type": "(â¨… x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ“ f b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²} : (â¨… x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ“ f b := by rw [infáµ¢_insert]; sorry",
  "name": "infáµ¢_pair",
  "kind": "theorem",
  "first-tactic": "rw [infáµ¢_insert]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²} : (â¨… x âˆˆ ({a, b} : Set Î²), f x) = f a âŠ“ f b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î±}  {a b : Î²}"},
 {"type": "(â¨† j, extend e f âŠ¥ j) = â¨† i, f i",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {e : Î¹ â†’ Î²}  (he : Injective e)  (f : Î¹ â†’ Î±) : (â¨† j, extend e f âŠ¥ j) = â¨† i, f i := by rw [supáµ¢_split _ fun j => âˆƒ i]; sorry",
  "name": "supáµ¢_extend_bot",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_split _ fun j => âˆƒ i]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {e : Î¹ â†’ Î²}  (he : Injective e)  (f : Î¹ â†’ Î±) : (â¨† j, extend e f âŠ¥ j) = â¨† i, f i",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {e : Î¹ â†’ Î²}  (he : Injective e)  (f : Î¹ â†’ Î±)"},
 {"type": "(â¨† b : Bool, f b) = f true âŠ” f false",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Bool â†’ Î±} : (â¨† b : Bool, f b) = f true âŠ” f false := by rw [supáµ¢]; sorry",
  "name": "supáµ¢_bool_eq",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Bool â†’ Î±} : (â¨† b : Bool, f b) = f true âŠ” f false",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Bool â†’ Î±}"},
 {"type": "x âŠ” y = â¨† b : Bool, cond b x y",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (x y : Î±) : x âŠ” y = â¨† b : Bool, cond b x y := by rw [supáµ¢_bool_eq]; sorry",
  "name": "sup_eq_supáµ¢",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢_bool_eq]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (x y : Î±) : x âŠ” y = â¨† b : Bool, cond b x y",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (x y : Î±)"},
 {"type": "IsGLB (f '' s) (â¨… x âˆˆ s, f x)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : IsGLB (f '' s) (â¨… x âˆˆ s, f x) := by simpa only [range_comp]; sorry",
  "name": "isGLB_binfáµ¢",
  "kind": "theorem",
  "first-tactic": "simpa only [range_comp]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : IsGLB (f '' s) (â¨… x âˆˆ s, f x)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±}"},
 {"type": "IsLUB (f '' s) (â¨† x âˆˆ s, f x)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : IsLUB (f '' s) (â¨† x âˆˆ s, f x) := by simpa only [range_comp]; sorry",
  "name": "isLUB_bsupáµ¢",
  "kind": "theorem",
  "first-tactic": "simpa only [range_comp]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±} : IsLUB (f '' s) (â¨† x âˆˆ s, f x)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {s : Set Î²}  {f : Î² â†’ Î±}"},
 {"type": "(â¨† x âˆˆ s Ã—Ë¢ t, f x) = â¨† (a âˆˆ s) (b âˆˆ t), f (a, b)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² Ã— Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : (â¨† x âˆˆ s Ã—Ë¢ t, f x) = â¨† (a âˆˆ s) (b âˆˆ t), f (a, b) := by simp_rw [supáµ¢_prod]; sorry",
  "name": "bsupáµ¢_prod",
  "kind": "theorem",
  "first-tactic": "simp_rw [supáµ¢_prod]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² Ã— Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : (â¨† x âˆˆ s Ã—Ë¢ t, f x) = â¨† (a âˆˆ s) (b âˆˆ t), f (a, b)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² Ã— Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³}"},
 {"type": "(â¨† o : Option Î², o.elim a f) = a âŠ” â¨† b, f b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (f : Î² â†’ Î±) : (â¨† o : Option Î², o.elim a f) = a âŠ” â¨† b, f b := by simp [supáµ¢_option]; sorry",
  "name": "supáµ¢_option_elim",
  "kind": "theorem",
  "first-tactic": "simp [supáµ¢_option]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (f : Î² â†’ Î±) : (â¨† o : Option Î², o.elim a f) = a âŠ” â¨† b, f b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (a : Î±)  (f : Î² â†’ Î±)"},
 {"type": "(â¨† i : { i // f i â‰  âŠ¥ }, f i) = â¨† i, f i",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î¹ â†’ Î±) : (â¨† i : { i // f i â‰  âŠ¥ }, f i) = â¨† i, f i := by by_cases htriv : âˆ€ i, f i = âŠ¥; sorry",
  "name": "supáµ¢_ne_bot_subtype",
  "kind": "theorem",
  "first-tactic": "by_cases htriv : âˆ€ i, f i = âŠ¥",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î¹ â†’ Î±) : (â¨† i : { i // f i â‰  âŠ¥ }, f i) = â¨† i, f i",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : Î¹ â†’ Î±)"},
 {"type": "supâ‚› (image2 f s t) = â¨† (a âˆˆ s) (b âˆˆ t), f a b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : supâ‚› (image2 f s t) = â¨† (a âˆˆ s) (b âˆˆ t), f a b := by rw [â† image_prod]; sorry",
  "name": "supâ‚›_image2",
  "kind": "theorem",
  "first-tactic": "rw [â† image_prod]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : supâ‚› (image2 f s t) = â¨† (a âˆˆ s) (b âˆˆ t), f a b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³}"},
 {"type": "infâ‚› (image2 f s t) = â¨… (a âˆˆ s) (b âˆˆ t), f a b",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : infâ‚› (image2 f s t) = â¨… (a âˆˆ s) (b âˆˆ t), f a b := by rw [â† image_prod]; sorry",
  "name": "infâ‚›_image2",
  "kind": "theorem",
  "first-tactic": "rw [â† image_prod]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³} : infâ‚› (image2 f s t) = â¨… (a âˆˆ s) (b âˆˆ t), f a b",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} {f : Î² â†’ Î³ â†’ Î±}  {s : Set Î²}  {t : Set Î³}"},
 {"type": "(â¨† i â‰¥ n, u i) = â¨† i, u (i + n)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (u : â„• â†’ Î±)  (n : â„•) : (â¨† i â‰¥ n, u i) = â¨† i, u (i + n) := by apply le_antisymm; sorry",
  "name": "supáµ¢_ge_eq_supáµ¢_nat_add",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (u : â„• â†’ Î±)  (n : â„•) : (â¨† i â‰¥ n, u i) = â¨† i, u (i + n)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (u : â„• â†’ Î±)  (n : â„•)"},
 {"type": "(â¨† n, â¨… i â‰¥ n, f (i + k)) = â¨† n, â¨… i â‰¥ n, f i",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±)  (k : â„•) : (â¨† n, â¨… i â‰¥ n, f (i + k)) = â¨† n, â¨… i â‰¥ n, f i := by have hf : Monotone fun n => â¨… i â‰¥ n, f i := fun n m h => binfáµ¢_mono fun i => h.trans; sorry",
  "name": "supáµ¢_infáµ¢_ge_nat_add",
  "kind": "theorem",
  "first-tactic":
  "have hf : Monotone fun n => â¨… i â‰¥ n, f i := fun n m h => binfáµ¢_mono fun i => h.trans",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±)  (k : â„•) : (â¨† n, â¨… i â‰¥ n, f (i + k)) = â¨† n, â¨… i â‰¥ n, f i",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±)  (k : â„•)"},
 {"type": "(â¨… i > 0, f i) = â¨… i, f (i + 1)",
  "tactic-prompt":
  "theorem {Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±) : (â¨… i > 0, f i) = â¨… i, f (i + 1) := by rw [â† infáµ¢_range]; sorry",
  "name": "infáµ¢_nat_gt_zero_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† infáµ¢_range]",
  "core-prompt":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±) : (â¨… i > 0, f i) = â¨… i, f (i + 1)",
  "args":
  "{Î± Î² Î²â‚‚ Î³ : Type _}  {Î¹ Î¹' : Sort _}  {Îº : Î¹ â†’ Sort _}  {Îº' : Î¹' â†’ Sort _} (f : â„• â†’ Î±)"},
 {"type": "supáµ¢ f = âŠ¤ â†” âˆ€ b < âŠ¤, âˆƒ i, b < f i",
  "tactic-prompt":
  "theorem [CompleteLinearOrder Î±] (f : Î¹ â†’ Î±) : supáµ¢ f = âŠ¤ â†” âˆ€ b < âŠ¤, âˆƒ i, b < f i := by simp only [â† supâ‚›_range]; sorry",
  "name": "supáµ¢_eq_top",
  "kind": "theorem",
  "first-tactic": "simp only [â† supâ‚›_range]",
  "core-prompt":
  "[CompleteLinearOrder Î±] (f : Î¹ â†’ Î±) : supáµ¢ f = âŠ¤ â†” âˆ€ b < âŠ¤, âˆƒ i, b < f i",
  "args": "[CompleteLinearOrder Î±] (f : Î¹ â†’ Î±)"},
 {"type": "infáµ¢ f = âŠ¥ â†” âˆ€ b > âŠ¥, âˆƒ i, f i < b",
  "tactic-prompt":
  "theorem [CompleteLinearOrder Î±] (f : Î¹ â†’ Î±) : infáµ¢ f = âŠ¥ â†” âˆ€ b > âŠ¥, âˆƒ i, f i < b := by simp only [â† infâ‚›_range]; sorry",
  "name": "infáµ¢_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp only [â† infâ‚›_range]",
  "core-prompt":
  "[CompleteLinearOrder Î±] (f : Î¹ â†’ Î±) : infáµ¢ f = âŠ¥ â†” âˆ€ b > âŠ¥, âˆƒ i, f i < b",
  "args": "[CompleteLinearOrder Î±] (f : Î¹ â†’ Î±)"},
 {"type": "(â¨† i, f i) a = â¨† i, f i a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Î± â†’ Type _}  {Î¹ : Sort _}  [âˆ€ i, SupSet (Î² i)]  {f : Î¹ â†’ âˆ€ a, Î² a}      {a : Î±} : (â¨† i, f i) a = â¨† i, f i a := by rw [supáµ¢]; sorry",
  "name": "supáµ¢_apply",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Î± â†’ Type _}  {Î¹ : Sort _}  [âˆ€ i, SupSet (Î² i)]  {f : Î¹ â†’ âˆ€ a, Î² a}      {a : Î±} : (â¨† i, f i) a = â¨† i, f i a",
  "args":
  "{Î± : Type _}  {Î² : Î± â†’ Type _}  {Î¹ : Sort _}  [âˆ€ i, SupSet (Î² i)]  {f : Î¹ â†’ âˆ€ a, Î² a}      {a : Î±}"},
 {"type": "supâ‚› s a â†” âˆƒ r : Î± â†’ Prop, r âˆˆ s âˆ§ r a",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±} : supâ‚› s a â†” âˆƒ r : Î± â†’ Prop, r âˆˆ s âˆ§ r a := by rw [supâ‚›_apply]; sorry",
  "name": "unary_relation_supâ‚›_iff",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_apply]",
  "core-prompt":
  "{Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±} : supâ‚› s a â†” âˆƒ r : Î± â†’ Prop, r âˆˆ s âˆ§ r a",
  "args": "{Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±}"},
 {"type": "infâ‚› s a â†” âˆ€ r : Î± â†’ Prop, r âˆˆ s â†’ r a",
  "tactic-prompt":
  "theorem {Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±} : infâ‚› s a â†” âˆ€ r : Î± â†’ Prop, r âˆˆ s â†’ r a := by rw [infâ‚›_apply]; sorry",
  "name": "unary_relation_infâ‚›_iff",
  "kind": "theorem",
  "first-tactic": "rw [infâ‚›_apply]",
  "core-prompt":
  "{Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±} : infâ‚› s a â†” âˆ€ r : Î± â†’ Prop, r âˆˆ s â†’ r a",
  "args": "{Î± : Type _}  (s : Set (Î± â†’ Prop))  {a : Î±}"},
 {"type": "supâ‚› s a b â†” âˆƒ r : Î± â†’ Î² â†’ Prop, r âˆˆ s âˆ§ r a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²} : supâ‚› s a b â†” âˆƒ r : Î± â†’ Î² â†’ Prop, r âˆˆ s âˆ§ r a b := by rw [supâ‚›_apply]; sorry",
  "name": "binary_relation_supâ‚›_iff",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_apply]",
  "core-prompt":
  "{Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²} : supâ‚› s a b â†” âˆƒ r : Î± â†’ Î² â†’ Prop, r âˆˆ s âˆ§ r a b",
  "args": "{Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²}"},
 {"type": "infâ‚› s a b â†” âˆ€ r : Î± â†’ Î² â†’ Prop, r âˆˆ s â†’ r a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²} : infâ‚› s a b â†” âˆ€ r : Î± â†’ Î² â†’ Prop, r âˆˆ s â†’ r a b := by rw [infâ‚›_apply]; sorry",
  "name": "binary_relation_infâ‚›_iff",
  "kind": "theorem",
  "first-tactic": "rw [infâ‚›_apply]",
  "core-prompt":
  "{Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²} : infâ‚› s a b â†” âˆ€ r : Î± â†’ Î² â†’ Prop, r âˆˆ s â†’ r a b",
  "args": "{Î± Î² : Type _}  (s : Set (Î± â†’ Î² â†’ Prop))  {a : Î±}  {b : Î²}"},
 {"type": "Acc s (f a) â†’ Acc r a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : Î±) : Acc s (f a) â†’ Acc r a := by generalize h : f a = b; sorry",
  "name": "acc",
  "kind": "theorem",
  "first-tactic": "generalize h : f a = b",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : Î±) : Acc s (f a) â†’ Acc r a",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [RelHomClass F r s]  (f : F)  (a : Î±)"},
 {"type": "Injective f",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (r : Î± â†’ Î± â†’ Prop)  (s : Î² â†’ Î² â†’ Prop)  [IsTrichotomous Î± r]      [IsIrrefl Î² s]  (f : Î± â†’ Î²)  (hf : âˆ€ {x y}, r x y â†’ s (f x) (f y)) : Injective f := by intro x y hxy; sorry",
  "name": "injective_of_increasing",
  "kind": "theorem",
  "first-tactic": "intro x y hxy",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (r : Î± â†’ Î± â†’ Prop)  (s : Î² â†’ Î² â†’ Prop)  [IsTrichotomous Î± r]      [IsIrrefl Î² s]  (f : Î± â†’ Î²)  (hf : âˆ€ {x y}, r x y â†’ s (f x) (f y)) : Injective f",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (r : Î± â†’ Î± â†’ Prop)  (s : Î² â†’ Î² â†’ Prop)  [IsTrichotomous Î± r]      [IsIrrefl Î² s]  (f : Î± â†’ Î²)  (hf : âˆ€ {x y}, r x y â†’ s (f x) (f y))"},
 {"type": "r = f â»Â¹'o s",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s) : r = f â»Â¹'o s := by ext (a b); sorry",
  "name": "eq_preimage",
  "kind": "theorem",
  "first-tactic": "ext (a b)",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s) : r = f â»Â¹'o s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s)"},
 {"type": "Acc s (f a) â†’ Acc r a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s)  (a : Î±) : Acc s (f a) â†’ Acc r a := by generalize h : f a = b; sorry",
  "name": "acc",
  "kind": "theorem",
  "first-tactic": "generalize h : f a = b",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s)  (a : Î±) : Acc s (f a) â†’ Acc r a",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} (f : r â†ªr s)  (a : Î±)"},
 {"type": "r â†ªr s",
  "tactic-prompt":
  "def {Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [IsTrichotomous Î± r]  [IsAsymm Î² s]  (f : Î± â†’ Î²)  (H : âˆ€ a b, r a b â†’ s (f a) (f b)) : r â†ªr s := by haveI := @IsAsymm.isIrrefl Î² s _; sorry",
  "name": "ofMonotone",
  "kind": "def",
  "first-tactic": "haveI := @IsAsymm.isIrrefl Î² s _",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [IsTrichotomous Î± r]  [IsAsymm Î² s]  (f : Î± â†’ Î²)  (H : âˆ€ a b, r a b â†’ s (f a) (f b)) : r â†ªr s",
  "args":
  "{Î± Î² Î³ Î´ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop}  {u : Î´ â†’ Î´ â†’ Prop} {F : Type _} [IsTrichotomous Î± r]  [IsAsymm Î² s]  (f : Î± â†’ Î²)  (H : âˆ€ a b, r a b â†’ s (f a) (f b))"},
 {"type": "EquivLike.inv f b â‰¤ a â†” b â‰¤ f a",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²} : EquivLike.inv f b â‰¤ a â†” b â‰¤ f a := by convert (@map_le_map_iff _ _ _ _ _ _ f (EquivLike.inv f b) a).symm; sorry",
  "name": "map_inv_le_iff",
  "kind": "theorem",
  "first-tactic":
  "convert (@map_le_map_iff _ _ _ _ _ _ f (EquivLike.inv f b) a).symm",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²} : EquivLike.inv f b â‰¤ a â†” b â‰¤ f a",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²}"},
 {"type": "a â‰¤ EquivLike.inv f b â†” f a â‰¤ b",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²} : a â‰¤ EquivLike.inv f b â†” f a â‰¤ b := by convert (@map_le_map_iff _ _ _ _ _ _ f a (EquivLike.inv f b)).symm; sorry",
  "name": "le_map_inv_iff",
  "kind": "theorem",
  "first-tactic":
  "convert (@map_le_map_iff _ _ _ _ _ _ f a (EquivLike.inv f b)).symm",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²} : a â‰¤ EquivLike.inv f b â†” f a â‰¤ b",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]   [LE Î±]  [LE Î²]  [OrderIsoClass F Î± Î²]  -- Porting note: needed to add explicit arguments to map_le_map_iff (f : F)  {a : Î±}  {b : Î²}"},
 {"type": "EquivLike.inv f b < a â†” b < f a",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²} : EquivLike.inv f b < a â†” b < f a := by rw [â† map_lt_map_iff f]; sorry",
  "name": "map_inv_lt_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† map_lt_map_iff f]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²} : EquivLike.inv f b < a â†” b < f a",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²}"},
 {"type": "a < EquivLike.inv f b â†” f a < b",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²} : a < EquivLike.inv f b â†” f a < b := by rw [â† map_lt_map_iff f]; sorry",
  "name": "lt_map_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† map_lt_map_iff f]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²} : a < EquivLike.inv f b â†” f a < b",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²]  [Preorder Î±]  [Preorder Î²]  [OrderIsoClass F Î± Î²] (f : F)  {a : Î±}  {b : Î²}"},
 {"type": "comp f id = f",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²) : comp f id = f := by ext; sorry",
  "name": "comp_id",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²) : comp f id = f",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²)"},
 {"type": "comp id f = f",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²) : comp id f = f := by ext; sorry",
  "name": "id_comp",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²) : comp id f = f",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] (f : Î± â†’o Î²)"},
 {"type": "(fst : Î± Ã— Î² â†’o Î±).prod snd = id",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] : (fst : Î± Ã— Î² â†’o Î±).prod snd = id := by ext âŸ¨x, yâŸ© : 2; sorry",
  "name": "fst_prod_snd",
  "kind": "theorem",
  "first-tactic": "ext âŸ¨x, yâŸ© : 2",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] : (fst : Î± Ã— Î² â†’o Î±).prod snd = id",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´]"},
 {"type": "e.symm.symm = e",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : e.symm.symm = e := by ext; sorry",
  "name": "symm_symm",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : e.symm.symm = e",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²)"},
 {"type": "(refl Î±).trans e = e",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : (refl Î±).trans e = e := by ext x; sorry",
  "name": "refl_trans",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : (refl Î±).trans e = e",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²)"},
 {"type": "e.trans (refl Î²) = e",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : e.trans (refl Î²) = e := by ext x; sorry",
  "name": "trans_refl",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²) : e.trans (refl Î²) = e",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²)  [LE Î±]  [LE Î²]  [LE Î³] (e : Î± â‰ƒo Î²)"},
 {"type": "f x = y",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE Î±]  [PartialOrder Î²]  (f : Î± â‰ƒo Î²)  {x : Î±}  {y : Î²}  (hx : âˆ€ x', x â‰¤ x')      (hy : âˆ€ y', y â‰¤ y') : f x = y := by refine' le_antisymm _ (hy _); sorry",
  "name": "OrderIso.map_bot'",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ (hy _)",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE Î±]  [PartialOrder Î²]  (f : Î± â‰ƒo Î²)  {x : Î±}  {y : Î²}  (hx : âˆ€ x', x â‰¤ x')      (hy : âˆ€ y', y â‰¤ y') : f x = y",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [LE Î±]  [PartialOrder Î²]  (f : Î± â‰ƒo Î²)  {x : Î±}  {y : Î²}  (hx : âˆ€ x', x â‰¤ x')      (hy : âˆ€ y', y â‰¤ y')"},
 {"type": "f (x âŠ“ y) = f x âŠ“ f y",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [SemilatticeInf Î²]  (f : Î± â‰ƒo Î²)  (x y : Î±) : f (x âŠ“ y) = f x âŠ“ f y := by refine' (f.toOrderEmbedding.map_inf_le x y).antisymm _; sorry",
  "name": "OrderIso.map_inf",
  "kind": "theorem",
  "first-tactic": "refine' (f.toOrderEmbedding.map_inf_le x y).antisymm _",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [SemilatticeInf Î²]  (f : Î± â‰ƒo Î²)  (x y : Î±) : f (x âŠ“ y) = f x âŠ“ f y",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [SemilatticeInf Î²]  (f : Î± â‰ƒo Î²)  (x y : Î±)"},
 {"type": "Disjoint (f a) (f b)",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [OrderBot Î±]  [SemilatticeInf Î²]  [OrderBot Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Disjoint a b) : Disjoint (f a) (f b) := by rw [disjoint_iff_inf_le]; sorry",
  "name": "Disjoint.map_orderIso",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [OrderBot Î±]  [SemilatticeInf Î²]  [OrderBot Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Disjoint a b) : Disjoint (f a) (f b)",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeInf Î±]  [OrderBot Î±]  [SemilatticeInf Î²]  [OrderBot Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Disjoint a b)"},
 {"type": "Codisjoint (f a) (f b)",
  "tactic-prompt":
  "theorem {F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup Î±]  [OrderTop Î±]  [SemilatticeSup Î²]  [OrderTop Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Codisjoint a b) : Codisjoint (f a) (f b) := by rw [codisjoint_iff_le_sup]; sorry",
  "name": "Codisjoint.map_orderIso",
  "kind": "theorem",
  "first-tactic": "rw [codisjoint_iff_le_sup]",
  "core-prompt":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup Î±]  [OrderTop Î±]  [SemilatticeSup Î²]  [OrderTop Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Codisjoint a b) : Codisjoint (f a) (f b)",
  "args":
  "{F Î± Î² Î³ Î´ : Type _} [Preorder Î±]  [Preorder Î²]  [OrderHomClass F Î± Î²] [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  [Preorder Î´] {Î¹ : Type _}  {Ï€ : Î¹ â†’ Type _}  [âˆ€ i, Preorder (Ï€ i)] [Preorder Î±]  [Preorder Î²]  (f : Î± â†ªo Î²) [Preorder Î±]  [Preorder Î²]  [Preorder Î³] [Preorder Î±]  [Preorder Î²] [LinearOrder Î±]  [Preorder Î²] (f : Î± â†’ Î²)  (h_mono : StrictMono f)  (h_surj : Function.Surjective f)  [SemilatticeSup Î±]  [OrderTop Î±]  [SemilatticeSup Î²]  [OrderTop Î²]      {a b : Î±}  (f : Î± â‰ƒo Î²)  (ha : Codisjoint a b)"},
 {"type": "((â¨… i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨… i, (f i : Î± â†’ Î²)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²) : ((â¨… i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨… i, (f i : Î± â†’ Î²) := by funext x; sorry",
  "name": "coe_infáµ¢",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²) : ((â¨… i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨… i, (f i : Î± â†’ Î²)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²)"},
 {"type": "((â¨† i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨† i, (f i : Î± â†’ Î²)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²) : ((â¨† i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨† i, (f i : Î± â†’ Î²) := by funext x; sorry",
  "name": "coe_supáµ¢",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²) : ((â¨† i, f i : Î± â†’o Î²) : Î± â†’ Î²) = â¨† i, (f i : Î± â†’ Î²)",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±] {Î¹ : Sort _}  [CompleteLattice Î²]  (f : Î¹ â†’ Î± â†’o Î²)"},
 {"type":
  "(âˆ€ nâ‚ nâ‚‚ aâ‚ aâ‚‚, (f^[nâ‚ + nâ‚‚]) (aâ‚ âŠ” aâ‚‚) â‰¤ (f^[nâ‚]) aâ‚ âŠ” (f^[nâ‚‚]) aâ‚‚) â†”\n      âˆ€ aâ‚ aâ‚‚, f (aâ‚ âŠ” aâ‚‚) â‰¤ f aâ‚ âŠ” aâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±] {Î± : Type _}  [SemilatticeSup Î±]  (f : Î± â†’o Î±) : (âˆ€ nâ‚ nâ‚‚ aâ‚ aâ‚‚, (f^[nâ‚ + nâ‚‚]) (aâ‚ âŠ” aâ‚‚) â‰¤ (f^[nâ‚]) aâ‚ âŠ” (f^[nâ‚‚]) aâ‚‚) â†”\n      âˆ€ aâ‚ aâ‚‚, f (aâ‚ âŠ” aâ‚‚) â‰¤ f aâ‚ âŠ” aâ‚‚ := by constructor; sorry",
  "name": "iterate_sup_le_sup_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±] {Î± : Type _}  [SemilatticeSup Î±]  (f : Î± â†’o Î±) : (âˆ€ nâ‚ nâ‚‚ aâ‚ aâ‚‚, (f^[nâ‚ + nâ‚‚]) (aâ‚ âŠ” aâ‚‚) â‰¤ (f^[nâ‚]) aâ‚ âŠ” (f^[nâ‚‚]) aâ‚‚) â†”\n      âˆ€ aâ‚ aâ‚‚, f (aâ‚ âŠ” aâ‚‚) â‰¤ f aâ‚ âŠ” aâ‚‚",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±] {Î± : Type _}  [SemilatticeSup Î±]  (f : Î± â†’o Î±)"},
 {"type": "(x.unbot h : WithBot Î±) = x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} (x : WithBot Î±)  (h : x â‰  âŠ¥) : (x.unbot h : WithBot Î±) = x := by cases x; sorry",
  "name": "coe_unbot",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} (x : WithBot Î±)  (h : x â‰  âŠ¥) : (x.unbot h : WithBot Î±) = x",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±} (x : WithBot Î±)  (h : x â‰  âŠ¥)"},
 {"type": "@LE.le (WithBot Î±) _ (Option.some a) (Option.some b) â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LE Î±] : @LE.le (WithBot Î±) _ (Option.some a) (Option.some b) â†” a â‰¤ b := by simp [LE.le]; sorry",
  "name": "some_le_some",
  "kind": "theorem",
  "first-tactic": "simp [LE.le]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LE Î±] : @LE.le (WithBot Î±) _ (Option.some a) (Option.some b) â†” a â‰¤ b",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LE Î±]"},
 {"type": "@LT.lt (WithBot Î±) _ (Option.some a) (Option.some b) â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LT Î±] : @LT.lt (WithBot Î±) _ (Option.some a) (Option.some b) â†” a < b := by simp [LT.lt]; sorry",
  "name": "some_lt_some",
  "kind": "theorem",
  "first-tactic": "simp [LT.lt]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LT Î±] : @LT.lt (WithBot Î±) _ (Option.some a) (Option.some b) â†” a < b",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±}  [LT Î±]"},
 {"type": "a.unbot' âŠ¥ â‰¤ b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} [LE Î±]  [OrderBot Î±]  {a : WithBot Î±}  {b : Î±} : a.unbot' âŠ¥ â‰¤ b â†” a â‰¤ b := by cases a; sorry",
  "name": "unbot'_bot_le_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} [LE Î±]  [OrderBot Î±]  {a : WithBot Î±}  {b : Î±} : a.unbot' âŠ¥ â‰¤ b â†” a â‰¤ b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} [LE Î±]  [OrderBot Î±]  {a : WithBot Î±}  {b : Î±}"},
 {"type": "a.unbot' b < c â†” a < c",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} [LT Î±]  {a : WithBot Î±}  {b c : Î±}  (ha : a â‰  âŠ¥) : a.unbot' b < c â†” a < c := by cases a; sorry",
  "name": "unbot'_lt_iff",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} [LT Î±]  {a : WithBot Î±}  {b c : Î±}  (ha : a â‰  âŠ¥) : a.unbot' b < c â†” a < c",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} [LT Î±]  {a : WithBot Î±}  {b c : Î±}  (ha : a â‰  âŠ¥)"},
 {"type": "(a : WithTop Î±) â‰¤ b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±] : (a : WithTop Î±) â‰¤ b â†” a â‰¤ b := by simp only [â† toDual_le_toDual_iff]; sorry",
  "name": "coe_le_coe",
  "kind": "theorem",
  "first-tactic": "simp only [â† toDual_le_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±] : (a : WithTop Î±) â‰¤ b â†” a â‰¤ b",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±]"},
 {"type": "IsMin (a : WithTop Î±)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±] (h : IsMin a) : IsMin (a : WithTop Î±) := by intro _ hb; sorry",
  "name": "_root_.IsMin.withTop",
  "kind": "theorem",
  "first-tactic": "intro _ hb",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±] (h : IsMin a) : IsMin (a : WithTop Î±)",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LE Î±] (h : IsMin a)"},
 {"type": "(a : WithTop Î±) < b â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} : (a : WithTop Î±) < b â†” a < b := by simp only [â† toDual_lt_toDual_iff]; sorry",
  "name": "coe_lt_coe",
  "kind": "theorem",
  "first-tactic": "simp only [â† toDual_lt_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} : (a : WithTop Î±) < b â†” a < b",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±}"},
 {"type": "(a : WithTop Î±) < âŠ¤",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : Î±) : (a : WithTop Î±) < âŠ¤ := by simp [â† toDual_lt_toDual_iff]; sorry",
  "name": "coe_lt_top",
  "kind": "theorem",
  "first-tactic": "simp [â† toDual_lt_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : Î±) : (a : WithTop Î±) < âŠ¤",
  "args": "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : Î±)"},
 {"type": "Â¬@LT.lt (WithTop Î±) _ none a",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : WithTop Î±) : Â¬@LT.lt (WithTop Î±) _ none a := by rw [â† toDual_lt_toDual_iff]; sorry",
  "name": "not_none_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† toDual_lt_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : WithTop Î±) : Â¬@LT.lt (WithTop Î±) _ none a",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} (a : WithTop Î±)"},
 {"type": "a < b â†” âˆƒ p : Î±, a = p âˆ§ â†‘p < b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {a b : WithTop Î±} : a < b â†” âˆƒ p : Î±, a = p âˆ§ â†‘p < b := by rw [â† toDual_lt_toDual_iff]; sorry",
  "name": "lt_iff_exists_coe",
  "kind": "theorem",
  "first-tactic": "rw [â† toDual_lt_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {a b : WithTop Î±} : a < b â†” âˆƒ p : Î±, a = p âˆ§ â†‘p < b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {a b : WithTop Î±}"},
 {"type": "â†‘a < x â†” âˆ€ b, x = â†‘b â†’ a < b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {x : WithTop Î±} : â†‘a < x â†” âˆ€ b, x = â†‘b â†’ a < b := by simp; sorry",
  "name": "coe_lt_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {x : WithTop Î±} : â†‘a < x â†” âˆ€ b, x = â†‘b â†’ a < b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±}  [LT Î±]  {a b : Î±} {x : WithTop Î±}"},
 {"type": "a.map f â‰¤ b.map f â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±} [Preorder Î±]  [Preorder Î²]  (f : Î± â†’ Î²)  (a b : WithTop Î±)      (mono_iff : âˆ€ {a b}, f a â‰¤ f b â†” a â‰¤ b) : a.map f â‰¤ b.map f â†” a â‰¤ b := by erw [â† toDual_le_toDual_iff]; sorry",
  "name": "map_le_iff",
  "kind": "theorem",
  "first-tactic": "erw [â† toDual_le_toDual_iff]",
  "core-prompt":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±} [Preorder Î±]  [Preorder Î²]  (f : Î± â†’ Î²)  (a b : WithTop Î±)      (mono_iff : âˆ€ {a b}, f a â‰¤ f b â†” a â‰¤ b) : a.map f â‰¤ b.map f â†” a â‰¤ b",
  "args":
  "{Î± Î² Î³ Î´ : Type _} {a b : Î±} {a b : Î±} [Preorder Î±]  [Preorder Î²]  (f : Î± â†’ Î²)  (a b : WithTop Î±)      (mono_iff : âˆ€ {a b}, f a â‰¤ f b â†” a â‰¤ b)"},
 {"type": "WellFounded r â†” âˆ€ s : Set Î±, s.Nonempty â†’ âˆƒ m âˆˆ s, âˆ€ x âˆˆ s, Â¬r x m",
  "tactic-prompt":
  "theorem {Î± : Type _} {r : Î± â†’ Î± â†’ Prop} : WellFounded r â†” âˆ€ s : Set Î±, s.Nonempty â†’ âˆƒ m âˆˆ s, âˆ€ x âˆˆ s, Â¬r x m := by refine âŸ¨fun h => h.has_min, fun h => âŸ¨fun x => ?_âŸ©âŸ©; sorry",
  "name": "wellFounded_iff_has_min",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => h.has_min, fun h => âŸ¨fun x => ?_âŸ©âŸ©",
  "core-prompt":
  "{Î± : Type _} {r : Î± â†’ Î± â†’ Prop} : WellFounded r â†” âˆ€ s : Set Î±, s.Nonempty â†’ âˆƒ m âˆˆ s, âˆ€ x âˆˆ s, Â¬r x m",
  "args": "{Î± : Type _} {r : Î± â†’ Î± â†’ Prop}"},
 {"type":
  "WellFounded ((Â· > Â·) : Î± â†’ Î± â†’ Prop) â†”\n      âˆ€ p : Set Î±, p.Nonempty â†’ âˆƒ m âˆˆ p, âˆ€ x âˆˆ p, m â‰¤ x â†’ x = m",
  "tactic-prompt":
  "theorem {Î± : Type _} [PartialOrder Î±] : WellFounded ((Â· > Â·) : Î± â†’ Î± â†’ Prop) â†”\n      âˆ€ p : Set Î±, p.Nonempty â†’ âˆƒ m âˆˆ p, âˆ€ x âˆˆ p, m â‰¤ x â†’ x = m := by simp [eq_iff_not_lt_of_le]; sorry",
  "name": "wellFounded_iff_has_max'",
  "kind": "theorem",
  "first-tactic": "simp [eq_iff_not_lt_of_le]",
  "core-prompt":
  "{Î± : Type _} [PartialOrder Î±] : WellFounded ((Â· > Â·) : Î± â†’ Î± â†’ Prop) â†”\n      âˆ€ p : Set Î±, p.Nonempty â†’ âˆƒ m âˆˆ p, âˆ€ x âˆˆ p, m â‰¤ x â†’ x = m",
  "args": "{Î± : Type _} [PartialOrder Î±]"},
 {"type": "r x (wf.succ x)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  (wf : WellFounded r)  {x : Î±}  (h : âˆƒ y, r x y) : r x (wf.succ x) := by rw [WellFounded.succ]; sorry",
  "name": "lt_succ",
  "kind": "theorem",
  "first-tactic": "rw [WellFounded.succ]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  (wf : WellFounded r)  {x : Î±}  (h : âˆƒ y, r x y) : r x (wf.succ x)",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  (wf : WellFounded r)  {x : Î±}  (h : âˆƒ y, r x y)"},
 {"type": "r y (wo.wf.succ x) â†” r y x âˆ¨ y = x",
  "tactic-prompt":
  "theorem {Î± : Type _} {r : Î± â†’ Î± â†’ Prop}  [wo : IsWellOrder Î± r]  {x : Î±}  (h : âˆƒ y, r x y)      (y : Î±) : r y (wo.wf.succ x) â†” r y x âˆ¨ y = x := by constructor; sorry",
  "name": "lt_succ_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _} {r : Î± â†’ Î± â†’ Prop}  [wo : IsWellOrder Î± r]  {x : Î±}  (h : âˆƒ y, r x y)      (y : Î±) : r y (wo.wf.succ x) â†” r y x âˆ¨ y = x",
  "args":
  "{Î± : Type _} {r : Î± â†’ Î± â†’ Prop}  [wo : IsWellOrder Î± r]  {x : Î±}  (h : âˆƒ y, r x y)      (y : Î±)"},
 {"type": "f b â‰¤ g b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f g : Î² â†’ Î³}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : Î²}  (H : âˆ€ a < b, f a = g a) : f b â‰¤ g b := by obtain âŸ¨c, hcâŸ© : g b âˆˆ Set.range f := by\n    rw [hfg]\n    exact Set.mem_range_self b; sorry",
  "name": "eq_strictMono_iff_eq_range_aux",
  "kind": "theorem",
  "first-tactic":
  "obtain âŸ¨c, hcâŸ© : g b âˆˆ Set.range f := by\n    rw [hfg]\n    exact Set.mem_range_self b",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f g : Î² â†’ Î³}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : Î²}  (H : âˆ€ a < b, f a = g a) : f b â‰¤ g b",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f g : Î² â†’ Î³}  (hf : StrictMono f)      (hg : StrictMono g)  (hfg : Set.range f = Set.range g)  {b : Î²}  (H : âˆ€ a < b, f a = g a)"},
 {"type": "âˆ€ n, n â‰¤ f n",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f : Î² â†’ Î²}  (hf : StrictMono f) : âˆ€ n, n â‰¤ f n := by by_contra' hâ‚; sorry",
  "name": "self_le_of_strictMono",
  "kind": "theorem",
  "first-tactic": "by_contra' hâ‚",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f : Î² â†’ Î²}  (hf : StrictMono f) : âˆ€ n, n â‰¤ f n",
  "args":
  "{Î± : Type _}  {Î² : Type _}  [LinearOrder Î²]  (h : WellFounded ((Â· < Â·) : Î² â†’ Î² â†’ Prop))  {Î³ : Type _}    [PartialOrder Î³] {f : Î² â†’ Î²}  (hf : StrictMono f)"},
 {"type": "supâ‚› s âŠ“ b = â¨† a âˆˆ s, a âŠ“ b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} : supâ‚› s âŠ“ b = â¨† a âˆˆ s, a âŠ“ b := by simpa only [inf_comm] using @inf_supâ‚›_eq Î± _ s b; sorry",
  "name": "supâ‚›_inf_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [inf_comm] using @inf_supâ‚›_eq Î± _ s b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} : supâ‚› s âŠ“ b = â¨† a âˆˆ s, a âŠ“ b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±}"},
 {"type": "(â¨† i, f i) âŠ“ a = â¨† i, f i âŠ“ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (f : Î¹ â†’ Î±)  (a : Î±) : (â¨† i, f i) âŠ“ a = â¨† i, f i âŠ“ a := by rw [supáµ¢]; sorry",
  "name": "supáµ¢_inf_eq",
  "kind": "theorem",
  "first-tactic": "rw [supáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (f : Î¹ â†’ Î±)  (a : Î±) : (â¨† i, f i) âŠ“ a = â¨† i, f i âŠ“ a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (f : Î¹ â†’ Î±)  (a : Î±)"},
 {"type": "(a âŠ“ â¨† i, f i) = â¨† i, a âŠ“ f i",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (f : Î¹ â†’ Î±) : (a âŠ“ â¨† i, f i) = â¨† i, a âŠ“ f i := by simpa only [inf_comm] using supáµ¢_inf_eq f a; sorry",
  "name": "inf_supáµ¢_eq",
  "kind": "theorem",
  "first-tactic": "simpa only [inf_comm] using supáµ¢_inf_eq f a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (f : Î¹ â†’ Î±) : (a âŠ“ â¨† i, f i) = â¨† i, a âŠ“ f i",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (f : Î¹ â†’ Î±)"},
 {"type": "(â¨† (i) (j), f i j) âŠ“ a = â¨† (i) (j), f i j âŠ“ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±) : (â¨† (i) (j), f i j) âŠ“ a = â¨† (i) (j), f i j âŠ“ a := by simp only [supáµ¢_inf_eq]; sorry",
  "name": "supáµ¢â‚‚_inf_eq",
  "kind": "theorem",
  "first-tactic": "simp only [supáµ¢_inf_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±) : (â¨† (i) (j), f i j) âŠ“ a = â¨† (i) (j), f i j âŠ“ a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±)"},
 {"type": "(a âŠ“ â¨† (i) (j), f i j) = â¨† (i) (j), a âŠ“ f i j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±) : (a âŠ“ â¨† (i) (j), f i j) = â¨† (i) (j), a âŠ“ f i j := by simp only [inf_supáµ¢_eq]; sorry",
  "name": "inf_supáµ¢â‚‚_eq",
  "kind": "theorem",
  "first-tactic": "simp only [inf_supáµ¢_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±) : (a âŠ“ â¨† (i) (j), f i j) = â¨† (i) (j), a âŠ“ f i j",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}  (a : Î±)"},
 {"type": "((â¨† i, f i) âŠ“ â¨† j, g j) = â¨† i : Î¹ Ã— Î¹', f i.1 âŠ“ g i.2",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±} : ((â¨† i, f i) âŠ“ â¨† j, g j) = â¨† i : Î¹ Ã— Î¹', f i.1 âŠ“ g i.2 := by simp_rw [supáµ¢_inf_eq]; sorry",
  "name": "supáµ¢_inf_supáµ¢",
  "kind": "theorem",
  "first-tactic": "simp_rw [supáµ¢_inf_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±} : ((â¨† i, f i) âŠ“ â¨† j, g j) = â¨† i : Î¹ Ã— Î¹', f i.1 âŠ“ g i.2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±}"},
 {"type":
  "((â¨† i âˆˆ s, f i) âŠ“ â¨† j âˆˆ t, g j) = â¨† p âˆˆ s Ã—Ë¢ t, f (p : Î¹ Ã— Î¹').1 âŠ“ g p.2",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±}  {s : Set Î¹}  {t : Set Î¹'} : ((â¨† i âˆˆ s, f i) âŠ“ â¨† j âˆˆ t, g j) = â¨† p âˆˆ s Ã—Ë¢ t, f (p : Î¹ Ã— Î¹').1 âŠ“ g p.2 := by simp only [supáµ¢_subtype']; sorry",
  "name": "bsupáµ¢_inf_bsupáµ¢",
  "kind": "theorem",
  "first-tactic": "simp only [supáµ¢_subtype']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±}  {s : Set Î¹}  {t : Set Î¹'} : ((â¨† i âˆˆ s, f i) âŠ“ â¨† j âˆˆ t, g j) = â¨† p âˆˆ s Ã—Ë¢ t, f (p : Î¹ Ã— Î¹').1 âŠ“ g p.2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ Î¹' : Type _}  {f : Î¹ â†’ Î±}  {g : Î¹' â†’ Î±}  {s : Set Î¹}  {t : Set Î¹'}"},
 {"type": "supâ‚› s âŠ“ supâ‚› t = â¨† p âˆˆ s Ã—Ë¢ t, (p : Î± Ã— Î±).1 âŠ“ p.2",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} : supâ‚› s âŠ“ supâ‚› t = â¨† p âˆˆ s Ã—Ë¢ t, (p : Î± Ã— Î±).1 âŠ“ p.2 := by simp only [supâ‚›_eq_supáµ¢]; sorry",
  "name": "supâ‚›_inf_supâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} : supâ‚› s âŠ“ supâ‚› t = â¨† p âˆˆ s Ã—Ë¢ t, (p : Î± Ã— Î±).1 âŠ“ p.2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±}"},
 {"type": "Disjoint (â¨† i, f i) a â†” âˆ€ i, Disjoint (f i) a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±} : Disjoint (â¨† i, f i) a â†” âˆ€ i, Disjoint (f i) a := by simp only [disjoint_iff]; sorry",
  "name": "supáµ¢_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±} : Disjoint (â¨† i, f i) a â†” âˆ€ i, Disjoint (f i) a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±}"},
 {"type": "Disjoint a (â¨† i, f i) â†” âˆ€ i, Disjoint a (f i)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±} : Disjoint a (â¨† i, f i) â†” âˆ€ i, Disjoint a (f i) := by simpa only [Disjoint.comm] using @supáµ¢_disjoint_iff; sorry",
  "name": "disjoint_supáµ¢_iff",
  "kind": "theorem",
  "first-tactic": "simpa only [Disjoint.comm] using @supáµ¢_disjoint_iff",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±} : Disjoint a (â¨† i, f i) â†” âˆ€ i, Disjoint a (f i)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : Î¹ â†’ Î±}"},
 {"type": "Disjoint (â¨† (i) (j), f i j) a â†” âˆ€ i j, Disjoint (f i j) a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±} : Disjoint (â¨† (i) (j), f i j) a â†” âˆ€ i j, Disjoint (f i j) a := by simp_rw [supáµ¢_disjoint_iff]; sorry",
  "name": "supáµ¢â‚‚_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [supáµ¢_disjoint_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±} : Disjoint (â¨† (i) (j), f i j) a â†” âˆ€ i j, Disjoint (f i j) a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "Disjoint a (â¨† (i) (j), f i j) â†” âˆ€ i j, Disjoint a (f i j)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±} : Disjoint a (â¨† (i) (j), f i j) â†” âˆ€ i j, Disjoint a (f i j) := by simp_rw [disjoint_supáµ¢_iff]; sorry",
  "name": "disjoint_supáµ¢â‚‚_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_supáµ¢_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±} : Disjoint a (â¨† (i) (j), f i j) â†” âˆ€ i j, Disjoint a (f i j)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "Disjoint (supâ‚› s) a â†” âˆ€ b âˆˆ s, Disjoint b a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±} : Disjoint (supâ‚› s) a â†” âˆ€ b âˆˆ s, Disjoint b a := by simp only [disjoint_iff]; sorry",
  "name": "supâ‚›_disjoint_iff",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±} : Disjoint (supâ‚› s) a â†” âˆ€ b âˆˆ s, Disjoint b a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±}"},
 {"type": "Disjoint a (supâ‚› s) â†” âˆ€ b âˆˆ s, Disjoint a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±} : Disjoint a (supâ‚› s) â†” âˆ€ b âˆˆ s, Disjoint a b := by simpa only [Disjoint.comm] using @supâ‚›_disjoint_iff; sorry",
  "name": "disjoint_supâ‚›_iff",
  "kind": "theorem",
  "first-tactic": "simpa only [Disjoint.comm] using @supâ‚›_disjoint_iff",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±} : Disjoint a (supâ‚› s) â†” âˆ€ b âˆˆ s, Disjoint a b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {s : Set Î±}"},
 {"type": "(â¨† i, f i âŠ“ g i) = (â¨† i, f i) âŠ“ â¨† i, g i",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ : Type _}  [Preorder Î¹]  [IsDirected Î¹ (Â· â‰¤ Â·)]  {f g : Î¹ â†’ Î±}      (hf : Monotone f)  (hg : Monotone g) : (â¨† i, f i âŠ“ g i) = (â¨† i, f i) âŠ“ â¨† i, g i := by refine' (le_supáµ¢_inf_supáµ¢ f g).antisymm _; sorry",
  "name": "supáµ¢_inf_of_monotone",
  "kind": "theorem",
  "first-tactic": "refine' (le_supáµ¢_inf_supáµ¢ f g).antisymm _",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ : Type _}  [Preorder Î¹]  [IsDirected Î¹ (Â· â‰¤ Â·)]  {f g : Î¹ â†’ Î±}      (hf : Monotone f)  (hg : Monotone g) : (â¨† i, f i âŠ“ g i) = (â¨† i, f i) âŠ“ â¨† i, g i",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [Frame Î±]  {s t : Set Î±}  {a b : Î±} {Î¹ : Type _}  [Preorder Î¹]  [IsDirected Î¹ (Â· â‰¤ Â·)]  {f g : Î¹ â†’ Î±}      (hf : Monotone f)  (hg : Monotone g)"},
 {"type": "infâ‚› sá¶œ = â¨† i âˆˆ s, iá¶œ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±} : infâ‚› sá¶œ = â¨† i âˆˆ s, iá¶œ := by simp only [infâ‚›_eq_infáµ¢]; sorry",
  "name": "compl_infâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [infâ‚›_eq_infáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±} : infâ‚› sá¶œ = â¨† i âˆˆ s, iá¶œ",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±}"},
 {"type": "supâ‚› sá¶œ = â¨… i âˆˆ s, iá¶œ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±} : supâ‚› sá¶œ = â¨… i âˆˆ s, iá¶œ := by simp only [supâ‚›_eq_supáµ¢]; sorry",
  "name": "compl_supâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±} : supâ‚› sá¶œ = â¨… i âˆˆ s, iá¶œ",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  [CompleteBooleanAlgebra Î±]  {a b : Î±}  {s : Set Î±}  {f : Î¹ â†’ Î±}"},
 {"type": "CompleteBooleanAlgebra PUnit",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand : CompleteBooleanAlgebra PUnit := by refine'\n    { PUnit.booleanAlgebra with\n      supâ‚› := fun _ => unit\n      infâ‚› := fun _ => unit\n      .. }; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic":
  "refine'\n    { PUnit.booleanAlgebra with\n      supâ‚› := fun _ => unit\n      infâ‚› := fun _ => unit\n      .. }",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand : CompleteBooleanAlgebra PUnit",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î¹ : Sort w}  {Îº : Î¹ â†’ Sort _}  (s : Set PUnit.{u + 1})  (x y : PUnit.{u + 1})  -- Porting note: we don't have `refine_struct` ported yet, so we do it by hand"},
 {"type": "Inhabited (Antisymmetrization Î± r)",
  "tactic-prompt":
  "instance {Î± Î² : Type _}  [Inhabited Î±] : Inhabited (Antisymmetrization Î± r) := by unfold Antisymmetrization; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "unfold Antisymmetrization",
  "core-prompt":
  "{Î± Î² : Type _}  [Inhabited Î±] : Inhabited (Antisymmetrization Î± r)",
  "args": "{Î± Î² : Type _}  [Inhabited Î±]"},
 {"type":
  "Relation.Fibration (Â· < Â·) (Â· < Â·) (@toAntisymmetrization Î± (Â· â‰¤ Â·) _)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} : Relation.Fibration (Â· < Â·) (Â· < Â·) (@toAntisymmetrization Î± (Â· â‰¤ Â·) _) := by rintro a âŸ¨bâŸ© h; sorry",
  "name": "antisymmetrization_fibration",
  "kind": "theorem",
  "first-tactic": "rintro a âŸ¨bâŸ© h",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} : Relation.Fibration (Â· < Â·) (Â· < Â·) (@toAntisymmetrization Î± (Â· â‰¤ Â·) _)",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±}"},
 {"type":
  "ofAntisymmetrization (Â· â‰¤ Â·) a â‰¤ ofAntisymmetrization (Â· â‰¤ Â·) b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)} : ofAntisymmetrization (Â· â‰¤ Â·) a â‰¤ ofAntisymmetrization (Â· â‰¤ Â·) b â†” a â‰¤ b := by rw [â† toAntisymmetrization_le_toAntisymmetrization_iff]; sorry",
  "name": "ofAntisymmetrization_le_ofAntisymmetrization_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† toAntisymmetrization_le_toAntisymmetrization_iff]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)} : ofAntisymmetrization (Â· â‰¤ Â·) a â‰¤ ofAntisymmetrization (Â· â‰¤ Â·) b â†” a â‰¤ b",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)}"},
 {"type":
  "ofAntisymmetrization (Â· â‰¤ Â·) a < ofAntisymmetrization (Â· â‰¤ Â·) b â†” a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)} : ofAntisymmetrization (Â· â‰¤ Â·) a < ofAntisymmetrization (Â· â‰¤ Â·) b â†” a < b := by rw [â† toAntisymmetrization_lt_toAntisymmetrization_iff]; sorry",
  "name": "ofAntisymmetrization_lt_ofAntisymmetrization_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† toAntisymmetrization_lt_toAntisymmetrization_iff]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)} : ofAntisymmetrization (Â· â‰¤ Â·) a < ofAntisymmetrization (Â· â‰¤ Â·) b â†” a < b",
  "args":
  "{Î± Î² : Type _}  [Preorder Î±]  [Preorder Î²]  {a b : Î±} {a b : Antisymmetrization Î± (Â· â‰¤ Â·)}"},
 {"type": "Unbounded (Â· â‰¤ Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a < b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±] : Unbounded (Â· â‰¤ Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a < b := by simp only [Unbounded]; sorry",
  "name": "unbounded_le_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Unbounded]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±] : Unbounded (Â· â‰¤ Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a < b",
  "args": "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]"},
 {"type": "Unbounded (Â· < Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a â‰¤ b",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±] : Unbounded (Â· < Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a â‰¤ b := by simp only [Unbounded]; sorry",
  "name": "unbounded_lt_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Unbounded]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±] : Unbounded (Â· < Â·) s â†” âˆ€ a, âˆƒ b âˆˆ s, a â‰¤ b",
  "args": "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]"},
 {"type": "Bounded (Â· â‰¤ Â·) s â†” Bounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±] : Bounded (Â· â‰¤ Â·) s â†” Bounded (Â· < Â·) s := by refine' âŸ¨fun h => _, bounded_le_of_bounded_ltâŸ©; sorry",
  "name": "bounded_le_iff_bounded_lt",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, bounded_le_of_bounded_ltâŸ©",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±] : Bounded (Â· â‰¤ Â·) s â†” Bounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±]"},
 {"type": "Unbounded (Â· < Â·) s â†” Unbounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±] : Unbounded (Â· < Â·) s â†” Unbounded (Â· â‰¤ Â·) s := by simp_rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_lt_iff_unbounded_le",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±] : Unbounded (Â· < Â·) s â†” Unbounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±]"},
 {"type": "Bounded (Â· < Â·) (Iic a)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (Iic a) := by simp only [â† bounded_le_iff_bounded_lt]; sorry",
  "name": "bounded_lt_Iic",
  "kind": "theorem",
  "first-tactic": "simp only [â† bounded_le_iff_bounded_lt]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (Iic a)",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMaxOrder Î±]  (a : Î±)"},
 {"type": "Bounded (Â· > Â·) (Ici a)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMinOrder Î±]  (a : Î±) : Bounded (Â· > Â·) (Ici a) := by simp only [â† bounded_ge_iff_bounded_gt]; sorry",
  "name": "bounded_gt_Ici",
  "kind": "theorem",
  "first-tactic": "simp only [â† bounded_ge_iff_bounded_gt]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMinOrder Î±]  (a : Î±) : Bounded (Â· > Â·) (Ici a)",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [Preorder Î±]  [NoMinOrder Î±]  (a : Î±)"},
 {"type": "Bounded r (s âˆ© { b | Â¬r b a }) â†” Bounded r s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±) : Bounded r (s âˆ© { b | Â¬r b a }) â†” Bounded r s := by refine' âŸ¨_, Bounded.mono (Set.inter_subset_left s _)âŸ©; sorry",
  "name": "bounded_inter_not",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, Bounded.mono (Set.inter_subset_left s _)âŸ©",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±) : Bounded r (s âˆ© { b | Â¬r b a }) â†” Bounded r s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±)"},
 {"type": "Unbounded r (s âˆ© { b | Â¬r b a }) â†” Unbounded r s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±) : Unbounded r (s âˆ© { b | Â¬r b a }) â†” Unbounded r s := by simp_rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_inter_not",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±) : Unbounded r (s âˆ© { b | Â¬r b a }) â†” Unbounded r s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} (H : âˆ€ a b, âˆƒ m, âˆ€ c, r c a âˆ¨ r c b â†’ r c m)  (a : Î±)"},
 {"type": "Unbounded (Â· â‰¤ Â·) (s âˆ© { b | Â¬b â‰¤ a }) â†” Unbounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | Â¬b â‰¤ a }) â†” Unbounded (Â· â‰¤ Â·) s := by rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_le_inter_not_le",
  "kind": "theorem",
  "first-tactic": "rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | Â¬b â‰¤ a }) â†” Unbounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±)"},
 {"type": "Bounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· â‰¤ Â·) s := by simp_rw [â† not_le]; sorry",
  "name": "bounded_le_inter_lt",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† not_le]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· â‰¤ Â·) s := by convert @unbounded_le_inter_not_le _ s _ a; sorry",
  "name": "unbounded_le_inter_lt",
  "kind": "theorem",
  "first-tactic": "convert @unbounded_le_inter_not_le _ s _ a",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Bounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· â‰¤ Â·) s := by refine' âŸ¨_, Bounded.mono (Set.inter_subset_left s _)âŸ©; sorry",
  "name": "bounded_le_inter_le",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨_, Bounded.mono (Set.inter_subset_left s _)âŸ©",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· â‰¤ Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· â‰¤ Â·) s := by rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_le_inter_le",
  "kind": "theorem",
  "first-tactic": "rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· â‰¤ Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· â‰¤ Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Unbounded (Â· < Â·) (s âˆ© { b | Â¬b < a }) â†” Unbounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | Â¬b < a }) â†” Unbounded (Â· < Â·) s := by rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_lt_inter_not_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | Â¬b < a }) â†” Unbounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [SemilatticeSup Î±]  (a : Î±)"},
 {"type": "Bounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· < Â·) s := by convert @bounded_lt_inter_not_lt _ s _ a; sorry",
  "name": "bounded_lt_inter_le",
  "kind": "theorem",
  "first-tactic": "convert @bounded_lt_inter_not_lt _ s _ a",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Bounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Unbounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· < Â·) s := by convert @unbounded_lt_inter_not_lt _ s _ a; sorry",
  "name": "unbounded_lt_inter_le",
  "kind": "theorem",
  "first-tactic": "convert @unbounded_lt_inter_not_lt _ s _ a",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | a â‰¤ b }) â†” Unbounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  (a : Î±)"},
 {"type": "Bounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· < Â·) s := by rw [â† bounded_le_iff_bounded_lt]; sorry",
  "name": "bounded_lt_inter_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† bounded_le_iff_bounded_lt]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±) : Bounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Bounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±)"},
 {"type": "Unbounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· < Â·) s",
  "tactic-prompt":
  "theorem {Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· < Â·) s := by rw [â† not_bounded_iff]; sorry",
  "name": "unbounded_lt_inter_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† not_bounded_iff]",
  "core-prompt":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±) : Unbounded (Â· < Â·) (s âˆ© { b | a < b }) â†” Unbounded (Â· < Â·) s",
  "args":
  "{Î± : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s t : Set Î±} [LinearOrder Î±]  [NoMaxOrder Î±]  (a : Î±)"},
 {"type": "Disjoint (a âŠ“ b) c â†” Disjoint a (b âŠ“ c)",
  "tactic-prompt":
  "theorem {Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint (a âŠ“ b) c â†” Disjoint a (b âŠ“ c) := by rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_assoc",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint (a âŠ“ b) c â†” Disjoint a (b âŠ“ c)",
  "args": "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±}"},
 {"type": "Disjoint a (b âŠ“ c) â†” Disjoint b (a âŠ“ c)",
  "tactic-prompt":
  "theorem {Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint a (b âŠ“ c) â†” Disjoint b (a âŠ“ c) := by simp_rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint a (b âŠ“ c) â†” Disjoint b (a âŠ“ c)",
  "args": "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±}"},
 {"type": "Disjoint (a âŠ“ b) c â†” Disjoint (a âŠ“ c) b",
  "tactic-prompt":
  "theorem {Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint (a âŠ“ b) c â†” Disjoint (a âŠ“ c) b := by simp_rw [disjoint_iff_inf_le]; sorry",
  "name": "disjoint_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [disjoint_iff_inf_le]",
  "core-prompt":
  "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±} : Disjoint (a âŠ“ b) c â†” Disjoint (a âŠ“ c) b",
  "args": "{Î± : Type _}   [SemilatticeInf Î±]  [OrderBot Î±]  {a b c d : Î±}"},
 {"type": "Disjoint (a âŠ” b) c â†” Disjoint a c âˆ§ Disjoint b c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±} : Disjoint (a âŠ” b) c â†” Disjoint a c âˆ§ Disjoint b c := by simp only [disjoint_iff]; sorry",
  "name": "disjoint_sup_left",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±} : Disjoint (a âŠ” b) c â†” Disjoint a c âˆ§ Disjoint b c",
  "args": "{Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±}"},
 {"type": "Disjoint a (b âŠ” c) â†” Disjoint a b âˆ§ Disjoint a c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±} : Disjoint a (b âŠ” c) â†” Disjoint a b âˆ§ Disjoint a c := by simp only [disjoint_iff]; sorry",
  "name": "disjoint_sup_right",
  "kind": "theorem",
  "first-tactic": "simp only [disjoint_iff]",
  "core-prompt":
  "{Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±} : Disjoint a (b âŠ” c) â†” Disjoint a b âˆ§ Disjoint a c",
  "args": "{Î± : Type _}   [DistribLattice Î±]  [OrderBot Î±]  {a b c : Î±}"},
 {"type": "Codisjoint (a âŠ“ b) c â†” Codisjoint a c âˆ§ Codisjoint b c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±} : Codisjoint (a âŠ“ b) c â†” Codisjoint a c âˆ§ Codisjoint b c := by simp only [codisjoint_iff]; sorry",
  "name": "codisjoint_inf_left",
  "kind": "theorem",
  "first-tactic": "simp only [codisjoint_iff]",
  "core-prompt":
  "{Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±} : Codisjoint (a âŠ“ b) c â†” Codisjoint a c âˆ§ Codisjoint b c",
  "args": "{Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±}"},
 {"type": "Codisjoint a (b âŠ“ c) â†” Codisjoint a b âˆ§ Codisjoint a c",
  "tactic-prompt":
  "theorem {Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±} : Codisjoint a (b âŠ“ c) â†” Codisjoint a b âˆ§ Codisjoint a c := by simp only [codisjoint_iff]; sorry",
  "name": "codisjoint_inf_right",
  "kind": "theorem",
  "first-tactic": "simp only [codisjoint_iff]",
  "core-prompt":
  "{Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±} : Codisjoint a (b âŠ“ c) â†” Codisjoint a b âˆ§ Codisjoint a c",
  "args": "{Î± : Type _}   [DistribLattice Î±]  [OrderTop Î±]  {a b c : Î±}"},
 {"type": "a â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b c : Î±} (hab : Disjoint a b)  (hbc : Codisjoint b c) : a â‰¤ c := by rw [â† @inf_top_eq _ _ _ a]; sorry",
  "name": "Disjoint.le_of_codisjoint",
  "kind": "theorem",
  "first-tactic": "rw [â† @inf_top_eq _ _ _ a]",
  "core-prompt":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b c : Î±} (hab : Disjoint a b)  (hbc : Codisjoint b c) : a â‰¤ c",
  "args":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b c : Î±} (hab : Disjoint a b)  (hbc : Codisjoint b c)"},
 {"type": "x âŠ“ y = âŠ¥ â†” x â‰¤ z",
  "tactic-prompt":
  "theorem {Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z) : x âŠ“ y = âŠ¥ â†” x â‰¤ z := by rw [â† le_bot_iff]; sorry",
  "name": "inf_left_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† le_bot_iff]",
  "core-prompt":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z) : x âŠ“ y = âŠ¥ â†” x â‰¤ z",
  "args":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z)"},
 {"type": "Disjoint x y â†” x â‰¤ z",
  "tactic-prompt":
  "theorem {Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z) : Disjoint x y â†” x â‰¤ z := by rw [disjoint_iff]; sorry",
  "name": "disjoint_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_iff]",
  "core-prompt":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z) : Disjoint x y â†” x â‰¤ z",
  "args":
  "{Î± : Type _}  [DistribLattice Î±]  [BoundedOrder Î±]  {a b x y z : Î±} (h : IsCompl y z)"},
 {"type": "Disjoint x y â†” Disjoint x.1 y.1 âˆ§ Disjoint x.2 y.2",
  "tactic-prompt":
  "theorem {Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [OrderBot Î±]  [OrderBot Î²]  {x y : Î± Ã— Î²} : Disjoint x y â†” Disjoint x.1 y.1 âˆ§ Disjoint x.2 y.2 := by constructor; sorry",
  "name": "disjoint_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [OrderBot Î±]  [OrderBot Î²]  {x y : Î± Ã— Î²} : Disjoint x y â†” Disjoint x.1 y.1 âˆ§ Disjoint x.2 y.2",
  "args":
  "{Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [OrderBot Î±]  [OrderBot Î²]  {x y : Î± Ã— Î²}"},
 {"type": "IsCompl x y â†” IsCompl x.1 y.1 âˆ§ IsCompl x.2 y.2",
  "tactic-prompt":
  "theorem {Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [BoundedOrder Î±]  [BoundedOrder Î²]  {x y : Î± Ã— Î²} : IsCompl x y â†” IsCompl x.1 y.1 âˆ§ IsCompl x.2 y.2 := by simp_rw [isCompl_iff]; sorry",
  "name": "isCompl_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [isCompl_iff]",
  "core-prompt":
  "{Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [BoundedOrder Î±]  [BoundedOrder Î²]  {x y : Î± Ã— Î²} : IsCompl x y â†” IsCompl x.1 y.1 âˆ§ IsCompl x.2 y.2",
  "args":
  "{Î± : Type _} {Î² : Type _}  [PartialOrder Î±]  [PartialOrder Î²] [BoundedOrder Î±]  [BoundedOrder Î²]  {x y : Î± Ã— Î²}"},
 {"type": "LinearOrder Prop",
  "tactic-prompt":
  "instance  : LinearOrder Prop := by classical\n  exact Lattice.toLinearOrder Prop; sorry",
  "name": "Prop.linearOrder",
  "kind": "instance",
  "first-tactic": "classical\n  exact Lattice.toLinearOrder Prop",
  "core-prompt": " : LinearOrder Prop",
  "args": ""},
 {"type": "Disjoint f g â†” âˆ€ i, Disjoint (f i) (g i)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, OrderBot (Î±' i)]  {f g : âˆ€ i, Î±' i} : Disjoint f g â†” âˆ€ i, Disjoint (f i) (g i) := by classical\n  constructor\n  Â· intro h i x hf hg\n    refine' (update_le_iff.mp <| h (update_le_iff.mpr âŸ¨hf, fun _ _ => _âŸ©)\n      (update_le_iff.mpr âŸ¨hg, fun _ _ => _âŸ©)).1\n    Â· exact bot_le\n    Â· exact bot_le\n  Â· intro h x hf hg i\n    apply h i (hf i) (hg i); sorry",
  "name": "disjoint_iff",
  "kind": "theorem",
  "first-tactic":
  "classical\n  constructor\n  Â· intro h i x hf hg\n    refine' (update_le_iff.mp <| h (update_le_iff.mpr âŸ¨hf, fun _ _ => _âŸ©)\n      (update_le_iff.mpr âŸ¨hg, fun _ _ => _âŸ©)).1\n    Â· exact bot_le\n    Â· exact bot_le\n  Â· intro h x hf hg i\n    apply h i (hf i) (hg i)",
  "core-prompt":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, OrderBot (Î±' i)]  {f g : âˆ€ i, Î±' i} : Disjoint f g â†” âˆ€ i, Disjoint (f i) (g i)",
  "args":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, OrderBot (Î±' i)]  {f g : âˆ€ i, Î±' i}"},
 {"type": "IsCompl f g â†” âˆ€ i, IsCompl (f i) (g i)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, BoundedOrder (Î±' i)]  {f g : âˆ€ i, Î±' i} : IsCompl f g â†” âˆ€ i, IsCompl (f i) (g i) := by simp_rw [_root_.isCompl_iff]; sorry",
  "name": "isCompl_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [_root_.isCompl_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, BoundedOrder (Î±' i)]  {f g : âˆ€ i, Î±' i} : IsCompl f g â†” âˆ€ i, IsCompl (f i) (g i)",
  "args":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] [âˆ€ i, BoundedOrder (Î±' i)]  {f g : âˆ€ i, Î±' i}"},
 {"type": "IsCompl P Q â†” Â¬(P â†” Q)",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] {P Q : Prop} : IsCompl P Q â†” Â¬(P â†” Q) := by rw [_root_.isCompl_iff]; sorry",
  "name": "Prop.isCompl_iff",
  "kind": "theorem",
  "first-tactic": "rw [_root_.isCompl_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] {P Q : Prop} : IsCompl P Q â†” Â¬(P â†” Q)",
  "args":
  "{Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  [âˆ€ i, PartialOrder (Î±' i)] {P Q : Prop}"},
 {"type": "min a b = if b â‰¤ a then b else a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±) : min a b = if b â‰¤ a then b else a := by rw [min_def]; sorry",
  "name": "min_def'",
  "kind": "theorem",
  "first-tactic": "rw [min_def]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±) : min a b = if b â‰¤ a then b else a",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±)"},
 {"type": "max a b = if b â‰¤ a then a else b",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±) : max a b = if b â‰¤ a then a else b := by rw [max_def]; sorry",
  "name": "max_def'",
  "kind": "theorem",
  "first-tactic": "rw [max_def]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±) : max a b = if b â‰¤ a then a else b",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [LinearOrder Î±]  (a b : Î±)"},
 {"type": "x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i} : x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i := by simp (config := { contextual := true }) [lt_iff_le_not_le]; sorry",
  "name": "Pi.lt_def",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [lt_iff_le_not_le]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i} : x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i}"},
 {"type":
  "Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ (j) (_ : j â‰  i), x j â‰¤ y j",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ (j) (_ : j â‰  i), x j â‰¤ y j := by simp (config := { contextual := true }) [update_le_iff]; sorry",
  "name": "update_le_update_iff",
  "kind": "theorem",
  "first-tactic": "simp (config := { contextual := true }) [update_le_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ (j) (_ : j â‰  i), x j â‰¤ y j",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i}"},
 {"type": "x â‰¤ update x i a â†” x i â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : x â‰¤ update x i a â†” x i â‰¤ a := by simp [le_update_iff]; sorry",
  "name": "le_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [le_update_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : x â‰¤ update x i a â†” x i â‰¤ a",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i}"},
 {"type": "update x i a â‰¤ x â†” a â‰¤ x i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : update x i a â‰¤ x â†” a â‰¤ x i := by simp [update_le_iff]; sorry",
  "name": "update_le_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [update_le_iff]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : update x i a â‰¤ x â†” a â‰¤ x i",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i}"},
 {"type": "x < update x i a â†” x i < a",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : x < update x i a â†” x i < a := by simp [lt_iff_le_not_le]; sorry",
  "name": "lt_update_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : x < update x i a â†” x i < a",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i}"},
 {"type": "update x i a < x â†” a < x i",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : update x i a < x â†” a < x i := by simp [lt_iff_le_not_le]; sorry",
  "name": "update_lt_self_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i} : update x i a < x â†” a < x i",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [DecidableEq Î¹]  [âˆ€ i, Preorder (Ï€ i)]  {x y : âˆ€ i, Ï€ i}  {i : Î¹}  {a b : Ï€ i}"},
 {"type": "const Î² a â‰¤ const Î² b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±} : const Î² a â‰¤ const Î² b â†” a â‰¤ b := by simp [Pi.le_def]; sorry",
  "name": "const_le_const",
  "kind": "theorem",
  "first-tactic": "simp [Pi.le_def]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±} : const Î² a â‰¤ const Î² b â†” a â‰¤ b",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}"},
 {"type": "const Î² a < const Î² b â†” a < b",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±} : const Î² a < const Î² b â†” a < b := by simpa [Pi.lt_def] using le_of_lt; sorry",
  "name": "const_lt_const",
  "kind": "theorem",
  "first-tactic": "simpa [Pi.lt_def] using le_of_lt",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±} : const Î² a < const Î² b â†” a < b",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}"},
 {"type": "min x y = if x < y then x else y",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±) : min x y = if x < y then x else y := by rw [min_comm]; sorry",
  "name": "min_def_lt",
  "kind": "theorem",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±) : min x y = if x < y then x else y",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±)"},
 {"type": "max x y = if x < y then y else x",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±) : max x y = if x < y then y else x := by rw [max_comm]; sorry",
  "name": "max_def_lt",
  "kind": "theorem",
  "first-tactic": "rw [max_comm]",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±) : max x y = if x < y then y else x",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [LinearOrder Î±]  {p : Î± â†’ Prop}  {x y : Î±} (x y : Î±)"},
 {"type": "x < y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2",
  "tactic-prompt":
  "theorem {Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²} : x < y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2 := by refine' âŸ¨fun h â†¦ _, _âŸ©; sorry",
  "name": "lt_iff",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h â†¦ _, _âŸ©",
  "core-prompt":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²} : x < y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2",
  "args":
  "{Î¹ : Type _}  {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Ï€ : Î¹ â†’ Type _}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} [Preorder Î±]  [Nonempty Î²]  {a b : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²}"},
 {"type": "o.swap.Compares a b â†” o.Compares b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering} : o.swap.Compares a b â†” o.Compares b a := by cases o; sorry",
  "name": "compares_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering} : o.swap.Compares a b â†” o.Compares b a",
  "args": "{Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering}"},
 {"type": "o.swap = o' â†” o = o'.swap",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} {o o' : Ordering} : o.swap = o' â†” o = o'.swap := by rw [â† swap_inj]; sorry",
  "name": "swap_eq_iff_eq_swap",
  "kind": "theorem",
  "first-tactic": "rw [â† swap_inj]",
  "core-prompt": "{Î± Î² : Type _} {o o' : Ordering} : o.swap = o' â†” o = o'.swap",
  "args": "{Î± Î² : Type _} {o o' : Ordering}"},
 {"type": "Compares o (toDual a) (toDual b) â†” Compares o b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering} : Compares o (toDual a) (toDual b) â†” Compares o b a := by cases o; sorry",
  "name": "toDual_compares_toDual",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering} : Compares o (toDual a) (toDual b) â†” Compares o b a",
  "args": "{Î± Î² : Type _} [LT Î±]  {a b : Î±}  {o : Ordering}"},
 {"type": "Compares o (ofDual a) (ofDual b) â†” Compares o b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LT Î±]  {a b : Î±áµ’áµˆ}  {o : Ordering} : Compares o (ofDual a) (ofDual b) â†” Compares o b a := by cases o; sorry",
  "name": "ofDual_compares_ofDual",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± Î² : Type _} [LT Î±]  {a b : Î±áµ’áµˆ}  {o : Ordering} : Compares o (ofDual a) (ofDual b) â†” Compares o b a",
  "args": "{Î± Î² : Type _} [LT Î±]  {a b : Î±áµ’áµˆ}  {o : Ordering}"},
 {"type": "(cmp a b).Compares a b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  (a b : Î±) : (cmp a b).Compares a b := by obtain h | h | h := lt_trichotomy a b; sorry",
  "name": "cmp_compares",
  "kind": "theorem",
  "first-tactic": "obtain h | h | h := lt_trichotomy a b",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  (a b : Î±) : (cmp a b).Compares a b",
  "args": "{Î± Î² : Type _} [LinearOrder Î±]  (a b : Î±)"},
 {"type": "(cmp a b).swap = cmp b a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [Preorder Î±]  [@DecidableRel Î± (Â· < Â·)]  (a b : Î±) : (cmp a b).swap = cmp b a := by unfold cmp cmpUsing; sorry",
  "name": "cmp_swap",
  "kind": "theorem",
  "first-tactic": "unfold cmp cmpUsing",
  "core-prompt":
  "{Î± Î² : Type _} [Preorder Î±]  [@DecidableRel Î± (Â· < Â·)]  (a b : Î±) : (cmp a b).swap = cmp b a",
  "args": "{Î± Î² : Type _} [Preorder Î±]  [@DecidableRel Î± (Â· < Â·)]  (a b : Î±)"},
 {"type": "cmp x x = Ordering.eq",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) : cmp x x = Ordering.eq := by rw [cmp_eq_eq_iff]; sorry",
  "name": "cmp_self_eq_eq",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_eq_iff]",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) : cmp x x = Ordering.eq",
  "args": "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±)"},
 {"type": "x < y â†” x' < y'",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x < y â†” x' < y' := by rw [â† cmp_eq_lt_iff]; sorry",
  "name": "lt_iff_lt_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [â† cmp_eq_lt_iff]",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x < y â†” x' < y'",
  "args":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y')"},
 {"type": "x â‰¤ y â†” x' â‰¤ y'",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x â‰¤ y â†” x' â‰¤ y' := by rw [â† not_lt]; sorry",
  "name": "le_iff_le_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [â† not_lt]",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x â‰¤ y â†” x' â‰¤ y'",
  "args":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y')"},
 {"type": "x = y â†” x' = y'",
  "tactic-prompt":
  "theorem {Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x = y â†” x' = y' := by rw [le_antisymm_iff]; sorry",
  "name": "eq_iff_eq_of_cmp_eq_cmp",
  "kind": "theorem",
  "first-tactic": "rw [le_antisymm_iff]",
  "core-prompt":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y') : x = y â†” x' = y'",
  "args":
  "{Î± Î² : Type _} [LinearOrder Î±]  (x y : Î±) (h : cmp x y = cmp x' y')"},
 {"type": "x \\ y âŠ” x âŠ“ y = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±) : x \\ y âŠ” x âŠ“ y = x := by rw [sup_comm]; sorry",
  "name": "sup_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±) : x \\ y âŠ” x âŠ“ y = x",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±)"},
 {"type": "x \\ y âŠ“ (x âŠ“ y) = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±) : x \\ y âŠ“ (x âŠ“ y) = âŠ¥ := by rw [inf_comm]; sorry",
  "name": "inf_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±) : x \\ y âŠ“ (x âŠ“ y) = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (x y : Î±)"},
 {"type": "x \\ y = z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (s : x âŠ“ y âŠ” z = x)  (i : x âŠ“ y âŠ“ z = âŠ¥) : x \\ y = z := by conv_rhs at s => rw [â† sup_inf_sdiff x y]; sorry",
  "name": "sdiff_unique",
  "kind": "theorem",
  "first-tactic": "conv_rhs at s => rw [â† sup_inf_sdiff x y]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (s : x âŠ“ y âŠ” z = x)  (i : x âŠ“ y âŠ“ z = âŠ¥) : x \\ y = z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (s : x âŠ“ y âŠ” z = x)  (i : x âŠ“ y âŠ“ z = âŠ¥)"},
 {"type": "y \\ x âŠ“ x = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : y \\ x âŠ“ x = âŠ¥ := by rw [inf_comm]; sorry",
  "name": "inf_sdiff_self_left",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : y \\ x âŠ“ x = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "z âŠ“ y \\ x = âŠ¥ â†” z â‰¤ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hz : z â‰¤ y)  (hx : x â‰¤ y) : z âŠ“ y \\ x = âŠ¥ â†” z â‰¤ x := by rw [â† disjoint_iff]; sorry",
  "name": "inf_sdiff_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† disjoint_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hz : z â‰¤ y)  (hx : x â‰¤ y) : z âŠ“ y \\ x = âŠ¥ â†” z â‰¤ x",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hz : z â‰¤ y)  (hx : x â‰¤ y)"},
 {"type": "x \\ y = x â†” Disjoint x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ y = x â†” Disjoint x y := by rw [sdiff_eq_self_iff_disjoint]; sorry",
  "name": "sdiff_eq_self_iff_disjoint'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq_self_iff_disjoint]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ y = x â†” Disjoint x y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "x \\ y < x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hx : y â‰¤ x)  (hy : y â‰  âŠ¥) : x \\ y < x := by refine' sdiff_le.lt_of_ne fun h => hy _; sorry",
  "name": "sdiff_lt",
  "kind": "theorem",
  "first-tactic": "refine' sdiff_le.lt_of_ne fun h => hy _",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hx : y â‰¤ x)  (hy : y â‰  âŠ¥) : x \\ y < x",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hx : y â‰¤ x)  (hy : y â‰  âŠ¥)"},
 {"type": "x \\ (y \\ z) = x \\ y âŠ” x âŠ“ y âŠ“ z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ (y \\ z) = x \\ y âŠ” x âŠ“ y âŠ“ z := by rw [sup_comm]; sorry",
  "name": "sdiff_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ (y \\ z) = x \\ y âŠ” x âŠ“ y âŠ“ z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "x \\ (y \\ z) = x \\ y âŠ” z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : z â‰¤ x) : x \\ (y \\ z) = x \\ y âŠ” z := by rw [sdiff_sdiff_right']; sorry",
  "name": "sdiff_sdiff_eq_sdiff_sup",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : z â‰¤ x) : x \\ (y \\ z) = x \\ y âŠ” z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : z â‰¤ x)"},
 {"type": "x \\ (x \\ y) = x âŠ“ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ (x \\ y) = x âŠ“ y := by rw [sdiff_sdiff_right]; sorry",
  "name": "sdiff_sdiff_right_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ (x \\ y) = x âŠ“ y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "x \\ (x \\ y) = y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y â‰¤ x) : x \\ (x \\ y) = y := by rw [sdiff_sdiff_right_self]; sorry",
  "name": "sdiff_sdiff_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_right_self]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y â‰¤ x) : x \\ (x \\ y) = y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y â‰¤ x)"},
 {"type": "x \\ z = y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hy : y â‰¤ x)  (h : x \\ y = z) : x \\ z = y := by rw [â† h]; sorry",
  "name": "sdiff_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [â† h]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hy : y â‰¤ x)  (h : x \\ y = z) : x \\ z = y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hy : y â‰¤ x)  (h : x \\ y = z)"},
 {"type": "x = y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hxz : x â‰¤ z)  (hyz : y â‰¤ z)  (h : z \\ x = z \\ y) : x = y := by rw [â† sdiff_sdiff_eq_self hxz]; sorry",
  "name": "eq_of_sdiff_eq_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [â† sdiff_sdiff_eq_self hxz]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hxz : x â‰¤ z)  (hyz : y â‰¤ z)  (h : z \\ x = z \\ y) : x = y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (hxz : x â‰¤ z)  (hyz : y â‰¤ z)  (h : z \\ x = z \\ y)"},
 {"type": "(x \\ y) \\ z = x \\ y âŠ“ x \\ z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : (x \\ y) \\ z = x \\ y âŠ“ x \\ z := by rw [sdiff_sdiff_left]; sorry",
  "name": "sdiff_sdiff_left'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_left]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : (x \\ y) \\ z = x \\ y âŠ“ x \\ z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "x \\ z âŠ“ y = (x âŠ“ y) \\ z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ z âŠ“ y = (x âŠ“ y) \\ z := by rw [@inf_comm _ _ x]; sorry",
  "name": "inf_sdiff_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [@inf_comm _ _ x]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] : x \\ z âŠ“ y = (x âŠ“ y) \\ z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±]"},
 {"type": "a âŠ“ b \\ c = (a âŠ“ b) \\ (a âŠ“ c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±) : a âŠ“ b \\ c = (a âŠ“ b) \\ (a âŠ“ c) := by rw [sdiff_inf]; sorry",
  "name": "inf_sdiff_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±) : a âŠ“ b \\ c = (a âŠ“ b) \\ (a âŠ“ c)",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±)"},
 {"type": "a \\ b âŠ“ c = (a âŠ“ c) \\ (b âŠ“ c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±) : a \\ b âŠ“ c = (a âŠ“ c) \\ (b âŠ“ c) := by simp_rw [@inf_comm _ _ _ c]; sorry",
  "name": "inf_sdiff_distrib_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [@inf_comm _ _ _ c]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±) : a \\ b âŠ“ c = (a âŠ“ c) \\ (b âŠ“ c)",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (a b c : Î±)"},
 {"type": "x âŠ” y < z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y < z \\ x)  (hxz : x â‰¤ z) : x âŠ” y < z := by rw [â† sup_sdiff_cancel_right hxz]; sorry",
  "name": "sup_lt_of_lt_sdiff_left",
  "kind": "theorem",
  "first-tactic": "rw [â† sup_sdiff_cancel_right hxz]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y < z \\ x)  (hxz : x â‰¤ z) : x âŠ” y < z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : y < z \\ x)  (hxz : x â‰¤ z)"},
 {"type": "x âŠ” y < z",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : x < z \\ y)  (hyz : y â‰¤ z) : x âŠ” y < z := by rw [â† sdiff_sup_cancel hyz]; sorry",
  "name": "sup_lt_of_lt_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [â† sdiff_sup_cancel hyz]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : x < z \\ y)  (hyz : y â‰¤ z) : x âŠ” y < z",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [GeneralizedBooleanAlgebra Î±] (h : x < z \\ y)  (hyz : y â‰¤ z)"},
 {"type": "xá¶œ = y â†” yá¶œ = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : xá¶œ = y â†” yá¶œ = x := by rw [eq_comm]; sorry",
  "name": "compl_eq_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : xá¶œ = y â†” yá¶œ = x",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "x = yá¶œ â†” y = xá¶œ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x = yá¶œ â†” y = xá¶œ := by rw [eq_comm]; sorry",
  "name": "eq_compl_comm",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x = yá¶œ â†” y = xá¶œ",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "xá¶œ â‰¤ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] (h : yá¶œ â‰¤ x) : xá¶œ â‰¤ y := by simpa only [compl_compl] using compl_le_compl h; sorry",
  "name": "compl_le_of_compl_le",
  "kind": "theorem",
  "first-tactic": "simpa only [compl_compl] using compl_le_compl h",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] (h : yá¶œ â‰¤ x) : xá¶œ â‰¤ y",
  "args":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] (h : yá¶œ â‰¤ x)"},
 {"type": "x \\ yá¶œ = x âŠ“ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x \\ yá¶œ = x âŠ“ y := by rw [sdiff_eq]; sorry",
  "name": "sdiff_compl",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x \\ yá¶œ = x âŠ“ y",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "x âŠ“ y âŠ” x âŠ“ yá¶œ = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x âŠ“ y âŠ” x âŠ“ yá¶œ = x := by rw [â† sdiff_eq]; sorry",
  "name": "sup_inf_inf_compl",
  "kind": "theorem",
  "first-tactic": "rw [â† sdiff_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : x âŠ“ y âŠ” x âŠ“ yá¶œ = x",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "(x \\ y)á¶œ = x â‡¨ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : (x \\ y)á¶œ = x â‡¨ y := by rw [sdiff_eq]; sorry",
  "name": "compl_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : (x \\ y)á¶œ = x â‡¨ y",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "xá¶œ \\ yá¶œ = y \\ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : xá¶œ \\ yá¶œ = y \\ x := by rw [sdiff_compl]; sorry",
  "name": "compl_sdiff_compl",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_compl]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : xá¶œ \\ yá¶œ = y \\ x",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "Disjoint (xá¶œ) y â†” y â‰¤ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : Disjoint (xá¶œ) y â†” y â‰¤ x := by rw [â† le_compl_iff_disjoint_left]; sorry",
  "name": "disjoint_compl_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† le_compl_iff_disjoint_left]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : Disjoint (xá¶œ) y â†” y â‰¤ x",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "Disjoint x (yá¶œ) â†” x â‰¤ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : Disjoint x (yá¶œ) â†” x â‰¤ y := by rw [â† le_compl_iff_disjoint_right]; sorry",
  "name": "disjoint_compl_right_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† le_compl_iff_disjoint_right]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±] : Disjoint x (yá¶œ) â†” x â‰¤ y",
  "args": "{Î± : Type u}  {Î² : Type _}  {w x y z : Î±}  [BooleanAlgebra Î±]"},
 {"type": "Â¬IsMin a â†” âˆƒ b, b < a",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a b : Î±} : Â¬IsMin a â†” âˆƒ b, b < a := by simp [lt_iff_le_not_le]; sorry",
  "name": "not_isMin_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a b : Î±} : Â¬IsMin a â†” âˆƒ b, b < a",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a b : Î±}"},
 {"type": "Â¬IsMax a â†” âˆƒ b, a < b",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  [Preorder Î±]  {a b : Î±} : Â¬IsMax a â†” âˆƒ b, a < b := by simp [lt_iff_le_not_le]; sorry",
  "name": "not_isMax_iff",
  "kind": "theorem",
  "first-tactic": "simp [lt_iff_le_not_le]",
  "core-prompt":
  "{Î± Î² : Type _}  [Preorder Î±]  {a b : Î±} : Â¬IsMax a â†” âˆƒ b, a < b",
  "args": "{Î± Î² : Type _}  [Preorder Î±]  {a b : Î±}"},
 {"type": "a â‰¤ b â†” âˆƒ c, b = a âŠ” c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a â‰¤ b â†” âˆƒ c, b = a âŠ” c := by constructor; sorry",
  "name": "le_iff_exists_sup",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a â‰¤ b â†” âˆƒ c, b = a âŠ” c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” a = a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” a = a := by simp; sorry",
  "name": "sup_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” a = a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” b = b âŠ” a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” b = b âŠ” a := by apply le_antisymm; sorry",
  "name": "sup_comm",
  "kind": "theorem",
  "first-tactic": "apply le_antisymm",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” b = b âŠ” a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” b âŠ” c = c âŠ” b âŠ” a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = c âŠ” b âŠ” a := by rw [sup_comm]; sorry",
  "name": "sup_left_right_swap",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = c âŠ” b âŠ” a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a âŠ” (a âŠ” b) = a âŠ” b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” (a âŠ” b) = a âŠ” b := by simp; sorry",
  "name": "sup_left_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” (a âŠ” b) = a âŠ” b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” b âŠ” b = a âŠ” b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” b âŠ” b = a âŠ” b := by simp; sorry",
  "name": "sup_right_idem",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} : a âŠ” b âŠ” b = a âŠ” b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” (b âŠ” c) = b âŠ” (a âŠ” c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” (b âŠ” c) = b âŠ” (a âŠ” c) := by rw [â† sup_assoc]; sorry",
  "name": "sup_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† sup_assoc]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” (b âŠ” c) = b âŠ” (a âŠ” c)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a âŠ” b âŠ” c = a âŠ” c âŠ” b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = a âŠ” c âŠ” b := by rw [sup_assoc]; sorry",
  "name": "sup_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [sup_assoc]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = a âŠ” c âŠ” b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a âŠ” b âŠ” (c âŠ” d) = a âŠ” c âŠ” (b âŠ” d)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c d : Î±) : a âŠ” b âŠ” (c âŠ” d) = a âŠ” c âŠ” (b âŠ” d) := by rw [sup_assoc]; sorry",
  "name": "sup_sup_sup_comm",
  "kind": "theorem",
  "first-tactic": "rw [sup_assoc]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c d : Î±) : a âŠ” b âŠ” (c âŠ” d) = a âŠ” c âŠ” (b âŠ” d)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c d : Î±)"},
 {"type": "a âŠ” (b âŠ” c) = a âŠ” b âŠ” (a âŠ” c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” (b âŠ” c) = a âŠ” b âŠ” (a âŠ” c) := by rw [sup_sup_sup_comm]; sorry",
  "name": "sup_sup_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_sup_sup_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” (b âŠ” c) = a âŠ” b âŠ” (a âŠ” c)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a âŠ” b âŠ” c = a âŠ” c âŠ” (b âŠ” c)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = a âŠ” c âŠ” (b âŠ” c) := by rw [sup_sup_sup_comm]; sorry",
  "name": "sup_sup_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_sup_sup_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±) : a âŠ” b âŠ” c = a âŠ” c âŠ” (b âŠ” c)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [SemilatticeSup Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "SemilatticeInf Î±",
  "tactic-prompt":
  "def {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {Î± : Type _}  [HasInf Î±]  (inf_comm : âˆ€ a b : Î±, a âŠ“ b = b âŠ“ a)      (inf_assoc : âˆ€ a b c : Î±, a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c))  (inf_idem : âˆ€ a : Î±, a âŠ“ a = a) : SemilatticeInf Î± := by haveI : SemilatticeSup Î±áµ’áµˆ := SemilatticeSup.mk' inf_comm inf_assoc inf_idem; sorry",
  "name": "SemilatticeInf.mk'",
  "kind": "def",
  "first-tactic":
  "haveI : SemilatticeSup Î±áµ’áµˆ := SemilatticeSup.mk' inf_comm inf_assoc inf_idem",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {Î± : Type _}  [HasInf Î±]  (inf_comm : âˆ€ a b : Î±, a âŠ“ b = b âŠ“ a)      (inf_assoc : âˆ€ a b c : Î±, a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c))  (inf_idem : âˆ€ a : Î±, a âŠ“ a = a) : SemilatticeInf Î±",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans {Î± : Type _}  [HasInf Î±]  (inf_comm : âˆ€ a b : Î±, a âŠ“ b = b âŠ“ a)      (inf_assoc : âˆ€ a b c : Î±, a âŠ“ b âŠ“ c = a âŠ“ (b âŠ“ c))  (inf_idem : âˆ€ a : Î±, a âŠ“ a = a)"},
 {"type": "a âŠ“ b < a âŠ” b â†” a â‰  b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ“ b < a âŠ” b â†” a â‰  b := by constructor; sorry",
  "name": "inf_lt_sup",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ“ b < a âŠ” b â†” a â‰  b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” b â‰¤ a âŠ“ b â†” a = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” b â‰¤ a âŠ“ b â†” a = b := by simp [le_antisymm_iff]; sorry",
  "name": "sup_le_inf",
  "kind": "theorem",
  "first-tactic": "simp [le_antisymm_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” b â‰¤ a âŠ“ b â†” a = b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±}"},
 {"type": "a âŠ“ (a âŠ” b) = a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ“ (a âŠ” b) = a := by simp; sorry",
  "name": "inf_sup_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ“ (a âŠ” b) = a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” a âŠ“ b = a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” a âŠ“ b = a := by simp; sorry",
  "name": "sup_inf_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” a âŠ“ b = a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±}"},
 {"type": "a âŠ” b = b â†” a âŠ“ b = a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” b = b â†” a âŠ“ b = a := by rw [sup_eq_right]; sorry",
  "name": "sup_eq_iff_inf_eq",
  "kind": "theorem",
  "first-tactic": "rw [sup_eq_right]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±} : a âŠ” b = b â†” a âŠ“ b = a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [Lattice Î±]  {a b c d : Î±}"},
 {"type": "y âŠ“ z âŠ” x = (y âŠ” x) âŠ“ (z âŠ” x)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±} : y âŠ“ z âŠ” x = (y âŠ” x) âŠ“ (z âŠ” x) := by simp only [sup_inf_left]; sorry",
  "name": "sup_inf_right",
  "kind": "theorem",
  "first-tactic": "simp only [sup_inf_left]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±} : y âŠ“ z âŠ” x = (y âŠ” x) âŠ“ (z âŠ” x)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±}"},
 {"type": "(y âŠ” z) âŠ“ x = y âŠ“ x âŠ” z âŠ“ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±} : (y âŠ” z) âŠ“ x = y âŠ“ x âŠ” z âŠ“ x := by simp only [inf_sup_left]; sorry",
  "name": "inf_sup_right",
  "kind": "theorem",
  "first-tactic": "simp only [inf_sup_left]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±} : (y âŠ” z) âŠ“ x = y âŠ“ x âŠ” z âŠ“ x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [DistribLattice Î±]  {x y z : Î±}"},
 {"type": "a â‰¤ b âŠ” c â†” a â‰¤ b âˆ¨ a â‰¤ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±} : a â‰¤ b âŠ” c â†” a â‰¤ b âˆ¨ a â‰¤ c := by exact âŸ¨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]; sorry",
  "name": "le_sup_iff",
  "kind": "theorem",
  "first-tactic":
  "exact âŸ¨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±} : a â‰¤ b âŠ” c â†” a â‰¤ b âˆ¨ a â‰¤ c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±}"},
 {"type": "a < b âŠ” c â†” a < b âˆ¨ a < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±} : a < b âŠ” c â†” a < b âˆ¨ a < c := by exact âŸ¨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]; sorry",
  "name": "lt_sup_iff",
  "kind": "theorem",
  "first-tactic":
  "exact âŸ¨fun h =>\n    (le_total c b).imp\n      (fun bc => by rwa [sup_eq_left.2 bc] at h)\n      (fun bc => by rwa [sup_eq_right.2 bc] at h)]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±} : a < b âŠ” c â†” a < b âˆ¨ a < c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans  [LinearOrder Î±]  {a b c d : Î±}"},
 {"type": "(Â· âŠ” Â·) = (maxDefault : Î± â†’ Î± â†’ Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)] : (Â· âŠ” Â·) = (maxDefault : Î± â†’ Î± â†’ Î±) := by ext (x y); sorry",
  "name": "sup_eq_maxDefault",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)] : (Â· âŠ” Â·) = (maxDefault : Î± â†’ Î± â†’ Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeSup Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)]"},
 {"type": "(Â· âŠ“ Â·) = (minDefault : Î± â†’ Î± â†’ Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)] : (Â· âŠ“ Â·) = (minDefault : Î± â†’ Î± â†’ Î±) := by ext (x y); sorry",
  "name": "inf_eq_minDefault",
  "kind": "theorem",
  "first-tactic": "ext (x y)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)] : (Â· âŠ“ Â·) = (minDefault : Î± â†’ Î± â†’ Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  -- TODO: move this eventually, if we decide to use them -- Porting note: no ematch attribute --attribute [ematch] le_trans lt_of_le_of_lt lt_of_lt_of_le lt_trans [SemilatticeInf Î±]  [DecidableRel ((Â· â‰¤ Â·) : Î± â†’ Î± â†’ Prop)]      [IsTotal Î± (Â· â‰¤ Â·)]"},
 {"type": "u y = z â†” âˆ€ x, x â‰¤ z â†” l x â‰¤ y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [PartialOrder Î±]  [Preorder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {z : Î±}  {y : Î²} : u y = z â†” âˆ€ x, x â‰¤ z â†” l x â‰¤ y := by constructor; sorry",
  "name": "u_eq",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [PartialOrder Î±]  [Preorder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {z : Î±}  {y : Î²} : u y = z â†” âˆ€ x, x â‰¤ z â†” l x â‰¤ y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [PartialOrder Î±]  [Preorder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {z : Î±}  {y : Î²}"},
 {"type": "l x = z â†” âˆ€ y, z â‰¤ y â†” x â‰¤ u y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [Preorder Î±]  [PartialOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {x : Î±}  {z : Î²} : l x = z â†” âˆ€ y, z â‰¤ y â†” x â‰¤ u y := by constructor; sorry",
  "name": "l_eq",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [Preorder Î±]  [PartialOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {x : Î±}  {z : Î²} : l x = z â†” âˆ€ y, z â‰¤ y â†” x â‰¤ u y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [Preorder Î±]  [PartialOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {x : Î±}  {z : Î²}"},
 {"type": "l (â¨† (i) (j), f i j) = â¨† (i) (j), l (f i j)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {f : âˆ€ i, Îº i â†’ Î±} : l (â¨† (i) (j), f i j) = â¨† (i) (j), l (f i j) := by simp_rw [gc.l_supáµ¢]; sorry",
  "name": "l_supáµ¢â‚‚",
  "kind": "theorem",
  "first-tactic": "simp_rw [gc.l_supáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {f : âˆ€ i, Îº i â†’ Î±} : l (â¨† (i) (j), f i j) = â¨† (i) (j), l (f i j)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {f : âˆ€ i, Îº i â†’ Î±}"},
 {"type": "l (supâ‚› s) = â¨† a âˆˆ s, l a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {s : Set Î±} : l (supâ‚› s) = â¨† a âˆˆ s, l a := by simp only [supâ‚›_eq_supáµ¢]; sorry",
  "name": "l_supâ‚›",
  "kind": "theorem",
  "first-tactic": "simp only [supâ‚›_eq_supáµ¢]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {s : Set Î±} : l (supâ‚› s) = â¨† a âˆˆ s, l a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [CompleteLattice Î±]  [CompleteLattice Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) {s : Set Î±}"},
 {"type": "GaloisConnection (l2 âˆ˜ l1) (u1 âˆ˜ u2)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {l1 : Î± â†’ Î²}  {u1 : Î² â†’ Î±}      {l2 : Î² â†’ Î³}  {u2 : Î³ â†’ Î²}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2) : GaloisConnection (l2 âˆ˜ l1) (u1 âˆ˜ u2) := by intro a b; sorry",
  "name": "compose",
  "kind": "theorem",
  "first-tactic": "intro a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {l1 : Î± â†’ Î²}  {u1 : Î² â†’ Î±}      {l2 : Î² â†’ Î³}  {u2 : Î³ â†’ Î²}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2) : GaloisConnection (l2 âˆ˜ l1) (u1 âˆ˜ u2)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {l1 : Î± â†’ Î²}  {u1 : Î² â†’ Î±}      {l2 : Î² â†’ Î³}  {u2 : Î³ â†’ Î²}  (gc1 : GaloisConnection l1 u1)  (gc2 : GaloisConnection l2 u2)"},
 {"type": "supâ‚› (image2 l s t) = l (supâ‚› s) (supâ‚› t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (swap l b) (uâ‚ b))      (hâ‚‚ : âˆ€ a, GaloisConnection (l a) (uâ‚‚ a)) : supâ‚› (image2 l s t) = l (supâ‚› s) (supâ‚› t) := by simp_rw [supâ‚›_image2]; sorry",
  "name": "supâ‚›_image2_eq_supâ‚›_supâ‚›",
  "kind": "theorem",
  "first-tactic": "simp_rw [supâ‚›_image2]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (swap l b) (uâ‚ b))      (hâ‚‚ : âˆ€ a, GaloisConnection (l a) (uâ‚‚ a)) : supâ‚› (image2 l s t) = l (supâ‚› s) (supâ‚› t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (swap l b) (uâ‚ b))      (hâ‚‚ : âˆ€ a, GaloisConnection (l a) (uâ‚‚ a))"},
 {"type": "infâ‚› (image2 u s t) = u (infâ‚› s) (infâ‚› t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (lâ‚ b) (swap u b))      (hâ‚‚ : âˆ€ a, GaloisConnection (lâ‚‚ a) (u a)) : infâ‚› (image2 u s t) = u (infâ‚› s) (infâ‚› t) := by simp_rw [infâ‚›_image2]; sorry",
  "name": "infâ‚›_image2_eq_infâ‚›_infâ‚›",
  "kind": "theorem",
  "first-tactic": "simp_rw [infâ‚›_image2]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (lâ‚ b) (swap u b))      (hâ‚‚ : âˆ€ a, GaloisConnection (lâ‚‚ a) (u a)) : infâ‚› (image2 u s t) = u (infâ‚› s) (infâ‚› t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u)  [CompleteLattice Î±]  [CompleteLattice Î²]  [CompleteLattice Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}    {t : Set Î²}  {l u : Î± â†’ Î² â†’ Î³}  {lâ‚ uâ‚ : Î² â†’ Î³ â†’ Î±}  {lâ‚‚ uâ‚‚ : Î± â†’ Î³ â†’ Î²} (hâ‚ : âˆ€ b, GaloisConnection (lâ‚ b) (swap u b))      (hâ‚‚ : âˆ€ a, GaloisConnection (lâ‚‚ a) (u a))"},
 {"type": "BddAbove (e â»Â¹' s) â†” BddAbove s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²} : BddAbove (e â»Â¹' s) â†” BddAbove s := by rw [â† e.bddAbove_image]; sorry",
  "name": "bddAbove_preimage",
  "kind": "theorem",
  "first-tactic": "rw [â† e.bddAbove_image]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²} : BddAbove (e â»Â¹' s) â†” BddAbove s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²}"},
 {"type": "BddBelow (e â»Â¹' s) â†” BddBelow s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²} : BddBelow (e â»Â¹' s) â†” BddBelow s := by rw [â† e.bddBelow_image]; sorry",
  "name": "bddBelow_preimage",
  "kind": "theorem",
  "first-tactic": "rw [â† e.bddBelow_image]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²} : BddBelow (e â»Â¹' s) â†” BddBelow s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] (e : Î± â‰ƒo Î²)  {s : Set Î²}"},
 {"type": "l (â¨† (i) (hi), u (f i hi)) = â¨† (i) (hi), f i hi",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²) : l (â¨† (i) (hi), u (f i hi)) = â¨† (i) (hi), f i hi := by simp only [supáµ¢_subtype']; sorry",
  "name": "l_bsupáµ¢_u",
  "kind": "theorem",
  "first-tactic": "simp only [supáµ¢_subtype']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²) : l (â¨† (i) (hi), u (f i hi)) = â¨† (i) (hi), f i hi",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²)"},
 {"type": "l (supâ‚› (u '' s)) = supâ‚› s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²) : l (supâ‚› (u '' s)) = supâ‚› s := by rw [supâ‚›_image]; sorry",
  "name": "l_supâ‚›_u_image",
  "kind": "theorem",
  "first-tactic": "rw [supâ‚›_image]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²) : l (supâ‚› (u '' s)) = supâ‚› s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²)"},
 {"type": "l (â¨… (i) (hi), u (f i hi)) = â¨… (i) (hi), f i hi",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²) : l (â¨… (i) (hi), u (f i hi)) = â¨… (i) (hi), f i hi := by simp only [infáµ¢_subtype']; sorry",
  "name": "l_binfáµ¢_u",
  "kind": "theorem",
  "first-tactic": "simp only [infáµ¢_subtype']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²) : l (â¨… (i) (hi), u (f i hi)) = â¨… (i) (hi), f i hi",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)  {Î¹ : Sort x}      {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î²)"},
 {"type": "l (infâ‚› (u '' s)) = infâ‚› s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²) : l (infâ‚› (u '' s)) = infâ‚› s := by rw [infâ‚›_image]; sorry",
  "name": "l_infâ‚›_u_image",
  "kind": "theorem",
  "first-tactic": "rw [infâ‚›_image]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²) : l (infâ‚› (u '' s)) = infâ‚› s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      (s : Set Î²)"},
 {"type": "l (â¨… (i) (hi), f i hi) = â¨… (i) (hi), l (f i hi)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      {Î¹ : Sort x}  {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î±)  (hf : âˆ€ i hi, u (l (f i hi)) = f i hi) : l (â¨… (i) (hi), f i hi) = â¨… (i) (hi), l (f i hi) := by rw [infáµ¢_subtype']; sorry",
  "name": "l_binfáµ¢_of_ul_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [infáµ¢_subtype']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      {Î¹ : Sort x}  {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î±)  (hf : âˆ€ i hi, u (l (f i hi)) = f i hi) : l (â¨… (i) (hi), f i hi) = â¨… (i) (hi), l (f i hi)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  {Îº : Î¹ â†’ Sort _}  {a aâ‚ aâ‚‚ : Î±}    {b bâ‚ bâ‚‚ : Î²}  [LinearOrder Î±]  [LinearOrder Î²]  {l : Î± â†’ Î²}  {u : Î² â†’ Î±}  (gc : GaloisConnection l u) [Preorder Î±]  [Preorder Î²] {l : Î± â†’ Î²}  {u : Î² â†’ Î±} [CompleteLattice Î±]  [CompleteLattice Î²]  (gi : GaloisInsertion l u)      {Î¹ : Sort x}  {p : Î¹ â†’ Prop}  (f : âˆ€ (i) (_ : p i), Î±)  (hf : âˆ€ i hi, u (l (f i hi)) = f i hi)"},
 {"type": "Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, Â¬y â‰¤ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, Â¬y â‰¤ x := by simp [BddAbove]; sorry",
  "name": "not_bddAbove_iff'",
  "kind": "theorem",
  "first-tactic": "simp [BddAbove]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, Â¬y â‰¤ x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}"},
 {"type": "Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, x < y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {Î± : Type _}  [LinearOrder Î±]  {s : Set Î±} : Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, x < y := by simp only [not_bddAbove_iff']; sorry",
  "name": "not_bddAbove_iff",
  "kind": "theorem",
  "first-tactic": "simp only [not_bddAbove_iff']",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {Î± : Type _}  [LinearOrder Î±]  {s : Set Î±} : Â¬BddAbove s â†” âˆ€ x, âˆƒ y âˆˆ s, x < y",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {Î± : Type _}  [LinearOrder Î±]  {s : Set Î±}"},
 {"type": "a â‰¤ b â†” b âˆˆ upperBounds s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsLUB s a) : a â‰¤ b â†” b âˆˆ upperBounds s := by rw [h.upperBounds_eq]; sorry",
  "name": "isLUB_le_iff",
  "kind": "theorem",
  "first-tactic": "rw [h.upperBounds_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsLUB s a) : a â‰¤ b â†” b âˆˆ upperBounds s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsLUB s a)"},
 {"type": "b â‰¤ a â†” b âˆˆ lowerBounds s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsGLB s a) : b â‰¤ a â†” b âˆˆ lowerBounds s := by rw [h.lowerBounds_eq]; sorry",
  "name": "le_isGLB_iff",
  "kind": "theorem",
  "first-tactic": "rw [h.lowerBounds_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsGLB s a) : b â‰¤ a â†” b âˆˆ lowerBounds s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (h : IsGLB s a)"},
 {"type":
  "IsLeast (s âˆª t) a â†” IsLeast s a âˆ§ a âˆˆ lowerBounds t âˆ¨ a âˆˆ lowerBounds s âˆ§ IsLeast t a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {a : Î±}  {s t : Set Î±} : IsLeast (s âˆª t) a â†” IsLeast s a âˆ§ a âˆˆ lowerBounds t âˆ¨ a âˆˆ lowerBounds s âˆ§ IsLeast t a := by simp [IsLeast]; sorry",
  "name": "isLeast_union_iff",
  "kind": "theorem",
  "first-tactic": "simp [IsLeast]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {a : Î±}  {s t : Set Î±} : IsLeast (s âˆª t) a â†” IsLeast s a âˆ§ a âˆˆ lowerBounds t âˆ¨ a âˆˆ lowerBounds s âˆ§ IsLeast t a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} {a : Î±}  {s t : Set Î±}"},
 {"type": "BddAbove s â†’ BddAbove t â†’ BddAbove (s âˆª t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s t : Set Î³} : BddAbove s â†’ BddAbove t â†’ BddAbove (s âˆª t) := by rintro âŸ¨bs, hsâŸ© âŸ¨bt, htâŸ©; sorry",
  "name": "BddAbove.union",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨bs, hsâŸ© âŸ¨bt, htâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s t : Set Î³} : BddAbove s â†’ BddAbove t â†’ BddAbove (s âˆª t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s t : Set Î³}"},
 {"type": "BddAbove s â†” âˆƒ x, xâ‚€ â‰¤ x âˆ§ âˆ€ y âˆˆ s, y â‰¤ x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s : Set Î³}  (xâ‚€ : Î³) : BddAbove s â†” âˆƒ x, xâ‚€ â‰¤ x âˆ§ âˆ€ y âˆˆ s, y â‰¤ x := by rw [bddAbove_def]; sorry",
  "name": "bddAbove_iff_exists_ge",
  "kind": "theorem",
  "first-tactic": "rw [bddAbove_def]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s : Set Î³}  (xâ‚€ : Î³) : BddAbove s â†” âˆƒ x, xâ‚€ â‰¤ x âˆ§ âˆ€ y âˆˆ s, y â‰¤ x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  {s : Set Î³}  (xâ‚€ : Î³)"},
 {"type": "j = i âˆ¨ Iio i = Iic j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  {j : Î³}  (i : Î³)  (hj : IsLUB (Iio i) j) : j = i âˆ¨ Iio i = Iic j := by cases' eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i hj_lt_i; sorry",
  "name": "lub_Iio_eq_self_or_Iio_eq_Iic",
  "kind": "theorem",
  "first-tactic":
  "cases' eq_or_lt_of_le (lub_Iio_le i hj) with hj_eq_i hj_lt_i",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  {j : Î³}  (i : Î³)  (hj : IsLUB (Iio i) j) : j = i âˆ¨ Iio i = Iic j",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  {j : Î³}  (i : Î³)  (hj : IsLUB (Iio i) j)"},
 {"type": "âˆƒ j, IsLUB (Iio i) j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [LinearOrder Î³] (i : Î³) : âˆƒ j, IsLUB (Iio i) j := by by_cases h_exists_lt : âˆƒ j, j âˆˆ upperBounds (Iio i) âˆ§ j < i; sorry",
  "name": "exists_lub_Iio",
  "kind": "theorem",
  "first-tactic": "by_cases h_exists_lt : âˆƒ j, j âˆˆ upperBounds (Iio i) âˆ§ j < i",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [LinearOrder Î³] (i : Î³) : âˆƒ j, IsLUB (Iio i) j",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [LinearOrder Î³] (i : Î³)"},
 {"type": "IsLUB (Ioo a b) b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b) : IsLUB (Ioo a b) b := by simpa only [dual_Ioo] using isGLB_Ioo hab.dual; sorry",
  "name": "isLUB_Ioo",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioo] using isGLB_Ioo hab.dual",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b) : IsLUB (Ioo a b) b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b)"},
 {"type": "IsLUB (Ico a b) b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b) : IsLUB (Ico a b) b := by simpa only [dual_Ioc] using isGLB_Ioc hab.dual; sorry",
  "name": "isLUB_Ico",
  "kind": "theorem",
  "first-tactic": "simpa only [dual_Ioc] using isGLB_Ioc hab.dual",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b) : IsLUB (Ico a b) b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}  [SemilatticeInf Î³]  [DenselyOrdered Î³] {a b : Î³}  (hab : a < b)"},
 {"type": "BddBelow s âˆ§ BddAbove s â†” âˆƒ a b, s âŠ† Icc a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : BddBelow s âˆ§ BddAbove s â†” âˆƒ a b, s âŠ† Icc a b := by simp [Ici_inter_Iic.symm]; sorry",
  "name": "bddBelow_bddAbove_iff_subset_Icc",
  "kind": "theorem",
  "first-tactic": "simp [Ici_inter_Iic.symm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : BddBelow s âˆ§ BddAbove s â†” âˆƒ a b, s âŠ† Icc a b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}"},
 {"type": "upperBounds (univ : Set Î³) = {âŠ¤}",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  [OrderTop Î³] : upperBounds (univ : Set Î³) = {âŠ¤} := by rw [isGreatest_univ.upperBounds_eq]; sorry",
  "name": "OrderTop.upperBounds_univ",
  "kind": "theorem",
  "first-tactic": "rw [isGreatest_univ.upperBounds_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  [OrderTop Î³] : upperBounds (univ : Set Î³) = {âŠ¤}",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [PartialOrder Î³]  [OrderTop Î³]"},
 {"type": "Â¬BddAbove (univ : Set Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [NoMaxOrder Î±] : Â¬BddAbove (univ : Set Î±) := by simp [BddAbove]; sorry",
  "name": "not_bddAbove_univ",
  "kind": "theorem",
  "first-tactic": "simp [BddAbove]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [NoMaxOrder Î±] : Â¬BddAbove (univ : Set Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [NoMaxOrder Î±]"},
 {"type": "upperBounds (âˆ… : Set Î±) = univ",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : upperBounds (âˆ… : Set Î±) = univ := by simp only [upperBounds]; sorry",
  "name": "upperBounds_empty",
  "kind": "theorem",
  "first-tactic": "simp only [upperBounds]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} : upperBounds (âˆ… : Set Î±) = univ",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±}"},
 {"type": "BddAbove (âˆ… : Set Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±] : BddAbove (âˆ… : Set Î±) := by simp only [BddAbove]; sorry",
  "name": "bddAbove_empty",
  "kind": "theorem",
  "first-tactic": "simp only [BddAbove]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±] : BddAbove (âˆ… : Set Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±]"},
 {"type": "BddBelow (âˆ… : Set Î±)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±] : BddBelow (âˆ… : Set Î±) := by simp only [BddBelow]; sorry",
  "name": "bddBelow_empty",
  "kind": "theorem",
  "first-tactic": "simp only [BddBelow]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±] : BddBelow (âˆ… : Set Î±)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Nonempty Î±]"},
 {"type": "IsGLB âˆ… (âŠ¤ : Î³)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Preorder Î³]  [OrderTop Î³] : IsGLB âˆ… (âŠ¤ : Î³) := by simp only [IsGLB]; sorry",
  "name": "isGLB_empty",
  "kind": "theorem",
  "first-tactic": "simp only [IsGLB]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Preorder Î³]  [OrderTop Î³] : IsGLB âˆ… (âŠ¤ : Î³)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [Preorder Î³]  [OrderTop Î³]"},
 {"type": "BddAbove (insert a s) â†” BddAbove s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  (a : Î³)  {s : Set Î³} : BddAbove (insert a s) â†” BddAbove s := by simp_rw [insert_eq]; sorry",
  "name": "bddAbove_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  (a : Î³)  {s : Set Î³} : BddAbove (insert a s) â†” BddAbove s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeSup Î³]  (a : Î³)  {s : Set Î³}"},
 {"type": "BddBelow (insert a s) â†” BddBelow s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeInf Î³]  (a : Î³)  {s : Set Î³} : BddBelow (insert a s) â†” BddBelow s := by simp_rw [insert_eq]; sorry",
  "name": "bddBelow_insert",
  "kind": "theorem",
  "first-tactic": "simp_rw [insert_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeInf Î³]  (a : Î³)  {s : Set Î³} : BddBelow (insert a s) â†” BddBelow s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} [SemilatticeInf Î³]  (a : Î³)  {s : Set Î³}"},
 {"type": "upperBounds (insert a s) = Ici a âˆ© upperBounds s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±) : upperBounds (insert a s) = Ici a âˆ© upperBounds s := by rw [insert_eq]; sorry",
  "name": "upperBounds_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±) : upperBounds (insert a s) = Ici a âˆ© upperBounds s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±)"},
 {"type": "lowerBounds (insert a s) = Iic a âˆ© lowerBounds s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±) : lowerBounds (insert a s) = Iic a âˆ© lowerBounds s := by rw [insert_eq]; sorry",
  "name": "lowerBounds_insert",
  "kind": "theorem",
  "first-tactic": "rw [insert_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±) : lowerBounds (insert a s) = Iic a âˆ© lowerBounds s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [Preorder Î±]  [Preorder Î²]  {s t : Set Î±}  {a b : Î±} (a : Î±)  (s : Set Î±)"},
 {"type": "b < a â†” âˆƒ c âˆˆ s, b < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [LinearOrder Î±]  {s : Set Î±}  {a b : Î±} (h : IsLUB s a) : b < a â†” âˆƒ c âˆˆ s, b < c := by simp_rw [â† not_le]; sorry",
  "name": "lt_isLUB_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† not_le]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [LinearOrder Î±]  {s : Set Î±}  {a b : Î±} (h : IsLUB s a) : b < a â†” âˆƒ c âˆˆ s, b < c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x}  [LinearOrder Î±]  {s : Set Î±}  {a b : Î±} (h : IsLUB s a)"},
 {"type": "f '' (upperBounds s âˆ© t) âŠ† upperBounds (f '' s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) (Hst : s âŠ† t) : f '' (upperBounds s âˆ© t) âŠ† upperBounds (f '' s) := by rintro _ âŸ¨a, ha, rflâŸ©; sorry",
  "name": "image_upperBounds_subset_upperBounds_image",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, ha, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) (Hst : s âŠ† t) : f '' (upperBounds s âˆ© t) âŠ† upperBounds (f '' s)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) (Hst : s âŠ† t)"},
 {"type": "f '' upperBounds s âŠ† upperBounds (f '' s)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} : f '' upperBounds s âŠ† upperBounds (f '' s) := by rintro _ âŸ¨a, ha, rflâŸ©; sorry",
  "name": "image_upperBounds_subset_upperBounds_image",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, ha, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} : f '' upperBounds s âŠ† upperBounds (f '' s)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±}"},
 {"type":
  "image2 f (upperBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (upperBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_upperBounds_upperBounds_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (upperBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (lowerBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_lowerBounds_lowerBounds_subset",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (lowerBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type": "BddAbove s â†’ BddAbove t â†’ BddAbove (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddAbove s â†’ BddAbove t â†’ BddAbove (image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddAbove.image2",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddAbove s â†’ BddAbove t â†’ BddAbove (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type": "BddBelow s â†’ BddBelow t â†’ BddBelow (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddBelow s â†’ BddBelow t â†’ BddBelow (image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddBelow.image2",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddBelow s â†’ BddBelow t â†’ BddBelow (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type":
  "image2 f (upperBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (upperBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_upperBounds_lowerBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (upperBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (lowerBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_lowerBounds_upperBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (lowerBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type": "BddAbove s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddAbove s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddAbove.bddAbove_image2_of_bddBelow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddAbove s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type": "BddBelow s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddBelow s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddBelow.bddBelow_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddBelow s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Monotone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (lowerBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_upperBounds_upperBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (lowerBounds s) (lowerBounds t) âŠ† upperBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type":
  "image2 f (upperBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (upperBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_lowerBounds_lowerBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : image2 f (upperBounds s) (upperBounds t) âŠ† lowerBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type": "BddBelow s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddBelow s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddBelow.image2_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddBelow s â†’ BddBelow t â†’ BddAbove (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type": "BddAbove s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddAbove s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddAbove.image2_bddBelow",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a)) : BddAbove s â†’ BddAbove t â†’ BddBelow (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Antitone (f a))"},
 {"type":
  "image2 f (lowerBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (lowerBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_lowerBounds_upperBounds_subset_upperBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (lowerBounds s) (upperBounds t) âŠ† upperBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type":
  "image2 f (upperBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (upperBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t) := by rintro _ âŸ¨a, b, ha, hb, rflâŸ©; sorry",
  "name": "image2_upperBounds_lowerBounds_subset_lowerBounds_image2",
  "kind": "theorem",
  "first-tactic": "rintro _ âŸ¨a, b, ha, hb, rflâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : image2 f (upperBounds s) (lowerBounds t) âŠ† lowerBounds (image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type": "BddBelow s â†’ BddAbove t â†’ BddAbove (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddBelow s â†’ BddAbove t â†’ BddAbove (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddBelow.bddAbove_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddBelow s â†’ BddAbove t â†’ BddAbove (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type": "BddAbove s â†’ BddBelow t â†’ BddBelow (Set.image2 f s t)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddAbove s â†’ BddBelow t â†’ BddBelow (Set.image2 f s t) := by rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©; sorry",
  "name": "BddAbove.bddBelow_image2_of_bddAbove",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a)) : BddAbove s â†’ BddBelow t â†’ BddBelow (Set.image2 f s t)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±}  [Preorder Î±]  [Preorder Î²]  [Preorder Î³]  {f : Î± â†’ Î² â†’ Î³}  {s : Set Î±}  {t : Set Î²}  {a : Î±}    {b : Î²}  (hâ‚€ : âˆ€ b, Antitone (swap f b))  (hâ‚ : âˆ€ a, Monotone (f a))"},
 {"type": "IsLUB s f â†” âˆ€ a, IsLUB (Function.eval a '' s) (f a)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} {Ï€ : Î± â†’ Type _}  [âˆ€ a, Preorder (Ï€ a)]  {s : Set (âˆ€ a, Ï€ a)}  {f : âˆ€ a, Ï€ a} : IsLUB s f â†” âˆ€ a, IsLUB (Function.eval a '' s) (f a) := by classical\n    refine'\n      âŸ¨fun H a => âŸ¨(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => _âŸ©, fun H =>\n        âŸ¨_, _âŸ©âŸ©\n    Â· suffices h : Function.update f a b âˆˆ upperBounds s from Function.update_same a b f â–¸ H.2 h a\n      refine' fun g hg => le_update_iff.2 âŸ¨hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg iâŸ©\n    Â· exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    Â· exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg); sorry",
  "name": "isLUB_pi",
  "kind": "theorem",
  "first-tactic":
  "classical\n    refine'\n      âŸ¨fun H a => âŸ¨(Function.monotone_eval a).mem_upperBounds_image H.1, fun b hb => _âŸ©, fun H =>\n        âŸ¨_, _âŸ©âŸ©\n    Â· suffices h : Function.update f a b âˆˆ upperBounds s from Function.update_same a b f â–¸ H.2 h a\n      refine' fun g hg => le_update_iff.2 âŸ¨hb <| mem_image_of_mem _ hg, fun i _ => H.1 hg iâŸ©\n    Â· exact fun g hg a => (H a).1 (mem_image_of_mem _ hg)\n    Â· exact fun g hg a => (H a).2 ((Function.monotone_eval a).mem_upperBounds_image hg)",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} {Ï€ : Î± â†’ Type _}  [âˆ€ a, Preorder (Ï€ a)]  {s : Set (âˆ€ a, Ï€ a)}  {f : âˆ€ a, Ï€ a} : IsLUB s f â†” âˆ€ a, IsLUB (Function.eval a '' s) (f a)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} {Ï€ : Î± â†’ Type _}  [âˆ€ a, Preorder (Ï€ a)]  {s : Set (âˆ€ a, Ï€ a)}  {f : âˆ€ a, Ï€ a}"},
 {"type": "IsLUB s p â†” IsLUB (Prod.fst '' s) p.1 âˆ§ IsLUB (Prod.snd '' s) p.2",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {s : Set (Î± Ã— Î²)}  (p : Î± Ã— Î²) : IsLUB s p â†” IsLUB (Prod.fst '' s) p.1 âˆ§ IsLUB (Prod.snd '' s) p.2 := by refine'\n    âŸ¨fun H =>\n      âŸ¨âŸ¨monotone_fst.mem_upperBounds_image H.1, fun a ha => _âŸ©,\n        âŸ¨monotone_snd.mem_upperBounds_image H.1, fun a ha => _âŸ©âŸ©,\n      fun H => âŸ¨_, _âŸ©âŸ©; sorry",
  "name": "isLUB_prod",
  "kind": "theorem",
  "first-tactic":
  "refine'\n    âŸ¨fun H =>\n      âŸ¨âŸ¨monotone_fst.mem_upperBounds_image H.1, fun a ha => _âŸ©,\n        âŸ¨monotone_snd.mem_upperBounds_image H.1, fun a ha => _âŸ©âŸ©,\n      fun H => âŸ¨_, _âŸ©âŸ©",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {s : Set (Î± Ã— Î²)}  (p : Î± Ã— Î²) : IsLUB s p â†” IsLUB (Prod.fst '' s) p.1 âˆ§ IsLUB (Prod.snd '' s) p.2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {Î¹ : Sort x} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : MonotoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  {s t : Set Î±}  (Hf : AntitoneOn f t)  {a : Î±}    (Hst : s âŠ† t) [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (Hf : Monotone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {f : Î± â†’ Î²}  (hf : Antitone f)  {a : Î±}  {s : Set Î±} [Preorder Î±]  [Preorder Î²]  {s : Set (Î± Ã— Î²)}  (p : Î± Ã— Î²)"},
 {"type": "IsLUB (f '' s) (f x) â†” IsLUB s x",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î±}  {x : Î±} : IsLUB (f '' s) (f x) â†” IsLUB s x := by rw [isLUB_image]; sorry",
  "name": "isLUB_image'",
  "kind": "theorem",
  "first-tactic": "rw [isLUB_image]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î±}  {x : Î±} : IsLUB (f '' s) (f x) â†” IsLUB s x",
  "args": "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î±}  {x : Î±}"},
 {"type": "IsLUB (f â»Â¹' s) x â†” IsLUB s (f x)",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î±} : IsLUB (f â»Â¹' s) x â†” IsLUB s (f x) := by rw [â† f.symm_symm]; sorry",
  "name": "isLUB_preimage",
  "kind": "theorem",
  "first-tactic": "rw [â† f.symm_symm]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î±} : IsLUB (f â»Â¹' s) x â†” IsLUB s (f x)",
  "args": "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î±}"},
 {"type": "IsLUB (f â»Â¹' s) (f.symm x) â†” IsLUB s x",
  "tactic-prompt":
  "theorem [Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î²} : IsLUB (f â»Â¹' s) (f.symm x) â†” IsLUB s x := by rw [isLUB_preimage]; sorry",
  "name": "isLUB_preimage'",
  "kind": "theorem",
  "first-tactic": "rw [isLUB_preimage]",
  "core-prompt":
  "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î²} : IsLUB (f â»Â¹' s) (f.symm x) â†” IsLUB s x",
  "args": "[Preorder Î±]  [Preorder Î²]  (f : Î± â‰ƒo Î²) {s : Set Î²}  {x : Î²}"},
 {"type": "PSum (OrderTop Î±) (NoTopOrder Î±)",
  "tactic-prompt":
  "def {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±] : PSum (OrderTop Î±) (NoTopOrder Î±) := by by_cases H : âˆ€ a : Î±, âˆƒ b, Â¬b â‰¤ a; sorry",
  "name": "topOrderOrNoTopOrder",
  "kind": "def",
  "first-tactic": "by_cases H : âˆ€ a : Î±, âˆƒ b, Â¬b â‰¤ a",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±] : PSum (OrderTop Î±) (NoTopOrder Î±)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±]"},
 {"type": "PSum (OrderBot Î±) (NoBotOrder Î±)",
  "tactic-prompt":
  "def {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±] : PSum (OrderBot Î±) (NoBotOrder Î±) := by by_cases H : âˆ€ a : Î±, âˆƒ b, Â¬a â‰¤ b; sorry",
  "name": "botOrderOrNoBotOrder",
  "kind": "def",
  "first-tactic": "by_cases H : âˆ€ a : Î±, âˆƒ b, Â¬a â‰¤ b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±] : PSum (OrderBot Î±) (NoBotOrder Î±)",
  "args": "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  (Î± : Type _)  [LE Î±]"},
 {"type": "a âŠ” b = âŠ¥ â†” a = âŠ¥ âˆ§ b = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  [SemilatticeSup Î±]  [OrderBot Î±]  {a b : Î±}  -- Porting note: Not simp because simp can prove it : a âŠ” b = âŠ¥ â†” a = âŠ¥ âˆ§ b = âŠ¥ := by rw [eq_bot_iff]; sorry",
  "name": "sup_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [eq_bot_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  [SemilatticeSup Î±]  [OrderBot Î±]  {a b : Î±}  -- Porting note: Not simp because simp can prove it : a âŠ” b = âŠ¥ â†” a = âŠ¥ âˆ§ b = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _}  [SemilatticeSup Î±]  [OrderBot Î±]  {a b : Î±}  -- Porting note: Not simp because simp can prove it"},
 {"type": "(x : Î±) = âŠ¥ â†” x = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderBot Î±]  [OrderBot (Subtype p)]  (hbot : p âŠ¥)  {x : { x // p x }} : (x : Î±) = âŠ¥ â†” x = âŠ¥ := by rw [â† coe_bot hbot]; sorry",
  "name": "coe_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† coe_bot hbot]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderBot Î±]  [OrderBot (Subtype p)]  (hbot : p âŠ¥)  {x : { x // p x }} : (x : Î±) = âŠ¥ â†” x = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderBot Î±]  [OrderBot (Subtype p)]  (hbot : p âŠ¥)  {x : { x // p x }}"},
 {"type": "(x : Î±) = âŠ¤ â†” x = âŠ¤",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderTop Î±]  [OrderTop (Subtype p)]  (htop : p âŠ¤)  {x : { x // p x }} : (x : Î±) = âŠ¤ â†” x = âŠ¤ := by rw [â† coe_top htop]; sorry",
  "name": "coe_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† coe_top htop]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderTop Î±]  [OrderTop (Subtype p)]  (htop : p âŠ¤)  {x : { x // p x }} : (x : Î±) = âŠ¤ â†” x = âŠ¤",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±] [OrderTop Î±]  [OrderTop (Subtype p)]  (htop : p âŠ¤)  {x : { x // p x }}"},
 {"type": "min a b = âŠ¥ â†” a = âŠ¥ âˆ¨ b = âŠ¥",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±]  [LinearOrder Î±]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot Î±]  {a b : Î±} : min a b = âŠ¥ â†” a = âŠ¥ âˆ¨ b = âŠ¥ := by simp only [â† inf_eq_min]; sorry",
  "name": "min_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp only [â† inf_eq_min]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±]  [LinearOrder Î±]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot Î±]  {a b : Î±} : min a b = âŠ¥ â†” a = âŠ¥ âˆ¨ b = âŠ¥",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ Î´ : Type _} {Î¹ : Type _}  {Î±' : Î¹ â†’ Type _}  {p : Î± â†’ Prop}  -- See note [reducible non-instances] [PartialOrder Î±]  [LinearOrder Î±]  -- `simp` can prove these, so they shouldn't be simp-lemmas. [OrderBot Î±]  {a b : Î±}"},
 {"type": "False",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  [IsWellOrder Î± r]  (f : r â‰ºi r) : False := by have h := f.lt_top f.top; sorry",
  "name": "irrefl",
  "kind": "theorem",
  "first-tactic": "have h := f.lt_top f.top",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  [IsWellOrder Î± r]  (f : r â‰ºi r) : False",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  [IsWellOrder Î± r]  (f : r â‰ºi r)"},
 {"type": "f.top = g.top",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î³ t]  (e : r â‰ƒr s)  (f : r â‰ºi t)  (g : s â‰ºi t) : f.top = g.top := by rw [Subsingleton.elim f (PrincipalSeg.equivLt e g)]; sorry",
  "name": "top_eq",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim f (PrincipalSeg.equivLt e g)]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î³ t]  (e : r â‰ƒr s)  (f : r â‰ºi t)  (g : s â‰ºi t) : f.top = g.top",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î³ t]  (e : r â‰ƒr s)  (f : r â‰ºi t)  (g : s â‰ºi t)"},
 {"type": "t h.top g.top",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  {t : Î³ â†’ Î³ â†’ Prop}  [IsWellOrder Î³ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t) : t h.top g.top := by rw [Subsingleton.elim h (f.trans g)]; sorry",
  "name": "topLtTop",
  "kind": "theorem",
  "first-tactic": "rw [Subsingleton.elim h (f.trans g)]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  {t : Î³ â†’ Î³ â†’ Prop}  [IsWellOrder Î³ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t) : t h.top g.top",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}  {t : Î³ â†’ Î³ â†’ Prop}  [IsWellOrder Î³ t]      (f : PrincipalSeg r s)  (g : PrincipalSeg s t)  (h : PrincipalSeg r t)"},
 {"type": "Sum (r â‰ºi s) (r â‰ƒr s)",
  "tactic-prompt":
  "def {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  (f : r â‰¼i s) : Sum (r â‰ºi s) (r â‰ƒr s) := by by_cases h : Surjective f; sorry",
  "name": "InitialSeg.ltOrEq",
  "kind": "def",
  "first-tactic": "by_cases h : Surjective f",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  (f : r â‰¼i s) : Sum (r â‰ºi s) (r â‰ƒr s)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  (f : r â‰¼i s)"},
 {"type": "(f.leLt g) a = g (f a)",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  [IsTrans Î³ t]  (f : r â‰¼i s)  (g : s â‰ºi t)  (a : Î±) : (f.leLt g) a = g (f a) := by delta InitialSeg.leLt; sorry",
  "name": "InitialSeg.leLt_apply",
  "kind": "theorem",
  "first-tactic": "delta InitialSeg.leLt",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  [IsTrans Î³ t]  (f : r â‰¼i s)  (g : s â‰ºi t)  (a : Î±) : (f.leLt g) a = g (f a)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop}    {t : Î³ â†’ Î³ â†’ Prop} [IsWellOrder Î² s]  [IsTrans Î³ t]  (f : r â‰¼i s)  (g : s â‰ºi t)  (a : Î±)"},
 {"type": "Â¬r b a â†’ r b c â†’ r a c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±} : Â¬r b a â†’ r b c â†’ r a c := by intro hâ‚ hâ‚‚; sorry",
  "name": "trans_trichotomous_left",
  "kind": "theorem",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±} : Â¬r b a â†’ r b c â†’ r a c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±}"},
 {"type": "r a b â†’ Â¬r c b â†’ r a c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±} : r a b â†’ Â¬r c b â†’ r a c := by intro hâ‚ hâ‚‚; sorry",
  "name": "trans_trichotomous_right",
  "kind": "theorem",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±} : r a b â†’ Â¬r c b â†’ r a c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [IsTrans Î± r]  [IsTrichotomous Î± r]  {a b c : Î±}"},
 {"type": "Â¬Bounded r s â†” Unbounded r s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±) : Â¬Bounded r s â†” Unbounded r s := by simp only [Bounded]; sorry",
  "name": "not_bounded_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Bounded]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±) : Â¬Bounded r s â†” Unbounded r s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±)"},
 {"type": "Â¬Unbounded r s â†” Bounded r s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±) : Â¬Unbounded r s â†” Bounded r s := by rw [not_iff_comm]; sorry",
  "name": "not_unbounded_iff",
  "kind": "theorem",
  "first-tactic": "rw [not_iff_comm]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±) : Â¬Unbounded r s â†” Bounded r s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] {r : Î± â†’ Î± â†’ Prop}  (s : Set Î±)"},
 {"type": "IsOrderConnected Î± (Â· < Â·)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsOrderConnected Î± (Â· < Â·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsOrderConnected Î± (Â· < Â·)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±]"},
 {"type": "IsIncompTrans Î± (Â· < Â·)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsIncompTrans Î± (Â· < Â·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsIncompTrans Î± (Â· < Â·)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±]"},
 {"type": "IsStrictWeakOrder Î± (Â· < Â·)",
  "tactic-prompt":
  "instance {Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsStrictWeakOrder Î± (Â· < Â·) := by infer_instance; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±] : IsStrictWeakOrder Î± (Â· < Â·)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {r : Î± â†’ Î± â†’ Prop}  {s : Î² â†’ Î² â†’ Prop} [LT Î±]  [WellFoundedLt Î±] [LT Î±]  [WellFoundedGt Î±] [LinearOrder Î±]"},
 {"type": "min a b = a âˆ§ a â‰¤ b âˆ¨ min a b = b âˆ§ b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±) : min a b = a âˆ§ a â‰¤ b âˆ¨ min a b = b âˆ§ b < a := by by_cases a â‰¤ b; sorry",
  "name": "min_cases",
  "kind": "theorem",
  "first-tactic": "by_cases a â‰¤ b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±) : min a b = a âˆ§ a â‰¤ b âˆ¨ min a b = b âˆ§ b < a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±)"},
 {"type": "min a b = c â†” a = c âˆ§ a â‰¤ b âˆ¨ b = c âˆ§ b â‰¤ a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a b = c â†” a = c âˆ§ a â‰¤ b âˆ¨ b = c âˆ§ b â‰¤ a := by constructor; sorry",
  "name": "min_eq_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a b = c â†” a = c âˆ§ a â‰¤ b âˆ¨ b = c âˆ§ b â‰¤ a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min)"},
 {"type": "min a c < min b c â†” a < b âˆ§ a < c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a c < min b c â†” a < b âˆ§ a < c := by simp_rw [lt_min_iff]; sorry",
  "name": "min_lt_min_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [lt_min_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a c < min b c â†” a < b âˆ§ a < c",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min)"},
 {"type": "min a b < min a c â†” b < c âˆ§ b < a",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a b < min a c â†” b < c âˆ§ b < a := by simp_rw [min_comm a]; sorry",
  "name": "min_lt_min_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [min_comm a]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) : min a b < min a c â†” b < c âˆ§ b < a",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min)"},
 {"type": "f (max a b) =\n    max (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : MonotoneOn f s)  (ha : a âˆˆ s)  (hb : b âˆˆ s) : f (max a b) =\n    max (f a) (f b) := by cases le_total a b; sorry",
  "name": "MonotoneOn.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : MonotoneOn f s)  (ha : a âˆˆ s)  (hb : b âˆˆ s) : f (max a b) =\n    max (f a) (f b)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : MonotoneOn f s)  (ha : a âˆˆ s)  (hb : b âˆˆ s)"},
 {"type": "f (max a b) = max (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Monotone f) : f (max a b) = max (f a) (f b) := by cases le_total a b; sorry",
  "name": "Monotone.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Monotone f) : f (max a b) = max (f a) (f b)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Monotone f)"},
 {"type": "f (max a b) = min (f a) (f b)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Antitone f) : f (max a b) = min (f a) (f b) := by cases le_total a b; sorry",
  "name": "Antitone.map_max",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Antitone f) : f (max a b) = min (f a) (f b)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (hf : Antitone f)"},
 {"type": "min a b = a âˆ¨ min a b = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±) : min a b = a âˆ¨ min a b = b := by cases le_total a b; sorry",
  "name": "min_choice",
  "kind": "theorem",
  "first-tactic": "cases le_total a b",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±) : min a b = a âˆ¨ min a b = b",
  "args":
  "{Î± : Type u}  {Î² : Type v}  [LinearOrder Î±]  [LinearOrder Î²]  {f : Î± â†’ Î²}  {s : Set Î±}  {a b c d : Î±}  -- translate from lattices to linear orders (sup â†’ max, inf â†’ min) (a b : Î±)"},
 {"type": "âˆ€ p q : Bool, p âˆ† q = xor p q",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _} : âˆ€ p q : Bool, p âˆ† q = xor p q := by decide; sorry",
  "name": "Bool.symmDiff_eq_xor",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _} : âˆ€ p q : Bool, p âˆ† q = xor p q",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}"},
 {"type": "a âˆ† b = b âˆ† a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b = b âˆ† a := by simp only [symmDiff]; sorry",
  "name": "symmDiff_comm",
  "kind": "theorem",
  "first-tactic": "simp only [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b = b âˆ† a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† a = âŠ¥",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† a = âŠ¥ := by rw [symmDiff]; sorry",
  "name": "symmDiff_self",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† a = âŠ¥",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† âŠ¥ = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† âŠ¥ = a := by rw [symmDiff]; sorry",
  "name": "symmDiff_bot",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† âŠ¥ = a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "âŠ¥ âˆ† a = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : âŠ¥ âˆ† a = a := by rw [symmDiff_comm]; sorry",
  "name": "bot_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : âŠ¥ âˆ† a = a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b = âŠ¥ â†” a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±} : a âˆ† b = âŠ¥ â†” a = b := by simp_rw [symmDiff]; sorry",
  "name": "symmDiff_eq_bot",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±} : a âˆ† b = âŠ¥ â†” a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}"},
 {"type": "a âˆ† b = b \\ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b) : a âˆ† b = b \\ a := by rw [symmDiff]; sorry",
  "name": "symmDiff_of_le",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b) : a âˆ† b = b \\ a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "a âˆ† b = a \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a) : a âˆ† b = a \\ b := by rw [symmDiff]; sorry",
  "name": "symmDiff_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a) : a âˆ† b = a \\ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "a âˆ† b â‰¤ c â†” a â‰¤ b âŠ” c âˆ§ b â‰¤ a âŠ” c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±} : a âˆ† b â‰¤ c â†” a â‰¤ b âŠ” c âˆ§ b â‰¤ a âŠ” c := by simp_rw [symmDiff]; sorry",
  "name": "symmDiff_le_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±} : a âˆ† b â‰¤ c â†” a â‰¤ b âŠ” c âˆ§ b â‰¤ a âŠ” c",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±}"},
 {"type": "a âˆ† b = (a âŠ” b) \\ (a âŠ“ b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b = (a âŠ” b) \\ (a âŠ“ b) := by simp [sup_sdiff]; sorry",
  "name": "symmDiff_eq_sup_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "simp [sup_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b = (a âŠ” b) \\ (a âŠ“ b)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Disjoint a b) : a âˆ† b = a âŠ” b := by rw [symmDiff]; sorry",
  "name": "Disjoint.symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Disjoint a b) : a âˆ† b = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Disjoint a b)"},
 {"type": "a âˆ† b \\ c = a \\ (b âŠ” c) âŠ” b \\ (a âŠ” c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ c = a \\ (b âŠ” c) âŠ” b \\ (a âŠ” c) := by rw [symmDiff]; sorry",
  "name": "symmDiff_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ c = a \\ (b âŠ” c) âŠ” b \\ (a âŠ” c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b \\ (a âŠ“ b) = a âˆ† b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ (a âŠ“ b) = a âˆ† b := by rw [symmDiff_sdiff]; sorry",
  "name": "symmDiff_sdiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ (a âŠ“ b) = a âˆ† b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† (b \\ a) = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† (b \\ a) = a âŠ” b := by rw [symmDiff]; sorry",
  "name": "symmDiff_sdiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† (b \\ a) = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "(a \\ b) âˆ† b = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : (a \\ b) âˆ† b = a âŠ” b := by rw [symmDiff_comm]; sorry",
  "name": "sdiff_symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : (a \\ b) âˆ† b = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âŠ” a âŠ“ b = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b âŠ” a âŠ“ b = a âŠ” b := by refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _; sorry",
  "name": "symmDiff_sup_inf",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm (sup_le symmDiff_le_sup inf_le_sup) _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b âŠ” a âŠ“ b = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âŠ“ b âŠ” a âˆ† b = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âŠ“ b âŠ” a âˆ† b = a âŠ” b := by rw [sup_comm]; sorry",
  "name": "inf_sup_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âŠ“ b âŠ” a âˆ† b = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âˆ† (a âŠ“ b) = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† (a âŠ“ b) = a âŠ” b := by rw [â† symmDiff_sdiff_inf a]; sorry",
  "name": "symmDiff_symmDiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [â† symmDiff_sdiff_inf a]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† (a âŠ“ b) = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "(a âŠ“ b) âˆ† (a âˆ† b) = a âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : (a âŠ“ b) âˆ† (a âˆ† b) = a âŠ” b := by rw [symmDiff_comm]; sorry",
  "name": "inf_symmDiff_symmDiff",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : (a âŠ“ b) âˆ† (a âˆ† b) = a âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† c â‰¤ a âˆ† b âŠ” b âˆ† c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† c â‰¤ a âˆ† b âŠ” b âˆ† c := by refine' (sup_le_sup (sdiff_triangle a b c) <| sdiff_triangle _ b _).trans_eq _; sorry",
  "name": "symmDiff_triangle",
  "kind": "theorem",
  "first-tactic":
  "refine' (sup_le_sup (sdiff_triangle a b c) <| sdiff_triangle _ b _).trans_eq _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±) : a âˆ† c â‰¤ a âˆ† b âŠ” b âˆ† c",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‡” b = b â‡” a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” b = b â‡” a := by simp only [(Â· â‡” Â·)]; sorry",
  "name": "bihimp_comm",
  "kind": "theorem",
  "first-tactic": "simp only [(Â· â‡” Â·)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” b = b â‡” a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‡” a = âŠ¤",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” a = âŠ¤ := by rw [bihimp]; sorry",
  "name": "bihimp_self",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” a = âŠ¤",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‡” âŠ¤ = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” âŠ¤ = a := by rw [bihimp]; sorry",
  "name": "bihimp_top",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” âŠ¤ = a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "âŠ¤ â‡” a = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : âŠ¤ â‡” a = a := by rw [bihimp_comm]; sorry",
  "name": "top_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : âŠ¤ â‡” a = a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‡” b = b â‡¨ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b) : a â‡” b = b â‡¨ a := by rw [bihimp]; sorry",
  "name": "bihimp_of_le",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b) : a â‡” b = b â‡¨ a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "a â‡” b = a â‡¨ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a) : a â‡” b = a â‡¨ b := by rw [bihimp]; sorry",
  "name": "bihimp_of_ge",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a) : a â‡” b = a â‡¨ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "a â‰¤ b â‡” c â†” a âŠ“ b â‰¤ c âˆ§ a âŠ“ c â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±} : a â‰¤ b â‡” c â†” a âŠ“ b â‰¤ c âˆ§ a âŠ“ c â‰¤ b := by simp_rw [bihimp]; sorry",
  "name": "le_bihimp_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±} : a â‰¤ b â‡” c â†” a âŠ“ b â‰¤ c âˆ§ a âŠ“ c â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b c : Î±}"},
 {"type": "a â‡” b = a âŠ” b â‡¨ a âŠ“ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” b = a âŠ” b â‡¨ a âŠ“ b := by simp [himp_inf_distrib]; sorry",
  "name": "bihimp_eq_inf_himp_inf",
  "kind": "theorem",
  "first-tactic": "simp [himp_inf_distrib]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡” b = a âŠ” b â‡¨ a âŠ“ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‡” b = a âŠ“ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Codisjoint a b) : a â‡” b = a âŠ“ b := by rw [bihimp]; sorry",
  "name": "Codisjoint.bihimp_eq_inf",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Codisjoint a b) : a â‡” b = a âŠ“ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) {a b : Î±}  (h : Codisjoint a b)"},
 {"type": "a â‡¨ b â‡” c = (a âŠ“ c â‡¨ b) âŠ“ (a âŠ“ b â‡¨ c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡¨ b â‡” c = (a âŠ“ c â‡¨ b) âŠ“ (a âŠ“ b â‡¨ c) := by rw [bihimp]; sorry",
  "name": "himp_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a â‡¨ b â‡” c = (a âŠ“ c â‡¨ b) âŠ“ (a âŠ“ b â‡¨ c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âŠ” b â‡¨ a â‡” b = a â‡” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a âŠ” b â‡¨ a â‡” b = a â‡” b := by rw [himp_bihimp]; sorry",
  "name": "sup_himp_bihimp",
  "kind": "theorem",
  "first-tactic": "rw [himp_bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±) : a âŠ” b â‡¨ a â‡” b = a â‡” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† âŠ¤ = ï¿¢a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : a âˆ† âŠ¤ = ï¿¢a := by simp [symmDiff]; sorry",
  "name": "symmDiff_top'",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : a âˆ† âŠ¤ = ï¿¢a",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±)"},
 {"type": "âŠ¤ âˆ† a = ï¿¢a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : âŠ¤ âˆ† a = ï¿¢a := by simp [symmDiff]; sorry",
  "name": "top_symmDiff'",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : âŠ¤ âˆ† a = ï¿¢a",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±)"},
 {"type": "(ï¿¢a) âˆ† a = âŠ¤",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : (ï¿¢a) âˆ† a = âŠ¤ := by rw [eq_top_iff]; sorry",
  "name": "hnot_symmDiff_self",
  "kind": "theorem",
  "first-tactic": "rw [eq_top_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : (ï¿¢a) âˆ† a = âŠ¤",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±)"},
 {"type": "a âˆ† (ï¿¢a) = âŠ¤",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : a âˆ† (ï¿¢a) = âŠ¤ := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_hnot_self",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) : a âˆ† (ï¿¢a) = âŠ¤",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±)"},
 {"type": "a âˆ† b = âŠ¤",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b) : a âˆ† b = âŠ¤ := by rw [h.eq_hnot]; sorry",
  "name": "IsCompl.symmDiff_eq_top",
  "kind": "theorem",
  "first-tactic": "rw [h.eq_hnot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b) : a âˆ† b = âŠ¤",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b)"},
 {"type": "a â‡” âŠ¥ = aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) : a â‡” âŠ¥ = aá¶œ := by simp [bihimp]; sorry",
  "name": "bihimp_bot",
  "kind": "theorem",
  "first-tactic": "simp [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) : a â‡” âŠ¥ = aá¶œ",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±)"},
 {"type": "âŠ¥ â‡” a = aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) : âŠ¥ â‡” a = aá¶œ := by simp [bihimp]; sorry",
  "name": "bot_bihimp",
  "kind": "theorem",
  "first-tactic": "simp [bihimp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) : âŠ¥ â‡” a = aá¶œ",
  "args": "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±)"},
 {"type": "a â‡” b = âŠ¥",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b) : a â‡” b = âŠ¥ := by rw [h.eq_compl]; sorry",
  "name": "IsCompl.bihimp_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [h.eq_compl]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b) : a â‡” b = âŠ¥",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  (a : Î±) {a b : Î±}  (h : IsCompl a b)"},
 {"type": "Disjoint (a âˆ† b) (a âŠ“ b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : Disjoint (a âˆ† b) (a âŠ“ b) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "disjoint_symmDiff_inf",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : Disjoint (a âˆ† b) (a âŠ“ b)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âŠ“ b âˆ† c = (a âŠ“ b) âˆ† (a âŠ“ c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âŠ“ b âˆ† c = (a âŠ“ b) âˆ† (a âŠ“ c) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "inf_symmDiff_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âŠ“ b âˆ† c = (a âŠ“ b) âˆ† (a âŠ“ c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âŠ“ c = (a âŠ“ c) âˆ† (b âŠ“ c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âŠ“ c = (a âŠ“ c) âˆ† (b âŠ“ c) := by simp_rw [@inf_comm _ _ _ c]; sorry",
  "name": "inf_symmDiff_distrib_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [@inf_comm _ _ _ c]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âŠ“ c = (a âŠ“ c) âˆ† (b âŠ“ c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ a âŠ“ c \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ a âŠ“ c \\ b := by simp only [(Â· âˆ† Â·)]; sorry",
  "name": "sdiff_symmDiff",
  "kind": "theorem",
  "first-tactic": "simp only [(Â· âˆ† Â·)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ a âŠ“ c \\ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ (a âŠ” b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ (a âŠ” b) := by rw [sdiff_symmDiff]; sorry",
  "name": "sdiff_symmDiff'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : c \\ a âˆ† b = c âŠ“ a âŠ“ b âŠ” c \\ (a âŠ” b)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b \\ a = b \\ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ a = b \\ a := by rw [symmDiff_def]; sorry",
  "name": "symmDiff_sdiff_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_def]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ a = b \\ a",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b \\ b = a \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ b = a \\ b := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_sdiff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b \\ b = a \\ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a \\ a âˆ† b = a âŠ“ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a \\ a âˆ† b = a âŠ“ b := by simp [sdiff_symmDiff]; sorry",
  "name": "sdiff_symmDiff_left",
  "kind": "theorem",
  "first-tactic": "simp [sdiff_symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a \\ a âˆ† b = a âŠ“ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "b \\ a âˆ† b = a âŠ“ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b \\ a âˆ† b = a âŠ“ b := by rw [symmDiff_comm]; sorry",
  "name": "sdiff_symmDiff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b \\ a âˆ† b = a âŠ“ b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b = a âŠ” b â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b = a âŠ” b â†” Disjoint a b := by refine' âŸ¨fun h => _, Disjoint.symmDiff_eq_supâŸ©; sorry",
  "name": "symmDiff_eq_sup",
  "kind": "theorem",
  "first-tactic": "refine' âŸ¨fun h => _, Disjoint.symmDiff_eq_supâŸ©",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b = a âŠ” b â†” Disjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a â‰¤ a âˆ† b â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a â‰¤ a âˆ† b â†” Disjoint a b := by refine' âŸ¨fun h => _, fun h => h.symmDiff_eq_sup.symm â–¸ le_sup_leftâŸ©; sorry",
  "name": "le_symmDiff_iff_left",
  "kind": "theorem",
  "first-tactic":
  "refine' âŸ¨fun h => _, fun h => h.symmDiff_eq_sup.symm â–¸ le_sup_leftâŸ©",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a â‰¤ a âˆ† b â†” Disjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "b â‰¤ a âˆ† b â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b â‰¤ a âˆ† b â†” Disjoint a b := by rw [symmDiff_comm]; sorry",
  "name": "le_symmDiff_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b â‰¤ a âˆ† b â†” Disjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âˆ† c = a âˆ† (b âˆ† c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† c = a âˆ† (b âˆ† c) := by rw [symmDiff_symmDiff_left]; sorry",
  "name": "symmDiff_assoc",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_symmDiff_left]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† c = a âˆ† (b âˆ† c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† (b âˆ† c) = b âˆ† (a âˆ† c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† (b âˆ† c) = b âˆ† (a âˆ† c) := by simp_rw [â† symmDiff_assoc]; sorry",
  "name": "symmDiff_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† symmDiff_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† (b âˆ† c) = b âˆ† (a âˆ† c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âˆ† c = a âˆ† c âˆ† b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† c = a âˆ† c âˆ† b := by simp_rw [symmDiff_assoc]; sorry",
  "name": "symmDiff_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† c = a âˆ† c âˆ† b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âˆ† (c âˆ† d) = a âˆ† c âˆ† (b âˆ† d)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† (c âˆ† d) = a âˆ† c âˆ† (b âˆ† d) := by simp_rw [symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_symmDiff_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† (c âˆ† d) = a âˆ† c âˆ† (b âˆ† d)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† (a âˆ† b) = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† (a âˆ† b) = b := by simp [â† symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp [â† symmDiff_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† (a âˆ† b) = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "b âˆ† a âˆ† a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b âˆ† a âˆ† a = b := by simp [symmDiff_assoc]; sorry",
  "name": "symmDiff_symmDiff_cancel_right",
  "kind": "theorem",
  "first-tactic": "simp [symmDiff_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : b âˆ† a âˆ† a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b âˆ† a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† a = b := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_symmDiff_self'",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b âˆ† a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "a âˆ† b = b â†” a = âŠ¥",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b = b â†” a = âŠ¥ := by rw [symmDiff_comm]; sorry",
  "name": "symmDiff_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) : a âˆ† b = b â†” a = âŠ¥",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±)"},
 {"type": "Disjoint (a âˆ† b) c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : Disjoint a c)  (hb : Disjoint b c) : Disjoint (a âˆ† b) c := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "Disjoint.symmDiff_left",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : Disjoint a c)  (hb : Disjoint b c) : Disjoint (a âˆ† b) c",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : Disjoint a c)  (hb : Disjoint b c)"},
 {"type": "a âˆ† b = c â†” c \\ a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : a â‰¤ c) : a âˆ† b = c â†” c \\ a = b := by rw [â† symmDiff_of_le ha]; sorry",
  "name": "symmDiff_eq_iff_sdiff_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† symmDiff_of_le ha]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : a â‰¤ c) : a âˆ† b = c â†” c \\ a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [GeneralizedBooleanAlgebra Î±]  (a b c d : Î±) (ha : a â‰¤ c)"},
 {"type": "a â‡” (b â‡” c) = b â‡” (a â‡” c)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” (b â‡” c) = b â‡” (a â‡” c) := by simp_rw [â† bihimp_assoc]; sorry",
  "name": "bihimp_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† bihimp_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” (b â‡” c) = b â‡” (a â‡” c)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” b â‡” c = a â‡” c â‡” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” c = a â‡” c â‡” b := by simp_rw [bihimp_assoc]; sorry",
  "name": "bihimp_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” c = a â‡” c â‡” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” b â‡” (c â‡” d) = a â‡” c â‡” (b â‡” d)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” (c â‡” d) = a â‡” c â‡” (b â‡” d) := by simp_rw [bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_bihimp_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [bihimp_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” (c â‡” d) = a â‡” c â‡” (b â‡” d)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” (a â‡” b) = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” (a â‡” b) = b := by simp [â† bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp [â† bihimp_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” (a â‡” b) = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "b â‡” a â‡” a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : b â‡” a â‡” a = b := by simp [bihimp_assoc]; sorry",
  "name": "bihimp_bihimp_cancel_right",
  "kind": "theorem",
  "first-tactic": "simp [bihimp_assoc]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : b â‡” a â‡” a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” b â‡” a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” a = b := by rw [bihimp_comm]; sorry",
  "name": "bihimp_bihimp_self",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b â‡” a = b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a âˆ† b = a âŠ“ bá¶œ âŠ” b âŠ“ aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = a âŠ“ bá¶œ âŠ” b âŠ“ aá¶œ := by simp only [(Â· âˆ† Â·)]; sorry",
  "name": "symmDiff_eq",
  "kind": "theorem",
  "first-tactic": "simp only [(Â· âˆ† Â·)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = a âŠ“ bá¶œ âŠ” b âŠ“ aá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” b = (a âŠ” bá¶œ) âŠ“ (b âŠ” aá¶œ)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b = (a âŠ” bá¶œ) âŠ“ (b âŠ” aá¶œ) := by simp only [(Â· â‡” Â·)]; sorry",
  "name": "bihimp_eq",
  "kind": "theorem",
  "first-tactic": "simp only [(Â· â‡” Â·)]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b = (a âŠ” bá¶œ) âŠ“ (b âŠ” aá¶œ)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a âˆ† b = (a âŠ” b) âŠ“ (aá¶œ âŠ” bá¶œ)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = (a âŠ” b) âŠ“ (aá¶œ âŠ” bá¶œ) := by rw [symmDiff_eq_sup_sdiff_inf]; sorry",
  "name": "symmDiff_eq'",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq_sup_sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = (a âŠ” b) âŠ“ (aá¶œ âŠ” bá¶œ)",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "(a âˆ† b)á¶œ = a â‡” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : (a âˆ† b)á¶œ = a â‡” b := by simp_rw [symmDiff]; sorry",
  "name": "compl_symmDiff",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : (a âˆ† b)á¶œ = a â‡” b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a âˆ† b = âŠ¤ â†” IsCompl a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = âŠ¤ â†” IsCompl a b := by rw [symmDiff_eq']; sorry",
  "name": "symmDiff_eq_top",
  "kind": "theorem",
  "first-tactic": "rw [symmDiff_eq']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a âˆ† b = âŠ¤ â†” IsCompl a b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "a â‡” b = âŠ¥ â†” IsCompl a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b = âŠ¥ â†” IsCompl a b := by rw [bihimp_eq']; sorry",
  "name": "bihimp_eq_bot",
  "kind": "theorem",
  "first-tactic": "rw [bihimp_eq']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ : a â‡” b = âŠ¥ â†” IsCompl a b",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/"},
 {"type": "c â‰¤ a âˆ† c âŠ” b âˆ† c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b) : c â‰¤ a âˆ† c âŠ” b âˆ† c := by trans c \\ (a âŠ“ b); sorry",
  "name": "Disjoint.le_symmDiff_sup_symmDiff_left",
  "kind": "theorem",
  "first-tactic": "trans c \\ (a âŠ“ b)",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b) : c â‰¤ a âˆ† c âŠ” b âˆ† c",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint a b)"},
 {"type": "a â‰¤ a âˆ† b âŠ” a âˆ† c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c) : a â‰¤ a âˆ† b âŠ” a âˆ† c := by simp_rw [symmDiff_comm a]; sorry",
  "name": "Disjoint.le_symmDiff_sup_symmDiff_right",
  "kind": "theorem",
  "first-tactic": "simp_rw [symmDiff_comm a]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c) : a â‰¤ a âˆ† b âŠ” a âˆ† c",
  "args":
  "{Î¹ Î± Î² : Type _}  {Ï€ : Î¹ â†’ Type _}  [BooleanAlgebra Î±]  (a b c d : Î±)  /- `CogeneralizedBooleanAlgebra` isn't actually a typeclass, but the lemmas in here are dual to the `GeneralizedBooleanAlgebra` ones -/ (h : Disjoint b c)"},
 {"type": "a â‰¤ b â‡¨ c â†” b âŠ“ a â‰¤ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ b â‡¨ c â†” b âŠ“ a â‰¤ c := by rw [le_himp_iff]; sorry",
  "name": "le_himp_iff'",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ b â‡¨ c â†” b âŠ“ a â‰¤ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "a â‰¤ b â‡¨ c â†” b â‰¤ a â‡¨ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ b â‡¨ c â†” b â‰¤ a â‡¨ c := by rw [le_himp_iff]; sorry",
  "name": "le_himp_comm",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ b â‡¨ c â†” b â‰¤ a â‡¨ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "a â‰¤ a â‡¨ b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ a â‡¨ b â†” a â‰¤ b := by rw [le_himp_iff]; sorry",
  "name": "le_himp_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‰¤ a â‡¨ b â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "a âŠ“ (a â‡¨ b) â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a âŠ“ (a â‡¨ b) â‰¤ b := by rw [inf_comm]; sorry",
  "name": "inf_himp_le",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a âŠ“ (a â‡¨ b) â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "(a â‡¨ b) âŠ“ a = b âŠ“ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : (a â‡¨ b) âŠ“ a = b âŠ“ a := by rw [inf_comm]; sorry",
  "name": "himp_inf_self",
  "kind": "theorem",
  "first-tactic": "rw [inf_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : (a â‡¨ b) âŠ“ a = b âŠ“ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±)"},
 {"type": "a â‡¨ b = âŠ¤ â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‡¨ b = âŠ¤ â†” a â‰¤ b := by rw [â† top_le_iff]; sorry",
  "name": "himp_eq_top_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† top_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : a â‡¨ b = âŠ¤ â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "b â‡¨ c â‰¤ (a â‡¨ b) â‡¨ a â‡¨ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : b â‡¨ c â‰¤ (a â‡¨ b) â‡¨ a â‡¨ c := by rw [le_himp_iff]; sorry",
  "name": "himp_le_himp_himp_himp",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : b â‡¨ c â‰¤ (a â‡¨ b) â‡¨ a â‡¨ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "(b â‡¨ c) âŠ“ (a â‡¨ b) âŠ“ a â‰¤ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : (b â‡¨ c) âŠ“ (a â‡¨ b) âŠ“ a â‰¤ c := by simpa using @himp_le_himp_himp_himp; sorry",
  "name": "himp_inf_himp_inf_le",
  "kind": "theorem",
  "first-tactic": "simpa using @himp_le_himp_himp_himp",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : (b â‡¨ c) âŠ“ (a â‡¨ b) âŠ“ a â‰¤ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "a â‡¨ b â‡¨ c = b â‡¨ a â‡¨ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±) : a â‡¨ b â‡¨ c = b â‡¨ a â‡¨ c := by simp_rw [himp_himp]; sorry",
  "name": "himp_left_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [himp_himp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±) : a â‡¨ b â‡¨ c = b â‡¨ a â‡¨ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±)"},
 {"type": "b â‡¨ b â‡¨ a = b â‡¨ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : b â‡¨ b â‡¨ a = b â‡¨ a := by rw [himp_himp]; sorry",
  "name": "himp_idem",
  "kind": "theorem",
  "first-tactic": "rw [himp_himp]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` : b â‡¨ b â‡¨ a = b â‡¨ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r`"},
 {"type": "a âŠ” b â‡¨ a = b â‡¨ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : a âŠ” b â‡¨ a = b â‡¨ a := by rw [sup_himp_distrib]; sorry",
  "name": "sup_himp_self_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_himp_distrib]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : a âŠ” b â‡¨ a = b â‡¨ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±)"},
 {"type": "a âŠ” b â‡¨ b = a â‡¨ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : a âŠ” b â‡¨ b = a â‡¨ b := by rw [sup_himp_distrib]; sorry",
  "name": "sup_himp_self_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_himp_distrib]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±) : a âŠ” b â‡¨ b = a â‡¨ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b : Î±)"},
 {"type": "b â‡¨ a = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : b â‡¨ a = a := by conv_rhs => rw [â† @top_himp _ _ a]; sorry",
  "name": "Codisjoint.himp_eq_right",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [â† @top_himp _ _ a]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : b â‡¨ a = a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b)"},
 {"type": "a â‡¨ a âŠ“ b = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : a â‡¨ a âŠ“ b = b := by rw [himp_inf_distrib]; sorry",
  "name": "Codisjoint.himp_inf_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [himp_inf_distrib]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : a â‡¨ a âŠ“ b = b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b)"},
 {"type": "b â‡¨ a âŠ“ b = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : b â‡¨ a âŠ“ b = a := by rw [himp_inf_distrib]; sorry",
  "name": "Codisjoint.himp_inf_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [himp_inf_distrib]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b) : b â‡¨ a âŠ“ b = a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (h : Codisjoint a b)"},
 {"type": "(a â‡¨ b) âŠ“ (b â‡¨ c) â‰¤ a â‡¨ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±) : (a â‡¨ b) âŠ“ (b â‡¨ c) â‰¤ a â‡¨ c := by rw [le_himp_iff]; sorry",
  "name": "himp_triangle",
  "kind": "theorem",
  "first-tactic": "rw [le_himp_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±) : (a â‡¨ b) âŠ“ (b â‡¨ c) â‰¤ a â‡¨ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedHeytingAlgebra Î±]  {a b c d : Î±}  /- In this section, we'll give interpretations of these results in the Heyting algebra model of intuitionistic logic,- where `â‰¤` can be interpreted as \"validates\", `â‡¨` as \"implies\", `âŠ“` as \"and\", `âŠ”` as \"or\", `âŠ¥` as \"false\" and `âŠ¤` as \"true\". Note that we confuse `â†’` and `âŠ¢` because those are the same in this logic.  See also `Prop.heyting_algebra`. -/ -- `p â†’ q â†’ r â†” p âˆ§ q â†’ r` (a b c : Î±)"},
 {"type": "a \\ b â‰¤ c â†” a â‰¤ c âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ c â†” a â‰¤ c âŠ” b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_iff'",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ c â†” a â‰¤ c âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "a \\ b â‰¤ c â†” a \\ c â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ c â†” a \\ c â‰¤ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_comm",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ c â†” a \\ c â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "a \\ b â‰¤ b â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ b â†” a â‰¤ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_le_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b â‰¤ b â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "a â‰¤ a \\ b âŠ” b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a â‰¤ a \\ b âŠ” b := by rw [sup_comm]; sorry",
  "name": "le_sdiff_sup",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a â‰¤ a \\ b âŠ” b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "b \\ a âŠ” a = b âŠ” a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : b \\ a âŠ” a = b âŠ” a := by rw [sup_comm]; sorry",
  "name": "sdiff_sup_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : b \\ a âŠ” a = b âŠ” a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±)"},
 {"type": "b âŠ” c \\ a = c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c) : b âŠ” c \\ a = c := by rw [sup_sdiff_eq_sup hab]; sorry",
  "name": "sup_sdiff_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff_eq_sup hab]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c) : b âŠ” c \\ a = c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (hab : a â‰¤ b)  (hbc : b â‰¤ c)"},
 {"type": "a \\ b âŠ” b = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : b â‰¤ a) : a \\ b âŠ” b = a := by rw [sup_comm]; sorry",
  "name": "sdiff_sup_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : b â‰¤ a) : a \\ b âŠ” b = a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : b â‰¤ a)"},
 {"type": "a \\ b = âŠ¥ â†” a â‰¤ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b = âŠ¥ â†” a â‰¤ b := by rw [â† le_bot_iff]; sorry",
  "name": "sdiff_eq_bot_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† le_bot_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a \\ b = âŠ¥ â†” a â‰¤ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "(a \\ b) \\ (a \\ c) â‰¤ c \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ (a \\ c) â‰¤ c \\ b := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_sdiff_sdiff_le_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ (a \\ c) â‰¤ c \\ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "a â‰¤ b âŠ” (a \\ c âŠ” c \\ b)",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a â‰¤ b âŠ” (a \\ c âŠ” c \\ b) := by simpa using @sdiff_sdiff_sdiff_le_sdiff; sorry",
  "name": "le_sup_sdiff_sup_sdiff",
  "kind": "theorem",
  "first-tactic": "simpa using @sdiff_sdiff_sdiff_le_sdiff",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : a â‰¤ b âŠ” (a \\ c âŠ” c \\ b)",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "(a \\ b) \\ c = (a \\ c) \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±) : (a \\ b) \\ c = (a \\ c) \\ b := by simp_rw [sdiff_sdiff]; sorry",
  "name": "sdiff_right_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [sdiff_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±) : (a \\ b) \\ c = (a \\ c) \\ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "(a \\ b) \\ b = a \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ b = a \\ b := by rw [sdiff_sdiff_left]; sorry",
  "name": "sdiff_idem",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_left]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ b = a \\ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "(a \\ b) \\ a = âŠ¥",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ a = âŠ¥ := by rw [sdiff_sdiff_comm]; sorry",
  "name": "sdiff_sdiff_self",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_sdiff_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a \\ b) \\ a = âŠ¥",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "(a âŠ” b) \\ b = a \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a âŠ” b) \\ b = a \\ b := by rw [sup_sdiff]; sorry",
  "name": "sup_sdiff_right_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a âŠ” b) \\ b = a \\ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "(a âŠ” b) \\ a = b \\ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a âŠ” b) \\ a = b \\ a := by rw [sup_comm]; sorry",
  "name": "sup_sdiff_left_self",
  "kind": "theorem",
  "first-tactic": "rw [sup_comm]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} : (a âŠ” b) \\ a = b \\ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±}"},
 {"type": "a \\ (a âŠ“ b) = a \\ b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : a \\ (a âŠ“ b) = a \\ b := by rw [sdiff_inf]; sorry",
  "name": "sdiff_inf_self_left",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : a \\ (a âŠ“ b) = a \\ b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±)"},
 {"type": "b \\ (a âŠ“ b) = b \\ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : b \\ (a âŠ“ b) = b \\ a := by rw [sdiff_inf]; sorry",
  "name": "sdiff_inf_self_right",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_inf]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±) : b \\ (a âŠ“ b) = b \\ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b : Î±)"},
 {"type": "a \\ b = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : a \\ b = a := by conv_rhs => rw [â† @sdiff_bot _ _ a]; sorry",
  "name": "Disjoint.sdiff_eq_left",
  "kind": "theorem",
  "first-tactic": "conv_rhs => rw [â† @sdiff_bot _ _ a]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : a \\ b = a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b)"},
 {"type": "(a âŠ” b) \\ a = b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : (a âŠ” b) \\ a = b := by rw [sup_sdiff]; sorry",
  "name": "Disjoint.sup_sdiff_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : (a âŠ” b) \\ a = b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b)"},
 {"type": "(a âŠ” b) \\ b = a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : (a âŠ” b) \\ b = a := by rw [sup_sdiff]; sorry",
  "name": "Disjoint.sup_sdiff_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [sup_sdiff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b) : (a âŠ” b) \\ b = a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : Disjoint a b)"},
 {"type": "a \\ c â‰¤ a \\ b âŠ” b \\ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±) : a \\ c â‰¤ a \\ b âŠ” b \\ c := by rw [sdiff_le_iff]; sorry",
  "name": "sdiff_triangle",
  "kind": "theorem",
  "first-tactic": "rw [sdiff_le_iff]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±) : a \\ c â‰¤ a \\ b âŠ” b \\ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (a b c : Î±)"},
 {"type": "a \\ c â‰¤ b \\ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : c âŠ” a â‰¤ c âŠ” b) : a \\ c â‰¤ b \\ c := by rw [â† sup_sdiff_left_self]; sorry",
  "name": "sdiff_le_sdiff_of_sup_le_sup_left",
  "kind": "theorem",
  "first-tactic": "rw [â† sup_sdiff_left_self]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : c âŠ” a â‰¤ c âŠ” b) : a \\ c â‰¤ b \\ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : c âŠ” a â‰¤ c âŠ” b)"},
 {"type": "a \\ c â‰¤ b \\ c",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : a âŠ” c â‰¤ b âŠ” c) : a \\ c â‰¤ b \\ c := by rw [â† sup_sdiff_right_self]; sorry",
  "name": "sdiff_le_sdiff_of_sup_le_sup_right",
  "kind": "theorem",
  "first-tactic": "rw [â† sup_sdiff_right_self]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : a âŠ” c â‰¤ b âŠ” c) : a \\ c â‰¤ b \\ c",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [GeneralizedCoheytingAlgebra Î±]  {a b c d : Î±} (h : a âŠ” c â‰¤ b âŠ” c)"},
 {"type": "(a âŠ” b)á¶œ = aá¶œ âŠ“ bá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a âŠ” b)á¶œ = aá¶œ âŠ“ bá¶œ := by simp_rw [â† himp_bot]; sorry",
  "name": "compl_sup_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† himp_bot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a âŠ” b)á¶œ = aá¶œ âŠ“ bá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "a â‡¨ aá¶œ = aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a : Î±) : a â‡¨ aá¶œ = aá¶œ := by rw [â† himp_bot]; sorry",
  "name": "himp_compl",
  "kind": "theorem",
  "first-tactic": "rw [â† himp_bot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a : Î±) : a â‡¨ aá¶œ = aá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a : Î±)"},
 {"type": "a â‡¨ bá¶œ = b â‡¨ aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : a â‡¨ bá¶œ = b â‡¨ aá¶œ := by simp_rw [â† himp_bot]; sorry",
  "name": "himp_compl_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† himp_bot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : a â‡¨ bá¶œ = b â‡¨ aá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "a â‰¤ bá¶œ â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : a â‰¤ bá¶œ â†” Disjoint a b := by rw [â† himp_bot]; sorry",
  "name": "le_compl_iff_disjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [â† himp_bot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : a â‰¤ bá¶œ â†” Disjoint a b",
  "args": "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "a â‰¤ bá¶œ â†” b â‰¤ aá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : a â‰¤ bá¶œ â†” b â‰¤ aá¶œ := by rw [le_compl_iff_disjoint_right]; sorry",
  "name": "le_compl_comm",
  "kind": "theorem",
  "first-tactic": "rw [le_compl_iff_disjoint_right]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : a â‰¤ bá¶œ â†” b â‰¤ aá¶œ",
  "args": "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "(âŠ¥ : Î±)á¶œ = âŠ¤",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : (âŠ¥ : Î±)á¶œ = âŠ¤ := by rw [â† himp_bot]; sorry",
  "name": "compl_bot",
  "kind": "theorem",
  "first-tactic": "rw [â† himp_bot]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : (âŠ¥ : Î±)á¶œ = âŠ¤",
  "args": "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "Disjoint (aá¶œá¶œ) b â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : Disjoint (aá¶œá¶œ) b â†” Disjoint a b := by simp_rw [â† le_compl_iff_disjoint_left]; sorry",
  "name": "disjoint_compl_compl_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† le_compl_iff_disjoint_left]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : Disjoint (aá¶œá¶œ) b â†” Disjoint a b",
  "args": "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "Disjoint a (bá¶œá¶œ) â†” Disjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : Disjoint a (bá¶œá¶œ) â†” Disjoint a b := by simp_rw [â† le_compl_iff_disjoint_right]; sorry",
  "name": "disjoint_compl_compl_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† le_compl_iff_disjoint_right]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} : Disjoint a (bá¶œá¶œ) â†” Disjoint a b",
  "args": "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "(a âŠ“ b)á¶œá¶œ = aá¶œá¶œ âŠ“ bá¶œá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a âŠ“ b)á¶œá¶œ = aá¶œá¶œ âŠ“ bá¶œá¶œ := by refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _; sorry",
  "name": "compl_compl_inf_distrib",
  "kind": "theorem",
  "first-tactic":
  "refine' ((compl_anti compl_sup_compl_le).trans (compl_sup_distrib _ _).le).antisymm _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a âŠ“ b)á¶œá¶œ = aá¶œá¶œ âŠ“ bá¶œá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "(a â‡¨ b)á¶œá¶œ = aá¶œá¶œ â‡¨ bá¶œá¶œ",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a â‡¨ b)á¶œá¶œ = aá¶œá¶œ â‡¨ bá¶œá¶œ := by refine' le_antisymm _ _; sorry",
  "name": "compl_compl_himp_distrib",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : (a â‡¨ b)á¶œá¶œ = aá¶œá¶œ â‡¨ bá¶œá¶œ",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [HeytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "ï¿¢(a âŠ“ b) = ï¿¢a âŠ” ï¿¢b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢(a âŠ“ b) = ï¿¢a âŠ” ï¿¢b := by simp_rw [â† top_sdiff']; sorry",
  "name": "hnot_inf_distrib",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† top_sdiff']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢(a âŠ“ b) = ï¿¢a âŠ” ï¿¢b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "ï¿¢a \\ a = ï¿¢a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a : Î±) : ï¿¢a \\ a = ï¿¢a := by rw [â† top_sdiff']; sorry",
  "name": "hnot_sdiff",
  "kind": "theorem",
  "first-tactic": "rw [â† top_sdiff']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a : Î±) : ï¿¢a \\ a = ï¿¢a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a : Î±)"},
 {"type": "ï¿¢a \\ b = ï¿¢b \\ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢a \\ b = ï¿¢b \\ a := by simp_rw [â† top_sdiff']; sorry",
  "name": "hnot_sdiff_comm",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† top_sdiff']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢a \\ b = ï¿¢b \\ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "ï¿¢a â‰¤ b â†” Codisjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢a â‰¤ b â†” Codisjoint a b := by rw [â† top_sdiff']; sorry",
  "name": "hnot_le_iff_codisjoint_right",
  "kind": "theorem",
  "first-tactic": "rw [â† top_sdiff']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢a â‰¤ b â†” Codisjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "ï¿¢a â‰¤ b â†” ï¿¢b â‰¤ a",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢a â‰¤ b â†” ï¿¢b â‰¤ a := by rw [hnot_le_iff_codisjoint_right]; sorry",
  "name": "hnot_le_comm",
  "kind": "theorem",
  "first-tactic": "rw [hnot_le_iff_codisjoint_right]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢a â‰¤ b â†” ï¿¢b â‰¤ a",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "ï¿¢(âŠ¤ : Î±) = âŠ¥",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢(âŠ¤ : Î±) = âŠ¥ := by rw [â† top_sdiff']; sorry",
  "name": "hnot_top",
  "kind": "theorem",
  "first-tactic": "rw [â† top_sdiff']",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : ï¿¢(âŠ¤ : Î±) = âŠ¥",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "Codisjoint (ï¿¢ï¿¢a) b â†” Codisjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : Codisjoint (ï¿¢ï¿¢a) b â†” Codisjoint a b := by simp_rw [â† hnot_le_iff_codisjoint_right]; sorry",
  "name": "codisjoint_hnot_hnot_left_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† hnot_le_iff_codisjoint_right]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : Codisjoint (ï¿¢ï¿¢a) b â†” Codisjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "Codisjoint a (ï¿¢ï¿¢b) â†” Codisjoint a b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : Codisjoint a (ï¿¢ï¿¢b) â†” Codisjoint a b := by simp_rw [â† hnot_le_iff_codisjoint_left]; sorry",
  "name": "codisjoint_hnot_hnot_right_iff",
  "kind": "theorem",
  "first-tactic": "simp_rw [â† hnot_le_iff_codisjoint_left]",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} : Codisjoint a (ï¿¢ï¿¢b) â†” Codisjoint a b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±}"},
 {"type": "ï¿¢ï¿¢(a âŠ” b) = ï¿¢ï¿¢a âŠ” ï¿¢ï¿¢b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢ï¿¢(a âŠ” b) = ï¿¢ï¿¢a âŠ” ï¿¢ï¿¢b := by refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _; sorry",
  "name": "hnot_hnot_sup_distrib",
  "kind": "theorem",
  "first-tactic":
  "refine' ((hnot_inf_distrib _ _).ge.trans <| hnot_anti le_hnot_inf_hnot).antisymm' _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢ï¿¢(a âŠ” b) = ï¿¢ï¿¢a âŠ” ï¿¢ï¿¢b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "ï¿¢ï¿¢(a \\ b) = ï¿¢ï¿¢a \\ ï¿¢ï¿¢b",
  "tactic-prompt":
  "theorem {Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢ï¿¢(a \\ b) = ï¿¢ï¿¢a \\ ï¿¢ï¿¢b := by refine' le_antisymm _ _; sorry",
  "name": "hnot_hnot_sdiff_distrib",
  "kind": "theorem",
  "first-tactic": "refine' le_antisymm _ _",
  "core-prompt":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±) : ï¿¢ï¿¢(a \\ b) = ï¿¢ï¿¢a \\ ï¿¢ï¿¢b",
  "args":
  "{Î¹ Î± Î² : Type _} {Ï€ : Î¹ â†’ Type _}  [CoheytingAlgebra Î±]  {a b c : Î±} (a b : Î±)"},
 {"type": "(a âˆ§ b âˆ¨ Â¬(a âˆ§ b)) âˆ§ ((a âˆ¨ b) âˆ¨ Â¬(a âˆ¨ b)) â†’ a âˆ¨ Â¬a",
  "tactic-prompt":
  "example {Î± : Type _} [CoheytingAlgebra Î±]  {a b : Î±} (a b : Prop) : (a âˆ§ b âˆ¨ Â¬(a âˆ§ b)) âˆ§ ((a âˆ¨ b) âˆ¨ Â¬(a âˆ¨ b)) â†’ a âˆ¨ Â¬a := by rintro âŸ¨âŸ¨ha, _âŸ© | hnab, (ha | hb) | hnabâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro âŸ¨âŸ¨ha, _âŸ© | hnab, (ha | hb) | hnabâŸ©",
  "core-prompt":
  "{Î± : Type _} [CoheytingAlgebra Î±]  {a b : Î±} (a b : Prop) : (a âˆ§ b âˆ¨ Â¬(a âˆ§ b)) âˆ§ ((a âˆ¨ b) âˆ¨ Â¬(a âˆ¨ b)) â†’ a âˆ¨ Â¬a",
  "args": "{Î± : Type _} [CoheytingAlgebra Î±]  {a b : Î±} (a b : Prop)"},
 {"type": "IsFixedPt f (f x)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {x : Î±}  (hx : IsFixedPt f x) : IsFixedPt f (f x) := by convert hx; sorry",
  "name": "apply",
  "kind": "theorem",
  "first-tactic": "convert hx",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {x : Î±}  (hx : IsFixedPt f x) : IsFixedPt f (f x)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {x : Î±}  (hx : IsFixedPt f x)"},
 {"type": "IsFixedPt (Set.preimage (f^[n])) s",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {s : Set Î±}  (h : IsFixedPt (Set.preimage f) s)  (n : â„•) : IsFixedPt (Set.preimage (f^[n])) s := by rw [Set.preimage_iterate_eq]; sorry",
  "name": "preimage_iterate",
  "kind": "theorem",
  "first-tactic": "rw [Set.preimage_iterate_eq]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {s : Set Î±}  (h : IsFixedPt (Set.preimage f) s)  (n : â„•) : IsFixedPt (Set.preimage (f^[n])) s",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {s : Set Î±}  (h : IsFixedPt (Set.preimage f) s)  (n : â„•)"},
 {"type": "IsFixedPt (â‡‘(e ^ n)) x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : IsFixedPt e x)  (n : â„•) : IsFixedPt (â‡‘(e ^ n)) x := by rw [â† Equiv.Perm.iterate_eq_pow]; sorry",
  "name": "perm_pow",
  "kind": "theorem",
  "first-tactic": "rw [â† Equiv.Perm.iterate_eq_pow]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : IsFixedPt e x)  (n : â„•) : IsFixedPt (â‡‘(e ^ n)) x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : IsFixedPt e x)  (n : â„•)"},
 {"type": "x âˆˆ fixedPoints f â†” f x = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {Î± : Type _}  {f : Î± â†’ Î±}  {x : Î±} : x âˆˆ fixedPoints f â†” f x = x := by rfl; sorry",
  "name": "mem_fixedPoints_iff",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {Î± : Type _}  {f : Î± â†’ Î±}  {x : Î±} : x âˆˆ fixedPoints f â†” f x = x",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} {Î± : Type _}  {f : Î± â†’ Î±}  {x : Î±}"},
 {"type": "Set.InvOn f g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.InvOn f g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g) := by simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g; sorry",
  "name": "Commute.invOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic":
  "simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.InvOn f g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g)"},
 {"type": "Set.BijOn f (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.BijOn f (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g) := by simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f; sorry",
  "name": "Commute.left_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.BijOn f (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g)"},
 {"type": "Set.BijOn g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.BijOn g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g) := by simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g; sorry",
  "name": "Commute.right_bijOn_fixedPoints_comp",
  "kind": "theorem",
  "first-tactic": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g) : Set.BijOn g (fixedPoints <| f âˆ˜ g) (fixedPoints <| f âˆ˜ g)",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {f fa g : Î± â†’ Î±}  {x y : Î±}  {fb : Î² â†’ Î²}  {m n k : â„•}  {e : Perm Î±} (h : Commute f g)"},
 {"type": "P âˆ¨ Q",
  "tactic-prompt": "example (h : P) : P âˆ¨ Q := by apply .inl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply .inl",
  "core-prompt": "(h : P) : P âˆ¨ Q",
  "args": "(h : P)"},
 {"type": "p (let_fun x := 0; x + 1)",
  "tactic-prompt":
  "theorem  : p (let_fun x := 0; x + 1) := by apply p_of_q; sorry",
  "name": "pletfun",
  "kind": "theorem",
  "first-tactic": "apply p_of_q",
  "core-prompt": " : p (let_fun x := 0; x + 1)",
  "args": ""},
 {"type": "(image (Nat.succ âˆ˜ Nat.succ) Î“) = (image (fun a => a.succ.succ) Î“)",
  "tactic-prompt":
  "example {Î“: Set Nat} : (image (Nat.succ âˆ˜ Nat.succ) Î“) = (image (fun a => a.succ.succ) Î“) := by simp only [Function.comp_apply]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [Function.comp_apply]",
  "core-prompt":
  "{Î“: Set Nat} : (image (Nat.succ âˆ˜ Nat.succ) Î“) = (image (fun a => a.succ.succ) Î“)",
  "args": "{Î“: Set Nat}"},
 {"type": "r.toFun x = y",
  "tactic-prompt":
  "example (x y : Î±)  (h : x = y) : r.toFun x = y := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x y : Î±)  (h : x = y) : r.toFun x = y",
  "args": "(x y : Î±)  (h : x = y)"},
 {"type": "p â‰¤ p",
  "tactic-prompt": "theorem (p : Phase) : p â‰¤ p := by cases p; sorry",
  "name": "Phase.le_refl",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": "(p : Phase) : p â‰¤ p",
  "args": "(p : Phase)"},
 {"type":
  "open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v)",
  "tactic-prompt":
  "example {v : SemanticTokenType} : open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v) := by cases v; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases v",
  "core-prompt":
  "{v : SemanticTokenType} : open SemanticTokenType in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v)",
  "args": "{v : SemanticTokenType}"},
 {"type":
  "open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v)",
  "tactic-prompt":
  "example {v : SemanticTokenModifier} : open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v) := by cases v; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases v",
  "core-prompt":
  "{v : SemanticTokenModifier} : open SemanticTokenModifier in\n    names[v.toNat]?.map (toString <| toJson Â·) = some (toString <| toJson v)",
  "args": "{v : SemanticTokenModifier}"},
 {"type": "(ks.set i k).size = (vs.set j v).size",
  "tactic-prompt":
  "theorem {ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : Î±)  (v : Î²) : (ks.set i k).size = (vs.set j v).size := by simp [h]; sorry",
  "name": "size_set",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : Î±)  (v : Î²) : (ks.set i k).size = (vs.set j v).size",
  "args":
  "{ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (i : Fin ks.size)  (j : Fin vs.size)  (k : Î±)  (v : Î²)"},
 {"type": "(ks.push k).size = (vs.push v).size",
  "tactic-prompt":
  "theorem {ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (k : Î±)  (v : Î²) : (ks.push k).size = (vs.push v).size := by simp [h]; sorry",
  "name": "size_push",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (k : Î±)  (v : Î²) : (ks.push k).size = (vs.push v).size",
  "args":
  "{ks : Array Î±}  {vs : Array Î²}  (h : ks.size = vs.size)  (k : Î±)  (v : Î²)"},
 {"type": "{a : â„¤} â†’ Â¬(a + a + 1 = 0)",
  "tactic-prompt": "lemma  : {a : â„¤} â†’ Â¬(a + a + 1 = 0) := by intro a h; sorry",
  "name": "odd_ne_zero",
  "kind": "lemma",
  "first-tactic": "intro a h",
  "core-prompt": " : {a : â„¤} â†’ Â¬(a + a + 1 = 0)",
  "args": ""},
 {"type": "âˆ€ g : P, g ^ 2 = 1 â†’ g = 1",
  "tactic-prompt":
  "theorem  : âˆ€ g : P, g ^ 2 = 1 â†’ g = 1 := by intro âŸ¨(p, q, r), xâŸ©; sorry",
  "name": "square_free",
  "kind": "theorem",
  "first-tactic": "intro âŸ¨(p, q, r), xâŸ©",
  "core-prompt": " : âˆ€ g : P, g ^ 2 = 1 â†’ g = 1",
  "args": ""},
 {"type": "âˆ€ {q : Q}, c 0 q = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ {q : Q}, c 0 q = (0 : K) := by intro q; sorry",
  "name": "leftId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ {q : Q}, c 0 q = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]"},
 {"type": "âˆ€ {q : Q}, c q 0 = (0 : K)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ {q : Q}, c q 0 = (0 : K) := by intro q; sorry",
  "name": "rightId",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ {q : Q}, c q 0 = (0 : K)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]"},
 {"type": "âˆ€ q : Q, c q (-q) = q â€¢ (c (-q) q)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ q : Q, c q (-q) = q â€¢ (c (-q) q) := by intro q; sorry",
  "name": "invRel",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ q : Q, c q (-q) = q â€¢ (c (-q) q)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]"},
 {"type": "âˆ€ q : Q, c (-q) q = (-q) â€¢ (c q (-q))",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ q : Q, c (-q) q = (-q) â€¢ (c q (-q)) := by intro q; sorry",
  "name": "invRel'",
  "kind": "theorem",
  "first-tactic": "intro q",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ q : Q, c (-q) q = (-q) â€¢ (c q (-q))",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]"},
 {"type": "âˆ€ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ k k' : Metabelian.Kernel Q K, k * k' = k' * k := by intro âŸ¨âŸ¨ka, 0âŸ©, rflâŸ©; sorry",
  "name": "Metabelian.Kernel.mul_comm",
  "kind": "theorem",
  "first-tactic": "intro âŸ¨âŸ¨ka, 0âŸ©, rflâŸ©",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] : âˆ€ k k' : Metabelian.Kernel Q K, k * k' = k' * k",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c] {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]  /- The multiplication operation defined using the cocycle. The cocycle condition is crucially used in showing associativity and other properties. -/  (Q K : Type _)  [AddCommGroup Q]  [AddCommGroup K] (c : Q â†’ Q â†’ K)  [ccl : Cocycle c]"},
 {"type": "âˆ€ {a : A}, a â€¢ (0 : B) = (0 : B)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, a â€¢ (0 : B) = (0 : B) := by intro; sorry",
  "name": "act_zero",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, a â€¢ (0 : B) = (0 : B)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±]"},
 {"type": "âˆ€ {a : A}, âˆ€ {b b' : B}, a â€¢ (b + b') = a â€¢ b + a â€¢ b'",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, âˆ€ {b b' : B}, a â€¢ (b + b') = a â€¢ b + a â€¢ b' := by intro; sorry",
  "name": "add_dist",
  "kind": "theorem",
  "first-tactic": "intro",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, âˆ€ {b b' : B}, a â€¢ (b + b') = a â€¢ b + a â€¢ b'",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±]"},
 {"type": "âˆ€ {a : A}, âˆ€ {b : B}, a â€¢ (-b) = - (a â€¢ b)",
  "tactic-prompt":
  "theorem (A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, âˆ€ {b : B}, a â€¢ (-b) = - (a â€¢ b) := by intros; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±] : âˆ€ {a : A}, âˆ€ {b : B}, a â€¢ (-b) = - (a â€¢ b)",
  "args":
  "(A B : Type _)  [AddCommGroup A]  [AddCommGroup B]  (Î± : A â†’ B â†’ B)  [AA : AutAction A B Î±]"},
 {"type": "âˆ€ x : Fin 3, x + 0 = x",
  "tactic-prompt": "example  : âˆ€ x : Fin 3, x + 0 = x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x : Fin 3, x + 0 = x",
  "args": ""},
 {"type": "âˆ€ x y : Fin 3, x + y = y + x",
  "tactic-prompt":
  "example  : âˆ€ x y : Fin 3, x + y = y + x := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y : Fin 3, x + y = y + x",
  "args": ""},
 {"type": "âˆ€ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "tactic-prompt":
  "theorem  : âˆ€ x y z : Fin 3, (x + y) + z = x + (y + z) := by decide; sorry",
  "name": "Zmod3.assoc",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : âˆ€ x y z : Fin 3, (x + y) + z = x + (y + z)",
  "args": ""},
 {"type":
  "âˆ€ xy : (Fin 3) Ã— (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "tactic-prompt":
  "example  : âˆ€ xy : (Fin 3) Ã— (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val := by decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "decide",
  "core-prompt":
  " : âˆ€ xy : (Fin 3) Ã— (Fin 2), \n      xy.1.val + xy.2.val  = xy.2.val + xy.1.val",
  "args": ""},
 {"type": "ys = fst ++ [xâ»Â¹] ++ snd â†’ x :: ys = fst^x ++ snd",
  "tactic-prompt":
  "theorem (x: Letter)  (ys fst snd: Word) : ys = fst ++ [xâ»Â¹] ++ snd â†’ x :: ys = fst^x ++ snd := by intro hyp; sorry",
  "name": "conj_split",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(x: Letter)  (ys fst snd: Word) : ys = fst ++ [xâ»Â¹] ++ snd â†’ x :: ys = fst^x ++ snd",
  "args": "(x: Letter)  (ys fst snd: Word)"},
 {"type": "ps.fst.length + 1 â‰¤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 â‰¤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitFirst",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.fst.length + 1 â‰¤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ps.snd.length + 1 â‰¤ w.length",
  "tactic-prompt":
  "theorem {l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 â‰¤ w.length := by let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append; sorry",
  "name": "splitSecond",
  "kind": "theorem",
  "first-tactic":
  "let lem : (ps.fst ++ [l] ++ ps.snd).length = \n                (ps.fst ++ [l]).length + ps.snd.length := by apply List.length_append",
  "core-prompt":
  "{l: Letter} {w: Word} (ps: ProvedSplit l w) : ps.snd.length + 1 â‰¤ w.length",
  "args": "{l: Letter} {w: Word} (ps: ProvedSplit l w)"},
 {"type": "ProofTree fst â†’ ProofTree snd â†’ ProofTree (x :: ys)",
  "tactic-prompt":
  "def (x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [xâ»Â¹] ++ snd) : ProofTree fst â†’ ProofTree snd â†’ ProofTree (x :: ys) := by intros pt1 pt2; sorry",
  "name": "ProofTree.headMatches",
  "kind": "def",
  "first-tactic": "intros pt1 pt2",
  "core-prompt":
  "(x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [xâ»Â¹] ++ snd) : ProofTree fst â†’ ProofTree snd â†’ ProofTree (x :: ys)",
  "args": "(x: Letter) (ys fst snd: Word)    (eqn : ys = fst ++ [xâ»Â¹] ++ snd)"},
 {"type": "ProofTree (x :: w)",
  "tactic-prompt":
  "def {w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w) := by have exp : x :: w = [x] ++ w := by rfl; sorry",
  "name": "ProofTree.prepend",
  "kind": "def",
  "first-tactic": "have exp : x :: w = [x] ++ w := by rfl",
  "core-prompt":
  "{w : Word}  (x: Letter)           (pt: ProofTree w) : ProofTree (x :: w)",
  "args": "{w : Word}  (x: Letter)           (pt: ProofTree w)"},
 {"type":
  "âˆ€ g h : K Ã— Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : âˆ€ g h : K Ã— Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g := by intro (k, q); sorry",
  "name": "product_comm",
  "kind": "theorem",
  "first-tactic": "intro (k, q)",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] : âˆ€ g h : K Ã— Q, MetabelianGroup.mul trivial_cocycle g h = MetabelianGroup.mul trivial_cocycle h g",
  "args": "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K]"},
 {"type": "(a, b) = (c, d) â†” (a = c) âˆ§ (b = d)",
  "tactic-prompt":
  "theorem {Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {Î± Î² : Type _}  (a c : Î±)  (b d : Î²) : (a, b) = (c, d) â†” (a = c) âˆ§ (b = d) := by apply Iff.intro; sorry",
  "name": "prod_eq",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {Î± Î² : Type _}  (a c : Î±)  (b d : Î²) : (a, b) = (c, d) â†” (a = c) âˆ§ (b = d)",
  "args":
  "{Q K : Type _}  [AddCommGroup Q]  [AddCommGroup K] {Î± Î² : Type _}  (a c : Î±)  (b d : Î²)"},
 {"type":
  "MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b') := by show (a + a' + 0, b + b') = _; sorry",
  "name": "mul",
  "kind": "theorem",
  "first-tactic": "show (a + a' + 0, b + b') = _",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B} : MetabelianGroup.mul trivial_cocycle (a, b) (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] {a a' : A}  {b b' : B}"},
 {"type": "(a, b) + (a', b') = (a + a', b + b')",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b') := by simp only [HAdd.hAdd]; sorry",
  "name": "add",
  "kind": "theorem",
  "first-tactic": "simp only [HAdd.hAdd]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B) : (a, b) + (a', b') = (a + a', b + b')",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B]  -- Direct sums as an additive version of products -- @[irreducible] (a a' : A)  (b b' : B)"},
 {"type": "zsmul (n+1) x = x + zsmul n x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (n: â„¤)  (x : A) : zsmul (n+1) x = x + zsmul n x := by cases n; sorry",
  "name": "zsmul_succ",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (n: â„¤)  (x : A) : zsmul (n+1) x = x + zsmul n x",
  "args": "{A : Type}  [abg : AddCommGroup A] (n: â„¤)  (x : A)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n : â„¤)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m := by induction m; sorry",
  "name": "isHomâ‚",
  "kind": "theorem",
  "first-tactic": "induction m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : â„¤)  (m: Nat) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n : â„¤)  (m: Nat)"},
 {"type":
  "zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n) := by simp [zhom]; sorry",
  "name": "isHomâ‚‚",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat) : zhom x ((Int.negSucc n) + (Int.negSucc m)) =\n          zhom x (Int.negSucc m) + zhom x (Int.negSucc n)",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)  (n m : Nat)"},
 {"type": "zhom x (n + m) = zhom x n + zhom x m",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x: A)  (n m : â„¤) : zhom x (n + m) = zhom x n + zhom x m := by cases m; sorry",
  "name": "zhom_is_hom",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : â„¤) : zhom x (n + m) = zhom x n + zhom x m",
  "args": "{A : Type}  [abg : AddCommGroup A] (x: A)  (n m : â„¤)"},
 {"type": "zhom x 1 = x",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x := by simp [zhom]; sorry",
  "name": "zhom_one",
  "kind": "theorem",
  "first-tactic": "simp [zhom]",
  "core-prompt": "{A : Type}  [abg : AddCommGroup A] (x : A) : zhom x 1 = x",
  "args": "{A : Type}  [abg : AddCommGroup A] (x : A)"},
 {"type": "f 1 = g 1  â†’ âˆ€ n: â„•, f (n + 1) = g (n + 1)",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  â†’ âˆ€ n: â„•, f (n + 1) = g (n + 1) := by intro hyp; sorry",
  "name": "unique_morphism_nat",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  â†’ âˆ€ n: â„•, f (n + 1) = g (n + 1)",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "f 1 = g 1  â†’ f = g",
  "tactic-prompt":
  "theorem {A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  â†’ f = g := by intro hyp; sorry",
  "name": "unique_morphism",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g] : f 1 = g 1  â†’ f = g",
  "args":
  "{A : Type}  [abg : AddCommGroup A] (f g : â„¤ â†’ A) [AddCommGroup.Homomorphism f]          [AddCommGroup.Homomorphism g]"},
 {"type": "F â†’ A",
  "tactic-prompt":
  "def {F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X â†’ A) : F â†’ A := by apply fag.inducedMap; sorry",
  "name": "fromBasis",
  "kind": "def",
  "first-tactic": "apply fag.inducedMap",
  "core-prompt":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X â†’ A) : F â†’ A",
  "args":
  "{F: Type} [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]  (f: X â†’ A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A} : @AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A} : @AddCommGroup.Homomorphism F A _ _\n    (@fromBasis F _ X  fag A _ f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A}"},
 {"type": "D â†’  F â†’ A",
  "tactic-prompt":
  "def (F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D â†’ X â†’ A) : D â†’  F â†’ A := by intro p; sorry",
  "name": "fromBasisFamily",
  "kind": "def",
  "first-tactic": "intro p",
  "core-prompt":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D â†’ X â†’ A) : D â†’  F â†’ A",
  "args":
  "(F: Type) [AddCommGroup F] {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] (D: Type) (f: D â†’ X â†’ A)"},
 {"type":
  "@AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D â†’ X â†’ A} {p : D} : @AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p) := by apply fag.induced_hom; sorry",
  "name": "fromBasisFamilyHom",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D â†’ X â†’ A} {p : D} : @AddCommGroup.Homomorphism F A _ _\n    ((@fromBasisFamily F _ X  fag A _ D f) p)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A] {D : Type}    {f: D â†’ X â†’ A} {p : D}"},
 {"type": "@AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A} : @AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f) := by apply fag.induced_hom; sorry",
  "name": "fromBasisHom'",
  "kind": "instance",
  "first-tactic": "apply fag.induced_hom",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A} : @AddCommGroup.Homomorphism F A _ _\n    (fag.inducedMap A f)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fag : FreeAbelianGroup F X] {A: Type} [AddCommGroup A]    {f: X â†’ A}"},
 {"type": "Decidable (f = g)",
  "tactic-prompt":
  "instance {F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F â†’ A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g) := by apply decideHomsEqual X; sorry",
  "name": "decHomsEqual",
  "kind": "instance",
  "first-tactic": "apply decideHomsEqual X",
  "core-prompt":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F â†’ A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g] : Decidable (f = g)",
  "args":
  "{F: Type} [AddCommGroup F]    {X: Type} [fgp : FreeAbelianGroup F X]    {A: Type} [AddCommGroup A] [DecidableEq A] [DecideForall X]      (f g : F â†’ A) [AddCommGroup.Homomorphism f] [AddCommGroup.Homomorphism g]"},
 {"type":
  "âˆ€ (x y: Fin 2),\n  (egAction' x) âˆ˜ (egAction' y) = egAction' (x + y)",
  "tactic-prompt":
  "theorem  : âˆ€ (x y: Fin 2),\n  (egAction' x) âˆ˜ (egAction' y) = egAction' (x + y) := by decide; sorry",
  "name": "egIsAction",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : âˆ€ (x y: Fin 2),\n  (egAction' x) âˆ˜ (egAction' y) = egAction' (x + y)",
  "args": ""},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚ : A â†’ A Ã— B) = (FAb_A.inducedMap G (f âˆ˜ Sum.inl))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G) : (FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚ : A â†’ A Ã— B) = (FAb_A.inducedMap G (f âˆ˜ Sum.inl)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_left",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G) : (FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚ : A â†’ A Ã— B) = (FAb_A.inducedMap G (f âˆ˜ Sum.inl))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G)"},
 {"type":
  "(FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚‚ : B â†’ A Ã— B) = (FAb_B.inducedMap G (f âˆ˜ Sum.inr))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G) : (FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚‚ : B â†’ A Ã— B) = (FAb_B.inducedMap G (f âˆ˜ Sum.inr)) := by apply funext; sorry",
  "name": "FreeAbelianGroup.induced_right",
  "kind": "theorem",
  "first-tactic": "apply funext",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G) : (FreeAbelianGroup.inducedMap G f) âˆ˜ (Î¹â‚‚ : B â†’ A Ã— B) = (FAb_B.inducedMap G (f âˆ˜ Sum.inr))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (G : Type _)  [AddCommGroup G]  (f : X_A âŠ• X_B â†’ G)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inl xa) : X_A âŠ• X_B) = (FAb_A.i xa, (0 : B))",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A âŠ• X_B) = (FAb_A.i xa, (0 : B)) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.left_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A) : FreeAbelianGroup.i ((Sum.inl xa) : X_A âŠ• X_B) = (FAb_A.i xa, (0 : B))",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xa : X_A)"},
 {"type":
  "FreeAbelianGroup.i ((Sum.inr xb) : X_A âŠ• X_B) = ((0 : A), FAb_B.i xb)",
  "tactic-prompt":
  "theorem {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A âŠ• X_B) = ((0 : A), FAb_B.i xb) := by simp [i]; sorry",
  "name": "FreeAbelianGroup.right_incl",
  "kind": "theorem",
  "first-tactic": "simp [i]",
  "core-prompt":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B) : FreeAbelianGroup.i ((Sum.inr xb) : X_A âŠ• X_B) = ((0 : A), FAb_B.i xb)",
  "args":
  "{A B : Type _}  [AddCommGroup A]  [AddCommGroup B] {X_A X_B : Type _} [FAb_A : FreeAbelianGroup A X_A]  [FAb_B : FreeAbelianGroup B X_B ] (xb : X_B)"},
 {"type": "AddCommGroup.Homomorphism (action q)",
  "tactic-prompt":
  "instance (q : Q) : AddCommGroup.Homomorphism (action q) := by revert q; sorry",
  "name": "",
  "kind": "instance",
  "first-tactic": "revert q",
  "core-prompt": "(q : Q) : AddCommGroup.Homomorphism (action q)",
  "args": "(q : Q)"},
 {"type": "Â¬ (trivial_element Î±)",
  "tactic-prompt": "theorem  : Â¬ (trivial_element Î±) := by intro contra; sorry",
  "name": "Î±_non_trivial",
  "kind": "theorem",
  "first-tactic": "intro contra",
  "core-prompt": " : Â¬ (trivial_element Î±)",
  "args": ""},
 {"type": "coords (mulMonom 0 g s) xâ‚€ = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g xâ‚€: G) (s: FormalSum R G) : coords (mulMonom 0 g s) xâ‚€ = 0 := by induction s; sorry",
  "name": "mul_monom_zero",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g xâ‚€: G) (s: FormalSum R G) : coords (mulMonom 0 g s) xâ‚€ = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (g xâ‚€: G) (s: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (sâ‚  ++ sâ‚‚)) xâ‚€ = coords (mulMonom b h sâ‚) xâ‚€ + coords (mulMonom b h sâ‚‚) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G) : coords (mulMonom b h (sâ‚  ++ sâ‚‚)) xâ‚€ = coords (mulMonom b h sâ‚) xâ‚€ + coords (mulMonom b h sâ‚‚) xâ‚€ := by induction sâ‚; sorry",
  "name": "mul_monom_dist",
  "kind": "theorem",
  "first-tactic": "induction sâ‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G) : coords (mulMonom b h (sâ‚  ++ sâ‚‚)) xâ‚€ = coords (mulMonom b h sâ‚) xâ‚€ + coords (mulMonom b h sâ‚‚) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G)"},
 {"type":
  "coords (mul sâ‚ (sâ‚‚  ++ sâ‚ƒ)) xâ‚€ = coords (mul sâ‚ sâ‚‚) xâ‚€ + coords (mul sâ‚ sâ‚ƒ) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (xâ‚€ : G) (sâ‚ sâ‚‚ sâ‚ƒ: FormalSum R G) : coords (mul sâ‚ (sâ‚‚  ++ sâ‚ƒ)) xâ‚€ = coords (mul sâ‚ sâ‚‚) xâ‚€ + coords (mul sâ‚ sâ‚ƒ) xâ‚€ := by induction sâ‚‚; sorry",
  "name": "mul_dist",
  "kind": "theorem",
  "first-tactic": "induction sâ‚‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (xâ‚€ : G) (sâ‚ sâ‚‚ sâ‚ƒ: FormalSum R G) : coords (mul sâ‚ (sâ‚‚  ++ sâ‚ƒ)) xâ‚€ = coords (mul sâ‚ sâ‚‚) xâ‚€ + coords (mul sâ‚ sâ‚ƒ) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (xâ‚€ : G) (sâ‚ sâ‚‚ sâ‚ƒ: FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mulMonom a x s)) xâ‚€ = \n    coords (mulMonom (a * b) (x * h) s) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h xâ‚€ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) xâ‚€ = \n    coords (mulMonom (a * b) (x * h) s) xâ‚€ := by induction s; sorry",
  "name": "mul_monom_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h xâ‚€ : G) (s : FormalSum R G) : coords (mulMonom b h (mulMonom a x s)) xâ‚€ = \n    coords (mulMonom (a * b) (x * h) s) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (a b : R) (h xâ‚€ : G) (s : FormalSum R G)"},
 {"type":
  "coords (mulMonom b h (mul sâ‚ sâ‚‚)) xâ‚€ = \n    coords (mul sâ‚ (mulMonom b h sâ‚‚)) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G) : coords (mulMonom b h (mul sâ‚ sâ‚‚)) xâ‚€ = \n    coords (mul sâ‚ (mulMonom b h sâ‚‚)) xâ‚€ := by induction sâ‚‚; sorry",
  "name": "mul_monom_assoc",
  "kind": "theorem",
  "first-tactic": "induction sâ‚‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G) : coords (mulMonom b h (mul sâ‚ sâ‚‚)) xâ‚€ = \n    coords (mul sâ‚ (mulMonom b h sâ‚‚)) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚: FormalSum R G)"},
 {"type":
  "coords (mulMonom (bâ‚ + bâ‚‚) h s) xâ‚€ = coords (mulMonom bâ‚ h s) xâ‚€ + coords (mulMonom bâ‚‚ h s) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (bâ‚ bâ‚‚ : R) (h xâ‚€ : G) (s: FormalSum R G) : coords (mulMonom (bâ‚ + bâ‚‚) h s) xâ‚€ = coords (mulMonom bâ‚ h s) xâ‚€ + coords (mulMonom bâ‚‚ h s) xâ‚€ := by induction s; sorry",
  "name": "mul_monom_add",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (bâ‚ bâ‚‚ : R) (h xâ‚€ : G) (s: FormalSum R G) : coords (mulMonom (bâ‚ + bâ‚‚) h s) xâ‚€ = coords (mulMonom bâ‚ h s) xâ‚€ + coords (mulMonom bâ‚‚ h s) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (bâ‚ bâ‚‚ : R) (h xâ‚€ : G) (s: FormalSum R G)"},
 {"type": "mul s ((0, h) :: t) â‰ˆ  mul s t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) â‰ˆ  mul s t := by induction s; sorry",
  "name": "mul_zero_cons",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G) : mul s ((0, h) :: t) â‰ˆ  mul s t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (s t : FormalSum R G) (g: G)"},
 {"type": "FormalSum R G â†’ FreeModule R G â†’ FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G â†’ FreeModule R G â†’ FreeModule R G := by intro s; sorry",
  "name": "mulAux",
  "kind": "def",
  "first-tactic": "intro s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FormalSum R G â†’ FreeModule R G â†’ FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type": "coords (mulMonom b h sâ‚) xâ‚€ = coords (mulMonom b h sâ‚‚) xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚ : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚) : coords (mulMonom b h sâ‚) xâ‚€ = coords (mulMonom b h sâ‚‚) xâ‚€ := by induction rel; sorry",
  "name": "mul_monom_invariant",
  "kind": "theorem",
  "first-tactic": "induction rel",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚ : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚) : coords (mulMonom b h sâ‚) xâ‚€ = coords (mulMonom b h sâ‚‚) xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (b : R) (h xâ‚€ : G) (sâ‚ sâ‚‚ : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚)"},
 {"type": "FormalSum.mul sâ‚ t â‰ˆ  FormalSum.mul sâ‚‚ t",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (sâ‚ sâ‚‚ t : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚) : FormalSum.mul sâ‚ t â‰ˆ  FormalSum.mul sâ‚‚ t := by cases t; sorry",
  "name": "first_arg_invariant",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (sâ‚ sâ‚‚ t : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚) : FormalSum.mul sâ‚ t â‰ˆ  FormalSum.mul sâ‚‚ t",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] (sâ‚ sâ‚‚ t : FormalSum R G)  (rel : ElementaryMove R G sâ‚ sâ‚‚)"},
 {"type": "FreeModule R G â†’ FreeModule R G â†’ FreeModule R G",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G â†’ FreeModule R G â†’ FreeModule R G := by let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t; sorry",
  "name": "mul",
  "kind": "def",
  "first-tactic":
  "let f  := fun (s : FormalSum R G) => \n    fun  (t : FreeModule R G) => mulAux  s t",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G] : FreeModule R G â†’ FreeModule R G â†’ FreeModule R G",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {G: Type}  [Group G]  [DecidableEq G]"},
 {"type":
  "monomCoeff R X xâ‚€ (a + b, x) = monomCoeff R X xâ‚€ (a, x) + monomCoeff R X xâ‚€ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X)  (a b : R) : monomCoeff R X xâ‚€ (a + b, x) = monomCoeff R X xâ‚€ (a, x) + monomCoeff R X xâ‚€ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_hom",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X)  (a b : R) : monomCoeff R X xâ‚€ (a + b, x) = monomCoeff R X xâ‚€ (a, x) + monomCoeff R X xâ‚€ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X)  (a b : R)"},
 {"type": "monomCoeff R X xâ‚€ (a * b, x) = a * monomCoeff R X xâ‚€ (b, x)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (a b : R) : monomCoeff R X xâ‚€ (a * b, x) = a * monomCoeff R X xâ‚€ (b, x) := by repeat\n    (\n      rw [monomCoeff]); sorry",
  "name": "monom_coords_mul",
  "kind": "theorem",
  "first-tactic": "repeat\n    (\n      rw [monomCoeff])",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (a b : R) : monomCoeff R X xâ‚€ (a * b, x) = a * monomCoeff R X xâ‚€ (b, x)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (a b : R)"},
 {"type": "monomCoeff R X xâ‚€ (0, x) = 0",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X) : monomCoeff R X xâ‚€ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coords_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X) : monomCoeff R X xâ‚€ (0, x) = 0",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ x : X)"},
 {"type": "f = g â†’ equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X â†’ R) : f = g â†’ equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X â†’ R) : f = g â†’ equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (l : List X)  (f g : X â†’ R)"},
 {"type": "eqlCoords R X s s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X) : eqlCoords R X s s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (s : FormalSum R X)"},
 {"type": "eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ : FormalSum R X} : eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ : FormalSum R X} : eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ : FormalSum R X}"},
 {"type": "eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚ƒ â†’ eqlCoords R X sâ‚ sâ‚ƒ",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum R X} : eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚ƒ â†’ eqlCoords R X sâ‚ sâ‚ƒ := by intro hypâ‚ hypâ‚‚; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hypâ‚ hypâ‚‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum R X} : eqlCoords R X sâ‚ sâ‚‚ â†’ eqlCoords R X sâ‚‚ sâ‚ƒ â†’ eqlCoords R X sâ‚ sâ‚ƒ",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum R X}"},
 {"type": "beqOnSupport l f g = true â†’ equalOnSupport l f g",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X â†’ R} : beqOnSupport l f g = true â†’ equalOnSupport l f g := by intro hyp; sorry",
  "name": "eql_on_support_of_true",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X â†’ R} : beqOnSupport l f g = true â†’ equalOnSupport l f g",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {l : List X}  {f g : X â†’ R}"},
 {"type": "âŸ¦sâ‚âŸ§ = âŸ¦sâ‚‚âŸ§",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X) (câ‚ : beqOnSupport sâ‚.support sâ‚.coords sâ‚‚.coords) (câ‚‚ : beqOnSupport sâ‚‚.support sâ‚.coords sâ‚‚.coords) : âŸ¦sâ‚âŸ§ = âŸ¦sâ‚‚âŸ§ := by let châ‚ := eql_on_support_of_true câ‚; sorry",
  "name": "eqlquot_of_beq_support",
  "kind": "theorem",
  "first-tactic": "let châ‚ := eql_on_support_of_true câ‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X) (câ‚ : beqOnSupport sâ‚.support sâ‚.coords sâ‚‚.coords) (câ‚‚ : beqOnSupport sâ‚‚.support sâ‚.coords sâ‚‚.coords) : âŸ¦sâ‚âŸ§ = âŸ¦sâ‚‚âŸ§",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X) (câ‚ : beqOnSupport sâ‚.support sâ‚.coords sâ‚‚.coords) (câ‚‚ : beqOnSupport sâ‚‚.support sâ‚.coords sâ‚‚.coords)"},
 {"type": "Bool",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : Bool := by apply Quotient.liftâ‚‚ (fun (sâ‚ sâ‚‚ : FormalSum R X) => decide (âŸ¦sâ‚âŸ§ = âŸ¦sâ‚‚âŸ§)); sorry",
  "name": "beq_quot",
  "kind": "def",
  "first-tactic":
  "apply Quotient.liftâ‚‚ (fun (sâ‚ sâ‚‚ : FormalSum R X) => decide (âŸ¦sâ‚âŸ§ = âŸ¦sâ‚‚âŸ§))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : Bool",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X)"},
 {"type": "âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = true â†’ xâ‚ = xâ‚‚",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = true â†’ xâ‚ = xâ‚‚ := by let f :=\n    @Quotient.indâ‚‚ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (xâ‚ xâ‚‚ : FreeModule R X) => xâ‚.beq_quot xâ‚‚ = true â†’ xâ‚ = xâ‚‚); sorry",
  "name": "eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.indâ‚‚ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (xâ‚ xâ‚‚ : FreeModule R X) => xâ‚.beq_quot xâ‚‚ = true â†’ xâ‚ = xâ‚‚)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = true â†’ xâ‚ = xâ‚‚",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚) := by let f :=\n    @Quotient.indâ‚‚ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (xâ‚ xâ‚‚ : FreeModule R X) => xâ‚.beq_quot xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚)); sorry",
  "name": "neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f :=\n    @Quotient.indâ‚‚ (FormalSum R X) (FormalSum R X) (formalSumSetoid R X) (formalSumSetoid R X)\n      (fun (xâ‚ xâ‚‚ : FreeModule R X) => xâ‚.beq_quot xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeModule R X, xâ‚.beq_quot xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚)",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "Decidable (xâ‚ = xâ‚‚)",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : Decidable (xâ‚ = xâ‚‚) := by match p : xâ‚.beq_quot xâ‚‚ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic":
  "match p : xâ‚.beq_quot xâ‚‚ with\n  | true =>\n    apply Decidable.isTrue\n    apply FreeModule.eq_of_beq_true\n    assumption\n  | false =>\n    apply Decidable.isFalse\n    apply FreeModule.neq_of_beq_false\n    assumption",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : Decidable (xâ‚ = xâ‚‚)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X)"},
 {"type": "sâ‚ â‰ˆ sâ‚‚ â†’ sâ‚.coords = sâ‚‚.coords",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X) : sâ‚ â‰ˆ sâ‚‚ â†’ sâ‚.coords = sâ‚‚.coords := by intro hyp; sorry",
  "name": "equal_coords_of_approx",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X) : sâ‚ â‰ˆ sâ‚‚ â†’ sâ‚.coords = sâ‚‚.coords",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)"},
 {"type": "FreeModule R X â†’  R",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X) : FreeModule R X â†’  R := by apply Quotient.lift (fun s : FormalSum R X => s.coords xâ‚€); sorry",
  "name": "coordinates",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (fun s : FormalSum R X => s.coords xâ‚€)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X) : FreeModule R X â†’  R",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)"},
 {"type": "(r * s.coords xâ‚€) = (s.scmul r).coords xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (xâ‚€ : X) : (r * s.coords xâ‚€) = (s.scmul r).coords xâ‚€ := by induction s; sorry",
  "name": "scmul_coords",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (xâ‚€ : X) : (r * s.coords xâ‚€) = (s.scmul r).coords xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (r : R)  (s : FormalSum R X)  (xâ‚€ : X)"},
 {"type": "R â†’ FreeModule R X â†’ FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R â†’ FreeModule R X â†’ FreeModule R X := by intro r; sorry",
  "name": "FreeModule.scmul",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : R â†’ FreeModule R X â†’ FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(sâ‚.coords xâ‚€) + (sâ‚‚.coords xâ‚€) = (sâ‚ ++ sâ‚‚).coords xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (xâ‚€ : X) : (sâ‚.coords xâ‚€) + (sâ‚‚.coords xâ‚€) = (sâ‚ ++ sâ‚‚).coords xâ‚€ := by induction sâ‚; sorry",
  "name": "append_coords",
  "kind": "theorem",
  "first-tactic": "induction sâ‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (xâ‚€ : X) : (sâ‚.coords xâ‚€) + (sâ‚‚.coords xâ‚€) = (sâ‚ ++ sâ‚‚).coords xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (xâ‚€ : X)"},
 {"type": "(sâ‚ â‰ˆ sâ‚‚) â†’ (tâ‚ â‰ˆ tâ‚‚) â†’ sâ‚ ++ tâ‚ â‰ˆ sâ‚‚ ++ tâ‚‚",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ tâ‚ tâ‚‚ : FormalSum R X) : (sâ‚ â‰ˆ sâ‚‚) â†’ (tâ‚ â‰ˆ tâ‚‚) â†’ sâ‚ ++ tâ‚ â‰ˆ sâ‚‚ ++ tâ‚‚ := by intro eqvâ‚ eqvâ‚‚; sorry",
  "name": "append_equiv",
  "kind": "theorem",
  "first-tactic": "intro eqvâ‚ eqvâ‚‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ tâ‚ tâ‚‚ : FormalSum R X) : (sâ‚ â‰ˆ sâ‚‚) â†’ (tâ‚ â‰ˆ tâ‚‚) â†’ sâ‚ ++ tâ‚ â‰ˆ sâ‚‚ ++ tâ‚‚",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ tâ‚ tâ‚‚ : FormalSum R X)"},
 {"type": "FreeModule R X â†’ FreeModule R X â†’ FreeModule R X",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X â†’ FreeModule R X â†’ FreeModule R X := by let f : FormalSum R X â†’ FormalSum R X â†’ FreeModule R X := fun sâ‚ sâ‚‚ => âŸ¦sâ‚ ++ sâ‚‚âŸ§; sorry",
  "name": "FreeModule.add",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X â†’ FormalSum R X â†’ FreeModule R X := fun sâ‚ sâ‚‚ => âŸ¦sâ‚ ++ sâ‚‚âŸ§",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X] : FreeModule R X â†’ FreeModule R X â†’ FreeModule R X",
  "args": "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]"},
 {"type": "(s.scmul b).scmul a = s.scmul (a * b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b) := by induction s; sorry",
  "name": "action",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul b).scmul a = s.scmul (a * b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "(s.scmul a) ++ (s.scmul b) â‰ˆ  s.scmul (a + b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) â‰ˆ  s.scmul (a + b) := by induction s; sorry",
  "name": "act_sum",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X) : (s.scmul a) ++ (s.scmul b) â‰ˆ  s.scmul (a + b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (s : FormalSum R X)"},
 {"type": "a â€¢ (b â€¢ x) = (a * b) â€¢ x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a â€¢ (b â€¢ x) = (a * b) â€¢ x := by apply @Quotient.ind (motive := fun x : FreeModule R X => a â€¢ (b â€¢ x) = (a * b) â€¢ x); sorry",
  "name": "module_action",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => a â€¢ (b â€¢ x) = (a * b) â€¢ x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X) : a â€¢ (b â€¢ x) = (a * b) â€¢ x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : R)  (x : FreeModule R X)"},
 {"type": "xâ‚ + xâ‚‚ = xâ‚‚ + xâ‚",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : xâ‚ + xâ‚‚ = xâ‚‚ + xâ‚ := by apply @Quotient.indâ‚‚ (motive := fun xâ‚ xâ‚‚ : FreeModule R X => xâ‚ + xâ‚‚ = xâ‚‚ + xâ‚); sorry",
  "name": "addn_comm",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.indâ‚‚ (motive := fun xâ‚ xâ‚‚ : FreeModule R X => xâ‚ + xâ‚‚ = xâ‚‚ + xâ‚)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X) : xâ‚ + xâ‚‚ = xâ‚‚ + xâ‚",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ : FreeModule R X)"},
 {"type": "(âŸ¦sâ‚âŸ§ + xâ‚‚) + xâ‚ƒ = âŸ¦sâ‚âŸ§ + (xâ‚‚ + xâ‚ƒ)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ : FormalSum R X)  (xâ‚‚ xâ‚ƒ : FreeModule R X) : (âŸ¦sâ‚âŸ§ + xâ‚‚) + xâ‚ƒ = âŸ¦sâ‚âŸ§ + (xâ‚‚ + xâ‚ƒ) := by apply @Quotient.indâ‚‚ (motive := fun xâ‚‚ xâ‚ƒ : FreeModule R X => (âŸ¦sâ‚âŸ§ + xâ‚‚) + xâ‚ƒ = âŸ¦sâ‚âŸ§ + (xâ‚‚ + xâ‚ƒ)); sorry",
  "name": "add_assoc_aux",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.indâ‚‚ (motive := fun xâ‚‚ xâ‚ƒ : FreeModule R X => (âŸ¦sâ‚âŸ§ + xâ‚‚) + xâ‚ƒ = âŸ¦sâ‚âŸ§ + (xâ‚‚ + xâ‚ƒ))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ : FormalSum R X)  (xâ‚‚ xâ‚ƒ : FreeModule R X) : (âŸ¦sâ‚âŸ§ + xâ‚‚) + xâ‚ƒ = âŸ¦sâ‚âŸ§ + (xâ‚‚ + xâ‚ƒ)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ : FormalSum R X)  (xâ‚‚ xâ‚ƒ : FreeModule R X)"},
 {"type": "(xâ‚ + xâ‚‚) + xâ‚ƒ = xâ‚ + (xâ‚‚ + xâ‚ƒ)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ xâ‚ƒ : FreeModule R X) : (xâ‚ + xâ‚‚) + xâ‚ƒ = xâ‚ + (xâ‚‚ + xâ‚ƒ) := by apply @Quotient.ind (motive := fun xâ‚ : FreeModule R X => (xâ‚ + xâ‚‚) + xâ‚ƒ = xâ‚ + (xâ‚‚ + xâ‚ƒ)); sorry",
  "name": "addn_assoc",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun xâ‚ : FreeModule R X => (xâ‚ + xâ‚‚) + xâ‚ƒ = xâ‚ + (xâ‚‚ + xâ‚ƒ))",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ xâ‚ƒ : FreeModule R X) : (xâ‚ + xâ‚‚) + xâ‚ƒ = xâ‚ + (xâ‚‚ + xâ‚ƒ)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚ xâ‚‚ xâ‚ƒ : FreeModule R X)"},
 {"type": "x + zero = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x); sorry",
  "name": "addn_zero",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => x + zero = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : x + zero = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "zero + x = x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x := by apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x); sorry",
  "name": "zero_addn",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => zero + x = x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : zero + x = x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "a â€¢ (xâ‚ + xâ‚‚) = a â€¢ xâ‚ + a â€¢ xâ‚‚",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (xâ‚ xâ‚‚ : FreeModule R X) : a â€¢ (xâ‚ + xâ‚‚) = a â€¢ xâ‚ + a â€¢ xâ‚‚ := by apply @Quotient.indâ‚‚ (motive := fun xâ‚ xâ‚‚ : FreeModule R X => a â€¢ (xâ‚ + xâ‚‚) = a â€¢ xâ‚ + a â€¢ xâ‚‚); sorry",
  "name": "elem_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.indâ‚‚ (motive := fun xâ‚ xâ‚‚ : FreeModule R X => a â€¢ (xâ‚ + xâ‚‚) = a â€¢ xâ‚ + a â€¢ xâ‚‚)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (xâ‚ xâ‚‚ : FreeModule R X) : a â€¢ (xâ‚ + xâ‚‚) = a â€¢ xâ‚ + a â€¢ xâ‚‚",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a : R)  (xâ‚ xâ‚‚ : FreeModule R X)"},
 {"type": "a â€¢ x + b â€¢ x = (a + b) â€¢ x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a â€¢ x + b â€¢ x = (a + b) â€¢ x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a â€¢ x + b â€¢ x = (a + b) â€¢ x); sorry",
  "name": "coeffs_distrib",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    a â€¢ x + b â€¢ x = (a + b) â€¢ x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X) : a â€¢ x + b â€¢ x = (a + b) â€¢ x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b: R) (x: FreeModule R X)"},
 {"type": "(1 : R) â€¢ x =  x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) â€¢ x =  x := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) â€¢ x =  x); sorry",
  "name": "unit_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (1 : R) â€¢ x =  x)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (1 : R) â€¢ x =  x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "(0 : R) â€¢ x =  âŸ¦ [] âŸ§",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) â€¢ x =  âŸ¦ [] âŸ§ := by apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) â€¢ x =  âŸ¦ [] âŸ§); sorry",
  "name": "zero_coeffs",
  "kind": "theorem",
  "first-tactic":
  "apply @Quotient.ind (motive := fun x : FreeModule R X => \n    (0 : R) â€¢ x =  âŸ¦ [] âŸ§)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) : (0 : R) â€¢ x =  âŸ¦ [] âŸ§",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X)"},
 {"type": "coords sâ‚ xâ‚€ = coords sâ‚‚ xâ‚€",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (sâ‚ sâ‚‚ : FormalSum R X)  (h : ElementaryMove R X sâ‚ sâ‚‚) : coords sâ‚ xâ‚€ = coords sâ‚‚ xâ‚€ := by induction h; sorry",
  "name": "coords_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (sâ‚ sâ‚‚ : FormalSum R X)  (h : ElementaryMove R X sâ‚ sâ‚‚) : coords sâ‚ xâ‚€ = coords sâ‚‚ xâ‚€",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X)  (sâ‚ sâ‚‚ : FormalSum R X)  (h : ElementaryMove R X sâ‚ sâ‚‚)"},
 {"type": "FreeModuleAux.coeff  x (sum s) = s.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x := by simp [FreeModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeModuleAux.coeff]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X) : FreeModuleAux.coeff  x (sum s) = s.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (s : FormalSum R X)"},
 {"type": "sâ‚ â‰ƒ sâ‚‚ â†’ sâ‚.coords x = sâ‚‚.coords x",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (sâ‚ sâ‚‚ : FormalSum R X) : sâ‚ â‰ƒ sâ‚‚ â†’ sâ‚.coords x = sâ‚‚.coords x := by intro hyp; sorry",
  "name": "coords_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (sâ‚ sâ‚‚ : FormalSum R X) : sâ‚ â‰ƒ sâ‚‚ â†’ sâ‚.coords x = sâ‚‚.coords x",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x : X)  (sâ‚ sâ‚‚ : FormalSum R X)"},
 {"type": "sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (a : R)  (x : X) : sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (a : R)  (x : X) : sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum R X)  (a : R)  (x : X)"},
 {"type":
  "0 â‰  s.coords xâ‚€ â†’ (âˆƒ ys : FormalSum R X, (((s.coords xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ (List.length ys < s.length))",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X) (s : FormalSum R X) : 0 â‰  s.coords xâ‚€ â†’ (âˆƒ ys : FormalSum R X, (((s.coords xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ (List.length ys < s.length)) := by induction s; sorry",
  "name": "nonzero_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X) (s : FormalSum R X) : 0 â‰  s.coords xâ‚€ â†’ (âˆƒ ys : FormalSum R X, (((s.coords xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ (List.length ys < s.length))",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (xâ‚€ : X) (s : FormalSum R X)"},
 {"type":
  "(âˆ€ sâ‚ sâ‚‚ : FormalSum R X, ElementaryMove R X sâ‚ sâ‚‚ â†’ f sâ‚ = f sâ‚‚) â†’ (âˆ€ sâ‚ sâ‚‚ : FormalSum R X, sâ‚ â‰ˆ sâ‚‚ â†’ f sâ‚ = f sâ‚‚)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {Î² : Sort u}  (f : FormalSum R X â†’ Î²) : (âˆ€ sâ‚ sâ‚‚ : FormalSum R X, ElementaryMove R X sâ‚ sâ‚‚ â†’ f sâ‚ = f sâ‚‚) â†’ (âˆ€ sâ‚ sâ‚‚ : FormalSum R X, sâ‚ â‰ˆ sâ‚‚ â†’ f sâ‚ = f sâ‚‚) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {Î² : Sort u}  (f : FormalSum R X â†’ Î²) : (âˆ€ sâ‚ sâ‚‚ : FormalSum R X, ElementaryMove R X sâ‚ sâ‚‚ â†’ f sâ‚ = f sâ‚‚) â†’ (âˆ€ sâ‚ sâ‚‚ : FormalSum R X, sâ‚ â‰ˆ sâ‚‚ â†’ f sâ‚ = f sâ‚‚)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  {Î² : Sort u}  (f : FormalSum R X â†’ Î²)"},
 {"type": "a â‰¤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a â‰¤ max a b := by simp [max]; sorry",
  "name": "fst_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : a â‰¤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "b â‰¤ max a b",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b â‰¤ max a b := by simp [max]; sorry",
  "name": "snd_le_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : b â‰¤ max a b",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type": "(max a b = a) âˆ¨ (max a b = b)",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) âˆ¨ (max a b = b) := by simp [max]; sorry",
  "name": "eq_fst_or_snd_of_max",
  "kind": "theorem",
  "first-tactic": "simp [max]",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat) : (max a b = a) âˆ¨ (max a b = b)",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (a b : Nat)"},
 {"type":
  "maxNormSuccOnSupp norm crds s > 0 â†’ \n  âˆƒ x : X, crds x â‰  0 âˆ§ maxNormSuccOnSupp norm crds s = norm x + 1",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 â†’ \n  âˆƒ x : X, crds x â‰  0 âˆ§ maxNormSuccOnSupp norm crds s = norm x + 1 := by intro h; sorry",
  "name": "max_in_support",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X) : maxNormSuccOnSupp norm crds s > 0 â†’ \n  âˆƒ x : X, crds x â‰  0 âˆ§ maxNormSuccOnSupp norm crds s = norm x + 1",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X)"},
 {"type":
  "(x: X) â†’ x âˆˆ s â†’  crds x â‰  0 â†’ norm x + 1 â‰¤ maxNormSuccOnSupp norm crds s",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X) : (x: X) â†’ x âˆˆ s â†’  crds x â‰  0 â†’ norm x + 1 â‰¤ maxNormSuccOnSupp norm crds s := by intro x hâ‚ hâ‚‚; sorry",
  "name": "supp_below_max",
  "kind": "theorem",
  "first-tactic": "intro x hâ‚ hâ‚‚",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X) : (x: X) â†’ x âˆˆ s â†’  crds x â‰  0 â†’ norm x + 1 â‰¤ maxNormSuccOnSupp norm crds s",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm: X â†’ Nat) (crds : X â†’ R) (s: List X)"},
 {"type": "sâ‚.normSucc norm = sâ‚‚.normSucc norm",
  "tactic-prompt":
  "theorem {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X â†’ Nat) (sâ‚ sâ‚‚: FormalSum R X) (eql : sâ‚ â‰ˆ sâ‚‚) : sâ‚.normSucc norm = sâ‚‚.normSucc norm := by apply Nat.le_antisymm; sorry",
  "name": "norm_succ_eq",
  "kind": "theorem",
  "first-tactic": "apply Nat.le_antisymm",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X â†’ Nat) (sâ‚ sâ‚‚: FormalSum R X) (eql : sâ‚ â‰ˆ sâ‚‚) : sâ‚.normSucc norm = sâ‚‚.normSucc norm",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (norm : X â†’ Nat) (sâ‚ sâ‚‚: FormalSum R X) (eql : sâ‚ â‰ˆ sâ‚‚)"},
 {"type": "Nat",
  "tactic-prompt":
  "def {R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat := by let f : FormalSum R X â†’ Nat := fun s => s.normSucc (nx.norm); sorry",
  "name": "FreeModule.normBound",
  "kind": "def",
  "first-tactic":
  "let f : FormalSum R X â†’ Nat := fun s => s.normSucc (nx.norm)",
  "core-prompt":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X] : Nat",
  "args":
  "{R : Type}  [Ring R]  [DecidableEq R] {X : Type}  [DecidableEq X]  (x: FreeModule R X) [nx : NormCube X]"},
 {"type": ".append p .nil = p",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B) : .append p .nil = p := by induction p; sorry",
  "name": "append_nil",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B) : .append p .nil = p",
  "args": "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)"},
 {"type": "snoc (cons e p) e' = cons e (snoc p e')",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (e : A âŸ¶ B)  (p : Path B C)  (e' : C âŸ¶ D) : snoc (cons e p) e' = cons e (snoc p e') := by cases p; sorry",
  "name": "snoc_cons",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (e : A âŸ¶ B)  (p : Path B C)  (e' : C âŸ¶ D) : snoc (cons e p) e' = cons e (snoc p e')",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (e : A âŸ¶ B)  (p : Path B C)  (e' : C âŸ¶ D)"},
 {"type": "append p (snoc p' e) = snoc (append p p') e",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C âŸ¶ D) : append p (snoc p' e) = snoc (append p p') e := by induction p; sorry",
  "name": "append_snoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C âŸ¶ D) : append p (snoc p' e) = snoc (append p p') e",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (p' : Path B C)  (e : C âŸ¶ D)"},
 {"type": "append p (cons e p') = append (snoc p e) p'",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B âŸ¶ C)  (p' : Path C D) : append p (cons e p') = append (snoc p e) p' := by induction p; sorry",
  "name": "append_cons",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B âŸ¶ C)  (p' : Path C D) : append p (cons e p') = append (snoc p e) p'",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (e : B âŸ¶ C)  (p' : Path C D)"},
 {"type": "append (append p q) r = append p (append q r)",
  "tactic-prompt":
  "theorem {V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D) : append (append p q) r = append p (append q r) := by induction p; sorry",
  "name": "append_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D) : append (append p q) r = append p (append q r)",
  "args":
  "{V : Sort _}  [Quiver V]  {A B C D : V} (p : Path A B)  (q : Path B C)  (r : Path C D)"},
 {"type": "NullHomotopy (.append p (.append l q)) â†’ NullHomotopy (.append p q)",
  "tactic-prompt":
  "def {V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p (.append l q)) â†’ NullHomotopy (.append p q) := by intro r; sorry",
  "name": "contract",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p (.append l q)) â†’ NullHomotopy (.append p q)",
  "args":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u}"},
 {"type": "NullHomotopy (.append p q) â†’ NullHomotopy (.append p (.append l q))",
  "tactic-prompt":
  "def {V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p q) â†’ NullHomotopy (.append p (.append l q)) := by intro r; sorry",
  "name": "splice",
  "kind": "def",
  "first-tactic": "intro r",
  "core-prompt":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u} : NullHomotopy (.append p q) â†’ NullHomotopy (.append p (.append l q))",
  "args":
  "{V : Sort _}  [C : CombinatorialTwoComplex V]  {u v w : V}  (l l' : Loop v) {u v : V}  {p : Path u v}  {l : Loop v}  (rel : NullHomotopy l)  {q : Path v u}"},
 {"type": "(p : Path A B) â†’ p.last = p.inverse.first",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) : (p : Path A B) â†’ p.last = p.inverse.first := by intro p; sorry",
  "name": "last_eq_inv_first",
  "kind": "theorem",
  "first-tactic": "intro p",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) : (p : Path A B) â†’ p.last = p.inverse.first",
  "args": "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B)"},
 {"type": "l.inv.inv = l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : l.inv.inv = l := by simp; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : l.inv.inv = l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(rotate A l.inv).inv = rotate' A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (rotate A l.inv).inv = rotate' A l := by simp [rotate']; sorry",
  "name": "inv_rotate_inv",
  "kind": "theorem",
  "first-tactic": "simp [rotate']",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (rotate A l.inv).inv = rotate' A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(prev A l.inv) = next A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (prev A l.inv) = next A l := by simp [prev]; sorry",
  "name": "prev_inv",
  "kind": "theorem",
  "first-tactic": "simp [prev]",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (prev A l.inv) = next A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(next A l.inv) = prev A l",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (next A l.inv) = prev A l := by simp; sorry",
  "name": "next_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (next A l.inv) = prev A l",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "(l.rotate' A).next _ = A",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (l.rotate' A).next _ = A := by show prev _ (rotate _ l.inv) = A; sorry",
  "name": "rotate'_next",
  "kind": "theorem",
  "first-tactic": "show prev _ (rotate _ l.inv) = A",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : (l.rotate' A).next _ = A",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "HEq (rotate' A l.inv) (rotate A l).inv",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate' A l.inv) (rotate A l).inv := by rw [â† inv_rotate_inv A l.inv]; sorry",
  "name": "rotate'_inv_heq",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_rotate_inv A l.inv]",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate' A l.inv) (rotate A l).inv",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "HEq (rotate A l.inv) (rotate' A l).inv",
  "tactic-prompt":
  "theorem {V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate A l.inv) (rotate' A l).inv := by rw [rotate']; sorry",
  "name": "rotate_inv_heq",
  "kind": "theorem",
  "first-tactic": "rw [rotate']",
  "core-prompt":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A) : HEq (rotate A l.inv) (rotate' A l).inv",
  "args":
  "{V : Sort _}  [G : SerreGraph V]  {A B C : V}  (p : Path A B) {V : Sort _}  [SerreGraph V]  (A : V) (l : Loop A)"},
 {"type": "gâ»Â¹ â‰« (g â‰« h) = h",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : gâ»Â¹ â‰« (g â‰« h) = h := by rw [â† comp_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [â† comp_assoc]",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : gâ»Â¹ â‰« (g â‰« h) = h",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(ðŸ™ X)â»Â¹ = ðŸ™ X",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (ðŸ™ X)â»Â¹ = ðŸ™ X := by have := left_inv_cancel (ðŸ™ X) (ðŸ™ X); sorry",
  "name": "id_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (ðŸ™ X) (ðŸ™ X)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (ðŸ™ X)â»Â¹ = ðŸ™ X",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(gâ»Â¹)â»Â¹ = g",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (gâ»Â¹)â»Â¹ = g := by have := left_inv_cancel (gâ»Â¹) g; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (gâ»Â¹) g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (gâ»Â¹)â»Â¹ = g",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "g â‰« (gâ»Â¹ â‰« h) = h",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) (h : X âŸ¶ Z) : g â‰« (gâ»Â¹ â‰« h) = h := by have := left_inv_cancel gâ»Â¹ h; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel gâ»Â¹ h",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) (h : X âŸ¶ Z) : g â‰« (gâ»Â¹ â‰« h) = h",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) (h : X âŸ¶ Z)"},
 {"type": "(g â‰« h)â»Â¹ = hâ»Â¹ â‰« gâ»Â¹",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g â‰« h)â»Â¹ = hâ»Â¹ â‰« gâ»Â¹ := by have := left_cancel_inv (g â‰« h)â»Â¹ (hâ»Â¹ â‰« gâ»Â¹); sorry",
  "name": "inv_comp",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (g â‰« h)â»Â¹ (hâ»Â¹ â‰« gâ»Â¹)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g â‰« h)â»Â¹ = hâ»Â¹ â‰« gâ»Â¹",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(g = g â‰« e) â†” ðŸ™ Y = e",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g = g â‰« e) â†” ðŸ™ Y = e := by have := left_cancel g (ðŸ™ _) e; sorry",
  "name": "left_cancel_id",
  "kind": "theorem",
  "first-tactic": "have := left_cancel g (ðŸ™ _) e",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g = g â‰« e) â†” ðŸ™ Y = e",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(g â‰« e = g) â†” e = ðŸ™ Y",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g â‰« e = g) â†” e = ðŸ™ Y := by have := left_cancel g e (ðŸ™ Y); sorry",
  "name": "left_cancel_id'",
  "kind": "theorem",
  "first-tactic": "have := left_cancel g e (ðŸ™ Y)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g â‰« e = g) â†” e = ðŸ™ Y",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(g = e â‰« g) â†” ðŸ™ X = e",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g = e â‰« g) â†” ðŸ™ X = e := by have := right_cancel (ðŸ™ X) e g; sorry",
  "name": "right_cancel_id",
  "kind": "theorem",
  "first-tactic": "have := right_cancel (ðŸ™ X) e g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (g = e â‰« g) â†” ðŸ™ X = e",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "(e â‰« g = g) â†” e = ðŸ™ X",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (e â‰« g = g) â†” e = ðŸ™ X := by have := right_cancel e (ðŸ™ X) g; sorry",
  "name": "right_cancel_id'",
  "kind": "theorem",
  "first-tactic": "have := right_cancel e (ðŸ™ X) g",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) : (e â‰« g = g) â†” e = ðŸ™ X",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z)"},
 {"type": "Î¦.map (ðŸ™ X) = ðŸ™ (Î¦.obj X)",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X : S} : Î¦.map (ðŸ™ X) = ðŸ™ (Î¦.obj X) := by have := Î¦.map_comp (ðŸ™ X) (ðŸ™ X); sorry",
  "name": "map_id'",
  "kind": "theorem",
  "first-tactic": "have := Î¦.map_comp (ðŸ™ X) (ðŸ™ X)",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X : S} : Î¦.map (ðŸ™ X) = ðŸ™ (Î¦.obj X)",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X : S}"},
 {"type": "Î¦.map gâ»Â¹ = (Î¦.map g)â»Â¹",
  "tactic-prompt":
  "theorem {S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X Y : S}  (g : X âŸ¶ Y) : Î¦.map gâ»Â¹ = (Î¦.map g)â»Â¹ := by apply (Groupoid.left_cancel (Î¦.map g) _ _).mp; sorry",
  "name": "map_inv",
  "kind": "theorem",
  "first-tactic": "apply (Groupoid.left_cancel (Î¦.map g) _ _).mp",
  "core-prompt":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X Y : S}  (g : X âŸ¶ Y) : Î¦.map gâ»Â¹ = (Î¦.map g)â»Â¹",
  "args":
  "{S : Sort _}  [G : Groupoid S]  {X Y Z : S}  (g g' : X âŸ¶ Y)  (h h' : Y âŸ¶ Z) {R S T : Sort _}  [F : Groupoid R]  [G : Groupoid S]  [H : Groupoid T] (Î¨ : Groupoid.Functor F G)  (Î¦ : Groupoid.Functor G H) {X Y : S}  (g : X âŸ¶ Y)"},
 {"type": "(EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V} : (EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x â†’ (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x â†’ (term G (G.bar e) = x) := by intro h; sorry",
  "name": "term_bar_equals_init",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x : V} {e : E} : G.init e = x â†’ (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(term G e = x) â†’ G.init (G.bar e) = x",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) â†’ G.init (G.bar e) = x := by intro hyp; sorry",
  "name": "init_bar_equals_term",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x :V}  {e : E} : (term G e = x) â†’ G.init (G.bar e) = x",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x :V}  {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "{ rp : EdgePath G x z // rp.length â‰¤ (cons ex hâ‚ hâ‚‚ exy).length}",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (hâ‚ : G.init ex = x)  (hâ‚‚ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length â‰¤ (cons ex hâ‚ hâ‚‚ exy).length} := by cases exy; sorry",
  "name": "reducePathAux",
  "kind": "def",
  "first-tactic": "cases exy",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (hâ‚ : G.init ex = x)  (hâ‚‚ : term G ex = y)  (exy : EdgePath G y z) : { rp : EdgePath G x z // rp.length â‰¤ (cons ex hâ‚ hâ‚‚ exy).length}",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (ex : E)  (hâ‚ : G.init ex = x)  (hâ‚‚ : term G ex = y)  (exy : EdgePath G y z)"},
 {"type": "homotopy p q â†’ homotopy q r â†’ homotopy p r",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q â†’ homotopy q r â†’ homotopy p r := by intro hâ‚ hâ‚‚; sorry",
  "name": "homotopy_trans",
  "kind": "theorem",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y) : homotopy p q â†’ homotopy q r â†’ homotopy p r",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (p q r : EdgePath G x y)"},
 {"type":
  "(p q : EdgePath G y z) â†’ homotopy p q â†’ (ex : E) â†’(h1 : G.init ex = x) â†’ ( h : term G ex = y)â†’ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) â†’ homotopy p q â†’ (ex : E) â†’(h1 : G.init ex = x) â†’ ( h : term G ex = y)â†’ homotopy (cons ex h1 h p) (cons ex h1 h q) := by intro p q h ex h1 h2; sorry",
  "name": "homotopy_left_mult_edge",
  "kind": "theorem",
  "first-tactic": "intro p q h ex h1 h2",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V} : (p q : EdgePath G y z) â†’ homotopy p q â†’ (ex : E) â†’(h1 : G.init ex = x) â†’ ( h : term G ex = y)â†’ homotopy (cons ex h1 h p) (cons ex h1 h q)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "ht G y z â†’  ht G x z",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y) : ht G y z â†’  ht G x z := by let func: EdgePath G y z â†’ ht G x z := by intro p ; exact htclass (multiply pâ‚ p); sorry",
  "name": "homotopy_left_multiplication",
  "kind": "def",
  "first-tactic":
  "let func: EdgePath G y z â†’ ht G x z := by intro p ; exact htclass (multiply pâ‚ p)",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y) : ht G y z â†’  ht G x z",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y)"},
 {"type":
  "homotopy_left_multiplication pâ‚ (htclass pâ‚‚) = htclass (multiply pâ‚ pâ‚‚)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y)  (pâ‚‚ : EdgePath G y z) : homotopy_left_multiplication pâ‚ (htclass pâ‚‚) = htclass (multiply pâ‚ pâ‚‚) := by simp[htclass]; sorry",
  "name": "homotopy_left_multiplication_class",
  "kind": "theorem",
  "first-tactic": "simp[htclass]",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y)  (pâ‚‚ : EdgePath G y z) : homotopy_left_multiplication pâ‚ (htclass pâ‚‚) = htclass (multiply pâ‚ pâ‚‚)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G :Graph V E}  {x y z : V}  (pâ‚ : EdgePath G x y)  (pâ‚‚ : EdgePath G y z)"},
 {"type": "homotopy pâ‚ (reducePath pâ‚)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (pâ‚ : EdgePath G x y) : homotopy pâ‚ (reducePath pâ‚) := by induction pâ‚; sorry",
  "name": "homotopy_reducePath",
  "kind": "theorem",
  "first-tactic": "induction pâ‚",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (pâ‚ : EdgePath G x y) : homotopy pâ‚ (reducePath pâ‚)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {xâ‚ xâ‚‚ : V} {G : Graph V E}  {x y : V}  (pâ‚ : EdgePath G x y)"},
 {"type": "(succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n) := by rfl; sorry",
  "name": "mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (succ n) * (succ m) =\n          succ ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type": "n * m = 0 â†’ n = 0 âˆ¨ m = 0",
  "tactic-prompt":
  "theorem (n m: Nat) : n * m = 0 â†’ n = 0 âˆ¨ m = 0 := by cases n; sorry",
  "name": "nat_domain",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n m: Nat) : n * m = 0 â†’ n = 0 âˆ¨ m = 0",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_succ_succ",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.ofNat (succ m)) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n) := by rfl; sorry",
  "name": "int_mul_succ_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.ofNat (succ n)) * (Int.negSucc m) =\n         Int.negSucc ((succ n) * m + n)",
  "args": "(n m: Nat)"},
 {"type":
  "(Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "tactic-prompt":
  "theorem (n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n)) := by rfl; sorry",
  "name": "int_mul_negsucc_negsucc",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(n m: Nat) : (Int.negSucc n) * (Int.negSucc m) =\n         Int.ofNat (succ ((succ n) * m + n))",
  "args": "(n m: Nat)"},
 {"type": "n' * m' = 0 â†’ n' = 0 âˆ¨ m' = 0",
  "tactic-prompt":
  "theorem (n' m': Int) : n' * m' = 0 â†’ n' = 0 âˆ¨ m' = 0 := by cases n'; sorry",
  "name": "int_domain",
  "kind": "theorem",
  "first-tactic": "cases n'",
  "core-prompt": "(n' m': Int) : n' * m' = 0 â†’ n' = 0 âˆ¨ m' = 0",
  "args": "(n' m': Int)"},
 {"type": "m â€¢ n = m * n",
  "tactic-prompt": "lemma (m n : â„¤) : m â€¢ n = m * n := by induction m; sorry",
  "name": "zsmul_int",
  "kind": "lemma",
  "first-tactic": "induction m",
  "core-prompt": "(m n : â„¤) : m â€¢ n = m * n",
  "args": "(m n : â„¤)"},
 {"type": "a * b = a * c â†’ b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a * c â†’ b = c := by intro h; sorry",
  "name": "Group.mul_left_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a * c â†’ b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = c * a â†’ b = c",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = c * a â†’ b = c := by intro h; sorry",
  "name": "Group.mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = c * a â†’ b = c",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "(1 : G)â»Â¹ = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)â»Â¹ = 1 := by have : (1 : G)â»Â¹ * 1 = 1 := mul_left_inv 1; sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have : (1 : G)â»Â¹ * 1 = 1 := mul_left_inv 1",
  "core-prompt":
  "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G] : (1 : G)â»Â¹ = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G} {G : Type _}  [Group G]"},
 {"type": "a * b = a â†” b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : a * b = a â†” b = 1 := by apply Iff.intro; sorry",
  "name": "mul_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : a * b = a â†” b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "b * a = a â†” b = 1",
  "tactic-prompt":
  "theorem {G : Type u}  [Group G]  {a b c : G} : b * a = a â†” b = 1 := by apply Iff.intro; sorry",
  "name": "mul_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt": "{G : Type u}  [Group G]  {a b c : G} : b * a = a â†” b = 1",
  "args": "{G : Type u}  [Group G]  {a b c : G}"},
 {"type": "a + b = a â†” b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a â†” b = 0 := by apply Iff.intro; sorry",
  "name": "add_left_eq_cancel",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : a + b = a â†” b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "b + a = a â†” b = 0",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a â†” b = 0 := by rw [add_comm]; sorry",
  "name": "add_right_eq_cancel",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c : A} : b + a = a â†” b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c : A}"},
 {"type": "Ï• 1 = 1",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] : Ï• 1 = 1 := by have : (Ï• 1) * (Ï• 1) = (Ï• 1) * 1 := by rw [â† Homomorphism.mul_distrib]; sorry",
  "name": "one_image",
  "kind": "theorem",
  "first-tactic":
  "have : (Ï• 1) * (Ï• 1) = (Ï• 1) * 1 := by rw [â† Homomorphism.mul_distrib]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] : Ï• 1 = 1",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]"},
 {"type": "(Ï• g)â»Â¹ = Ï• gâ»Â¹",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G} : (Ï• g)â»Â¹ = Ï• gâ»Â¹ := by have : Ï• g * Ï• gâ»Â¹ = Ï• g * (Ï• g)â»Â¹ := by rw [â† Homomorphism.mul_distrib]; simp; sorry",
  "name": "hom_inv",
  "kind": "theorem",
  "first-tactic":
  "have : Ï• g * Ï• gâ»Â¹ = Ï• g * (Ï• g)â»Â¹ := by rw [â† Homomorphism.mul_distrib]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G} : (Ï• g)â»Â¹ = Ï• gâ»Â¹",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G}"},
 {"type": "(Ï• g) ^ n = Ï• (g ^ n)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G}  {n : â„•} : (Ï• g) ^ n = Ï• (g ^ n) := by induction n; sorry",
  "name": "hom_pow",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G}  {n : â„•} : (Ï• g) ^ n = Ï• (g ^ n)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {g : G}  {n : â„•}"},
 {"type": "SubNegMonoid.zsmul (â†‘(n) + 1) a = a + SubNegMonoid.zsmul (â†‘ n) a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : â„•) : SubNegMonoid.zsmul (â†‘(n) + 1) a = a + SubNegMonoid.zsmul (â†‘ n) a := by rw [â† Int.cast_ofNat]; sorry",
  "name": "SubNegMonoid.zsmul_succ'_",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.cast_ofNat]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : â„•) : SubNegMonoid.zsmul (â†‘(n) + 1) a = a + SubNegMonoid.zsmul (â†‘ n) a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A) (n : â„•)"},
 {"type": "SubNegMonoid.zsmul 1 a = a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.zsmul 1 a = a := by rw [â† Int.ofNat_one]; sorry",
  "name": "SubNegMonoid.zsmul_one",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.ofNat_one]",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A) : SubNegMonoid.zsmul 1 a = a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•]  {A : Type _}  [SubNegMonoid A]  (a : A)"},
 {"type": "Ï• (0 : A) = (0 : B)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : Ï• (0 : A) = (0 : B) := by have : Ï• 0 + Ï• 0 = Ï• 0 + 0 := by rw [â† add_dist]; simp; sorry",
  "name": "zero_image",
  "kind": "theorem",
  "first-tactic": "have : Ï• 0 + Ï• 0 = Ï• 0 + 0 := by rw [â† add_dist]; simp",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : Ï• (0 : A) = (0 : B)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]"},
 {"type": "âˆ€ a : A, Ï• (-a) = -Ï• a",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a : A, Ï• (-a) = -Ï• a := by intro a; sorry",
  "name": "neg_push",
  "kind": "theorem",
  "first-tactic": "intro a",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a : A, Ï• (-a) = -Ï• a",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]"},
 {"type": "âˆ€ a a' : A, Ï• (a - a') = Ï• a - Ï• a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a a' : A, Ï• (a - a') = Ï• a - Ï• a' := by intros; sorry",
  "name": "neg_dist",
  "kind": "theorem",
  "first-tactic": "intros",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a a' : A, Ï• (a - a') = Ï• a - Ï• a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]"},
 {"type": "âˆ€ a : A, âˆ€ n : â„•, n â€¢ (Ï• a) = Ï• (n â€¢ a)",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a : A, âˆ€ n : â„•, n â€¢ (Ï• a) = Ï• (n â€¢ a) := by intro a n; sorry",
  "name": "hom_mul",
  "kind": "theorem",
  "first-tactic": "intro a n",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a : A, âˆ€ n : â„•, n â€¢ (Ï• a) = Ï• (n â€¢ a)",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]"},
 {"type": "âˆ€ a a' : A, -(a + a') = -a + -a'",
  "tactic-prompt":
  "theorem {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a a' : A, -(a + a') = -a + -a' := by intro a a'; sorry",
  "name": "neg_hom",
  "kind": "theorem",
  "first-tactic": "intro a a'",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•] : âˆ€ a a' : A, -(a + a') = -a + -a'",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]"},
 {"type": "AddCommGroup.Isomorphism A A",
  "tactic-prompt":
  "instance {G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A := by assumption; sorry",
  "name": "reflMorph",
  "kind": "instance",
  "first-tactic": "assumption",
  "core-prompt":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A] : AddCommGroup.Isomorphism A A",
  "args":
  "{G H : Type _}  [GrpG : Group G]  [GrpH : Group H] {Ï• : G â†’ H}  [HomÏ• : Group.Homomorphism Ï•] {A B : Type _}  [AddCommGroup A]  [AddCommGroup B] (Ï• : A â†’ B)  [AddCommGroup.Homomorphism Ï•]  (A B C : Type _)  [AddCommGroup A]  [AddCommGroup B]  [AddCommGroup C] [AddCommGroup.Isomorphism A A]"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : â„¤} : x + x + y - x - y + z - x = z := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt": "{x y z : â„¤} : x + x + y - x - y + z - x = z",
  "args": "{x y z : â„¤}"},
 {"type": "(a + b) - (b - a) - a = a",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b : A} : (a + b) - (b - a) - a = a",
  "args": "{A : Type _}  [AddCommGroup A]  {a b : A}"},
 {"type": "a + b - a - b = b - b + a - a",
  "tactic-prompt":
  "example {a b : â„¤} : a + b - a - b = b - b + a - a := by have pâ‚— := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have pâ‚— := freeGroupEq",
  "core-prompt": "{a b : â„¤} : a + b - a - b = b - b + a - a",
  "args": "{a b : â„¤}"},
 {"type": "a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "tactic-prompt":
  "example {A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0 := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {a b c d e : A} : a + b - c - d + e - a + b + c - a - e + a - b + d - b = 0",
  "args": "{A : Type _}  [AddCommGroup A]  {a b c d e : A}"},
 {"type": "arr.getIdx? a = some i â†’ arr.size > 0",
  "tactic-prompt":
  "lemma {Î± : Type _}  [DecidableEq Î±]  {arr : Array Î±}  {a : Î±}  {i : â„•} : arr.getIdx? a = some i â†’ arr.size > 0 := by rw [getIdx?]; sorry",
  "name": "Array.size_pos_if_index",
  "kind": "lemma",
  "first-tactic": "rw [getIdx?]",
  "core-prompt":
  "{Î± : Type _}  [DecidableEq Î±]  {arr : Array Î±}  {a : Î±}  {i : â„•} : arr.getIdx? a = some i â†’ arr.size > 0",
  "args": "{Î± : Type _}  [DecidableEq Î±]  {arr : Array Î±}  {a : Î±}  {i : â„•}"},
 {"type": "(arr.push a).size > 0",
  "tactic-prompt":
  "lemma {Î± : Type _}  (arr : Array Î±)  (a : Î±) : (arr.push a).size > 0 := by match arr with\n    | âŸ¨lâŸ© =>\n      simp only [push]; sorry",
  "name": "Array.push_size_pos",
  "kind": "lemma",
  "first-tactic": "match arr with\n    | âŸ¨lâŸ© =>\n      simp only [push]",
  "core-prompt":
  "{Î± : Type _}  (arr : Array Î±)  (a : Î±) : (arr.push a).size > 0",
  "args": "{Î± : Type _}  (arr : Array Î±)  (a : Î±)"},
 {"type": "(arr : Array Î±) â†’ (t.indexTree arr).2.size > 0",
  "tactic-prompt":
  "theorem {Î± : Type _} [Repr Î±] [DecidableEq Î±]  (t: AddTree Î±) : (arr : Array Î±) â†’ (t.indexTree arr).2.size > 0 := by induction t; sorry",
  "name": "pos_size",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{Î± : Type _} [Repr Î±] [DecidableEq Î±]  (t: AddTree Î±) : (arr : Array Î±) â†’ (t.indexTree arr).2.size > 0",
  "args": "{Î± : Type _} [Repr Î±] [DecidableEq Î±]  (t: AddTree Î±)"},
 {"type": "egIndMap x y = x + y + x - y",
  "tactic-prompt":
  "theorem {Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±]     (x y: Î±) : egIndMap x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±]     (x y: Î±) : egIndMap x y = x + y + x - y",
  "args":
  "{Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±]     (x y: Î±)"},
 {"type": "egIndMap'' x y = x + y + x - y",
  "tactic-prompt":
  "theorem {Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±] [Inhabited Î±]     (x y: Î±) : egIndMap'' x y = x + y + x - y := by simp; sorry",
  "name": "egIndMapInv''",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±] [Inhabited Î±]     (x y: Î±) : egIndMap'' x y = x + y + x - y",
  "args":
  "{Î± : Type _} [AddCommGroup Î±] [Repr Î±] [DecidableEq Î±] [Inhabited Î±]     (x y: Î±)"},
 {"type": "xâ»Â¹ * (x * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : xâ»Â¹ * (x * y) = y := by rw [â† mul_assoc]; sorry",
  "name": "left_inv_cancel",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : xâ»Â¹ * (x * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(1 : G)â»Â¹ = (1 : G)",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)â»Â¹ = (1 : G) := by have := left_inv_cancel (1 : G) (1 : G); sorry",
  "name": "one_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (1 : G) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (1 : G)â»Â¹ = (1 : G)",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(xâ»Â¹)â»Â¹ = x",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (xâ»Â¹)â»Â¹ = x := by have := left_inv_cancel (xâ»Â¹) x; sorry",
  "name": "inv_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (xâ»Â¹) x",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (xâ»Â¹)â»Â¹ = x",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * xâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * xâ»Â¹ = 1 := by have := left_inv_cancel (xâ»Â¹) (1 : G); sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (xâ»Â¹) (1 : G)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * xâ»Â¹ = 1",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "x * (xâ»Â¹ * y) = y",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (xâ»Â¹ * y) = y := by have := left_inv_cancel (xâ»Â¹) y; sorry",
  "name": "left_cancel_inv",
  "kind": "theorem",
  "first-tactic": "have := left_inv_cancel (xâ»Â¹) y",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : x * (xâ»Â¹ * y) = y",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "(x * y)â»Â¹ = yâ»Â¹ * xâ»Â¹",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)â»Â¹ = yâ»Â¹ * xâ»Â¹ := by have := left_cancel_inv (x * y)â»Â¹ (yâ»Â¹ * xâ»Â¹); sorry",
  "name": "prod_inv",
  "kind": "theorem",
  "first-tactic": "have := left_cancel_inv (x * y)â»Â¹ (yâ»Â¹ * xâ»Â¹)",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms : (x * y)â»Â¹ = yâ»Â¹ * xâ»Â¹",
  "args": "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms"},
 {"type": "((aâ»Â¹ * a) * (b * bâ»Â¹))â»Â¹ = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((aâ»Â¹ * a) * (b * bâ»Â¹))â»Â¹ = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : ((aâ»Â¹ * a) * (b * bâ»Â¹))â»Â¹ = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "b * ((a * b)â»Â¹ * a) = 1",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)â»Â¹ * a) = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : b * ((a * b)â»Â¹ * a) = 1",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type": "a * (câ»Â¹ * b) * (((bâ»Â¹ * c) * b) * (a * b)â»Â¹) = (1 : G)",
  "tactic-prompt":
  "example {G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (câ»Â¹ * b) * (((bâ»Â¹ * c) * b) * (a * b)â»Â¹) = (1 : G) := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G) : a * (câ»Â¹ * b) * (((bâ»Â¹ * c) * b) * (a * b)â»Â¹) = (1 : G)",
  "args":
  "{G : Type _}  [Group G]  (x y z : G)  -- the group axioms {G : Type _}  [Group G]  (a b c : G)"},
 {"type":
  "(âˆ€ (A : Type) [AddCommGroup A], âˆ€ x y z : A, (Î½ A x y z)) â†” (Î½ (â„¤ Ã— â„¤ Ã— â„¤) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "tactic-prompt":
  "theorem  : (âˆ€ (A : Type) [AddCommGroup A], âˆ€ x y z : A, (Î½ A x y z)) â†” (Î½ (â„¤ Ã— â„¤ Ã— â„¤) (1, 0, 0) (0, 1, 0) (0, 0, 1)) := by apply Iff.intro; sorry",
  "name": "eqn_iff_free_basis",
  "kind": "theorem",
  "first-tactic": "apply Iff.intro",
  "core-prompt":
  " : (âˆ€ (A : Type) [AddCommGroup A], âˆ€ x y z : A, (Î½ A x y z)) â†” (Î½ (â„¤ Ã— â„¤ Ã— â„¤) (1, 0, 0) (0, 1, 0) (0, 0, 1))",
  "args": ""},
 {"type": "âˆ€ l' : List Î±, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "tactic-prompt":
  "lemma {Î± : Type _}  (l : List Î±) : âˆ€ l' : List Î±, List.toArrayAux l {data := l'} = {data := l' ++ l} := by induction l; sorry",
  "name": "List.aux_append",
  "kind": "lemma",
  "first-tactic": "induction l",
  "core-prompt":
  "{Î± : Type _}  (l : List Î±) : âˆ€ l' : List Î±, List.toArrayAux l {data := l'} = {data := l' ++ l}",
  "args": "{Î± : Type _}  (l : List Î±)"},
 {"type": "l.toArray.data = l",
  "tactic-prompt":
  "theorem {A : Type _}  (l : List A) : l.toArray.data = l := by rw [toArray]; sorry",
  "name": "List.arraydata",
  "kind": "theorem",
  "first-tactic": "rw [toArray]",
  "core-prompt": "{A : Type _}  (l : List A) : l.toArray.data = l",
  "args": "{A : Type _}  (l : List A)"},
 {"type": "l.toArray.size = l.length",
  "tactic-prompt":
  "theorem {Î± : Type _}  (l : List Î±) : l.toArray.size = l.length := by rw [Array.size]; sorry",
  "name": "List.arraysize",
  "kind": "theorem",
  "first-tactic": "rw [Array.size]",
  "core-prompt": "{Î± : Type _}  (l : List Î±) : l.toArray.size = l.length",
  "args": "{Î± : Type _}  (l : List Î±)"},
 {"type": "List.length (h :: tl) = Nat.succ m â†’ List.length tl = m",
  "tactic-prompt":
  "theorem  : List.length (h :: tl) = Nat.succ m â†’ List.length tl = m := by intro hyp; sorry",
  "name": "List.cons_len_eq_succ",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt": " : List.length (h :: tl) = Nat.succ m â†’ List.length tl = m",
  "args": ""},
 {"type":
  "IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (â„¤basis n).toArray (by simp [hpos]))",
  "tactic-prompt":
  "theorem (t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : â„•}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (â„¤basis n).toArray (by simp [hpos])) := by induction t; sorry",
  "name": "IndexAddTree.fold_tree_freegroup_eq",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : â„•}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas : IndexAddTree.foldMap t l.toArray (by simp [h, hpos]) =\n                         (inducedFreeMap l h) (IndexAddTree.foldMap t (â„¤basis n).toArray (by simp [hpos]))",
  "args":
  "(t : IndexAddTree) {A : Type _}  [AddCommGroup A]  [Repr A] {n : â„•}  (l : List A)  (h : l.length = n)  (hpos : n > 0) -- basisImages  -- a few helper results and lemmas"},
 {"type": "sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum X)  (a: Nat)  (x: X) : sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚ := by intro h; sorry",
  "name": "cons_equiv_of_equiv",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum X)  (a: Nat)  (x: X) : sâ‚ â‰ƒ sâ‚‚ â†’ (a, x) :: sâ‚ â‰ƒ (a, x) :: sâ‚‚",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]  (sâ‚ sâ‚‚ : FormalSum X)  (a: Nat)  (x: X)"},
 {"type":
  "monomCoeff xâ‚€ (a + b, x) = monomCoeff xâ‚€ (a, x) + monomCoeff xâ‚€ (b, x)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (xâ‚€ x : X) (a b : Nat) : monomCoeff xâ‚€ (a + b, x) = monomCoeff xâ‚€ (a, x) + monomCoeff xâ‚€ (b, x) := by repeat (rw [monomCoeff]); sorry",
  "name": "monom_coeff_hom",
  "kind": "theorem",
  "first-tactic": "repeat (rw [monomCoeff])",
  "core-prompt":
  "(X: Type) [DecidableEq X] (xâ‚€ x : X) (a b : Nat) : monomCoeff xâ‚€ (a + b, x) = monomCoeff xâ‚€ (a, x) + monomCoeff xâ‚€ (b, x)",
  "args": "(X: Type) [DecidableEq X] (xâ‚€ x : X) (a b : Nat)"},
 {"type": "monomCoeff xâ‚€ (0, x) = 0",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (xâ‚€ x : X) : monomCoeff xâ‚€ (0, x) = 0 := by rw [monomCoeff]; sorry",
  "name": "monom_coeff_at_zero",
  "kind": "theorem",
  "first-tactic": "rw [monomCoeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (xâ‚€ x : X) : monomCoeff xâ‚€ (0, x) = 0",
  "args": "(X: Type) [DecidableEq X] (xâ‚€ x : X)"},
 {"type": "coeff  xâ‚€  sâ‚ = coeff  xâ‚€ sâ‚‚",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (xâ‚€ : X) (sâ‚ sâ‚‚: FormalSum X) (h: BasicRel X sâ‚ sâ‚‚) : coeff  xâ‚€  sâ‚ = coeff  xâ‚€ sâ‚‚ := by induction h; sorry",
  "name": "coeff_move_invariant",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(X: Type) [DecidableEq X] (xâ‚€ : X) (sâ‚ sâ‚‚: FormalSum X) (h: BasicRel X sâ‚ sâ‚‚) : coeff  xâ‚€  sâ‚ = coeff  xâ‚€ sâ‚‚",
  "args":
  "(X: Type) [DecidableEq X] (xâ‚€ : X) (sâ‚ sâ‚‚: FormalSum X) (h: BasicRel X sâ‚ sâ‚‚)"},
 {"type": "FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s := by simp [FreeNatModuleAux.coeff]; sorry",
  "name": "coeff_factors",
  "kind": "theorem",
  "first-tactic": "simp [FreeNatModuleAux.coeff]",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X) : FreeNatModuleAux.coeff X x (sum s) = coeff x s",
  "args": "(X: Type) [DecidableEq X] (x: X) (s: FormalSum X)"},
 {"type": "sâ‚ â‰ƒ sâ‚‚ â†’ (coeff x sâ‚) = (coeff x sâ‚‚)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (x: X) (sâ‚ sâ‚‚: FormalSum X) : sâ‚ â‰ƒ sâ‚‚ â†’ (coeff x sâ‚) = (coeff x sâ‚‚) := by intro hyp; sorry",
  "name": "coeff_well_defined",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] (x: X) (sâ‚ sâ‚‚: FormalSum X) : sâ‚ â‰ƒ sâ‚‚ â†’ (coeff x sâ‚) = (coeff x sâ‚‚)",
  "args": "(X: Type) [DecidableEq X] (x: X) (sâ‚ sâ‚‚: FormalSum X)"},
 {"type":
  "0 < s.coeff xâ‚€  â†’ \n          (âˆƒ ys: FormalSum X, \n            (((s.coeff xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ \n            (List.length ys < s.length))",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] (xâ‚€ : X) (s : FormalSum X) : 0 < s.coeff xâ‚€  â†’ \n          (âˆƒ ys: FormalSum X, \n            (((s.coeff xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ \n            (List.length ys < s.length)) := by induction s; sorry",
  "name": "pos_coeff_has_complement",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt":
  "(X: Type) [DecidableEq X] (xâ‚€ : X) (s : FormalSum X) : 0 < s.coeff xâ‚€  â†’ \n          (âˆƒ ys: FormalSum X, \n            (((s.coeff xâ‚€, xâ‚€) :: ys) â‰ƒ s) âˆ§ \n            (List.length ys < s.length))",
  "args": "(X: Type) [DecidableEq X] (xâ‚€ : X) (s : FormalSum X)"},
 {"type": "f = g â†’ equalOnSupport l f g",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X â†’ Nat) : f = g â†’ equalOnSupport l f g := by intro hyp; sorry",
  "name": "equal_on_support_of_equal",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X â†’ Nat) : f = g â†’ equalOnSupport l f g",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]    (l: List X) (f g : X â†’ Nat)"},
 {"type": "eqlCoords X s s",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s := by rfl; sorry",
  "name": "refl",
  "kind": "theorem",
  "first-tactic": "rfl",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X) : eqlCoords X s s",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (s: FormalSum X)"},
 {"type": "eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ : FormalSum X} : eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚ := by intro hyp; sorry",
  "name": "symm",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ : FormalSum X} : eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ : FormalSum X}"},
 {"type": "eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚ƒ â†’ eqlCoords X sâ‚ sâ‚ƒ",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum X} : eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚ƒ â†’ eqlCoords X sâ‚ sâ‚ƒ := by intro hypâ‚ hypâ‚‚; sorry",
  "name": "trans",
  "kind": "theorem",
  "first-tactic": "intro hypâ‚ hypâ‚‚",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum X} : eqlCoords X sâ‚ sâ‚‚ â†’ eqlCoords X sâ‚‚ sâ‚ƒ â†’ eqlCoords X sâ‚ sâ‚ƒ",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {sâ‚ sâ‚‚ sâ‚ƒ : FormalSum X}"},
 {"type":
  "(âˆ€ sâ‚ sâ‚‚ : FormalSum X, âˆ€ mv : BasicRel X sâ‚ sâ‚‚, f sâ‚ = f sâ‚‚) â†’ \n  (âˆ€ sâ‚ sâ‚‚ : FormalSum X, sâ‚ â‰ˆ sâ‚‚ â†’  f sâ‚ = f sâ‚‚)",
  "tactic-prompt":
  "theorem (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {Î² : Sort u}    (f : FormalSum X â†’ Î²) : (âˆ€ sâ‚ sâ‚‚ : FormalSum X, âˆ€ mv : BasicRel X sâ‚ sâ‚‚, f sâ‚ = f sâ‚‚) â†’ \n  (âˆ€ sâ‚ sâ‚‚ : FormalSum X, sâ‚ â‰ˆ sâ‚‚ â†’  f sâ‚ = f sâ‚‚) := by intro hyp; sorry",
  "name": "func_eql_of_move_equiv",
  "kind": "theorem",
  "first-tactic": "intro hyp",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {Î² : Sort u}    (f : FormalSum X â†’ Î²) : (âˆ€ sâ‚ sâ‚‚ : FormalSum X, âˆ€ mv : BasicRel X sâ‚ sâ‚‚, f sâ‚ = f sâ‚‚) â†’ \n  (âˆ€ sâ‚ sâ‚‚ : FormalSum X, sâ‚ â‰ˆ sâ‚‚ â†’  f sâ‚ = f sâ‚‚)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] {Î² : Sort u}    (f : FormalSum X â†’ Î²)"},
 {"type": "FreeNatModule X â†’ Nat",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (fâ‚€ : X â†’ Nat) : FreeNatModule X â†’ Nat := by apply Quotient.lift (linear_extension fâ‚€); sorry",
  "name": "miniUniversalProperty",
  "kind": "def",
  "first-tactic": "apply Quotient.lift (linear_extension fâ‚€)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (fâ‚€ : X â†’ Nat) : FreeNatModule X â†’ Nat",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] (fâ‚€ : X â†’ Nat)"},
 {"type": "Bool",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X) : Bool := by apply Quotient.liftâ‚‚ (fun (sâ‚ sâ‚‚ : FormalSum X) => \n          decide ( âŸ¦ sâ‚ âŸ§ = âŸ¦ sâ‚‚ âŸ§)); sorry",
  "name": "FreeNatModule.beq?",
  "kind": "def",
  "first-tactic":
  "apply Quotient.liftâ‚‚ (fun (sâ‚ sâ‚‚ : FormalSum X) => \n          decide ( âŸ¦ sâ‚ âŸ§ = âŸ¦ sâ‚‚ âŸ§))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X) : Bool",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X)"},
 {"type": "âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = true â†’ xâ‚ = xâ‚‚",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = true â†’ xâ‚ = xâ‚‚ := by let f := @Quotient.indâ‚‚ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (xâ‚ xâ‚‚ : FreeNatModule X) =>   xâ‚.beq? xâ‚‚ = true â†’ xâ‚ = xâ‚‚); sorry",
  "name": "FreeNatModule.eq_of_beq_true",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.indâ‚‚ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (xâ‚ xâ‚‚ : FreeNatModule X) =>   xâ‚.beq? xâ‚‚ = true â†’ xâ‚ = xâ‚‚)",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = true â†’ xâ‚ = xâ‚‚",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚) := by let f := @Quotient.indâ‚‚ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (xâ‚ xâ‚‚ : FreeNatModule X) =>   xâ‚.beq? xâ‚‚ = false â†’\n                Not (xâ‚ = xâ‚‚)); sorry",
  "name": "FreeNatModule.neq_of_beq_false",
  "kind": "def",
  "first-tactic":
  "let f := @Quotient.indâ‚‚ (FormalSum X) (FormalSum X)\n              (formalSumSetoid X) (formalSumSetoid X)\n              (fun (xâ‚ xâ‚‚ : FreeNatModule X) =>   xâ‚.beq? xâ‚‚ = false â†’\n                Not (xâ‚ = xâ‚‚))",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X] : âˆ€ xâ‚ xâ‚‚ : FreeNatModule X,  xâ‚.beq? xâ‚‚ = false â†’ Not (xâ‚ = xâ‚‚)",
  "args": "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]"},
 {"type": "Decidable (xâ‚ = xâ‚‚)",
  "tactic-prompt":
  "def (X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X) : Decidable (xâ‚ = xâ‚‚) := by match p:xâ‚.beq? xâ‚‚ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption; sorry",
  "name": "FreeNatModule.decEq",
  "kind": "def",
  "first-tactic":
  "match p:xâ‚.beq? xâ‚‚ with\n    | true => \n      apply Decidable.isTrue\n      apply FreeNatModule.eq_of_beq_true\n      assumption\n    | false => \n      apply Decidable.isFalse\n      apply FreeNatModule.neq_of_beq_false\n      assumption",
  "core-prompt":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X) : Decidable (xâ‚ = xâ‚‚)",
  "args":
  "(X: Type) [DecidableEq X] {X: Type} [DecidableEq X]      (xâ‚ xâ‚‚ : FreeNatModule X)"},
 {"type": "(EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z)",
  "tactic-prompt":
  "def {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z) := by intro p q; sorry",
  "name": "multiply",
  "kind": "def",
  "first-tactic": "intro p q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V} : (EdgePath G x y) â†’ (EdgePath G y z) â†’ (EdgePath G x z)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}"},
 {"type": "G.init e = x â†’ (term G (G.bar e) = x)",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x â†’ (term G (G.bar e) = x) := by intro h; sorry",
  "name": "lemma1",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E} : G.init e = x â†’ (term G (G.bar e) = x)",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x : V} {e : E}"},
 {"type": "(multiply (multiply p q) r) = (multiply p (multiply q r))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r)) := by induction p; sorry",
  "name": "mult_assoc",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z) : (multiply (multiply p q) r) = (multiply p (multiply q r))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  (p : EdgePath G w x)  (q : EdgePath G x y)  (r : EdgePath G y z)"},
 {"type": "(multiply p (single y)) = p",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p := by induction p; sorry",
  "name": "mult_const",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y} : (multiply p (single y)) = p",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {p : EdgePath G x y}"},
 {"type": "(homotopy (multiply q p1) (multiply q p2))",
  "tactic-prompt":
  "theorem {V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2)) := by induction q; sorry",
  "name": "homotopy_left_mult",
  "kind": "theorem",
  "first-tactic": "induction q",
  "core-prompt":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2) : (homotopy (multiply q p1) (multiply q p2))",
  "args":
  "{V: Type} {E: Type} [DecidableEq V] [DecidableEq E] {G : Graph V E}  {x y z : V}  (p1 p2 : EdgePath G y z)  (q : EdgePath G x y)  (h :homotopy p1 p2)"},
 {"type": "(inducedFreeMap l h) (â„¤basisElem n k) = l.get âŸ¨k, h â–¸ hkâŸ©",
  "tactic-prompt":
  "theorem {A : Type _}  [AddCommGroup A]  {n : â„•}  (l : List A)  (h : l.length = n)  (k: â„•)  (hk : k < n) : (inducedFreeMap l h) (â„¤basisElem n k) = l.get âŸ¨k, h â–¸ hkâŸ© := by rw [â„¤basisElem]; sorry",
  "name": "induced_free_map_at",
  "kind": "theorem",
  "first-tactic": "rw [â„¤basisElem]",
  "core-prompt":
  "{A : Type _}  [AddCommGroup A]  {n : â„•}  (l : List A)  (h : l.length = n)  (k: â„•)  (hk : k < n) : (inducedFreeMap l h) (â„¤basisElem n k) = l.get âŸ¨k, h â–¸ hkâŸ©",
  "args":
  "{A : Type _}  [AddCommGroup A]  {n : â„•}  (l : List A)  (h : l.length = n)  (k: â„•)  (hk : k < n)"},
 {"type": "x + x + y - x - y + z - x = z",
  "tactic-prompt":
  "example {x y z : â„¤} : x + x + y - x - y + z - x = z := by have p := freeGroupEq; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have p := freeGroupEq",
  "core-prompt": "{x y z : â„¤} : x + x + y - x - y + z - x = z",
  "args": "{x y z : â„¤}"},
 {"type": "Graph Unit Bool",
  "tactic-prompt": "example  : Graph Unit Bool := by apply Graph.mk; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Graph.mk",
  "core-prompt": " : Graph Unit Bool",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by if 1 + 1 = 2 then _ else ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if 1 + 1 = 2 then _ else ?_",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (p : Prop) : True := by if p then ?foo else trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "if p then ?foo else trivial",
  "core-prompt": "(p : Prop) : True",
  "args": "(p : Prop)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "P",
  "tactic-prompt": "example {P : Prop}  (p : P) : P := by simpa using p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simpa using p",
  "core-prompt": "{P : Prop}  (p : P) : P",
  "args": "{P : Prop}  (p : P)"},
 {"type": "foo n = [n]",
  "tactic-prompt":
  "example  : foo n = [n] := by fail_if_success simpa only [foo]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success simpa only [foo]",
  "core-prompt": " : foo n = [n]",
  "args": ""},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (h : p (a + b)) : p (b + a) := by have : a + b = b + a := Nat.add_comm _ _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a + b = b + a := Nat.add_comm _ _",
  "core-prompt": "(p : Nat â†’ Prop)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat â†’ Prop)  (h : p (a + b))"},
 {"type": "injective fun a => a / b",
  "tactic-prompt":
  "theorem [Group G] (b : G) : injective fun a => a / b := by simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic":
  "simpa only [div_eq_mul_inv] using fun a a' h => mul_left_injective (Inv.inv b) h",
  "core-prompt": "[Group G] (b : G) : injective fun a => a / b",
  "args": "[Group G] (b : G)"},
 {"type": "Nat Ã— Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat Ã— Nat := by show_term\n    constructor\n    exact n\n    exact 37; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term\n    constructor\n    exact n\n    exact 37",
  "core-prompt": "(n : Nat) : Nat Ã— Nat",
  "args": "(n : Nat)"},
 {"type": "Nat Ã— Nat",
  "tactic-prompt":
  "example (n : Nat) : Nat Ã— Nat := by show_term constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "show_term constructor",
  "core-prompt": "(n : Nat) : Nat Ã— Nat",
  "args": "(n : Nat)"},
 {"type": "P â†’ P",
  "tactic-prompt": "example (P : Prop) : P â†’ P := by by_contra; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra",
  "core-prompt": "(P : Prop) : P â†’ P",
  "args": "(P : Prop)"},
 {"type": "a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c)",
  "tactic-prompt":
  "theorem  : a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c) := by rw [â† and_assoc]; sorry",
  "name": "and_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† and_assoc]",
  "core-prompt": " : a âˆ§ (b âˆ§ c) â†” b âˆ§ (a âˆ§ c)",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b := by simp only [and_left_comm]; sorry",
  "name": "and_right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b",
  "args": ""},
 {"type": "a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a",
  "tactic-prompt":
  "theorem  : a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a := by simp only [and_left_comm]; sorry",
  "name": "and_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [and_left_comm]",
  "core-prompt": " : a âˆ§ b âˆ§ c â†” b âˆ§ c âˆ§ a",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d := by rw [â† and_assoc]; sorry",
  "name": "and_and_and_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† and_assoc]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c âˆ§ d â†” (a âˆ§ c) âˆ§ b âˆ§ d",
  "args": ""},
 {"type": "a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c",
  "tactic-prompt":
  "theorem  : a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_left",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : a âˆ§ b âˆ§ c â†” (a âˆ§ b) âˆ§ a âˆ§ c",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c := by rw [and_and_and_comm]; sorry",
  "name": "and_and_right",
  "kind": "theorem",
  "first-tactic": "rw [and_and_and_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ§ c â†” (a âˆ§ c) âˆ§ b âˆ§ c",
  "args": ""},
 {"type": "(p â†” p âˆ§ q) â†” (p â†’ q)",
  "tactic-prompt":
  "theorem  : (p â†” p âˆ§ q) â†” (p â†’ q) := by rw [@Iff.comm p]; sorry",
  "name": "iff_self_and",
  "kind": "theorem",
  "first-tactic": "rw [@Iff.comm p]",
  "core-prompt": " : (p â†” p âˆ§ q) â†” (p â†’ q)",
  "args": ""},
 {"type": "(p â†” q âˆ§ p) â†” (p â†’ q)",
  "tactic-prompt":
  "theorem  : (p â†” q âˆ§ p) â†” (p â†’ q) := by rw [and_comm]; sorry",
  "name": "iff_and_self",
  "kind": "theorem",
  "first-tactic": "rw [and_comm]",
  "core-prompt": " : (p â†” q âˆ§ p) â†” (p â†’ q)",
  "args": ""},
 {"type": "(a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b)",
  "tactic-prompt":
  "theorem  : (a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b) := by simp only [and_comm]; sorry",
  "name": "and_congr_left_iff",
  "kind": "theorem",
  "first-tactic": "simp only [and_comm]",
  "core-prompt": " : (a âˆ§ c â†” b âˆ§ c) â†” c â†’ (a â†” b)",
  "args": ""},
 {"type": "a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c)",
  "tactic-prompt":
  "theorem  : a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c) := by rw [â† or_assoc]; sorry",
  "name": "or_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† or_assoc]",
  "core-prompt": " : a âˆ¨ (b âˆ¨ c) â†” b âˆ¨ (a âˆ¨ c)",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b := by rw [or_assoc]; sorry",
  "name": "or_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [or_assoc]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d := by rw [â† or_assoc]; sorry",
  "name": "or_or_or_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† or_assoc]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c âˆ¨ d â†” (a âˆ¨ c) âˆ¨ b âˆ¨ d",
  "args": ""},
 {"type": "a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c",
  "tactic-prompt":
  "theorem  : a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_left",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : a âˆ¨ b âˆ¨ c â†” (a âˆ¨ b) âˆ¨ a âˆ¨ c",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c := by rw [or_or_or_comm]; sorry",
  "name": "or_or_distrib_right",
  "kind": "theorem",
  "first-tactic": "rw [or_or_or_comm]",
  "core-prompt": " : (a âˆ¨ b) âˆ¨ c â†” (a âˆ¨ c) âˆ¨ b âˆ¨ c",
  "args": ""},
 {"type": "a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a",
  "tactic-prompt":
  "theorem  : a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a := by simp only [or_left_comm]; sorry",
  "name": "or_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [or_left_comm]",
  "core-prompt": " : a âˆ¨ b âˆ¨ c â†” b âˆ¨ c âˆ¨ a",
  "args": ""},
 {"type": "(a âˆ¨ b â†” b) â†” (a â†’ b)",
  "tactic-prompt": "theorem  : (a âˆ¨ b â†” b) â†” (a â†’ b) := by rw [or_comm]; sorry",
  "name": "or_iff_right_iff_imp",
  "kind": "theorem",
  "first-tactic": "rw [or_comm]",
  "core-prompt": " : (a âˆ¨ b â†” b) â†” (a â†’ b)",
  "args": ""},
 {"type": "(a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c)",
  "tactic-prompt":
  "theorem  : (a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c) := by simp [and_comm]; sorry",
  "name": "or_and_right",
  "kind": "theorem",
  "first-tactic": "simp [and_comm]",
  "core-prompt": " : (a âˆ¨ b) âˆ§ c â†” (a âˆ§ c) âˆ¨ (b âˆ§ c)",
  "args": ""},
 {"type": "(a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
  "tactic-prompt":
  "theorem  : (a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c) := by simp [or_comm]; sorry",
  "name": "and_or_right",
  "kind": "theorem",
  "first-tactic": "simp [or_comm]",
  "core-prompt": " : (a âˆ§ b) âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
  "args": ""},
 {"type": "(âˆ€ a, a' = a â†’ p a) â†” p a'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±} : (âˆ€ a, a' = a â†’ p a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "forall_eq'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±} : (âˆ€ a, a' = a â†’ p a) â†” p a'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {a' : Î±}"},
 {"type": "(âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b := by simp [And.comm]; sorry",
  "name": "exists_and_right",
  "kind": "theorem",
  "first-tactic": "simp [And.comm]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ x, p x âˆ§ b) â†” (âˆƒ x, p x) âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ a, a' = a âˆ§ p a) â†” p a'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, a' = a âˆ§ p a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_left'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, a' = a âˆ§ p a) â†” p a'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a := by simp only [or_imp]; sorry",
  "name": "forall_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_imp]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆ€ a, a = a' âˆ¨ q a â†’ p a) â†” p a' âˆ§ âˆ€ a, q a â†’ p a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a := by simp only [or_and_right]; sorry",
  "name": "exists_eq_or_imp",
  "kind": "theorem",
  "first-tactic": "simp only [or_and_right]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ a, (a = a' âˆ¨ q a) âˆ§ p a) â†” p a' âˆ¨ âˆƒ a, q a âˆ§ p a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b := by simp [â† and_assoc]; sorry",
  "name": "exists_eq_right_right",
  "kind": "theorem",
  "first-tactic": "simp [â† and_assoc]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a = a') â†” p a' âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b := by (conv in _=_ => rw [eq_comm]); sorry",
  "name": "exists_eq_right_right'",
  "kind": "theorem",
  "first-tactic": "(conv in _=_ => rw [eq_comm])",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} : (âˆƒ (a : Î±), p a âˆ§ b âˆ§ a' = a) â†” p a' âˆ§ b",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _}"},
 {"type": "(decide p = true) â†” p",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p] : (decide p = true) â†” p := by simp; sorry",
  "name": "decide_eq_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p] : (decide p = true) â†” p",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (p : Prop)  [Decidable p]"},
 {"type": "(Â¬a â†’ a) â†” a",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (Â¬a â†’ a) â†” a := by have := @imp_not_self (Â¬a); sorry",
  "name": "Decidable.not_imp_self",
  "kind": "theorem",
  "first-tactic": "have := @imp_not_self (Â¬a)",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (Â¬a â†’ a) â†” a",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]"},
 {"type": "(a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c) := by by_cases a; sorry",
  "name": "Decidable.imp_or",
  "kind": "theorem",
  "first-tactic": "by_cases a",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a] : (a â†’ b âˆ¨ c) â†” (a â†’ b) âˆ¨ (a â†’ c)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]"},
 {"type": "(Â¬a â†” Â¬b) â†” (a â†” b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” Â¬b) â†” (a â†” b) := by rw [@iff_def (Â¬a)]; sorry",
  "name": "Decidable.not_iff_not",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (Â¬a)]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” Â¬b) â†” (a â†” b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(Â¬a â†” b) â†” (Â¬b â†” a)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” b) â†” (Â¬b â†” a) := by rw [@iff_def (Â¬a)]; sorry",
  "name": "Decidable.not_iff_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def (Â¬a)]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (Â¬a â†” b) â†” (Â¬b â†” a)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "Â¬(a â†” b) â†” (Â¬a â†” b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b] : Â¬(a â†” b) â†” (Â¬a â†” b) := by by_cases h : b; sorry",
  "name": "Decidable.not_iff",
  "kind": "theorem",
  "first-tactic": "by_cases h : b",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b] : Â¬(a â†” b) â†” (Â¬a â†” b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable b]"},
 {"type": "(a â†” Â¬b) â†” (b â†” Â¬a)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” Â¬b) â†” (b â†” Â¬a) := by rw [@iff_def a]; sorry",
  "name": "Decidable.iff_not_comm",
  "kind": "theorem",
  "first-tactic": "rw [@iff_def a]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” Â¬b) â†” (b â†” Â¬a)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "(a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b) := by rw [iff_iff_implies_and_implies a b]; sorry",
  "name": "Decidable.iff_iff_not_or_and_or_not",
  "kind": "theorem",
  "first-tactic": "rw [iff_iff_implies_and_implies a b]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : (a â†” b) â†” (Â¬a âˆ¨ b) âˆ§ (a âˆ¨ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b) := by rw [â† not_or]; sorry",
  "name": "Decidable.or_iff_not_and_not",
  "kind": "theorem",
  "first-tactic": "rw [â† not_or]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ¨ b â†” Â¬(Â¬a âˆ§ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b)",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b) := by rw [â† not_and]; sorry",
  "name": "Decidable.and_iff_not_or_not",
  "kind": "theorem",
  "first-tactic": "rw [â† not_and]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b] : a âˆ§ b â†” Â¬(Â¬a âˆ¨ Â¬b)",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  [Decidable b]"},
 {"type": "a âˆ¨ c â†” b âˆ¨ c",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b)) : a âˆ¨ c â†” b âˆ¨ c := by rw [or_iff_not_imp_right]; sorry",
  "name": "Decidable.or_congr_left'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_right]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b)) : a âˆ¨ c â†” b âˆ¨ c",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable c]  (h : Â¬c â†’ (a â†” b))"},
 {"type": "a âˆ¨ b â†” a âˆ¨ c",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c)) : a âˆ¨ b â†” a âˆ¨ c := by rw [or_iff_not_imp_left]; sorry",
  "name": "Decidable.or_congr_right'",
  "kind": "theorem",
  "first-tactic": "rw [or_iff_not_imp_left]",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c)) : a âˆ¨ b â†” a âˆ¨ c",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} [Decidable a]  (h : Â¬a â†’ (b â†” c))"},
 {"type": "HEq hp hq",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq := by cases propext (iff_of_true hp hq); sorry",
  "name": "proof_irrel_heq",
  "kind": "theorem",
  "first-tactic": "cases propext (iff_of_true hp hq)",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q) : HEq hp hq",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {p q : Prop}  (hp : p)  (hq : q)"},
 {"type": "(@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a') : (@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y := by cases h; sorry",
  "name": "eq_rec_constant",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a') : (@Eq.rec Î± a (fun Î± _ => Î²) y a' h) = y",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} {Î± : Sort _}  {a a' : Î±}  {Î² : Sort _}  (y : Î²)  (h : a = a')"},
 {"type": "f x y = f x' y'",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y') : f x y = f x' y' := by subst hx hy; sorry",
  "name": "congrArgâ‚‚",
  "kind": "theorem",
  "first-tactic": "subst hx hy",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y') : f x y = f x' y'",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î² â†’ Î³)  {x x' : Î±}  {y y' : Î²}      (hx : x = x')  (hy : y = y')"},
 {"type": "f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h)) := by by_cases h : P; sorry",
  "name": "apply_dite",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±) : f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (f : Î± â†’ Î²)  (P : Prop)  [Decidable P]  (x : P â†’ Î±)  (y : Â¬P â†’ Î±)"},
 {"type": "dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "tactic-prompt":
  "theorem {p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x := by by_cases h : P; sorry",
  "name": "dite_not",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (fun h => y (not_not_intro h)) x",
  "args":
  "{p q : Î± â†’ Prop}  {b : Prop}  {Î² : Î± â†’ Sort _} {Î³ : âˆ€ a, Î² a â†’ Sort _} {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {Îµ : âˆ€ a b c, Î´ a b c â†’ Sort _} (P : Prop)  [Decidable P]   (x : Â¬P â†’ Î±)  (y : Â¬Â¬P â†’ Î±)"},
 {"type": "(a == b) = false â†” a â‰  b",
  "tactic-prompt":
  "theorem [BEq Î±]  [LawfulBEq Î±]      (a b : Î±) : (a == b) = false â†” a â‰  b := by rw [ne_eq]; sorry",
  "name": "beq_eq_false_iff_ne",
  "kind": "theorem",
  "first-tactic": "rw [ne_eq]",
  "core-prompt":
  "[BEq Î±]  [LawfulBEq Î±]      (a b : Î±) : (a == b) = false â†” a â‰  b",
  "args": "[BEq Î±]  [LawfulBEq Î±]      (a b : Î±)"},
 {"type": "SatisfiesM q (f <$> x)",
  "tactic-prompt":
  "theorem [Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a)) : SatisfiesM q (f <$> x) := by let âŸ¨x', hxâŸ© := hx; sorry",
  "name": "map",
  "kind": "theorem",
  "first-tactic": "let âŸ¨x', hxâŸ© := hx",
  "core-prompt":
  "[Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a)) : SatisfiesM q (f <$> x)",
  "args":
  "[Functor m]  [LawfulFunctor m]  {x : m Î±}      (hx : SatisfiesM p x)  (hf : âˆ€ {a}, p a â†’ q (f a))"},
 {"type": "SatisfiesM q (f <*> x)",
  "tactic-prompt":
  "theorem [Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a)) : SatisfiesM q (f <*> x) := by match f, x, hf, hx with | _, _, âŸ¨f, rflâŸ©, âŸ¨x, rflâŸ© => ?_; sorry",
  "name": "seq",
  "kind": "theorem",
  "first-tactic": "match f, x, hf, hx with | _, _, âŸ¨f, rflâŸ©, âŸ¨x, rflâŸ© => ?_",
  "core-prompt":
  "[Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a)) : SatisfiesM q (f <*> x)",
  "args":
  "[Applicative m]  [LawfulApplicative m]  {x : m Î±}      (hf : SatisfiesM pâ‚ f)  (hx : SatisfiesM pâ‚‚ x)      (H : âˆ€ {f a}, pâ‚ f â†’ pâ‚‚ a â†’ q (f a))"},
 {"type": "SatisfiesM q (x >>= f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a)) : SatisfiesM q (x >>= f) := by match x, hx with | _, âŸ¨x, rflâŸ© => ?_; sorry",
  "name": "bind",
  "kind": "theorem",
  "first-tactic": "match x, hx with | _, âŸ¨x, rflâŸ© => ?_",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a)) : SatisfiesM q (x >>= f)",
  "args":
  "[Monad m]  [LawfulMonad m]  {f : Î± â†’ m Î²}      (hx : SatisfiesM p x)  (hf : âˆ€ a, p a â†’ SatisfiesM q (f a))"},
 {"type": "SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s)",
  "tactic-prompt":
  "theorem [Monad m] : SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s) := by simp; sorry",
  "name": "SatisfiesM_StateRefT_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "[Monad m] : SatisfiesM (m := StateRefT' Ï‰ Ïƒ m) p x â†” âˆ€ s, SatisfiesM p (x s)",
  "args": "[Monad m]"},
 {"type":
  "SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s) := by refine .trans âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, hâŸ© => ?_âŸ© Classical.skolem.symm; sorry",
  "name": "SatisfiesM_StateT_eq",
  "kind": "theorem",
  "first-tactic":
  "refine .trans âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, hâŸ© => ?_âŸ© Classical.skolem.symm",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := StateT Ï m) (Î± := Î±) p x â†” âˆ€ s, SatisfiesM (m := m) (p Â·.1) (x s)",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type":
  "SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x := by refine âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, eqâŸ© => eq â–¸ ?_âŸ©; sorry",
  "name": "SatisfiesM_ExceptT_eq",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun âŸ¨f, eqâŸ© => eq â–¸ ?_, fun âŸ¨f, eqâŸ© => eq â–¸ ?_âŸ©",
  "core-prompt":
  "[Monad m]  [LawfulMonad m] : SatisfiesM (m := ExceptT Ï m) (Î± := Î±) p x â†” SatisfiesM (m := m) (âˆ€ a, Â· = .ok a â†’ p a) x",
  "args": "[Monad m]  [LawfulMonad m]"},
 {"type": "o.swap.swap = o",
  "tactic-prompt":
  "theorem {o : Ordering} : o.swap.swap = o := by cases o; sorry",
  "name": "Ordering.swap_swap",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": "{o : Ordering} : o.swap.swap = o",
  "args": "{o : Ordering}"},
 {"type": "cmp x y = .gt â†” cmp y x = .lt",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .gt â†” cmp y x = .lt := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_eq_gt",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .gt â†” cmp y x = .lt",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x y = .eq â†” cmp y x = .eq",
  "tactic-prompt":
  "theorem [OrientedCmp cmp] : cmp x y = .eq â†” cmp y x = .eq := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_eq_eq_symm",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt": "[OrientedCmp cmp] : cmp x y = .eq â†” cmp y x = .eq",
  "args": "[OrientedCmp cmp]"},
 {"type": "cmp x z â‰  .lt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt) : cmp x z â‰  .lt := by have := @TransCmp.le_trans _ cmp _ z y x; sorry",
  "name": "ge_trans",
  "kind": "theorem",
  "first-tactic": "have := @TransCmp.le_trans _ cmp _ z y x",
  "core-prompt":
  "[TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt) : cmp x z â‰  .lt",
  "args": "[TransCmp cmp] (hâ‚ : cmp x y â‰  .lt)  (hâ‚‚ : cmp y z â‰  .lt)"},
 {"type": "cmp x z = .gt",
  "tactic-prompt":
  "theorem [TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt) : cmp x z = .gt := by rw [cmp_eq_gt] at hâ‚ hâ‚‚ âŠ¢; sorry",
  "name": "gt_trans",
  "kind": "theorem",
  "first-tactic": "rw [cmp_eq_gt] at hâ‚ hâ‚‚ âŠ¢",
  "core-prompt":
  "[TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt) : cmp x z = .gt",
  "args": "[TransCmp cmp] (hâ‚ : cmp x y = .gt)  (hâ‚‚ : cmp y z = .gt)"},
 {"type": "cmp x y = cmp x z",
  "tactic-prompt":
  "theorem [TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z := by rw [â† Ordering.swap_inj]; sorry",
  "name": "cmp_congr_right",
  "kind": "theorem",
  "first-tactic": "rw [â† Ordering.swap_inj]",
  "core-prompt":
  "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq) : cmp x y = cmp x z",
  "args": "[TransCmp cmp] [TransCmp cmp]  (yz : cmp y z = .eq)"},
 {"type": "WF (empty n : Imp Î± Î²)",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±] : WF (empty n : Imp Î± Î²) := by unfold empty; sorry",
  "name": "WF.empty",
  "kind": "theorem",
  "first-tactic": "unfold empty",
  "core-prompt": "[BEq Î±]  [Hashable Î±] : WF (empty n : Imp Î± Î²)",
  "args": "[BEq Î±]  [Hashable Î±]"},
 {"type": "(reinsertAux data a b).size = data.size.succ",
  "tactic-prompt":
  "theorem [Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²) : (reinsertAux data a b).size = data.size.succ := by simp [Bucket.size_eq]; sorry",
  "name": "reinsertAux_size",
  "kind": "theorem",
  "first-tactic": "simp [Bucket.size_eq]",
  "core-prompt":
  "[Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²) : (reinsertAux data a b).size = data.size.succ",
  "args": "[Hashable Î±]  (data : Bucket Î± Î²)  (a : Î±)  (b : Î²)"},
 {"type": "(expand sz buckets).buckets.size = buckets.size",
  "tactic-prompt":
  "theorem [Hashable Î±]  {buckets : Bucket Î± Î²} : (expand sz buckets).buckets.size = buckets.size := by rw [expand]; sorry",
  "name": "expand_size",
  "kind": "theorem",
  "first-tactic": "rw [expand]",
  "core-prompt":
  "[Hashable Î±]  {buckets : Bucket Î± Î²} : (expand sz buckets).buckets.size = buckets.size",
  "args": "[Hashable Î±]  {buckets : Bucket Î± Î²}"},
 {"type":
  "(l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i := by induction l generalizing target with\n  | nil => exact âŸ¨htâ‚, fun _ hâ‚ _ hâ‚‚ => (htâ‚‚ _ hâ‚ _ hâ‚‚).1âŸ©\n  | cons _ _ ih =>\n    simp at hlâ‚ hlâ‚‚ htâ‚‚\n    refine ih hlâ‚.2 hlâ‚‚.2\n      (reinsertAux_WF htâ‚ fun _ h => (htâ‚‚ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ h _ hf\n      exact âŸ¨hâ‚, hâ‚‚.2âŸ©\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact âŸ¨hlâ‚‚.1 â–¸ Nat.le_refl _, fun _ h h' => hlâ‚.1 _ h (PartialEquivBEq.symm h')âŸ©\n      | _, .tail _ h =>\n        have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ (Array.getElem_mem_data ..) _ h\n        exact âŸ¨hâ‚, hâ‚‚.2âŸ©; sorry",
  "name": "expand_WF.foldl",
  "kind": "theorem",
  "first-tactic":
  "induction l generalizing target with\n  | nil => exact âŸ¨htâ‚, fun _ hâ‚ _ hâ‚‚ => (htâ‚‚ _ hâ‚ _ hâ‚‚).1âŸ©\n  | cons _ _ ih =>\n    simp at hlâ‚ hlâ‚‚ htâ‚‚\n    refine ih hlâ‚.2 hlâ‚‚.2\n      (reinsertAux_WF htâ‚ fun _ h => (htâ‚‚ _ (Array.getElem_mem_data ..) _ h).2.1)\n      (fun _ h => ?_)\n    simp [reinsertAux, Bucket.update] at h\n    match List.mem_or_eq_of_mem_set h with\n    | .inl h =>\n      intro _ hf\n      have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ h _ hf\n      exact âŸ¨hâ‚, hâ‚‚.2âŸ©\n    | .inr h => subst h; intro\n      | _, .head .. =>\n        exact âŸ¨hlâ‚‚.1 â–¸ Nat.le_refl _, fun _ h h' => hlâ‚.1 _ h (PartialEquivBEq.symm h')âŸ©\n      | _, .tail _ h =>\n        have âŸ¨hâ‚, hâ‚‚âŸ© := htâ‚‚ _ (Array.getElem_mem_data ..) _ h\n        exact âŸ¨hâ‚, hâ‚‚.2âŸ©",
  "core-prompt":
  "[BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k)) : (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF âˆ§\n    âˆ€ bucket âˆˆ (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k â‰¤ i",
  "args":
  "[BEq Î±]  [Hashable Î±]  (rank : Î± â†’ Nat)  {l : List (Î± Ã— Î²)}  {i : Nat}      (hlâ‚ : âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], l.Pairwise fun a b => Â¬(a.1 == b.1))      (hlâ‚‚ : âˆ€ x âˆˆ l, rank x.1 = i)      {target : Bucket Î± Î²}  (htâ‚ : target.WF)      (htâ‚‚ : âˆ€ bucket âˆˆ target.1.data,       bucket.All fun k _ => rank k â‰¤ i âˆ§         âˆ€ [PartialEquivBEq Î±] [LawfulHashable Î±], âˆ€ x âˆˆ l, Â¬(x.1 == k))"},
 {"type":
  "x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l",
  "tactic-prompt":
  "theorem {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool} : x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l := by induction l; sorry",
  "name": "mem_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool} : x âˆˆ (l.replaceF fun a => bif p a then some (k, v) else none) â†’ x.1 = k âˆ¨ x âˆˆ l",
  "args": "{l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  {p : Î± Ã— Î² â†’ Bool}"},
 {"type":
  "(l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst)",
  "tactic-prompt":
  "theorem [BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst) := by induction hxâ‚; sorry",
  "name": "pairwise_replaceF",
  "kind": "theorem",
  "first-tactic": "induction hxâ‚",
  "core-prompt":
  "[BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst)) : (l.replaceF fun a => bif a.fst == k then some (k, v) else none)\n      |>.Pairwise fun a b => Â¬(a.fst == b.fst)",
  "args":
  "[BEq Î±]  [PartialEquivBEq Î±]      {l : List (Î± Ã— Î²)}  {x : Î± Ã— Î²}  (hxâ‚ : x âˆˆ l)  (hxâ‚‚ : x.fst == k)      (H : l.Pairwise fun a b => Â¬(a.fst == b.fst))"},
 {"type": "m.size = m.buckets.size âˆ§ m.buckets.WF",
  "tactic-prompt":
  "theorem [BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF) : m.size = m.buckets.size âˆ§ m.buckets.WF := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "[BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF) : m.size = m.buckets.size âˆ§ m.buckets.WF",
  "args": "[BEq Î±]  [Hashable Î±]  {m : Imp Î± Î²}  (h : m.WF)"},
 {"type": "s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1 := by cases s; sorry",
  "name": "Heap.realSize_deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s')) : s.realSize = s'.realSize + 1",
  "args": "{s : Heap Î±}  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1",
  "tactic-prompt":
  "theorem {s : Heap Î±} : s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.realSize_tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "{s : Heap Î±} : s.tail? le = some s' â†’\n    s.realSize = s'.realSize + 1",
  "args": "{s : Heap Î±}"},
 {"type":
  "(merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n)",
  "tactic-prompt":
  "theorem (hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n) : (merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n) := by unfold merge; sorry",
  "name": "Heap.WellFormed.merge'",
  "kind": "theorem",
  "first-tactic": "unfold merge",
  "core-prompt":
  "(hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n) : (merge le sâ‚ sâ‚‚).WellFormed le n âˆ§\n    ((sâ‚.rankGT n â†” sâ‚‚.rankGT n) â†’ (merge le sâ‚ sâ‚‚).rankGT n)",
  "args": "(hâ‚ : sâ‚.WellFormed le n)  (hâ‚‚ : sâ‚‚.WellFormed le n)"},
 {"type": "s.toHeap.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : HeapNode Î±}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0 := by rw [toHeap]; sorry",
  "name": "HeapNode.WellFormed.toHeap",
  "kind": "theorem",
  "first-tactic": "rw [toHeap]",
  "core-prompt":
  "{s : HeapNode Î±}      (h : s.WellFormed le a n) : s.toHeap.WellFormed le 0",
  "args": "{s : HeapNode Î±}      (h : s.WellFormed le a n)"},
 {"type": "s'.WellFormed le 0",
  "tactic-prompt":
  "theorem {s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0 := by cases s; sorry",
  "name": "Heap.WellFormed.deleteMin",
  "kind": "theorem",
  "first-tactic": "cases s",
  "core-prompt":
  "{s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s')) : s'.WellFormed le 0",
  "args":
  "{s : Heap Î±}      (h : s.WellFormed le n)  (eq : s.deleteMin le = some (a, s'))"},
 {"type": "s.tail? le = some tl â†’\n  tl.WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WellFormed le n) : s.tail? le = some tl â†’\n  tl.WellFormed le 0 := by simp only [Heap.tail?]; sorry",
  "name": "Heap.WellFormed.tail?",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail?]",
  "core-prompt":
  "(hwf : (s : Heap Î±).WellFormed le n) : s.tail? le = some tl â†’\n  tl.WellFormed le 0",
  "args": "(hwf : (s : Heap Î±).WellFormed le n)"},
 {"type": "(s.tail le).WellFormed le 0",
  "tactic-prompt":
  "theorem (hwf : (s : Heap Î±).WellFormed le n) : (s.tail le).WellFormed le 0 := by simp only [Heap.tail]; sorry",
  "name": "Heap.WellFormed.tail",
  "kind": "theorem",
  "first-tactic": "simp only [Heap.tail]",
  "core-prompt":
  "(hwf : (s : Heap Î±).WellFormed le n) : (s.tail le).WellFormed le 0",
  "args": "(hwf : (s : Heap Î±).WellFormed le n)"},
 {"type": "(gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n)",
  "tactic-prompt":
  "theorem (m n : Nat) : (gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n) := by induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact âŸ¨Nat.dvd_zero n, Nat.dvd_refl nâŸ©\n  | H1 m n _ IH => rw [â† gcd_rec] at IH; exact âŸ¨IH.2, (dvd_mod_iff IH.2).1 IH.1âŸ©; sorry",
  "name": "gcd_dvd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with\n  | H0 n => rw [gcd_zero_left]; exact âŸ¨Nat.dvd_zero n, Nat.dvd_refl nâŸ©\n  | H1 m n _ IH => rw [â† gcd_rec] at IH; exact âŸ¨IH.2, (dvd_mod_iff IH.2).1 IH.1âŸ©",
  "core-prompt": "(m n : Nat) : (gcd m n âˆ£ m) âˆ§ (gcd m n âˆ£ n)",
  "args": "(m n : Nat)"},
 {"type": "k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n",
  "tactic-prompt":
  "theorem  : k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n := by induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km; sorry",
  "name": "dvd_gcd",
  "kind": "theorem",
  "first-tactic":
  "induction m, n using gcd.induction with intro km kn\n  | H0 n => rw [gcd_zero_left]; exact kn\n  | H1 n m _ IH => rw [gcd_rec]; exact IH ((dvd_mod_iff km).2 kn) km",
  "core-prompt": " : k âˆ£ m â†’ k âˆ£ n â†’ k âˆ£ gcd m n",
  "args": ""},
 {"type": "m âˆ£ n â†” gcd n m = m",
  "tactic-prompt": "theorem  : m âˆ£ n â†” gcd n m = m := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right_iff_dvd",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": " : m âˆ£ n â†” gcd n m = m",
  "args": ""},
 {"type": "gcd (m * n) (m * k) = m * gcd n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k := by induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [â† mul_mod_mul_left, â† gcd_rec, â† gcd_rec] at IH; sorry",
  "name": "gcd_mul_left",
  "kind": "theorem",
  "first-tactic":
  "induction n, k using gcd.induction with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [â† mul_mod_mul_left, â† gcd_rec, â† gcd_rec] at IH",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k",
  "args": "(m n k : Nat)"},
 {"type": "gcd (m * n) (k * n) = gcd m k * n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n := by rw [Nat.mul_comm m n]; sorry",
  "name": "gcd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m n]",
  "core-prompt": "(m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n",
  "args": "(m n k : Nat)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : gcd m n = 0) : n = 0 := by rw [gcd_comm] at H; sorry",
  "name": "eq_zero_of_gcd_eq_zero_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm] at H",
  "core-prompt": "{m n : Nat}  (H : gcd m n = 0) : n = 0",
  "args": "{m n : Nat}  (H : gcd m n = 0)"},
 {"type": "gcd m n = n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n âˆ£ m) : gcd m n = n := by rw [gcd_comm]; sorry",
  "name": "gcd_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "{m n : Nat}  (H : n âˆ£ m) : gcd m n = n",
  "args": "{m n : Nat}  (H : n âˆ£ m)"},
 {"type": "gcd n (m * n) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (m * n) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (m * n) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd (n * m) n = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (n * m) n = n := by rw [Nat.mul_comm]; sorry",
  "name": "gcd_mul_right_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : gcd (n * m) n = n",
  "args": "(m n : Nat)"},
 {"type": "gcd n (n * m) = n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd n (n * m) = n := by rw [gcd_comm]; sorry",
  "name": "gcd_mul_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd n (n * m) = n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (gcd n m) = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m (gcd n m) = gcd n m := by rw [gcd_comm n m]; sorry",
  "name": "gcd_gcd_self_right_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm n m]",
  "core-prompt": "(m n : Nat) : gcd m (gcd n m) = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd n m) m = gcd n m",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd n m) m = gcd n m := by rw [gcd_comm]; sorry",
  "name": "gcd_gcd_self_left_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm]",
  "core-prompt": "(m n : Nat) : gcd (gcd n m) m = gcd n m",
  "args": "(m n : Nat)"},
 {"type": "gcd (gcd m n) m = gcd m n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd (gcd m n) m = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "gcd_gcd_self_left_left",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(m n : Nat) : gcd (gcd m n) m = gcd m n",
  "args": "(m n : Nat)"},
 {"type": "gcd m (n + k * m) = gcd m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : gcd m (n + k * m) = gcd m n := by simp [gcd_rec m (n + k * m)]; sorry",
  "name": "gcd_add_mul_self",
  "kind": "theorem",
  "first-tactic": "simp [gcd_rec m (n + k * m)]",
  "core-prompt": "(m n k : Nat) : gcd m (n + k * m) = gcd m n",
  "args": "(m n k : Nat)"},
 {"type": "lcm m n = lcm n m",
  "tactic-prompt":
  "theorem (m n : Nat) : lcm m n = lcm n m := by rw [lcm]; sorry",
  "name": "lcm_comm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : lcm m n = lcm n m",
  "args": "(m n : Nat)"},
 {"type": "lcm 0 m = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm 0 m = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 0 m = 0",
  "args": "(m : Nat)"},
 {"type": "lcm m 0 = 0",
  "tactic-prompt": "theorem (m : Nat) : lcm m 0 = 0 := by simp [lcm]; sorry",
  "name": "lcm_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 0 = 0",
  "args": "(m : Nat)"},
 {"type": "lcm 1 m = m",
  "tactic-prompt": "theorem (m : Nat) : lcm 1 m = m := by simp [lcm]; sorry",
  "name": "lcm_one_left",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm 1 m = m",
  "args": "(m : Nat)"},
 {"type": "lcm m 1 = m",
  "tactic-prompt": "theorem (m : Nat) : lcm m 1 = m := by simp [lcm]; sorry",
  "name": "lcm_one_right",
  "kind": "theorem",
  "first-tactic": "simp [lcm]",
  "core-prompt": "(m : Nat) : lcm m 1 = m",
  "args": "(m : Nat)"},
 {"type": "lcm m m = m",
  "tactic-prompt":
  "theorem (m : Nat) : lcm m m = m := by match eq_zero_or_pos m with\n  | .inl h => rw [h]; sorry",
  "name": "lcm_self",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos m with\n  | .inl h => rw [h]",
  "core-prompt": "(m : Nat) : lcm m m = m",
  "args": "(m : Nat)"},
 {"type": "gcd m n * lcm m n = m * n",
  "tactic-prompt":
  "theorem (m n : Nat) : gcd m n * lcm m n = m * n := by rw [lcm]; sorry",
  "name": "gcd_mul_lcm",
  "kind": "theorem",
  "first-tactic": "rw [lcm]",
  "core-prompt": "(m n : Nat) : gcd m n * lcm m n = m * n",
  "args": "(m n : Nat)"},
 {"type": "lcm m n âˆ£ k",
  "tactic-prompt":
  "theorem {m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k) : lcm m n âˆ£ k := by match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]; sorry",
  "name": "lcm_dvd",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos k with\n  | .inl h => rw [h]; exact Nat.dvd_zero _\n  | .inr kpos =>\n    apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n    rw [gcd_mul_lcm]",
  "core-prompt": "{m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k) : lcm m n âˆ£ k",
  "args": "{m n k : Nat}  (H1 : m âˆ£ k)  (H2 : n âˆ£ k)"},
 {"type": "lcm m n â‰  0",
  "tactic-prompt":
  "theorem (hm : m â‰  0)  (hn : n â‰  0) : lcm m n â‰  0 := by intro h; sorry",
  "name": "lcm_ne_zero",
  "kind": "theorem",
  "first-tactic": "intro h",
  "core-prompt": "(hm : m â‰  0)  (hn : n â‰  0) : lcm m n â‰  0",
  "args": "(hm : m â‰  0)  (hn : n â‰  0)"},
 {"type": "k âˆ£ m",
  "tactic-prompt":
  "theorem (H1 : coprime k n)  (H2 : k âˆ£ m * n) : k âˆ£ m := by let t := dvd_gcd (Nat.dvd_mul_left k m) H2; sorry",
  "name": "coprime.dvd_of_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "let t := dvd_gcd (Nat.dvd_mul_left k m) H2",
  "core-prompt": "(H1 : coprime k n)  (H2 : k âˆ£ m * n) : k âˆ£ m",
  "args": "(H1 : coprime k n)  (H2 : k âˆ£ m * n)"},
 {"type": "gcd (m * k) n = gcd m n",
  "tactic-prompt":
  "theorem (m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n := by rw [Nat.mul_comm m k]; sorry",
  "name": "coprime.gcd_mul_right_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(m : Nat)  (H : coprime k n) : gcd (m * k) n = gcd m n",
  "args": "(m : Nat)  (H : coprime k n)"},
 {"type": "gcd m (k * n) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n := by rw [gcd_comm m n]; sorry",
  "name": "coprime.gcd_mul_left_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [gcd_comm m n]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (k * n) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "gcd m (n * k) = gcd m n",
  "tactic-prompt":
  "theorem (n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n := by rw [Nat.mul_comm n k]; sorry",
  "name": "coprime.gcd_mul_right_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm n k]",
  "core-prompt": "(n : Nat)      (H : coprime k m) : gcd m (n * k) = gcd m n",
  "args": "(n : Nat)      (H : coprime k m)"},
 {"type": "coprime (m / gcd m n) (n / gcd m n)",
  "tactic-prompt":
  "theorem (H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n) := by rw [coprime_iff_gcd_eq_one]; sorry",
  "name": "coprime_div_gcd_div_gcd",
  "kind": "theorem",
  "first-tactic": "rw [coprime_iff_gcd_eq_one]",
  "core-prompt": "(H : 0 < gcd m n) : coprime (m / gcd m n) (n / gcd m n)",
  "args": "(H : 0 < gcd m n)"},
 {"type": "coprime m n",
  "tactic-prompt":
  "theorem (H1 : m âˆ£ k)  (H2 : coprime k n) : coprime m n := by apply eq_one_of_dvd_one; sorry",
  "name": "coprime.coprime_dvd_left",
  "kind": "theorem",
  "first-tactic": "apply eq_one_of_dvd_one",
  "core-prompt": "(H1 : m âˆ£ k)  (H2 : coprime k n) : coprime m n",
  "args": "(H1 : m âˆ£ k)  (H2 : coprime k n)"},
 {"type": "coprime (m / a) n",
  "tactic-prompt":
  "theorem (cmn : coprime m n)  (dvd : a âˆ£ m) : coprime (m / a) n := by match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn âŠ¢\n    simp; assumption\n  | .inr hpos =>\n    let âŸ¨k]; sorry",
  "name": "coprime.coprime_div_left",
  "kind": "theorem",
  "first-tactic":
  "match eq_zero_or_pos a with\n  | .inl h0 =>\n    rw [h0] at dvd\n    rw [Nat.eq_zero_of_zero_dvd dvd] at cmn âŠ¢\n    simp; assumption\n  | .inr hpos =>\n    let âŸ¨k]",
  "core-prompt": "(cmn : coprime m n)  (dvd : a âˆ£ m) : coprime (m / a) n",
  "args": "(cmn : coprime m n)  (dvd : a âˆ£ m)"},
 {"type": "coprime k (m * n) â†” coprime k m âˆ§ coprime k n",
  "tactic-prompt":
  "theorem  : coprime k (m * n) â†” coprime k m âˆ§ coprime k n := by rw [@coprime_comm k]; sorry",
  "name": "coprime_mul_iff_right",
  "kind": "theorem",
  "first-tactic": "rw [@coprime_comm k]",
  "core-prompt": " : coprime k (m * n) â†” coprime k m âˆ§ coprime k n",
  "args": ""},
 {"type": "coprime 0 n â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime 0 n â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_left",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime 0 n â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n 0 â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n 0 â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_zero_right",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n 0 â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime n n â†” n = 1",
  "tactic-prompt":
  "theorem (n : Nat) : coprime n n â†” n = 1 := by simp [coprime]; sorry",
  "name": "coprime_self",
  "kind": "theorem",
  "first-tactic": "simp [coprime]",
  "core-prompt": "(n : Nat) : coprime n n â†” n = 1",
  "args": "(n : Nat)"},
 {"type": "coprime (m ^ n) k",
  "tactic-prompt":
  "theorem (n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k := by induction n; sorry",
  "name": "coprime.pow_left",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  (H1 : coprime m k) : coprime (m ^ n) k",
  "args": "(n : Nat)  (H1 : coprime m k)"},
 {"type": "k = 1",
  "tactic-prompt":
  "theorem {k m : Nat}  (H : coprime k m)  (d : k âˆ£ m) : k = 1 := by rw [â† H.gcd_eq_one]; sorry",
  "name": "coprime.eq_one_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [â† H.gcd_eq_one]",
  "core-prompt": "{k m : Nat}  (H : coprime k m)  (d : k âˆ£ m) : k = 1",
  "args": "{k m : Nat}  (H : coprime k m)  (d : k âˆ£ m)"},
 {"type": "gcd k (m * n) âˆ£ gcd k m * gcd k n",
  "tactic-prompt":
  "theorem (k m n : Nat) : gcd k (m * n) âˆ£ gcd k m * gcd k n := by let âŸ¨âŸ¨âŸ¨m', hm'âŸ©, âŸ¨n', hn'âŸ©âŸ©, (h : gcd k (m * n) = m' * n')âŸ© :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n); sorry",
  "name": "gcd_mul_dvd_mul_gcd",
  "kind": "theorem",
  "first-tactic":
  "let âŸ¨âŸ¨âŸ¨m', hm'âŸ©, âŸ¨n', hn'âŸ©âŸ©, (h : gcd k (m * n) = m' * n')âŸ© :=\n    prod_dvd_and_dvd_of_dvd_prod <| gcd_dvd_right k (m * n)",
  "core-prompt": "(k m n : Nat) : gcd k (m * n) âˆ£ gcd k m * gcd k n",
  "args": "(k m n : Nat)"},
 {"type": "a.gcd c * b.gcd c = c",
  "tactic-prompt":
  "theorem (cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c := by apply dvd_antisymm; sorry",
  "name": "gcd_mul_gcd_of_coprime_of_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "apply dvd_antisymm",
  "core-prompt":
  "(cop : coprime c d)  (h : a * b = c * d) : a.gcd c * b.gcd c = c",
  "args": "(cop : coprime c d)  (h : a * b = c * d)"},
 {"type": "n < k + n",
  "tactic-prompt":
  "theorem {n k : Nat}  (h : 0 < k) : n < k + n := by rw [Nat.add_comm]; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n k : Nat}  (h : 0 < k) : n < k + n",
  "args": "{n k : Nat}  (h : 0 < k)"},
 {"type": "x + k â‰¤ y â†” x â‰¤ y - k",
  "tactic-prompt":
  "theorem (x : Nat)  {y k : Nat}  (h : k â‰¤ y) : x + k â‰¤ y â†” x â‰¤ y - k := by rw [â† Nat.add_sub_cancel x k]; sorry",
  "name": "add_le_to_le_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.add_sub_cancel x k]",
  "core-prompt": "(x : Nat)  {y k : Nat}  (h : k â‰¤ y) : x + k â‰¤ y â†” x â‰¤ y - k",
  "args": "(x : Nat)  {y k : Nat}  (h : k â‰¤ y)"},
 {"type": "min a b = min b a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b = min b a := by simp [Nat.min_def]; sorry",
  "name": "min_comm",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b = min b a",
  "args": "(a b : Nat)"},
 {"type": "min a b â‰¤ a",
  "tactic-prompt":
  "theorem (a b : Nat) : min a b â‰¤ a := by simp [Nat.min_def]; sorry",
  "name": "min_le_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(a b : Nat) : min a b â‰¤ a",
  "args": "(a b : Nat)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a â‰¤ b) : min a b = a := by simp [Nat.min_def]; sorry",
  "name": "min_eq_left",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "{a b : Nat}  (h : a â‰¤ b) : min a b = a",
  "args": "{a b : Nat}  (h : a â‰¤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b â‰¤ a) : min a b = b := by rw [Nat.min_comm a b]; sorry",
  "name": "min_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_comm a b]",
  "core-prompt": "{a b : Nat}  (h : b â‰¤ a) : min a b = b",
  "args": "{a b : Nat}  (h : b â‰¤ a)"},
 {"type": "max a b = max b a",
  "tactic-prompt":
  "theorem (a b : Nat) : max a b = max b a := by simp only [Nat.max_def]; sorry",
  "name": "max_comm",
  "kind": "theorem",
  "first-tactic": "simp only [Nat.max_def]",
  "core-prompt": "(a b : Nat) : max a b = max b a",
  "args": "(a b : Nat)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : a â‰¤ b) : max a b = b := by simp [Nat.max_def]; sorry",
  "name": "max_eq_right",
  "kind": "theorem",
  "first-tactic": "simp [Nat.max_def]",
  "core-prompt": "{a b : Nat}  (h : a â‰¤ b) : max a b = b",
  "args": "{a b : Nat}  (h : a â‰¤ b)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "theorem {a b : Nat}  (h : b â‰¤ a) : max a b = a := by rw [â† Nat.max_comm b a]; sorry",
  "name": "max_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.max_comm b a]",
  "core-prompt": "{a b : Nat}  (h : b â‰¤ a) : max a b = a",
  "args": "{a b : Nat}  (h : b â‰¤ a)"},
 {"type": "min (succ x) (succ y) = succ (min x y)",
  "tactic-prompt":
  "theorem (x y : Nat) : min (succ x) (succ y) = succ (min x y) := by simp [Nat.min_def]; sorry",
  "name": "min_succ_succ",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_def]",
  "core-prompt": "(x y : Nat) : min (succ x) (succ y) = succ (min x y)",
  "args": "(x y : Nat)"},
 {"type": "n - m = n - min n m",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m = n - min n m := by rw [Nat.min_def]; sorry",
  "name": "sub_eq_sub_min",
  "kind": "theorem",
  "first-tactic": "rw [Nat.min_def]",
  "core-prompt": "(n m : Nat) : n - m = n - min n m",
  "args": "(n m : Nat)"},
 {"type": "n - m + min n m = n",
  "tactic-prompt":
  "theorem (n m : Nat) : n - m + min n m = n := by rw [sub_eq_sub_min]; sorry",
  "name": "sub_add_min_cancel",
  "kind": "theorem",
  "first-tactic": "rw [sub_eq_sub_min]",
  "core-prompt": "(n m : Nat) : n - m + min n m = n",
  "args": "(n m : Nat)"},
 {"type": "n * m * k = n * k * m",
  "tactic-prompt":
  "theorem (n m k : Nat) : n * m * k = n * k * m := by rw [Nat.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_assoc]",
  "core-prompt": "(n m k : Nat) : n * m * k = n * k * m",
  "args": "(n m k : Nat)"},
 {"type": "m % k + k * (m / k) = m",
  "tactic-prompt":
  "theorem (m k : Nat) : m % k + k * (m / k) = m := by induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, â† Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/; sorry",
  "name": "mod_add_div",
  "kind": "theorem",
  "first-tactic":
  "induction m, k using mod.inductionOn with rw [div_eq, mod_eq]\n  | base x y h => simp [h]\n  | ind x y h IH => simp [h]; rw [Nat.mul_succ, â† Nat.add_assoc, IH, Nat.sub_add_cancel h.2]\n\n/- div -/",
  "core-prompt": "(m k : Nat) : m % k + k * (m / k) = m",
  "args": "(m k : Nat)"},
 {"type": "n / 1 = n",
  "tactic-prompt":
  "theorem (n : Nat) : n / 1 = n := by have := mod_add_div n 1; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div n 1",
  "core-prompt": "(n : Nat) : n / 1 = n",
  "args": "(n : Nat)"},
 {"type": "n / 0 = 0",
  "tactic-prompt": "theorem (n : Nat) : n / 0 = 0 := by rw [div_eq]; sorry",
  "name": "div_zero",
  "kind": "theorem",
  "first-tactic": "rw [div_eq]",
  "core-prompt": "(n : Nat) : n / 0 = 0",
  "args": "(n : Nat)"},
 {"type": "x â‰¤ y / k â†” x * k â‰¤ y",
  "tactic-prompt":
  "theorem (k0 : 0 < k) : x â‰¤ y / k â†” x * k â‰¤ y := by induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h âŸ¨k0, h'âŸ©\n  | ind y k h IH =>\n    rw [â† add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        â† Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]; sorry",
  "name": "le_div_iff_mul_le",
  "kind": "theorem",
  "first-tactic":
  "induction y, k using mod.inductionOn generalizing x with\n    (rw [div_eq]; simp [h]; cases x with simp [zero_le] | succ x => ?_)\n  | base y k h =>\n    simp [not_succ_le_zero x, succ_mul, Nat.add_comm]\n    refine Nat.lt_of_lt_of_le ?_ (Nat.le_add_right ..)\n    exact Nat.not_le.1 fun h' => h âŸ¨k0, h'âŸ©\n  | ind y k h IH =>\n    rw [â† add_one, Nat.add_le_add_iff_le_right, IH k0, succ_mul,\n        â† Nat.add_sub_cancel (x*k) k, Nat.sub_le_sub_right_iff h.2, Nat.add_sub_cancel]",
  "core-prompt": "(k0 : 0 < k) : x â‰¤ y / k â†” x * k â‰¤ y",
  "args": "(k0 : 0 < k)"},
 {"type": "a / b = (a - b) / b + 1",
  "tactic-prompt":
  "theorem (hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a) : a / b = (a - b) / b + 1 := by rw [div_eq a]; sorry",
  "name": "div_eq_sub_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a) : a / b = (a - b) / b + 1",
  "args": "(hâ‚ : 0 < b)  (hâ‚‚ : b â‰¤ a)"},
 {"type": "a / b = 0",
  "tactic-prompt":
  "theorem (hâ‚€ : a < b) : a / b = 0 := by rw [div_eq a]; sorry",
  "name": "div_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [div_eq a]",
  "core-prompt": "(hâ‚€ : a < b) : a / b = 0",
  "args": "(hâ‚€ : a < b)"},
 {"type": "x / k < y â†” x < y * k",
  "tactic-prompt":
  "theorem (Hk : 0 < k) : x / k < y â†” x < y * k := by rw [â† Nat.not_le]; sorry",
  "name": "div_lt_iff_lt_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.not_le]",
  "core-prompt": "(Hk : 0 < k) : x / k < y â†” x < y * k",
  "args": "(Hk : 0 < k)"},
 {"type": "n = 0 âˆ¨ n = succ (pred n)",
  "tactic-prompt":
  "theorem (n : Nat) : n = 0 âˆ¨ n = succ (pred n) := by cases n; sorry",
  "name": "eq_zero_or_eq_succ_pred",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : n = 0 âˆ¨ n = succ (pred n)",
  "args": "(n : Nat)"},
 {"type": "n.succ = 1 + n",
  "tactic-prompt":
  "theorem (n : Nat) : n.succ = 1 + n := by rw [Nat.succ_eq_add_one]; sorry",
  "name": "succ_eq_one_add",
  "kind": "theorem",
  "first-tactic": "rw [Nat.succ_eq_add_one]",
  "core-prompt": "(n : Nat) : n.succ = 1 + n",
  "args": "(n : Nat)"},
 {"type": "succ n + m = n + succ m",
  "tactic-prompt":
  "theorem (n m : Nat) : succ n + m = n + succ m := by simp [succ_add]; sorry",
  "name": "succ_add_eq_succ_add",
  "kind": "theorem",
  "first-tactic": "simp [succ_add]",
  "core-prompt": "(n m : Nat) : succ n + m = n + succ m",
  "args": "(n m : Nat)"},
 {"type": "1 + n = succ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 + n = succ n := by simp [Nat.add_comm]; sorry",
  "name": "one_add",
  "kind": "theorem",
  "first-tactic": "simp [Nat.add_comm]",
  "core-prompt": "(n : Nat) : 1 + n = succ n",
  "args": "(n : Nat)"},
 {"type": "a - b + b = max a b",
  "tactic-prompt":
  "theorem {a b : Nat} : a - b + b = max a b := by match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]; sorry",
  "name": "sub_add_eq_max",
  "kind": "theorem",
  "first-tactic":
  "match a.le_total b with\n  | .inl hl => rw [Nat.max_eq_right hl]",
  "core-prompt": "{a b : Nat} : a - b + b = max a b",
  "args": "{a b : Nat}"},
 {"type": "succ n - m - succ k = n - m - k",
  "tactic-prompt":
  "theorem (n m k : Nat) : succ n - m - succ k = n - m - k := by rw [Nat.sub_sub]; sorry",
  "name": "succ_sub_sub_succ",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(n m k : Nat) : succ n - m - succ k = n - m - k",
  "args": "(n m k : Nat)"},
 {"type": "m - n - k = m - k - n",
  "tactic-prompt":
  "theorem (m n k : Nat) : m - n - k = m - k - n := by rw [Nat.sub_sub]; sorry",
  "name": "sub.right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(m n k : Nat) : m - n - k = m - k - n",
  "args": "(m n k : Nat)"},
 {"type": "a * a - b * b = (a + b) * (a - b)",
  "tactic-prompt":
  "theorem (a b : Nat) : a * a - b * b = (a + b) * (a - b) := by rw [Nat.mul_sub_left_distrib]; sorry",
  "name": "mul_self_sub_mul_self_eq",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_sub_left_distrib]",
  "core-prompt": "(a b : Nat) : a * a - b * b = (a + b) * (a - b)",
  "args": "(a b : Nat)"},
 {"type": "succ a * succ b = a * b + a + b + 1",
  "tactic-prompt":
  "theorem (a b : Nat) : succ a * succ b = a * b + a + b + 1 := by rw [mul_succ]; sorry",
  "name": "succ_mul_succ_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_succ]",
  "core-prompt": "(a b : Nat) : succ a * succ b = a * b + a + b + 1",
  "args": "(a b : Nat)"},
 {"type": "succ m - n = succ (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n â‰¤ m) : succ m - n = succ (m - n) := by let âŸ¨k, hkâŸ© := Nat.le.dest h; sorry",
  "name": "succ_sub",
  "kind": "theorem",
  "first-tactic": "let âŸ¨k, hkâŸ© := Nat.le.dest h",
  "core-prompt": "{m n : Nat}  (h : n â‰¤ m) : succ m - n = succ (m - n)",
  "args": "{m n : Nat}  (h : n â‰¤ m)"},
 {"type": "0 < n - m",
  "tactic-prompt":
  "theorem (h : m < n) : 0 < n - m := by apply Nat.lt_of_add_lt_add_right (b := m); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Nat.lt_of_add_lt_add_right (b := m)",
  "core-prompt": "(h : m < n) : 0 < n - m",
  "args": "(h : m < n)"},
 {"type": "n + m - k = n - k + m",
  "tactic-prompt":
  "theorem {n m k : Nat}  (h : k â‰¤ n) : n + m - k = n - k + m := by rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]; sorry",
  "name": "sub_add_comm",
  "kind": "theorem",
  "first-tactic":
  "rw [Nat.sub_eq_iff_eq_add (Nat.le_trans h (Nat.le_add_right ..))]",
  "core-prompt": "{n m k : Nat}  (h : k â‰¤ n) : n + m - k = n - k + m",
  "args": "{n m k : Nat}  (h : k â‰¤ n)"},
 {"type": "n - 1 - i < n",
  "tactic-prompt":
  "theorem (h : i < n) : n - 1 - i < n := by rw [Nat.sub_sub]; sorry",
  "name": "sub_one_sub_lt",
  "kind": "theorem",
  "first-tactic": "rw [Nat.sub_sub]",
  "core-prompt": "(h : i < n) : n - 1 - i < n",
  "args": "(h : i < n)"},
 {"type": "b - a < b",
  "tactic-prompt":
  "theorem {a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b) : b - a < b := by apply sub_lt _ hâ‚€; sorry",
  "name": "sub_lt_self",
  "kind": "theorem",
  "first-tactic": "apply sub_lt _ hâ‚€",
  "core-prompt": "{a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b) : b - a < b",
  "args": "{a b : Nat}  (hâ‚€ : 0 < a)  (hâ‚ : a â‰¤ b)"},
 {"type": "m + (n - m) = n",
  "tactic-prompt":
  "theorem {n m : Nat}  (h : m â‰¤ n) : m + (n - m) = n := by rw [Nat.add_comm]; sorry",
  "name": "add_sub_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{n m : Nat}  (h : m â‰¤ n) : m + (n - m) = n",
  "args": "{n m : Nat}  (h : m â‰¤ n)"},
 {"type": "k - n < m",
  "tactic-prompt":
  "theorem {n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m) : k - n < m := by have := Nat.sub_le_sub_right (succ_le_of_lt h) n; sorry",
  "name": "sub_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have := Nat.sub_le_sub_right (succ_le_of_lt h) n",
  "core-prompt": "{n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m) : k - n < m",
  "args": "{n k m : Nat}  (H : n â‰¤ k)  (h : k < n + m)"},
 {"type": "x â‰¤ y - k â†” x + k â‰¤ y",
  "tactic-prompt":
  "theorem {x y k : Nat}  (h : k â‰¤ y) : x â‰¤ y - k â†” x + k â‰¤ y := by rw [â† Nat.add_sub_cancel x k]; sorry",
  "name": "le_sub_iff_add_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.add_sub_cancel x k]",
  "core-prompt": "{x y k : Nat}  (h : k â‰¤ y) : x â‰¤ y - k â†” x + k â‰¤ y",
  "args": "{x y k : Nat}  (h : k â‰¤ y)"},
 {"type": "(x + z) % z = x % z",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % z = x % z := by rw [mod_eq_sub_mod (Nat.le_add_left ..)]; sorry",
  "name": "add_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [mod_eq_sub_mod (Nat.le_add_left ..)]",
  "core-prompt": "(x z : Nat) : (x + z) % z = x % z",
  "args": "(x z : Nat)"},
 {"type": "(x + z) % x = z % x",
  "tactic-prompt":
  "theorem (x z : Nat) : (x + z) % x = z % x := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(x z : Nat) : (x + z) % x = z % x",
  "args": "(x z : Nat)"},
 {"type": "(x + y * z) % y = x % y",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % y = x % y := by match z with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "add_mul_mod_self_left",
  "kind": "theorem",
  "first-tactic": "match z with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % y = x % y",
  "args": "(x y z : Nat)"},
 {"type": "(x + y * z) % z = x % z",
  "tactic-prompt":
  "theorem (x y z : Nat) : (x + y * z) % z = x % z := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_mod_self_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(x y z : Nat) : (x + y * z) % z = x % z",
  "args": "(x y z : Nat)"},
 {"type": "(m * n) % m = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % m = 0 := by rw [â† Nat.zero_add (m * n)]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.zero_add (m * n)]",
  "core-prompt": "(m n : Nat) : (m * n) % m = 0",
  "args": "(m n : Nat)"},
 {"type": "(m * n) % n = 0",
  "tactic-prompt":
  "theorem (m n : Nat) : (m * n) % n = 0 := by rw [Nat.mul_comm]; sorry",
  "name": "mul_mod_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m n : Nat) : (m * n) % n = 0",
  "args": "(m n : Nat)"},
 {"type": "(x * z) % (y * z) = (x % y) * z",
  "tactic-prompt":
  "theorem (z x y : Nat) : (x * z) % (y * z) = (x % y) * z := by rw [Nat.mul_comm x z]; sorry",
  "name": "mul_mod_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm x z]",
  "core-prompt": "(z x y : Nat) : (x * z) % (y * z) = (x % y) * z",
  "args": "(z x y : Nat)"},
 {"type": "(x - n*k) % n = x % n",
  "tactic-prompt":
  "theorem {x k n : Nat}  (hâ‚ : n*k â‰¤ x) : (x - n*k) % n = x % n := by match k with\n  | 0 => rw [Nat.mul_zero]; sorry",
  "name": "sub_mul_mod",
  "kind": "theorem",
  "first-tactic": "match k with\n  | 0 => rw [Nat.mul_zero]",
  "core-prompt": "{x k n : Nat}  (hâ‚ : n*k â‰¤ x) : (x - n*k) % n = x % n",
  "args": "{x k n : Nat}  (hâ‚ : n*k â‰¤ x)"},
 {"type": "(x - n*p) / n = x / n - p",
  "tactic-prompt":
  "theorem (x n p : Nat)  (hâ‚ : n*p â‰¤ x) : (x - n*p) / n = x / n - p := by match eq_zero_or_pos n with\n  | .inl hâ‚€ => rw [hâ‚€]; sorry",
  "name": "sub_mul_div",
  "kind": "theorem",
  "first-tactic": "match eq_zero_or_pos n with\n  | .inl hâ‚€ => rw [hâ‚€]",
  "core-prompt": "(x n p : Nat)  (hâ‚ : n*p â‰¤ x) : (x - n*p) / n = x / n - p",
  "args": "(x n p : Nat)  (hâ‚ : n*p â‰¤ x)"},
 {"type": "(x + z) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z) := by rw [div_eq_sub_div H (Nat.le_add_left _ _)]; sorry",
  "name": "add_div_right",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_sub_div H (Nat.le_add_left _ _)]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (x + z) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "(z + x) / z = succ (x / z)",
  "tactic-prompt":
  "theorem (x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z) := by rw [Nat.add_comm]; sorry",
  "name": "add_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt":
  "(x : Nat)  {z : Nat}  (H : 0 < z) : (z + x) / z = succ (x / z)",
  "args": "(x : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / m = n",
  "tactic-prompt":
  "theorem (n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n := by induction n; sorry",
  "name": "mul_div_right",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat)  {m : Nat}  (H : 0 < m) : m * n / m = n",
  "args": "(n : Nat)  {m : Nat}  (H : 0 < m)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n / n = 1",
  "tactic-prompt":
  "theorem (H : 0 < n) : n / n = 1 := by let t := add_div_right 0 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "let t := add_div_right 0 H",
  "core-prompt": "(H : 0 < n) : n / n = 1",
  "args": "(H : 0 < n)"},
 {"type": "(x + y * z) / y = x / y + z",
  "tactic-prompt":
  "theorem (x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z := by induction z; sorry",
  "name": "add_mul_div_left",
  "kind": "theorem",
  "first-tactic": "induction z",
  "core-prompt":
  "(x z : Nat)  {y : Nat}  (H : 0 < y) : (x + y * z) / y = x / y + z",
  "args": "(x z : Nat)  {y : Nat}  (H : 0 < y)"},
 {"type": "(x + y * z) / z = x / z + y",
  "tactic-prompt":
  "theorem (x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y := by rw [Nat.mul_comm]; sorry",
  "name": "add_mul_div_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt":
  "(x y : Nat)  {z : Nat}  (H : 0 < z) : (x + y * z) / z = x / z + y",
  "args": "(x y : Nat)  {z : Nat}  (H : 0 < z)"},
 {"type": "m * n / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m := by let t := add_mul_div_right 0 m H; sorry",
  "name": "mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "let t := add_mul_div_right 0 m H",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : m * n / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "n * m / n = m",
  "tactic-prompt":
  "theorem (m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m := by rw [Nat.mul_comm]; sorry",
  "name": "mul_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "(m : Nat)  {n : Nat}  (H : 0 < n) : n * m / n = m",
  "args": "(m : Nat)  {n : Nat}  (H : 0 < n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = k * n) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = k * n) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = k * n)"},
 {"type": "m / n = k",
  "tactic-prompt":
  "theorem (H1 : 0 < n)  (H2 : m = n * k) : m / n = k := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt": "(H1 : 0 < n)  (H2 : m = n * k) : m / n = k",
  "args": "(H1 : 0 < n)  (H2 : m = n * k)"},
 {"type": "(n * p - succ x) / n = p - succ (x / n)",
  "tactic-prompt":
  "theorem (x n p : Nat)  (hâ‚ : x < n*p) : (n * p - succ x) / n = p - succ (x / n) := by have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]; sorry",
  "name": "mul_sub_div",
  "kind": "theorem",
  "first-tactic":
  "have npos : 0 < n := (eq_zero_or_pos _).resolve_left fun n0 => by\n    rw [n0]",
  "core-prompt":
  "(x n p : Nat)  (hâ‚ : x < n*p) : (n * p - succ x) / n = p - succ (x / n)",
  "args": "(x n p : Nat)  (hâ‚ : x < n*p)"},
 {"type": "m / n / k = m / (n * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : m / n / k = m / (n * k) := by cases eq_zero_or_pos k; sorry",
  "name": "div_div_eq_div_mul",
  "kind": "theorem",
  "first-tactic": "cases eq_zero_or_pos k",
  "core-prompt": "(m n k : Nat) : m / n / k = m / (n * k)",
  "args": "(m n k : Nat)"},
 {"type": "m * n / (m * k) = n / k",
  "tactic-prompt":
  "theorem {m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k := by rw [â† Nat.div_div_eq_div_mul]; sorry",
  "name": "mul_div_mul",
  "kind": "theorem",
  "first-tactic": "rw [â† Nat.div_div_eq_div_mul]",
  "core-prompt":
  "{m : Nat}  (n k : Nat)  (H : 0 < m) : m * n / (m * k) = n / k",
  "args": "{m : Nat}  (n k : Nat)  (H : 0 < m)"},
 {"type": "n * (m / n) â‰¤ m",
  "tactic-prompt":
  "theorem (m n : Nat) : n * (m / n) â‰¤ m := by match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, â† Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/; sorry",
  "name": "mul_div_le",
  "kind": "theorem",
  "first-tactic":
  "match n, Nat.eq_zero_or_pos n with\n  | _, Or.inl rfl => rw [Nat.zero_mul]; exact m.zero_le\n  | n, Or.inr h => rw [Nat.mul_comm, â† Nat.le_div_iff_mul_le h]; exact Nat.le_refl _\n\n/- dvd -/",
  "core-prompt": "(m n : Nat) : n * (m / n) â‰¤ m",
  "args": "(m n : Nat)"},
 {"type": "k âˆ£ m â†” k âˆ£ m + n",
  "tactic-prompt":
  "theorem {k m n : Nat}  (h : k âˆ£ n) : k âˆ£ m â†” k âˆ£ m + n := by rw [Nat.add_comm]; sorry",
  "name": "dvd_add_iff_left",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "{k m n : Nat}  (h : k âˆ£ n) : k âˆ£ m â†” k âˆ£ m + n",
  "args": "{k m n : Nat}  (h : k âˆ£ n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : n % m = 0) : m âˆ£ n := by exists n / m; sorry",
  "name": "dvd_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "exists n / m",
  "core-prompt": "{m n : Nat}  (H : n % m = 0) : m âˆ£ n",
  "args": "{m n : Nat}  (H : n % m = 0)"},
 {"type": "n % m = 0",
  "tactic-prompt":
  "theorem {m n : Nat}  (H : m âˆ£ n) : n % m = 0 := by let âŸ¨z, HâŸ© := H; sorry",
  "name": "mod_eq_zero_of_dvd",
  "kind": "theorem",
  "first-tactic": "let âŸ¨z, HâŸ© := H",
  "core-prompt": "{m n : Nat}  (H : m âˆ£ n) : n % m = 0",
  "args": "{m n : Nat}  (H : m âˆ£ n)"},
 {"type": "n * (m / n) = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n âˆ£ m) : n * (m / n) = m := by have := mod_add_div m n; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div m n",
  "core-prompt": "{n m : Nat}  (H : n âˆ£ m) : n * (m / n) = m",
  "args": "{n m : Nat}  (H : n âˆ£ m)"},
 {"type": "m / n * n = m",
  "tactic-prompt":
  "theorem {n m : Nat}  (H : n âˆ£ m) : m / n * n = m := by rw [Nat.mul_comm]; sorry",
  "name": "div_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm]",
  "core-prompt": "{n m : Nat}  (H : n âˆ£ m) : m / n * n = m",
  "args": "{n m : Nat}  (H : n âˆ£ m)"},
 {"type": "m * n / k = m * (n / k)",
  "tactic-prompt":
  "theorem (m : Nat)  (H : k âˆ£ n) : m * n / k = m * (n / k) := by match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "match Nat.eq_zero_or_pos k with\n  | .inl h0 => rw [h0]",
  "core-prompt": "(m : Nat)  (H : k âˆ£ n) : m * n / k = m * (n / k)",
  "args": "(m : Nat)  (H : k âˆ£ n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : k * m âˆ£ k * n) : m âˆ£ n := by let âŸ¨l, HâŸ© := H; sorry",
  "name": "dvd_of_mul_dvd_mul_left",
  "kind": "theorem",
  "first-tactic": "let âŸ¨l, HâŸ© := H",
  "core-prompt": "(kpos : 0 < k)  (H : k * m âˆ£ k * n) : m âˆ£ n",
  "args": "(kpos : 0 < k)  (H : k * m âˆ£ k * n)"},
 {"type": "m âˆ£ n",
  "tactic-prompt":
  "theorem (kpos : 0 < k)  (H : m * k âˆ£ n * k) : m âˆ£ n := by rw [Nat.mul_comm m k]; sorry",
  "name": "dvd_of_mul_dvd_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [Nat.mul_comm m k]",
  "core-prompt": "(kpos : 0 < k)  (H : m * k âˆ£ n * k) : m âˆ£ n",
  "args": "(kpos : 0 < k)  (H : m * k âˆ£ n * k)"},
 {"type": "c * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Nat}  (hâ‚ : a â‰¤ b) : c * a â‰¤ c * b := by if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (hâ‚ : a â‰¤ b) : c * a â‰¤ c * b",
  "args": "{a b c : Nat}  (hâ‚ : a â‰¤ b)"},
 {"type": "a * c â‰¤ b * c",
  "tactic-prompt":
  "theorem {a b c : Nat}  (hâ‚ : a â‰¤ b) : a * c â‰¤ b * c := by if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then simp [Nat.le_antisymm hba hâ‚] else\n  if hc0 : c â‰¤ 0 then simp [Nat.le_antisymm hc0 (zero_le c)]",
  "core-prompt": "{a b c : Nat}  (hâ‚ : a â‰¤ b) : a * c â‰¤ b * c",
  "args": "{a b c : Nat}  (hâ‚ : a â‰¤ b)"},
 {"type": "a * b % n = (a % n) * (b % n) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : a * b % n = (a % n) * (b % n) % n := by conv => lhs; rw [\n    â† mod_add_div a n]; sorry",
  "name": "mul_mod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    â† mod_add_div a n]",
  "core-prompt": "(a b n : Nat) : a * b % n = (a % n) * (b % n) % n",
  "args": "(a b n : Nat)"},
 {"type": "(m % n + k) % n = (m + k) % n",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m % n + k) % n = (m + k) % n := by have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm; sorry",
  "name": "mod_add_mod",
  "kind": "theorem",
  "first-tactic": "have := (add_mul_mod_self_left (m % n + k) n (m / n)).symm",
  "core-prompt": "(m n k : Nat) : (m % n + k) % n = (m + k) % n",
  "args": "(m n k : Nat)"},
 {"type": "(m + n % k) % k = (m + n) % k",
  "tactic-prompt":
  "theorem (m n k : Nat) : (m + n % k) % k = (m + n) % k := by rw [Nat.add_comm]; sorry",
  "name": "add_mod_mod",
  "kind": "theorem",
  "first-tactic": "rw [Nat.add_comm]",
  "core-prompt": "(m n k : Nat) : (m + n % k) % k = (m + n) % k",
  "args": "(m n k : Nat)"},
 {"type": "(a + b) % n = ((a % n) + (b % n)) % n",
  "tactic-prompt":
  "theorem (a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n := by rw [add_mod_mod]; sorry",
  "name": "add_mod",
  "kind": "theorem",
  "first-tactic": "rw [add_mod_mod]",
  "core-prompt": "(a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n",
  "args": "(a b n : Nat)"},
 {"type": "m ^ n.succ = m * m ^ n",
  "tactic-prompt":
  "theorem {m n : Nat} : m ^ n.succ = m * m ^ n := by rw [Nat.pow_succ]; sorry",
  "name": "pow_succ'",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pow_succ]",
  "core-prompt": "{m n : Nat} : m ^ n.succ = m * m ^ n",
  "args": "{m n : Nat}"},
 {"type": "1 <<< n = 2 ^ n",
  "tactic-prompt":
  "theorem (n : Nat) : 1 <<< n = 2 ^ n := by rw [shiftLeft_eq]; sorry",
  "name": "one_shiftLeft",
  "kind": "theorem",
  "first-tactic": "rw [shiftLeft_eq]",
  "core-prompt": "(n : Nat) : 1 <<< n = 2 ^ n",
  "args": "(n : Nat)"},
 {"type": "Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚",
  "tactic-prompt":
  "theorem  : Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚ := by induction lâ‚; sorry",
  "name": "sum_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt": " : Nat.sum (lâ‚ ++ lâ‚‚) = Nat.sum lâ‚ + Nat.sum lâ‚‚",
  "args": ""},
 {"type": "fdiv 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fdiv 0 b = 0 := by cases b; sorry",
  "name": "zero_fdiv",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fdiv 0 b = 0",
  "args": "(b : Int)"},
 {"type": "(-a) / (-b) = a / b",
  "tactic-prompt":
  "theorem (a b : Int) : (-a) / (-b) = a / b := by simp [Int.div_neg]; sorry",
  "name": "neg_div_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.div_neg]",
  "core-prompt": "(a b : Int) : (-a) / (-b) = a / b",
  "args": "(a b : Int)"},
 {"type": "(a + b).ediv c = a.ediv c + b.ediv c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : c âˆ£ a) : (a + b).ediv c = a.ediv c + b.ediv c := by rw [Int.add_comm]; sorry",
  "name": "add_ediv_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{a b c : Int}  (H : c âˆ£ a) : (a + b).ediv c = a.ediv c + b.ediv c",
  "args": "{a b c : Int}  (H : c âˆ£ a)"},
 {"type": "ediv (a * b) b = a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : b â‰  0) : ediv (a * b) b = a := by have := Int.add_mul_ediv_right 0 a H; sorry",
  "name": "mul_ediv_cancel",
  "kind": "theorem",
  "first-tactic": "have := Int.add_mul_ediv_right 0 a H",
  "core-prompt": "(a : Int)  {b : Int}  (H : b â‰  0) : ediv (a * b) b = a",
  "args": "(a : Int)  {b : Int}  (H : b â‰  0)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a / a = 1 := by have := Int.mul_div_cancel 1 H; sorry",
  "name": "div_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_div_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a / a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "a.fdiv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a.fdiv a = 1 := by have := Int.mul_fdiv_cancel 1 H; sorry",
  "name": "fdiv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_fdiv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a.fdiv a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "a.ediv a = 1",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰  0) : a.ediv a = 1 := by have := Int.mul_ediv_cancel 1 H; sorry",
  "name": "ediv_self",
  "kind": "theorem",
  "first-tactic": "have := Int.mul_ediv_cancel 1 H",
  "core-prompt": "{a : Int}  (H : a â‰  0) : a.ediv a = 1",
  "args": "{a : Int}  (H : a â‰  0)"},
 {"type": "ofNat (m % n) = fmod m n",
  "tactic-prompt":
  "theorem (m n : Nat) : ofNat (m % n) = fmod m n := by cases m; sorry",
  "name": "ofNat_fmod",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : ofNat (m % n) = fmod m n",
  "args": "(m n : Nat)"},
 {"type": "0 % b = 0",
  "tactic-prompt": "theorem (b : Int) : 0 % b = 0 := by cases b; sorry",
  "name": "zero_mod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : 0 % b = 0",
  "args": "(b : Int)"},
 {"type": "fmod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : fmod 0 b = 0 := by cases b; sorry",
  "name": "zero_fmod",
  "kind": "theorem",
  "first-tactic": "cases b",
  "core-prompt": "(b : Int) : fmod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "emod 0 b = 0",
  "tactic-prompt": "theorem (b : Int) : emod 0 b = 0 := by simp [emod]; sorry",
  "name": "zero_emod",
  "kind": "theorem",
  "first-tactic": "simp [emod]",
  "core-prompt": "(b : Int) : emod 0 b = 0",
  "args": "(b : Int)"},
 {"type": "a % b = a - b * (a / b)",
  "tactic-prompt":
  "theorem (a b : Int) : a % b = a - b * (a / b) := by rw [â† Int.add_sub_cancel (a % b)]; sorry",
  "name": "mod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (a % b)]",
  "core-prompt": "(a b : Int) : a % b = a - b * (a / b)",
  "args": "(a b : Int)"},
 {"type": "a.fmod b = a - b * (a.fdiv b)",
  "tactic-prompt":
  "theorem (a b : Int) : a.fmod b = a - b * (a.fdiv b) := by rw [â† Int.add_sub_cancel (a.fmod b)]; sorry",
  "name": "fmod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (a.fmod b)]",
  "core-prompt": "(a b : Int) : a.fmod b = a - b * (a.fdiv b)",
  "args": "(a b : Int)"},
 {"type": "a.emod b = a - b * (a.ediv b)",
  "tactic-prompt":
  "theorem (a b : Int) : a.emod b = a - b * (a.ediv b) := by rw [â† Int.add_sub_cancel (a.emod b)]; sorry",
  "name": "emod_def",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel (a.emod b)]",
  "core-prompt": "(a b : Int) : a.emod b = a - b * (a.ediv b)",
  "args": "(a b : Int)"},
 {"type": "fmod a b = emod a b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (hb : 0 â‰¤ b) : fmod a b = emod a b := by simp [fmod_def]; sorry",
  "name": "fmod_eq_emod",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int)  {b : Int}  (hb : 0 â‰¤ b) : fmod a b = emod a b",
  "args": "(a : Int)  {b : Int}  (hb : 0 â‰¤ b)"},
 {"type": "emod a b = a % b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : emod a b = a % b := by simp [emod_def]; sorry",
  "name": "emod_eq_mod",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : emod a b = a % b",
  "args": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "a % -b = a % b",
  "tactic-prompt":
  "theorem (a b : Int) : a % -b = a % b := by rw [mod_def]; sorry",
  "name": "mod_neg",
  "kind": "theorem",
  "first-tactic": "rw [mod_def]",
  "core-prompt": "(a b : Int) : a % -b = a % b",
  "args": "(a b : Int)"},
 {"type": "a.emod (-b) = a.emod b",
  "tactic-prompt":
  "theorem (a b : Int) : a.emod (-b) = a.emod b := by rw [emod_def]; sorry",
  "name": "emod_neg",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt": "(a b : Int) : a.emod (-b) = a.emod b",
  "args": "(a b : Int)"},
 {"type": "a % 1 = 0",
  "tactic-prompt": "theorem (a : Int) : a % 1 = 0 := by simp [mod_def]; sorry",
  "name": "mod_one",
  "kind": "theorem",
  "first-tactic": "simp [mod_def]",
  "core-prompt": "(a : Int) : a % 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.emod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.emod 1 = 0 := by simp [emod_def]; sorry",
  "name": "emod_one",
  "kind": "theorem",
  "first-tactic": "simp [emod_def]",
  "core-prompt": "(a : Int) : a.emod 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod 1 = 0",
  "tactic-prompt":
  "theorem (a : Int) : a.fmod 1 = 0 := by simp [fmod_def]; sorry",
  "name": "fmod_one",
  "kind": "theorem",
  "first-tactic": "simp [fmod_def]",
  "core-prompt": "(a : Int) : a.fmod 1 = 0",
  "args": "(a : Int)"},
 {"type": "a.fmod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.fmod b = a := by rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "fmod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [fmod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.fmod b = a",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b)"},
 {"type": "a.emod b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.emod b = a := by rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]; sorry",
  "name": "emod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "rw [emod_eq_mod H1 (Int.le_trans H1 (Int.le_of_lt H2))]",
  "core-prompt": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b) : a.emod b = a",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : a < b)"},
 {"type": "m % k + m / k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m % k + m / k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "mod_add_div'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m % k + m / k * k = m",
  "args": "(m k : Int)"},
 {"type": "m / k * k + m % k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m / k * k + m % k = m := by rw [Int.mul_comm]; sorry",
  "name": "div_add_mod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m / k * k + m % k = m",
  "args": "(m k : Int)"},
 {"type": "m.emod k + m.ediv k * k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.emod k + m.ediv k * k = m := by rw [Int.mul_comm]; sorry",
  "name": "emod_add_ediv'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.emod k + m.ediv k * k = m",
  "args": "(m k : Int)"},
 {"type": "m.ediv k * k + m.emod k = m",
  "tactic-prompt":
  "theorem (m k : Int) : m.ediv k * k + m.emod k = m := by rw [Int.mul_comm]; sorry",
  "name": "ediv_add_emod'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m k : Int) : m.ediv k * k + m.emod k = m",
  "args": "(m k : Int)"},
 {"type": "(a + b * c).emod b = a.emod b",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b * c).emod b = a.emod b := by rw [Int.mul_comm]; sorry",
  "name": "add_mul_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b * c).emod b = a.emod b",
  "args": "(a b c : Int)"},
 {"type": "(a + b).emod b = a.emod b",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b).emod b = a.emod b := by have := add_mul_emod_self_left a b 1; sorry",
  "name": "add_emod_self",
  "kind": "theorem",
  "first-tactic": "have := add_mul_emod_self_left a b 1",
  "core-prompt": "{a b : Int} : (a + b).emod b = a.emod b",
  "args": "{a b : Int}"},
 {"type": "(a + b).emod a = b.emod a",
  "tactic-prompt":
  "theorem {a b : Int} : (a + b).emod a = b.emod a := by rw [Int.add_comm]; sorry",
  "name": "add_emod_self_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b : Int} : (a + b).emod a = b.emod a",
  "args": "{a b : Int}"},
 {"type": "(m.emod n + k).emod n = (m + k).emod n",
  "tactic-prompt":
  "theorem (m n k : Int) : (m.emod n + k).emod n = (m + k).emod n := by have := (add_mul_emod_self_left (m.emod n + k) n (m.ediv n)).symm; sorry",
  "name": "emod_add_emod",
  "kind": "theorem",
  "first-tactic":
  "have := (add_mul_emod_self_left (m.emod n + k) n (m.ediv n)).symm",
  "core-prompt": "(m n k : Int) : (m.emod n + k).emod n = (m + k).emod n",
  "args": "(m n k : Int)"},
 {"type": "(m + n.emod k).emod k = (m + n).emod k",
  "tactic-prompt":
  "theorem (m n k : Int) : (m + n.emod k).emod k = (m + n).emod k := by rw [Int.add_comm]; sorry",
  "name": "add_emod_emod",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(m n k : Int) : (m + n.emod k).emod k = (m + n).emod k",
  "args": "(m n k : Int)"},
 {"type": "(a + b).emod n = (a.emod n + b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a + b).emod n = (a.emod n + b.emod n).emod n := by rw [add_emod_emod]; sorry",
  "name": "add_emod",
  "kind": "theorem",
  "first-tactic": "rw [add_emod_emod]",
  "core-prompt":
  "(a b n : Int) : (a + b).emod n = (a.emod n + b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "(m + i).emod n = (k + i).emod n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (m + i).emod n = (k + i).emod n := by rw [â† emod_add_emod]; sorry",
  "name": "add_emod_eq_add_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [â† emod_add_emod]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (m + i).emod n = (k + i).emod n",
  "args": "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n)"},
 {"type": "(i + m).emod n = (i + k).emod n",
  "tactic-prompt":
  "theorem {m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (i + m).emod n = (i + k).emod n := by rw [Int.add_comm]; sorry",
  "name": "add_emod_eq_add_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n) : (i + m).emod n = (i + k).emod n",
  "args": "{m n k : Int}  (i : Int)      (H : m.emod n = k.emod n)"},
 {"type": "(i + m).emod n = (i + k).emod n â†” m.emod n = k.emod n",
  "tactic-prompt":
  "theorem {m n k i : Int} : (i + m).emod n = (i + k).emod n â†” m.emod n = k.emod n := by rw [Int.add_comm]; sorry",
  "name": "emod_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt":
  "{m n k i : Int} : (i + m).emod n = (i + k).emod n â†” m.emod n = k.emod n",
  "args": "{m n k i : Int}"},
 {"type": "(a * b).emod b = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).emod b = 0 := by rw [â† Int.zero_add (a * b)]; sorry",
  "name": "mul_emod_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.zero_add (a * b)]",
  "core-prompt": "(a b : Int) : (a * b).emod b = 0",
  "args": "(a b : Int)"},
 {"type": "a * b % a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : a * b % a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_mod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : a * b % a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).fmod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).fmod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_fmod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).fmod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).emod a = 0",
  "tactic-prompt":
  "theorem (a b : Int) : (a * b).emod a = 0 := by rw [Int.mul_comm]; sorry",
  "name": "mul_emod_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a b : Int) : (a * b).emod a = 0",
  "args": "(a b : Int)"},
 {"type": "(a * b).emod n = (a.emod n * b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a * b).emod n = (a.emod n * b.emod n).emod n := by conv => lhs; rw [\n    â† emod_add_ediv a n]; sorry",
  "name": "mul_emod",
  "kind": "theorem",
  "first-tactic": "conv => lhs; rw [\n    â† emod_add_ediv a n]",
  "core-prompt":
  "(a b n : Int) : (a * b).emod n = (a.emod n * b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "a % a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a % a = 0 := by have := mul_mod_left 1 a; sorry",
  "name": "mod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_mod_left 1 a",
  "core-prompt": "{a : Int} : a % a = 0",
  "args": "{a : Int}"},
 {"type": "a.fmod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.fmod a = 0 := by have := mul_fmod_left 1 a; sorry",
  "name": "fmod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_fmod_left 1 a",
  "core-prompt": "{a : Int} : a.fmod a = 0",
  "args": "{a : Int}"},
 {"type": "a.emod a = 0",
  "tactic-prompt":
  "theorem {a : Int} : a.emod a = 0 := by have := mul_emod_left 1 a; sorry",
  "name": "emod_self",
  "kind": "theorem",
  "first-tactic": "have := mul_emod_left 1 a",
  "core-prompt": "{a : Int} : a.emod a = 0",
  "args": "{a : Int}"},
 {"type": "(n.emod k).emod m = n.emod m",
  "tactic-prompt":
  "theorem (n : Int)  {m k : Int}      (h : m âˆ£ k) : (n.emod k).emod m = n.emod m := by conv => rhs; rw [â† emod_add_ediv n k]; sorry",
  "name": "emod_emod_of_dvd",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [â† emod_add_ediv n k]",
  "core-prompt":
  "(n : Int)  {m k : Int}      (h : m âˆ£ k) : (n.emod k).emod m = n.emod m",
  "args": "(n : Int)  {m k : Int}      (h : m âˆ£ k)"},
 {"type": "(a.emod b).emod b = a.emod b",
  "tactic-prompt":
  "theorem (a b : Int) : (a.emod b).emod b = a.emod b := by conv => rhs; rw [â† emod_add_ediv a b]; sorry",
  "name": "emod_emod",
  "kind": "theorem",
  "first-tactic": "conv => rhs; rw [â† emod_add_ediv a b]",
  "core-prompt": "(a b : Int) : (a.emod b).emod b = a.emod b",
  "args": "(a b : Int)"},
 {"type": "(a - b).emod n = (a.emod n - b.emod n).emod n",
  "tactic-prompt":
  "theorem (a b n : Int) : (a - b).emod n = (a.emod n - b.emod n).emod n := by apply (emod_add_cancel_right b).mp; sorry",
  "name": "sub_emod",
  "kind": "theorem",
  "first-tactic": "apply (emod_add_cancel_right b).mp",
  "core-prompt":
  "(a b n : Int) : (a - b).emod n = (a.emod n - b.emod n).emod n",
  "args": "(a b n : Int)"},
 {"type": "a.ediv b = q âˆ§ a.emod b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b",
  "tactic-prompt":
  "theorem {a b r q : Int}  (h : 0 < b) : a.ediv b = q âˆ§ a.emod b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b := by constructor; sorry",
  "name": "ediv_emod_unique",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{a b r q : Int}  (h : 0 < b) : a.ediv b = q âˆ§ a.emod b = r â†” r + b * q = a âˆ§ 0 â‰¤ r âˆ§ r < b",
  "args": "{a b r q : Int}  (h : 0 < b)"},
 {"type": "(a * b).ediv (c * b) = a.ediv c",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b).ediv (c * b) = a.ediv c := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b) : (a * b).ediv (c * b) = a.ediv c",
  "args": "(a : Int)  {b : Int}  (c : Int)  (H : 0 < b)"},
 {"type": "(a * b).emod (a * c) = a * (b.emod c)",
  "tactic-prompt":
  "theorem {a : Int}  (b c : Int)  (H : 0 < a) : (a * b).emod (a * c) = a * (b.emod c) := by rw [emod_def]; sorry",
  "name": "mul_emod_mul_of_pos",
  "kind": "theorem",
  "first-tactic": "rw [emod_def]",
  "core-prompt":
  "{a : Int}  (b c : Int)  (H : 0 < a) : (a * b).emod (a * c) = a * (b.emod c)",
  "args": "{a : Int}  (b c : Int)  (H : 0 < a)"},
 {"type": "a < (a / b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_div_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a / b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a < (a.ediv b + 1) * b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (H : 0 < b) : a < (a.ediv b + 1) * b := by rw [Int.add_mul]; sorry",
  "name": "lt_ediv_add_one_mul_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_mul]",
  "core-prompt": "(a : Int)  {b : Int}  (H : 0 < b) : a < (a.ediv b + 1) * b",
  "args": "(a : Int)  {b : Int}  (H : 0 < b)"},
 {"type": "a.ediv b â‰¤ a",
  "tactic-prompt":
  "theorem {a : Int}  (b : Int)  (Ha : 0 â‰¤ a) : a.ediv b â‰¤ a := by have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b); sorry",
  "name": "ediv_le_self",
  "kind": "theorem",
  "first-tactic":
  "have := Int.le_trans le_natAbs (ofNat_le.2 <| natAbs_div_le_natAbs a b)",
  "core-prompt": "{a : Int}  (b : Int)  (Ha : 0 â‰¤ a) : a.ediv b â‰¤ a",
  "args": "{a : Int}  (b : Int)  (Ha : 0 â‰¤ a)"},
 {"type": "b * (a / b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : b * (a / b) = a := by have := mod_add_div a b; sorry",
  "name": "mul_div_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := mod_add_div a b",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : b * (a / b) = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a % b = 0) : a / b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "div_mul_cancel_of_mod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a % b = 0) : a / b * b = a",
  "args": "{a b : Int}  (H : a % b = 0)"},
 {"type": "b * (a.ediv b) = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.emod b = 0) : b * (a.ediv b) = a := by have := emod_add_ediv a b; sorry",
  "name": "mul_ediv_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "have := emod_add_ediv a b",
  "core-prompt": "{a b : Int}  (H : a.emod b = 0) : b * (a.ediv b) = a",
  "args": "{a b : Int}  (H : a.emod b = 0)"},
 {"type": "a.ediv b * b = a",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a.emod b = 0) : a.ediv b * b = a := by rw [Int.mul_comm]; sorry",
  "name": "ediv_mul_cancel_of_emod_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a.emod b = 0) : a.ediv b * b = a",
  "args": "{a b : Int}  (H : a.emod b = 0)"},
 {"type": "-a âˆ£ b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : -a âˆ£ b â†” a âˆ£ b := by constructor; sorry",
  "name": "neg_dvd",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : -a âˆ£ b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "a âˆ£ -b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : a âˆ£ -b â†” a âˆ£ b := by constructor; sorry",
  "name": "dvd_neg",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a âˆ£ -b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "a âˆ£ b + c â†” a âˆ£ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c := by rw [Int.add_comm]; sorry",
  "name": "dvd_add_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (H : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c",
  "args": "{a b c : Int}  (H : a âˆ£ b)"},
 {"type": "a âˆ£ b â†” a âˆ£ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (H : a âˆ£ b + c) : a âˆ£ b â†” a âˆ£ c := by rw [â† Int.sub_neg] at H; sorry",
  "name": "dvd_iff_dvd_of_dvd_add",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.sub_neg] at H",
  "core-prompt": "{a b c : Int}  (H : a âˆ£ b + c) : a âˆ£ b â†” a âˆ£ c",
  "args": "{a b c : Int}  (H : a âˆ£ b + c)"},
 {"type": "(â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n",
  "tactic-prompt":
  "theorem {m n : Nat} : (â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n := by refine âŸ¨fun âŸ¨a, aeâŸ© => ?_, fun âŸ¨k, eâŸ© => âŸ¨k, by rw [e, Int.ofNat_mul]âŸ©âŸ©; sorry",
  "name": "ofNat_dvd",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun âŸ¨a, aeâŸ© => ?_, fun âŸ¨k, eâŸ© => âŸ¨k, by rw [e, Int.ofNat_mul]âŸ©âŸ©",
  "core-prompt": "{m n : Nat} : (â†‘m : Int) âˆ£ â†‘n â†” m âˆ£ n",
  "args": "{m n : Nat}"},
 {"type": "natAbs a âˆ£ natAbs b â†” a âˆ£ b",
  "tactic-prompt":
  "theorem {a b : Int} : natAbs a âˆ£ natAbs b â†” a âˆ£ b := by refine âŸ¨fun âŸ¨k, hkâŸ© => ?_, fun âŸ¨k, hkâŸ© => âŸ¨natAbs k, hk.symm â–¸ natAbs_mul a kâŸ©âŸ©; sorry",
  "name": "natAbs_dvd_natAbs",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun âŸ¨k, hkâŸ© => ?_, fun âŸ¨k, hkâŸ© => âŸ¨natAbs k, hk.symm â–¸ natAbs_mul a kâŸ©âŸ©",
  "core-prompt": "{a b : Int} : natAbs a âˆ£ natAbs b â†” a âˆ£ b",
  "args": "{a b : Int}"},
 {"type": "(â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : (â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs := by rw [â† natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_left",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : (â†‘n : Int) âˆ£ z â†” n âˆ£ z.natAbs",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n",
  "tactic-prompt":
  "theorem {n : Nat}  {z : Int} : z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n := by rw [â† natAbs_dvd_natAbs]; sorry",
  "name": "ofNat_dvd_right",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd_natAbs]",
  "core-prompt": "{n : Nat}  {z : Int} : z âˆ£ (â†‘n : Int) â†” z.natAbs âˆ£ n",
  "args": "{n : Nat}  {z : Int}"},
 {"type": "a âˆ£ b â†’ b âˆ£ a â†’ a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b) : a âˆ£ b â†’ b âˆ£ a â†’ a = b := by rw [â† natAbs_of_nonneg H1]; sorry",
  "name": "dvd_antisymm",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_of_nonneg H1]",
  "core-prompt":
  "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b) : a âˆ£ b â†’ b âˆ£ a â†’ a = b",
  "args": "{a b : Int}  (H1 : 0 â‰¤ a)  (H2 : 0 â‰¤ b)"},
 {"type": "b âˆ£ a - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a.emod b = c) : b âˆ£ a - c := by have hx : (a.emod b).emod b = c.emod b := by\n    rw [h]; sorry",
  "name": "dvd_sub_of_emod_eq",
  "kind": "theorem",
  "first-tactic": "have hx : (a.emod b).emod b = c.emod b := by\n    rw [h]",
  "core-prompt": "{a b c : Int}  (h : a.emod b = c) : b âˆ£ a - c",
  "args": "{a b c : Int}  (h : a.emod b = c)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a âˆ£ b) : a * (b / a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a âˆ£ b) : a * (b / a) = b",
  "args": "{a b : Int}  (H : a âˆ£ b)"},
 {"type": "a * (b.ediv a) = b",
  "tactic-prompt":
  "theorem {a b : Int}  (H : a âˆ£ b) : a * (b.ediv a) = b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "{a b : Int}  (H : a âˆ£ b) : a * (b.ediv a) = b",
  "args": "{a b : Int}  (H : a âˆ£ b)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}  (h : c âˆ£ a) : a * b / c = a / c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_div_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(b : Int)  {a c : Int}  (h : c âˆ£ a) : a * b / c = a / c * b",
  "args": "(b : Int)  {a c : Int}  (h : c âˆ£ a)"},
 {"type": "(a * b).ediv c = a.ediv c * b",
  "tactic-prompt":
  "theorem (b : Int)  {a c : Int}      (h : c âˆ£ a) : (a * b).ediv c = a.ediv c * b := by rw [Int.mul_comm]; sorry",
  "name": "mul_ediv_assoc'",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "(b : Int)  {a c : Int}      (h : c âˆ£ a) : (a * b).ediv c = a.ediv c * b",
  "args": "(b : Int)  {a c : Int}      (h : c âˆ£ a)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c := by rw [â† H2]; sorry",
  "name": "eq_mul_of_div_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c) : a = b * c := by rw [â† H2]; sorry",
  "name": "eq_mul_of_ediv_eq_right",
  "kind": "theorem",
  "first-tactic": "rw [â† H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c) : a = b * c",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a / b = c := by rw [H2]; sorry",
  "name": "div_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a / b = c",
  "args": "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c)"},
 {"type": "a.ediv b = c",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a.ediv b = c := by rw [H2]; sorry",
  "name": "ediv_eq_of_eq_mul_right",
  "kind": "theorem",
  "first-tactic": "rw [H2]",
  "core-prompt":
  "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c) : a.ediv b = c",
  "args": "{a b c : Int}      (H1 : b â‰  0)  (H2 : a = b * c)"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a / b = c â†” a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "div_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a / b = c â†” a = c * b",
  "args": "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a)"},
 {"type": "a.ediv b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a.ediv b = c â†” a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "ediv_eq_iff_eq_mul_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a) : a.ediv b = c â†” a = c * b",
  "args": "{a b c : Int}      (H : b â‰  0)  (H' : b âˆ£ a)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_div_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a / b = c)"},
 {"type": "a = c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c) : a = c * b := by rw [Int.mul_comm]; sorry",
  "name": "eq_mul_of_ediv_eq_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c) : a = c * b",
  "args": "{a b c : Int}      (H1 : b âˆ£ a)  (H2 : a.ediv b = c)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d âˆ£ n)  (H : n / d = 0) : n = 0 := by rw [â† Int.mul_div_cancel' h]; sorry",
  "name": "eq_zero_of_div_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_div_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d âˆ£ n)  (H : n / d = 0) : n = 0",
  "args": "{d n : Int}  (h : d âˆ£ n)  (H : n / d = 0)"},
 {"type": "n = 0",
  "tactic-prompt":
  "theorem {d n : Int}  (h : d âˆ£ n)  (H : n.ediv d = 0) : n = 0 := by rw [â† Int.mul_ediv_cancel' h]; sorry",
  "name": "eq_zero_of_ediv_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_ediv_cancel' h]",
  "core-prompt": "{d n : Int}  (h : d âˆ£ n)  (H : n.ediv d = 0) : n = 0",
  "args": "{d n : Int}  (h : d âˆ£ n)  (H : n.ediv d = 0)"},
 {"type": "(a - b).ediv c = a.ediv c - b.ediv c",
  "tactic-prompt":
  "theorem (a : Int)  {b c : Int}      (hcb : c âˆ£ b) : (a - b).ediv c = a.ediv c - b.ediv c := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_ediv_of_dvd",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt":
  "(a : Int)  {b c : Int}      (hcb : c âˆ£ b) : (a - b).ediv c = a.ediv c - b.ediv c",
  "args": "(a : Int)  {b c : Int}      (hcb : c âˆ£ b)"},
 {"type": "(a - b).ediv c = a.ediv c - b.ediv c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hcab : c âˆ£ a - b) : (a - b).ediv c = a.ediv c - b.ediv c := by rw [â† Int.add_sub_cancel ((a-b).ediv c)]; sorry",
  "name": "sub_ediv_of_dvd_sub",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_sub_cancel ((a-b).ediv c)]",
  "core-prompt":
  "{a b c : Int}      (hcab : c âˆ£ a - b) : (a - b).ediv c = a.ediv c - b.ediv c",
  "args": "{a b c : Int}      (hcab : c âˆ£ a - b)"},
 {"type": "a / d = b / d â†” a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b := by refine âŸ¨fun h => ?_, congrArg (Â· / d)âŸ©; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, congrArg (Â· / d)âŸ©",
  "core-prompt":
  "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a / d = b / d â†” a = b",
  "args": "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b)"},
 {"type": "a.ediv d = b.ediv d â†” a = b",
  "tactic-prompt":
  "theorem {a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a.ediv d = b.ediv d â†” a = b := by refine âŸ¨fun h => ?_, congrArg (ediv Â· d)âŸ©; sorry",
  "name": "ediv_left_inj",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h => ?_, congrArg (ediv Â· d)âŸ©",
  "core-prompt":
  "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b) : a.ediv d = b.ediv d â†” a = b",
  "args": "{a b d : Int}      (hda : d âˆ£ a)  (hdb : d âˆ£ b)"},
 {"type": "a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b := by rw [â† Int.div_mul_cancel H2]; sorry",
  "name": "le_mul_of_div_le",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.div_mul_cancel H2]",
  "core-prompt":
  "{a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c) : a â‰¤ c * b",
  "args": "{a b c : Int}  (H1 : 0 â‰¤ b)  (H2 : b âˆ£ a)  (H3 : a / b â‰¤ c)"},
 {"type": "a = c / b * d",
  "tactic-prompt":
  "theorem {a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d) : a = c / b * d := by cases' hbc with k hk; sorry",
  "name": "eq_mul_div_of_mul_eq_mul_of_dvd_left",
  "kind": "theorem",
  "first-tactic": "cases' hbc with k hk",
  "core-prompt":
  "{a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d) : a = c / b * d",
  "args": "{a b c d : Int}  (hb : b â‰  0)  (hbc : b âˆ£ c)  (h : b * a = c * d)"},
 {"type": "b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0 := by rw [â† natAbs_dvd]; sorry",
  "name": "eq_zero_of_dvd_ofNatAbs_lt_natAbs",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_dvd]",
  "core-prompt": "{a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a) : b = 0",
  "args": "{a b : Int}  (w : a âˆ£ b)  (h : natAbs b < natAbs a)"},
 {"type": "t / s âˆ£ t",
  "tactic-prompt":
  "theorem {s t : Int}  (hst : s âˆ£ t) : t / s âˆ£ t := by rcases eq_or_ne s 0 with (rfl | hs); sorry",
  "name": "div_dvd_of_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne s 0 with (rfl | hs)",
  "core-prompt": "{s t : Int}  (hst : s âˆ£ t) : t / s âˆ£ t",
  "args": "{s t : Int}  (hst : s âˆ£ t)"},
 {"type": "b âˆ£ c / a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a * b âˆ£ c) : b âˆ£ c / a := by rcases eq_or_ne a 0 with (rfl | ha); sorry",
  "name": "dvd_div_of_mul_dvd",
  "kind": "theorem",
  "first-tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
  "core-prompt": "{a b c : Int}  (h : a * b âˆ£ c) : b âˆ£ c / a",
  "args": "{a b c : Int}  (h : a * b âˆ£ c)"},
 {"type": "subNatNat m n = ofNat (m - n)",
  "tactic-prompt":
  "theorem {m n : Nat}  (h : n - m = 0) : subNatNat m n = ofNat (m - n) := by rw [subNatNat]; sorry",
  "name": "subNatNat_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [subNatNat]",
  "core-prompt": "{m n : Nat}  (h : n - m = 0) : subNatNat m n = ofNat (m - n)",
  "args": "{m n : Nat}  (h : n - m = 0)"},
 {"type": "subNatNat (m + n) m = ofNat n",
  "tactic-prompt":
  "theorem  : subNatNat (m + n) m = ofNat n := by unfold subNatNat; sorry",
  "name": "subNatNat_add_left",
  "kind": "theorem",
  "first-tactic": "unfold subNatNat",
  "core-prompt": " : subNatNat (m + n) m = ofNat n",
  "args": ""},
 {"type": "subNatNat m (m + n + 1) = negSucc n",
  "tactic-prompt":
  "theorem  : subNatNat m (m + n + 1) = negSucc n := by simp [subNatNat]; sorry",
  "name": "subNatNat_add_right",
  "kind": "theorem",
  "first-tactic": "simp [subNatNat]",
  "core-prompt": " : subNatNat m (m + n + 1) = negSucc n",
  "args": ""},
 {"type": "subNatNat (m + k) (n + k) = subNatNat m n",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n := by apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i); sorry",
  "name": "subNatNat_add_add",
  "kind": "theorem",
  "first-tactic":
  "apply subNatNat_elim m n (fun m n i => subNatNat (m + k) (n + k) = i)",
  "core-prompt": "(m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n",
  "args": "(m n k : Nat)"},
 {"type": "0 < natAbs a â†” a â‰  0",
  "tactic-prompt":
  "theorem  : 0 < natAbs a â†” a â‰  0 := by rw [Nat.pos_iff_ne_zero]; sorry",
  "name": "natAbs_pos",
  "kind": "theorem",
  "first-tactic": "rw [Nat.pos_iff_ne_zero]",
  "core-prompt": " : 0 < natAbs a â†” a â‰  0",
  "args": ""},
 {"type": "natAbs (negOfNat n) = n",
  "tactic-prompt":
  "theorem (n : Nat) : natAbs (negOfNat n) = n := by cases n; sorry",
  "name": "natAbs_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(n : Nat) : natAbs (negOfNat n) = n",
  "args": "(n : Nat)"},
 {"type": "natAbs (a * b) = natAbs a * natAbs b",
  "tactic-prompt":
  "theorem (a b : Int) : natAbs (a * b) = natAbs a * natAbs b := by cases a; sorry",
  "name": "natAbs_mul",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : natAbs (a * b) = natAbs a * natAbs b",
  "args": "(a b : Int)"},
 {"type": "a.natAbs * b.natAbs = c",
  "tactic-prompt":
  "theorem {a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c := by rw [â† natAbs_mul]; sorry",
  "name": "natAbs_mul_natAbs_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_mul]",
  "core-prompt":
  "{a b : Int}  {c : Nat}      (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c",
  "args": "{a b : Int}  {c : Nat}      (h : a * b = (c : Int))"},
 {"type": "(natAbs a * natAbs a : Int) = a * a",
  "tactic-prompt":
  "theorem (a : Int) : (natAbs a * natAbs a : Int) = a * a := by rw [â† Int.ofNat_mul]; sorry",
  "name": "natAbs_mul_self'",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.ofNat_mul]",
  "core-prompt": "(a : Int) : (natAbs a * natAbs a : Int) = a * a",
  "args": "(a : Int)"},
 {"type": "a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b",
  "tactic-prompt":
  "theorem {a b : Int} : a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b := by constructor; sorry",
  "name": "natAbs_eq_natAbs_iff",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{a b : Int} : a.natAbs = b.natAbs â†” a = b âˆ¨ a = -b",
  "args": "{a b : Int}"},
 {"type": "a.natAbs = n â†” a = n âˆ¨ a = -â†‘n",
  "tactic-prompt":
  "theorem {a : Int}  {n : Nat} : a.natAbs = n â†” a = n âˆ¨ a = -â†‘n := by rw [â† Int.natAbs_eq_natAbs_iff]; sorry",
  "name": "natAbs_eq_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.natAbs_eq_natAbs_iff]",
  "core-prompt": "{a : Int}  {n : Nat} : a.natAbs = n â†” a = n âˆ¨ a = -â†‘n",
  "args": "{a : Int}  {n : Nat}"},
 {"type": "z.sign.natAbs = 1",
  "tactic-prompt":
  "theorem {z : Int}  (hz : z â‰  0) : z.sign.natAbs = 1 := by rw [Int.natAbs_sign]; sorry",
  "name": "natAbs_sign_of_nonzero",
  "kind": "theorem",
  "first-tactic": "rw [Int.natAbs_sign]",
  "core-prompt": "{z : Int}  (hz : z â‰  0) : z.sign.natAbs = 1",
  "args": "{z : Int}  (hz : z â‰  0)"},
 {"type": "subNatNat (m - n) k = subNatNat m (k + n)",
  "tactic-prompt":
  "theorem (h : n â‰¤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n) := by rwa [â† subNatNat_add_add _ _ n]; sorry",
  "name": "subNatNat_sub",
  "kind": "theorem",
  "first-tactic": "rwa [â† subNatNat_add_add _ _ n]",
  "core-prompt":
  "(h : n â‰¤ m)  (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n)",
  "args": "(h : n â‰¤ m)  (k : Nat)"},
 {"type": "subNatNat (m + n) k = ofNat m + subNatNat n k",
  "tactic-prompt":
  "theorem (m n k : Nat) : subNatNat (m + n) k = ofNat m + subNatNat n k := by cases n.lt_or_ge k; sorry",
  "name": "subNatNat_add",
  "kind": "theorem",
  "first-tactic": "cases n.lt_or_ge k",
  "core-prompt":
  "(m n k : Nat) : subNatNat (m + n) k = ofNat m + subNatNat n k",
  "args": "(m n k : Nat)"},
 {"type": "a + (b + c) = b + (a + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + (b + c) = b + (a + c) := by rw [â† Int.add_assoc]; sorry",
  "name": "add_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + (b + c) = b + (a + c)",
  "args": "(a b c : Int)"},
 {"type": "a + b + c = a + c + b",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b + c = a + c + b := by rw [Int.add_assoc]; sorry",
  "name": "add_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b c : Int) : a + b + c = a + c + b",
  "args": "(a b c : Int)"},
 {"type": "a + -a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a + -a = 0 := by rw [Int.add_comm]; sorry",
  "name": "add_right_neg",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "(a : Int) : a + -a = 0",
  "args": "(a : Int)"},
 {"type": "-a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a + b = 0) : -a = b := by rw [â† Int.add_zero (-a)]; sorry",
  "name": "neg_eq_of_add_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_zero (-a)]",
  "core-prompt": "{a b : Int}  (h : a + b = 0) : -a = b",
  "args": "{a b : Int}  (h : a + b = 0)"},
 {"type": "b = -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = -b) : b = -a := by rw [h]; sorry",
  "name": "eq_neg_of_eq_neg",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = -b) : b = -a",
  "args": "{a b : Int}  (h : a = -b)"},
 {"type": "-a + (a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : -a + (a + b) = b := by rw [â† Int.add_assoc]; sorry",
  "name": "neg_add_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b : Int) : -a + (a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + (-a + b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a + (-a + b) = b := by rw [â† Int.add_assoc]; sorry",
  "name": "add_neg_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + (-a + b) = b",
  "args": "(a b : Int)"},
 {"type": "a + b + -b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + b + -b = a := by rw [Int.add_assoc]; sorry",
  "name": "add_neg_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + b + -b = a",
  "args": "(a b : Int)"},
 {"type": "a + -b + b = a",
  "tactic-prompt":
  "theorem (a b : Int) : a + -b + b = a := by rw [Int.add_assoc]; sorry",
  "name": "neg_add_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_assoc]",
  "core-prompt": "(a b : Int) : a + -b + b = a",
  "args": "(a b : Int)"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b = a + c) : b = c := by have hâ‚ : -a + (a + b) = -a + (a + c) := by rw [h]; sorry",
  "name": "add_left_cancel",
  "kind": "theorem",
  "first-tactic": "have hâ‚ : -a + (a + b) = -a + (a + c) := by rw [h]",
  "core-prompt": "{a b c : Int}  (h : a + b = a + c) : b = c",
  "args": "{a b c : Int}  (h : a + b = a + c)"},
 {"type": "-(a + b) = -a + -b",
  "tactic-prompt":
  "theorem {a b : Int} : -(a + b) = -a + -b := by apply Int.add_left_cancel (a := a + b); sorry",
  "name": "neg_add",
  "kind": "theorem",
  "first-tactic": "apply Int.add_left_cancel (a := a + b)",
  "core-prompt": "{a b : Int} : -(a + b) = -a + -b",
  "args": "{a b : Int}"},
 {"type": "a - a = 0",
  "tactic-prompt":
  "theorem (a : Int) : a - a = 0 := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "sub_self",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a : Int) : a - a = 0",
  "args": "(a : Int)"},
 {"type": "a - b = 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a = b) : a - b = 0 := by rw [h]; sorry",
  "name": "sub_eq_zero_of_eq",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{a b : Int}  (h : a = b) : a - b = 0",
  "args": "{a b : Int}  (h : a = b)"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b = 0) : a = b := by have : 0 + b = b := by rw [Int.zero_add]; sorry",
  "name": "eq_of_sub_eq_zero",
  "kind": "theorem",
  "first-tactic": "have : 0 + b = b := by rw [Int.zero_add]",
  "core-prompt": "{a b : Int}  (h : a - b = 0) : a = b",
  "args": "{a b : Int}  (h : a - b = 0)"},
 {"type": "a - b - c = a - (b + c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a - b - c = a - (b + c) := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a - b - c = a - (b + c)",
  "args": "(a b c : Int)"},
 {"type": "-(a - b) = b - a",
  "tactic-prompt":
  "theorem (a b : Int) : -(a - b) = b - a := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "neg_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : -(a - b) = b - a",
  "args": "(a b : Int)"},
 {"type": "a - (a - b) = b",
  "tactic-prompt":
  "theorem (a b : Int) : a - (a - b) = b := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_sub_self",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b : Int) : a - (a - b) = b",
  "args": "(a b : Int)"},
 {"type": "a - -b = a + b",
  "tactic-prompt":
  "theorem (a b : Int) : a - -b = a + b := by simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/; sorry",
  "name": "sub_neg",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]\n\n/- ## multiplication -/",
  "core-prompt": "(a b : Int) : a - -b = a + b",
  "args": "(a b : Int)"},
 {"type": "a * b = b * a",
  "tactic-prompt": "theorem (a b : Int) : a * b = b * a := by cases a; sorry",
  "name": "mul_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b : Int) : a * b = b * a",
  "args": "(a b : Int)"},
 {"type": "ofNat m * negOfNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : ofNat m * negOfNat n = negOfNat (m * n) := by cases n; sorry",
  "name": "ofNat_mul_negOfNat",
  "kind": "theorem",
  "first-tactic": "cases n",
  "core-prompt": "(m n : Nat) : ofNat m * negOfNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "negOfNat m * ofNat n = negOfNat (m * n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m * ofNat n = negOfNat (m * n) := by rw [Int.mul_comm]; sorry",
  "name": "negOfNat_mul_ofNat",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(m n : Nat) : negOfNat m * ofNat n = negOfNat (m * n)",
  "args": "(m n : Nat)"},
 {"type": "a * b * c = a * (b * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * (b * c) := by cases a; sorry",
  "name": "mul_assoc",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a b c : Int) : a * b * c = a * (b * c)",
  "args": "(a b c : Int)"},
 {"type": "a * (b * c) = b * (a * c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b * c) = b * (a * c) := by rw [â† Int.mul_assoc]; sorry",
  "name": "mul_left_comm",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * (b * c) = b * (a * c)",
  "args": "(a b c : Int)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem (a b c : Int) : a * b * c = a * c * b := by rw [Int.mul_assoc]; sorry",
  "name": "mul_right_comm",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_assoc]",
  "core-prompt": "(a b c : Int) : a * b * c = a * c * b",
  "args": "(a b c : Int)"},
 {"type": "a * 0 = 0",
  "tactic-prompt": "theorem (a : Int) : a * 0 = 0 := by cases a; sorry",
  "name": "mul_zero",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Int) : a * 0 = 0",
  "args": "(a : Int)"},
 {"type": "ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "tactic-prompt":
  "theorem (m n k : Nat) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k) := by cases m; sorry",
  "name": "ofNat_mul_subNatNat",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt":
  "(m n k : Nat) : ofNat m * subNatNat n k = subNatNat (m * n) (m * k)",
  "args": "(m n k : Nat)"},
 {"type": "negOfNat m + negOfNat n = negOfNat (m + n)",
  "tactic-prompt":
  "theorem (m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n) := by cases m; sorry",
  "name": "negOfNat_add",
  "kind": "theorem",
  "first-tactic": "cases m",
  "core-prompt": "(m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n)",
  "args": "(m n : Nat)"},
 {"type": "(a + b) * c = a * c + b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a + b) * c = a * c + b * c := by simp [Int.mul_comm]; sorry",
  "name": "add_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.mul_comm]",
  "core-prompt": "(a b c : Int) : (a + b) * c = a * c + b * c",
  "args": "(a b c : Int)"},
 {"type": "-a * -b = a * b",
  "tactic-prompt": "theorem (a b : Int) : -a * -b = a * b := by simp; sorry",
  "name": "neg_mul_neg",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * -b = a * b",
  "args": "(a b : Int)"},
 {"type": "-a * b = a * -b",
  "tactic-prompt": "theorem (a b : Int) : -a * b = a * -b := by simp; sorry",
  "name": "neg_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a b : Int) : -a * b = a * -b",
  "args": "(a b : Int)"},
 {"type": "a * (b - c) = a * b - a * c",
  "tactic-prompt":
  "theorem (a b c : Int) : a * (b - c) = a * b - a * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "mul_sub",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a * (b - c) = a * b - a * c",
  "args": "(a b c : Int)"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem (a b c : Int) : (a - b) * c = a * c - b * c := by simp [Int.sub_eq_add_neg]; sorry",
  "name": "sub_mul",
  "kind": "theorem",
  "first-tactic": "simp [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : (a - b) * c = a * c - b * c",
  "args": "(a b c : Int)"},
 {"type": "a + b - c = a + (b - c)",
  "tactic-prompt":
  "theorem (a b c : Int) : a + b - c = a + (b - c) := by rw [Int.sub_eq_add_neg]; sorry",
  "name": "add_sub_assoc",
  "kind": "theorem",
  "first-tactic": "rw [Int.sub_eq_add_neg]",
  "core-prompt": "(a b c : Int) : a + b - c = a + (b - c)",
  "args": "(a b c : Int)"},
 {"type": "ofNat (n - m) = ofNat n - ofNat m",
  "tactic-prompt":
  "theorem (h : m â‰¤ n) : ofNat (n - m) = ofNat n - ofNat m := by match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]; sorry",
  "name": "ofNat_sub",
  "kind": "theorem",
  "first-tactic":
  "match m with\n  | 0 => rfl\n  | succ m =>\n    show ofNat (n - succ m) = subNatNat n (succ m)\n    rw [subNatNat]",
  "core-prompt": "(h : m â‰¤ n) : ofNat (n - m) = ofNat n - ofNat m",
  "args": "(h : m â‰¤ n)"},
 {"type": "subNatNat m n = â†‘m - â†‘n",
  "tactic-prompt":
  "theorem {m n : Nat} : subNatNat m n = â†‘m - â†‘n := by apply subNatNat_elim m n fun m n i => i = m - n; sorry",
  "name": "subNatNat_eq_coe",
  "kind": "theorem",
  "first-tactic": "apply subNatNat_elim m n fun m n i => i = m - n",
  "core-prompt": "{m n : Nat} : subNatNat m n = â†‘m - â†‘n",
  "args": "{m n : Nat}"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem (a : Int) : a * 1 = a := by rw [Int.mul_comm]; sorry",
  "name": "mul_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt": "(a : Int) : a * 1 = a",
  "args": "(a : Int)"},
 {"type": "a * -1 = -a",
  "tactic-prompt":
  "theorem (a : Int) : a * -1 = -a := by rw [Int.mul_neg]; sorry",
  "name": "mul_neg_one",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_neg]",
  "core-prompt": "(a : Int) : a * -1 = -a",
  "args": "(a : Int)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (n : Nat)  (h : b - a = n) : a â‰¤ b := by simp [le_def]; sorry",
  "name": "le.intro_sub",
  "kind": "theorem",
  "first-tactic": "simp [le_def]",
  "core-prompt": "{a b : Int}  (n : Nat)  (h : b - a = n) : a â‰¤ b",
  "args": "{a b : Int}  (n : Nat)  (h : b - a = n)"},
 {"type": "âˆƒ n : Nat, a = n",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : âˆƒ n : Nat, a = n := by have t := le.dest_sub h; sorry",
  "name": "eq_ofNat_of_zero_le",
  "kind": "theorem",
  "first-tactic": "have t := le.dest_sub h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : âˆƒ n : Nat, a = n",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "(â†‘n : Int) < â†‘m â†” n < m",
  "tactic-prompt":
  "theorem {n m : Nat} : (â†‘n : Int) < â†‘m â†” n < m := by rw [lt_iff_add_one_le]; sorry",
  "name": "ofNat_lt",
  "kind": "theorem",
  "first-tactic": "rw [lt_iff_add_one_le]",
  "core-prompt": "{n m : Nat} : (â†‘n : Int) < â†‘m â†” n < m",
  "args": "{n m : Nat}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a) : a = b := by let âŸ¨n, hnâŸ© := le.dest hâ‚; sorry",
  "name": "le_antisymm",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := le.dest hâ‚",
  "core-prompt": "{a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a) : a = b",
  "args": "{a b : Int}  (hâ‚ : a â‰¤ b)  (hâ‚‚ : b â‰¤ a)"},
 {"type": "a < b â†” a â‰¤ b âˆ§ a â‰  b",
  "tactic-prompt":
  "theorem {a b : Int} : a < b â†” a â‰¤ b âˆ§ a â‰  b := by refine âŸ¨fun h => âŸ¨Int.le_of_lt h, Int.ne_of_lt hâŸ©, fun âŸ¨aleb, anebâŸ© => ?_âŸ©; sorry",
  "name": "lt_iff_le_and_ne",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun h => âŸ¨Int.le_of_lt h, Int.ne_of_lt hâŸ©, fun âŸ¨aleb, anebâŸ© => ?_âŸ©",
  "core-prompt": "{a b : Int} : a < b â†” a â‰¤ b âˆ§ a â‰  b",
  "args": "{a b : Int}"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b := by let âŸ¨n, hnâŸ© := eq_ofNat_of_zero_le ha; sorry",
  "name": "mul_nonneg",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := eq_ofNat_of_zero_le ha",
  "core-prompt": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b) : 0 â‰¤ a * b",
  "args": "{a b : Int}  (ha : 0 â‰¤ a)  (hb : 0 â‰¤ b)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b := by let âŸ¨n, hnâŸ© := eq_succ_of_zero_lt ha; sorry",
  "name": "mul_pos",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, hnâŸ© := eq_succ_of_zero_lt ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b) : 0 < a * b",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : 0 < b)"},
 {"type": "a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int} : a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a := by rw [Int.lt_iff_le_and_ne]; sorry",
  "name": "lt_iff_le_not_le",
  "kind": "theorem",
  "first-tactic": "rw [Int.lt_iff_le_and_ne]",
  "core-prompt": "{a b : Int} : a < b â†” a â‰¤ b âˆ§ Â¬b â‰¤ a",
  "args": "{a b : Int}"},
 {"type": "Â¬a < b â†” b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int} : Â¬a < b â†” b â‰¤ a := by rw [â† Int.not_le]; sorry",
  "name": "not_lt",
  "kind": "theorem",
  "first-tactic": "rw [â† Int.not_le]",
  "core-prompt": "{a b : Int} : Â¬a < b â†” b â‰¤ a",
  "args": "{a b : Int}"},
 {"type": "a = natAbs a",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : a = natAbs a := by let âŸ¨n, eâŸ© := eq_ofNat_of_zero_le h; sorry",
  "name": "eq_natAbs_of_zero_le",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, eâŸ© := eq_ofNat_of_zero_le h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : a = natAbs a",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ a + c) : b â‰¤ c := by have : -a + (a + b) â‰¤ -a + (a + c) := Int.add_le_add_left h _; sorry",
  "name": "le_of_add_le_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) â‰¤ -a + (a + c) := Int.add_le_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ a + c) : b â‰¤ c",
  "args": "{a b c : Int}  (h : a + b â‰¤ a + c)"},
 {"type": "b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < a + c) : b < c := by have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _; sorry",
  "name": "lt_of_add_lt_add_left",
  "kind": "theorem",
  "first-tactic":
  "have : -a + (a + b) < -a + (a + c) := Int.add_lt_add_left h _",
  "core-prompt": "{a b c : Int}  (h : a + b < a + c) : b < c",
  "args": "{a b c : Int}  (h : a + b < a + c)"},
 {"type": "a â‰¤ a + b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ b) : a â‰¤ a + b := by have : a + b â‰¥ a + 0 := Int.add_le_add_left h a; sorry",
  "name": "le_add_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "have : a + b â‰¥ a + 0 := Int.add_le_add_left h a",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ b) : a â‰¤ a + b",
  "args": "{a b : Int}  (h : 0 â‰¤ b)"},
 {"type": "a â‰¤ b + a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ b) : a â‰¤ b + a := by have : 0 + a â‰¤ b + a := Int.add_le_add_right h a; sorry",
  "name": "le_add_of_nonneg_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a â‰¤ b + a := Int.add_le_add_right h a",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ b) : a â‰¤ b + a",
  "args": "{a b : Int}  (h : 0 â‰¤ b)"},
 {"type": "a < a + b",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < a + b := by have : a + 0 < a + b := Int.add_lt_add_left h a; sorry",
  "name": "lt_add_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : a + 0 < a + b := Int.add_lt_add_left h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < a + b",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "a < b + a",
  "tactic-prompt":
  "theorem (a : Int)  {b : Int}  (h : 0 < b) : a < b + a := by have : 0 + a < b + a := Int.add_lt_add_right h a; sorry",
  "name": "lt_add_of_pos_left",
  "kind": "theorem",
  "first-tactic": "have : 0 + a < b + a := Int.add_lt_add_right h a",
  "core-prompt": "(a : Int)  {b : Int}  (h : 0 < b) : a < b + a",
  "args": "(a : Int)  {b : Int}  (h : 0 < b)"},
 {"type": "-b â‰¤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : -b â‰¤ -a := by have : 0 â‰¤ -a + b := Int.add_left_neg a â–¸ Int.add_le_add_left h (-a); sorry",
  "name": "neg_le_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 â‰¤ -a + b := Int.add_left_neg a â–¸ Int.add_le_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : -b â‰¤ -a",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "-a â‰¤ 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 â‰¤ a) : -a â‰¤ 0 := by have : -a â‰¤ -0 := Int.neg_le_neg h; sorry",
  "name": "neg_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic": "have : -a â‰¤ -0 := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : 0 â‰¤ a) : -a â‰¤ 0",
  "args": "{a : Int}  (h : 0 â‰¤ a)"},
 {"type": "0 â‰¤ -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a â‰¤ 0) : 0 â‰¤ -a := by have : -0 â‰¤ -a := Int.neg_le_neg h; sorry",
  "name": "neg_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic": "have : -0 â‰¤ -a := Int.neg_le_neg h",
  "core-prompt": "{a : Int}  (h : a â‰¤ 0) : 0 â‰¤ -a",
  "args": "{a : Int}  (h : a â‰¤ 0)"},
 {"type": "-b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : -b < -a := by have : 0 < -a + b := Int.add_left_neg a â–¸ Int.add_lt_add_left h (-a); sorry",
  "name": "neg_lt_neg",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < -a + b := Int.add_left_neg a â–¸ Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b : Int}  (h : a < b) : -b < -a",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "-a < 0",
  "tactic-prompt":
  "theorem {a : Int}  (h : 0 < a) : -a < 0 := by have : -a < -0 := Int.neg_lt_neg h; sorry",
  "name": "neg_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have : -a < -0 := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : 0 < a) : -a < 0",
  "args": "{a : Int}  (h : 0 < a)"},
 {"type": "0 < -a",
  "tactic-prompt":
  "theorem {a : Int}  (h : a < 0) : 0 < -a := by have : -0 < -a := Int.neg_lt_neg h; sorry",
  "name": "neg_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have : -0 < -a := Int.neg_lt_neg h",
  "core-prompt": "{a : Int}  (h : a < 0) : 0 < -a",
  "args": "{a : Int}  (h : a < 0)"},
 {"type": "b â‰¤ -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ -b) : b â‰¤ -a := by have h := Int.neg_le_neg h; sorry",
  "name": "le_neg_of_le_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : a â‰¤ -b) : b â‰¤ -a",
  "args": "{a b : Int}  (h : a â‰¤ -b)"},
 {"type": "-b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a â‰¤ b) : -b â‰¤ a := by have h := Int.neg_le_neg h; sorry",
  "name": "neg_le_of_neg_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_le_neg h",
  "core-prompt": "{a b : Int}  (h : -a â‰¤ b) : -b â‰¤ a",
  "args": "{a b : Int}  (h : -a â‰¤ b)"},
 {"type": "b < -a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < -b) : b < -a := by have h := Int.neg_lt_neg h; sorry",
  "name": "lt_neg_of_lt_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : a < -b) : b < -a",
  "args": "{a b : Int}  (h : a < -b)"},
 {"type": "-b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : -a < b) : -b < a := by have h := Int.neg_lt_neg h; sorry",
  "name": "neg_lt_of_neg_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.neg_lt_neg h",
  "core-prompt": "{a b : Int}  (h : -a < b) : -b < a",
  "args": "{a b : Int}  (h : -a < b)"},
 {"type": "0 â‰¤ a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b â‰¤ a) : 0 â‰¤ a - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonneg_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b â‰¤ a) : 0 â‰¤ a - b",
  "args": "{a b : Int}  (h : b â‰¤ a)"},
 {"type": "b â‰¤ a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 â‰¤ a - b) : b â‰¤ a := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonneg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 â‰¤ a - b) : b â‰¤ a",
  "args": "{a b : Int}  (h : 0 â‰¤ a - b)"},
 {"type": "a - b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a â‰¤ b) : a - b â‰¤ 0 := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_nonpos_of_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a â‰¤ b) : a - b â‰¤ 0",
  "args": "{a b : Int}  (h : a â‰¤ b)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b â‰¤ 0) : a â‰¤ b := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_of_sub_nonpos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b â‰¤ 0) : a â‰¤ b",
  "args": "{a b : Int}  (h : a - b â‰¤ 0)"},
 {"type": "0 < a - b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : b < a) : 0 < a - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_pos_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : b < a) : 0 < a - b",
  "args": "{a b : Int}  (h : b < a)"},
 {"type": "b < a",
  "tactic-prompt":
  "theorem {a b : Int}  (h : 0 < a - b) : b < a := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_pos",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : 0 < a - b) : b < a",
  "args": "{a b : Int}  (h : 0 < a - b)"},
 {"type": "a - b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a < b) : a - b < 0 := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_neg_of_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b : Int}  (h : a < b) : a - b < 0",
  "args": "{a b : Int}  (h : a < b)"},
 {"type": "a < b",
  "tactic-prompt":
  "theorem {a b : Int}  (h : a - b < 0) : a < b := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_of_sub_neg",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b : Int}  (h : a - b < 0) : a < b",
  "args": "{a b : Int}  (h : a - b < 0)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b â‰¤ -a + c) : a + b â‰¤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b â‰¤ -a + c) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : b â‰¤ -a + c)"},
 {"type": "b â‰¤ -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ -a + c := by have h := Int.add_le_add_left h (-a); sorry",
  "name": "le_neg_add_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ -a + c",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b â‰¤ c - a) : a + b â‰¤ c := by have h := Int.add_le_add_left h a; sorry",
  "name": "add_le_of_le_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b â‰¤ c - a) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : b â‰¤ c - a)"},
 {"type": "b â‰¤ c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ c - a := by have h := Int.add_le_add_right h (-a); sorry",
  "name": "le_sub_left_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : b â‰¤ c - a",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a + b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ c - b) : a + b â‰¤ c := by have h := Int.add_le_add_right h b; sorry",
  "name": "add_le_of_le_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ c - b) : a + b â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ c - b)"},
 {"type": "a â‰¤ c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b â‰¤ c) : a â‰¤ c - b := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "le_sub_right_of_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b â‰¤ c) : a â‰¤ c - b",
  "args": "{a b c : Int}  (h : a + b â‰¤ c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c := by have h := Int.add_le_add_left h b; sorry",
  "name": "le_add_of_neg_add_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -b + a â‰¤ c)"},
 {"type": "-b + a â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c := by have h := Int.add_le_add_left h (-b); sorry",
  "name": "neg_add_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b â‰¤ c) : a â‰¤ b + c := by have h := Int.add_le_add_right h b; sorry",
  "name": "le_add_of_sub_left_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : a - b â‰¤ c)"},
 {"type": "a - b â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : a - b â‰¤ c := by have h := Int.add_le_add_right h (-b); sorry",
  "name": "sub_left_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : a - b â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c â‰¤ b) : a â‰¤ b + c := by have h := Int.add_le_add_right h c; sorry",
  "name": "le_add_of_sub_right_le",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c â‰¤ b) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : a - c â‰¤ b)"},
 {"type": "a - c â‰¤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : a - c â‰¤ b := by have h := Int.add_le_add_right h (-c); sorry",
  "name": "sub_right_le_of_le_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_le_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : a - c â‰¤ b",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a â‰¤ c) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -b + a â‰¤ c)"},
 {"type": "-b + a â‰¤ c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_le_left_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -b + a â‰¤ c",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "a â‰¤ b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a â‰¤ b) : a â‰¤ b + c := by rw [Int.add_comm] at h; sorry",
  "name": "le_add_of_neg_add_le_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a â‰¤ b) : a â‰¤ b + c",
  "args": "{a b c : Int}  (h : -c + a â‰¤ b)"},
 {"type": "-c + a â‰¤ b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a â‰¤ b + c) : -c + a â‰¤ b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_le_right_of_le_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a â‰¤ b + c) : -c + a â‰¤ b",
  "args": "{a b c : Int}  (h : a â‰¤ b + c)"},
 {"type": "-a â‰¤ b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c â‰¤ a + b) : -a â‰¤ b - c := by have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h); sorry",
  "name": "neg_le_sub_left_of_le_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.le_neg_add_of_add_le (Int.sub_left_le_of_le_add h)",
  "core-prompt": "{a b c : Int}  (h : c â‰¤ a + b) : -a â‰¤ b - c",
  "args": "{a b c : Int}  (h : c â‰¤ a + b)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < -a + c) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_neg_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < -a + c) : a + b < c",
  "args": "{a b c : Int}  (h : b < -a + c)"},
 {"type": "b < -a + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < -a + c := by have h := Int.add_lt_add_left h (-a); sorry",
  "name": "lt_neg_add_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < -a + c",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : b < c - a) : a + b < c := by have h := Int.add_lt_add_left h a; sorry",
  "name": "add_lt_of_lt_sub_left",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h a",
  "core-prompt": "{a b c : Int}  (h : b < c - a) : a + b < c",
  "args": "{a b c : Int}  (h : b < c - a)"},
 {"type": "b < c - a",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : b < c - a := by have h := Int.add_lt_add_right h (-a); sorry",
  "name": "lt_sub_left_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-a)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : b < c - a",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a + b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < c - b) : a + b < c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "add_lt_of_lt_sub_right",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a < c - b) : a + b < c",
  "args": "{a b c : Int}  (h : a < c - b)"},
 {"type": "a < c - b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a + b < c) : a < c - b := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "lt_sub_right_of_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a + b < c) : a < c - b",
  "args": "{a b c : Int}  (h : a + b < c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by have h := Int.add_lt_add_left h b; sorry",
  "name": "lt_add_of_neg_add_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h b",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by have h := Int.add_lt_add_left h (-b); sorry",
  "name": "neg_add_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_left h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - b < c) : a < b + c := by have h := Int.add_lt_add_right h b; sorry",
  "name": "lt_add_of_sub_left_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h b",
  "core-prompt": "{a b c : Int}  (h : a - b < c) : a < b + c",
  "args": "{a b c : Int}  (h : a - b < c)"},
 {"type": "a - b < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - b < c := by have h := Int.add_lt_add_right h (-b); sorry",
  "name": "sub_left_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-b)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - b < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a - c < b) : a < b + c := by have h := Int.add_lt_add_right h c; sorry",
  "name": "lt_add_of_sub_right_lt",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h c",
  "core-prompt": "{a b c : Int}  (h : a - c < b) : a < b + c",
  "args": "{a b c : Int}  (h : a - c < b)"},
 {"type": "a - c < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : a - c < b := by have h := Int.add_lt_add_right h (-c); sorry",
  "name": "sub_right_lt_of_lt_add",
  "kind": "theorem",
  "first-tactic": "have h := Int.add_lt_add_right h (-c)",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : a - c < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -b + a < c) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_left",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -b + a < c) : a < b + c",
  "args": "{a b c : Int}  (h : -b + a < c)"},
 {"type": "-b + a < c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -b + a < c := by rw [Int.add_comm]; sorry",
  "name": "neg_add_lt_left_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm]",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -b + a < c",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "a < b + c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : -c + a < b) : a < b + c := by rw [Int.add_comm] at h; sorry",
  "name": "lt_add_of_neg_add_lt_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : -c + a < b) : a < b + c",
  "args": "{a b c : Int}  (h : -c + a < b)"},
 {"type": "-c + a < b",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : a < b + c) : -c + a < b := by rw [Int.add_comm] at h; sorry",
  "name": "neg_add_lt_right_of_lt_add",
  "kind": "theorem",
  "first-tactic": "rw [Int.add_comm] at h",
  "core-prompt": "{a b c : Int}  (h : a < b + c) : -c + a < b",
  "args": "{a b c : Int}  (h : a < b + c)"},
 {"type": "-a < b - c",
  "tactic-prompt":
  "theorem {a b c : Int}  (h : c < a + b) : -a < b - c := by have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h); sorry",
  "name": "neg_lt_sub_left_of_lt_add",
  "kind": "theorem",
  "first-tactic":
  "have h := Int.lt_neg_add_of_add_lt (Int.sub_left_lt_of_lt_add h)",
  "core-prompt": "{a b c : Int}  (h : c < a + b) : -a < b - c",
  "args": "{a b c : Int}  (h : c < a + b)"},
 {"type": "c * a < c * b",
  "tactic-prompt":
  "theorem {a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : c * a < c * b := by have : 0 < c * (b - a) := Int.mul_pos hâ‚‚ (Int.sub_pos_of_lt hâ‚); sorry",
  "name": "mul_lt_mul_of_pos_left",
  "kind": "theorem",
  "first-tactic":
  "have : 0 < c * (b - a) := Int.mul_pos hâ‚‚ (Int.sub_pos_of_lt hâ‚)",
  "core-prompt": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : c * a < c * b",
  "args": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c)"},
 {"type": "a * c < b * c",
  "tactic-prompt":
  "theorem {a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : a * c < b * c := by have : 0 < b - a := Int.sub_pos_of_lt hâ‚; sorry",
  "name": "mul_lt_mul_of_pos_right",
  "kind": "theorem",
  "first-tactic": "have : 0 < b - a := Int.sub_pos_of_lt hâ‚",
  "core-prompt": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c) : a * c < b * c",
  "args": "{a b c : Int}    (hâ‚ : a < b)  (hâ‚‚ : 0 < c)"},
 {"type": "c * a â‰¤ c * b",
  "tactic-prompt":
  "theorem {a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : c * a â‰¤ c * b := by if hba : b â‰¤ a then rw [Int.le_antisymm hba hâ‚]; apply Int.le_refl else\n  if hc0 : c â‰¤ 0 then simp [Int.le_antisymm hc0 hâ‚‚]; sorry",
  "name": "mul_le_mul_of_nonneg_left",
  "kind": "theorem",
  "first-tactic":
  "if hba : b â‰¤ a then rw [Int.le_antisymm hba hâ‚]; apply Int.le_refl else\n  if hc0 : c â‰¤ 0 then simp [Int.le_antisymm hc0 hâ‚‚]",
  "core-prompt":
  "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : c * a â‰¤ c * b",
  "args": "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c)"},
 {"type": "a * c â‰¤ b * c",
  "tactic-prompt":
  "theorem {a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : a * c â‰¤ b * c := by rw [Int.mul_comm]; sorry",
  "name": "mul_le_mul_of_nonneg_right",
  "kind": "theorem",
  "first-tactic": "rw [Int.mul_comm]",
  "core-prompt":
  "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c) : a * c â‰¤ b * c",
  "args": "{a b c : Int}      (hâ‚ : a â‰¤ b)  (hâ‚‚ : 0 â‰¤ c)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0 := by have h : a * b â‰¤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha; sorry",
  "name": "mul_nonpos_of_nonneg_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b â‰¤ a * 0 := Int.mul_le_mul_of_nonneg_left hb ha",
  "core-prompt": "{a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0) : a * b â‰¤ 0",
  "args": "{a b : Int}    (ha : 0 â‰¤ a)  (hb : b â‰¤ 0)"},
 {"type": "a * b â‰¤ 0",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0 := by have h : a * b â‰¤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb; sorry",
  "name": "mul_nonpos_of_nonpos_of_nonneg",
  "kind": "theorem",
  "first-tactic":
  "have h : a * b â‰¤ 0 * b := Int.mul_le_mul_of_nonneg_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b) : a * b â‰¤ 0",
  "args": "{a b : Int}    (ha : a â‰¤ 0)  (hb : 0 â‰¤ b)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0 := by have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha; sorry",
  "name": "mul_neg_of_pos_of_neg",
  "kind": "theorem",
  "first-tactic": "have h : a * b < a * 0 := Int.mul_lt_mul_of_pos_left hb ha",
  "core-prompt": "{a b : Int}  (ha : 0 < a)  (hb : b < 0) : a * b < 0",
  "args": "{a b : Int}  (ha : 0 < a)  (hb : b < 0)"},
 {"type": "a * b < 0",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0 := by have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb; sorry",
  "name": "mul_neg_of_neg_of_pos",
  "kind": "theorem",
  "first-tactic": "have h : a * b < 0 * b := Int.mul_lt_mul_of_pos_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : 0 < b) : a * b < 0",
  "args": "{a b : Int}  (ha : a < 0)  (hb : 0 < b)"},
 {"type": "0 â‰¤ a * b",
  "tactic-prompt":
  "theorem {a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b := by have : 0 * b â‰¤ a * b := Int.mul_le_mul_of_nonpos_right ha hb; sorry",
  "name": "mul_nonneg_of_nonpos_of_nonpos",
  "kind": "theorem",
  "first-tactic":
  "have : 0 * b â‰¤ a * b := Int.mul_le_mul_of_nonpos_right ha hb",
  "core-prompt": "{a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0) : 0 â‰¤ a * b",
  "args": "{a b : Int}    (ha : a â‰¤ 0)  (hb : b â‰¤ 0)"},
 {"type": "0 < a * b",
  "tactic-prompt":
  "theorem {a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b := by have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb; sorry",
  "name": "mul_pos_of_neg_of_neg",
  "kind": "theorem",
  "first-tactic": "have : 0 * b < a * b := Int.mul_lt_mul_of_neg_right ha hb",
  "core-prompt": "{a b : Int}  (ha : a < 0)  (hb : b < 0) : 0 < a * b",
  "args": "{a b : Int}  (ha : a < 0)  (hb : b < 0)"},
 {"type": "(natAbs a : Int) = -a",
  "tactic-prompt":
  "theorem {a : Int}  (H : a â‰¤ 0) : (natAbs a : Int) = -a := by rw [â† natAbs_neg]; sorry",
  "name": "ofNat_natAbs_of_nonpos",
  "kind": "theorem",
  "first-tactic": "rw [â† natAbs_neg]",
  "core-prompt": "{a : Int}  (H : a â‰¤ 0) : (natAbs a : Int) = -a",
  "args": "{a : Int}  (H : a â‰¤ 0)"},
 {"type": "a * b = 0 â†” a = 0 âˆ¨ b = 0",
  "tactic-prompt":
  "theorem {a b : Int} : a * b = 0 â†” a = 0 âˆ¨ b = 0 := by refine âŸ¨fun h => ?_, fun h => h.elim (by simp [Â·, Int.zero_mul]) (by simp [Â·, Int.mul_zero])âŸ©; sorry",
  "name": "mul_eq_zero",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun h => ?_, fun h => h.elim (by simp [Â·, Int.zero_mul]) (by simp [Â·, Int.mul_zero])âŸ©",
  "core-prompt": "{a b : Int} : a * b = 0 â†” a = 0 âˆ¨ b = 0",
  "args": "{a b : Int}"},
 {"type": "natAbs a = n â†” (a - n) * (a + n) = 0",
  "tactic-prompt":
  "theorem  : natAbs a = n â†” (a - n) * (a + n) = 0 := by rw [natAbs_eq_iff]; sorry",
  "name": "eq_natAbs_iff_mul_eq_zero",
  "kind": "theorem",
  "first-tactic": "rw [natAbs_eq_iff]",
  "core-prompt": " : natAbs a = n â†” (a - n) * (a + n) = 0",
  "args": ""},
 {"type": "as.toArray.size = as.length",
  "tactic-prompt":
  "theorem (as : List Î±) : as.toArray.size = as.length := by simp [size]; sorry",
  "name": "size_toArray",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(as : List Î±) : as.toArray.size = as.length",
  "args": "(as : List Î±)"},
 {"type": "a[i] = a.data.get âŸ¨i, hâŸ©",
  "tactic-prompt":
  "theorem (a : Array Î±)  (h : i < a.size) : a[i] = a.data.get âŸ¨i, hâŸ© := by by_cases i < a.size; sorry",
  "name": "getElem_eq_data_get",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array Î±)  (h : i < a.size) : a[i] = a.data.get âŸ¨i, hâŸ©",
  "args": "(a : Array Î±)  (h : i < a.size)"},
 {"type": "arr.foldlM f init = arr.data.foldlM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldlM f init = arr.data.foldlM f init := by simp [foldlM]; sorry",
  "name": "foldlM_eq_foldlM_data",
  "kind": "theorem",
  "first-tactic": "simp [foldlM]",
  "core-prompt":
  "[Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldlM f init = arr.data.foldlM f init",
  "args": "[Monad m]      (f : Î² â†’ Î± â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init := by have : arr = #[] âˆ¨ 0 < arr.size :=\n    match arr with | âŸ¨[]âŸ© => .inl rfl | âŸ¨a::lâŸ© => .inr (Nat.zero_lt_succ _); sorry",
  "name": "foldrM_eq_reverse_foldlM_data",
  "kind": "theorem",
  "first-tactic":
  "have : arr = #[] âˆ¨ 0 < arr.size :=\n    match arr with | âŸ¨[]âŸ© => .inl rfl | âŸ¨a::lâŸ© => .inr (Nat.zero_lt_succ _)",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "arr.foldrM f init = arr.data.foldrM f init",
  "tactic-prompt":
  "theorem [Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.foldrM f init := by rw [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_eq_foldrM_data",
  "kind": "theorem",
  "first-tactic": "rw [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±) : arr.foldrM f init = arr.data.foldrM f init",
  "args": "[Monad m]      (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)"},
 {"type": "(arr.push a).data = arr.data ++ [a]",
  "tactic-prompt":
  "theorem (arr : Array Î±)  (a : Î±) : (arr.push a).data = arr.data ++ [a] := by simp [push]; sorry",
  "name": "push_data",
  "kind": "theorem",
  "first-tactic": "simp [push]",
  "core-prompt":
  "(arr : Array Î±)  (a : Î±) : (arr.push a).data = arr.data ++ [a]",
  "args": "(arr : Array Î±)  (a : Î±)"},
 {"type": "(arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f := by simp [foldrM_eq_reverse_foldlM_data]; sorry",
  "name": "foldrM_push",
  "kind": "theorem",
  "first-tactic": "simp [foldrM_eq_reverse_foldlM_data]",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±)"},
 {"type":
  "(arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "tactic-prompt":
  "theorem [Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f := by simp [â† foldrM_push]; sorry",
  "name": "foldrM_push'",
  "kind": "theorem",
  "first-tactic": "simp [â† foldrM_push]",
  "core-prompt":
  "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±) : (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f",
  "args": "[Monad m]  (f : Î± â†’ Î² â†’ m Î²)  (init : Î²)  (arr : Array Î±)  (a : Î±)"},
 {"type": "arr.toList = arr.data",
  "tactic-prompt":
  "theorem (arr : Array Î±) : arr.toList = arr.data := by simp [toList]; sorry",
  "name": "toList_eq",
  "kind": "theorem",
  "first-tactic": "simp [toList]",
  "core-prompt": "(arr : Array Î±) : arr.toList = arr.data",
  "args": "(arr : Array Î±)"},
 {"type": "arr.toListRev = arr.data.reverse",
  "tactic-prompt":
  "theorem (arr : Array Î±) : arr.toListRev = arr.data.reverse := by rw [toListRev]; sorry",
  "name": "toListRev_eq",
  "kind": "theorem",
  "first-tactic": "rw [toListRev]",
  "core-prompt": "(arr : Array Î±) : arr.toListRev = arr.data.reverse",
  "args": "(arr : Array Î±)"},
 {"type": "SatisfiesM (motive as.size) (as.foldlM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init) := by let rec go {i j b} (hâ‚ : j â‰¤ as.size) (hâ‚‚ : as.size â‰¤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    Â· next hj =>\n      split\n      Â· cases Nat.not_le_of_gt (by simp [hj]) hâ‚‚\n      Â· exact (hf âŸ¨j]; sorry",
  "name": "SatisfiesM_foldlM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i j b} (hâ‚ : j â‰¤ as.size) (hâ‚‚ : as.size â‰¤ i + j) (H : motive j b) :\n    SatisfiesM (motive as.size) (foldlM.loop f as as.size (Nat.le_refl _) i j b) := by\n    unfold foldlM.loop; split\n    Â· next hj =>\n      split\n      Â· cases Nat.not_le_of_gt (by simp [hj]) hâ‚‚\n      Â· exact (hf âŸ¨j]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i])) : SatisfiesM (motive as.size) (as.foldlM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ SatisfiesM (motive (i.1 + 1)) (f b as[i]))"},
 {"type": "motive as.size (as.foldl f init)",
  "tactic-prompt":
  "theorem {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init) := by have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldl_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldlM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i])) : motive as.size (as.foldl f init)",
  "args":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive 0 init)  {f : Î² â†’ Î± â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive i.1 b â†’ motive (i.1 + 1) (f b as[i]))"},
 {"type":
  "haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i] := by simp only [push]; sorry",
  "name": "get_push_lt",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size] = x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±) : (a.push x)[a.size] = x := by simp only [push]; sorry",
  "name": "get_push_eq",
  "kind": "theorem",
  "first-tactic": "simp only [push]",
  "core-prompt": "(a : Array Î±)  (x : Î±) : (a.push x)[a.size] = x",
  "args": "(a : Array Î±)  (x : Î±)"},
 {"type": "(a.push x)[i] = if h : i < a.size then a[i] else x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x := by if h' : i < a.size then\n    simp [get_push_lt]; sorry",
  "name": "get_push",
  "kind": "theorem",
  "first-tactic": "if h' : i < a.size then\n    simp [get_push_lt]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size) : (a.push x)[i] = if h : i < a.size then a[i] else x",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < (a.push x).size)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as) := by unfold mapM; sorry",
  "name": "SatisfiesM_mapM",
  "kind": "theorem",
  "first-tactic": "unfold mapM",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapM f as)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f as[i]))"},
 {"type": "(arr.map f).data = arr.data.map f",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).data = arr.data.map f := by apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans; sorry",
  "name": "map_data",
  "kind": "theorem",
  "first-tactic":
  "apply congrArg data (foldl_eq_foldl_data (fun bs a => push bs (f a)) #[] arr) |>.trans",
  "core-prompt":
  "(f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).data = arr.data.map f",
  "args": "(f : Î± â†’ Î²)  (arr : Array Î±)"},
 {"type": "(arr.map f).size = arr.size",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).size = arr.size := by simp [size]; sorry",
  "name": "size_map",
  "kind": "theorem",
  "first-tactic": "simp [size]",
  "core-prompt": "(f : Î± â†’ Î²)  (arr : Array Î±) : (arr.map f).size = arr.size",
  "args": "(f : Î± â†’ Î²)  (arr : Array Î±)"},
 {"type": "(arr ++ arr').data = arr.data ++ arr'.data",
  "tactic-prompt":
  "theorem (arr arr' : Array Î±) : (arr ++ arr').data = arr.data ++ arr'.data := by rw [â† append_eq_append]; sorry",
  "name": "append_data",
  "kind": "theorem",
  "first-tactic": "rw [â† append_eq_append]",
  "core-prompt":
  "(arr arr' : Array Î±) : (arr ++ arr').data = arr.data ++ arr'.data",
  "args": "(arr arr' : Array Î±)"},
 {"type": "(arr ++ l).data = arr.data ++ l",
  "tactic-prompt":
  "theorem (arr : Array Î±)  (l : List Î±) : (arr ++ l).data = arr.data ++ l := by rw [â† appendList_eq_append]; sorry",
  "name": "appendList_data",
  "kind": "theorem",
  "first-tactic": "rw [â† appendList_eq_append]",
  "core-prompt":
  "(arr : Array Î±)  (l : List Î±) : (arr ++ l).data = arr.data ++ l",
  "args": "(arr : Array Î±)  (l : List Î±)"},
 {"type": "(l.foldl F acc).data = acc.data ++ l.bind G",
  "tactic-prompt":
  "theorem (l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_bind",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a) : (l.foldl F acc).data = acc.data ++ l.bind G",
  "args":
  "(l : List Î±)  (acc : Array Î²)      (F : Array Î² â†’ Î± â†’ Array Î²)  (G : Î± â†’ List Î²)      (H : âˆ€ acc a, (F acc a).data = acc.data ++ G a)"},
 {"type":
  "(l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "tactic-prompt":
  "theorem (l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G := by induction l generalizing acc; sorry",
  "name": "foldl_data_eq_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing acc",
  "core-prompt":
  "(l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²) : (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G",
  "args": "(l : List Î±)  (acc : Array Î²)  (G : Î± â†’ Î²)"},
 {"type": "a[i]? = none",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i) : a[i]? = none := by simp [getElem?_neg]; sorry",
  "name": "get?_len_le",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_neg]",
  "core-prompt": "(a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i) : a[i]? = none",
  "args": "(a : Array Î±)  (i : Nat)  (h : a.size â‰¤ i)"},
 {"type": "a[i] âˆˆ a.data",
  "tactic-prompt":
  "theorem (a : Array Î±)  (h : i < a.size) : a[i] âˆˆ a.data := by simp [getElem_eq_data_get]; sorry",
  "name": "getElem_mem_data",
  "kind": "theorem",
  "first-tactic": "simp [getElem_eq_data_get]",
  "core-prompt": "(a : Array Î±)  (h : i < a.size) : a[i] âˆˆ a.data",
  "args": "(a : Array Î±)  (h : i < a.size)"},
 {"type": "a[i]? = a.data.get? i",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat) : a[i]? = a.data.get? i := by by_cases i < a.size; sorry",
  "name": "getElem?_eq_data_get?",
  "kind": "theorem",
  "first-tactic": "by_cases i < a.size",
  "core-prompt": "(a : Array Î±)  (i : Nat) : a[i]? = a.data.get? i",
  "args": "(a : Array Î±)  (i : Nat)"},
 {"type": "a.get! n = (a.get? n).getD default",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : a.get! n = (a.get? n).getD default := by simp [get!_eq_getD]; sorry",
  "name": "get!_eq_get?",
  "kind": "theorem",
  "first-tactic": "simp [get!_eq_getD]",
  "core-prompt":
  "[Inhabited Î±]  (a : Array Î±) : a.get! n = (a.get? n).getD default",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "a.back = a.back?.getD default",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : a.back = a.back?.getD default := by simp [back]; sorry",
  "name": "back_eq_back?",
  "kind": "theorem",
  "first-tactic": "simp [back]",
  "core-prompt": "[Inhabited Î±]  (a : Array Î±) : a.back = a.back?.getD default",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "(a.push x).back? = some x",
  "tactic-prompt":
  "theorem (a : Array Î±) : (a.push x).back? = some x := by simp [back?]; sorry",
  "name": "back?_push",
  "kind": "theorem",
  "first-tactic": "simp [back?]",
  "core-prompt": "(a : Array Î±) : (a.push x).back? = some x",
  "args": "(a : Array Î±)"},
 {"type": "(a.push x).back = x",
  "tactic-prompt":
  "theorem [Inhabited Î±]  (a : Array Î±) : (a.push x).back = x := by simp; sorry",
  "name": "back_push",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[Inhabited Î±]  (a : Array Î±) : (a.push x).back = x",
  "args": "[Inhabited Î±]  (a : Array Î±)"},
 {"type": "(a.push x)[i]? = some a[i]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i] := by rw [getElem?_pos]; sorry",
  "name": "get?_push_lt",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt":
  "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size) : (a.push x)[i]? = some a[i]",
  "args": "(a : Array Î±)  (x : Î±)  (i : Nat)  (h : i < a.size)"},
 {"type": "(a.push x)[a.size]? = some x",
  "tactic-prompt":
  "theorem (a : Array Î±)  (x : Î±) : (a.push x)[a.size]? = some x := by rw [getElem?_pos]; sorry",
  "name": "get?_push_eq",
  "kind": "theorem",
  "first-tactic": "rw [getElem?_pos]",
  "core-prompt": "(a : Array Î±)  (x : Î±) : (a.push x)[a.size]? = some x",
  "args": "(a : Array Î±)  (x : Î±)"},
 {"type": "(a.set i v)[i.1]'(by simp [i.2]) = v",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]'(by simp [i.2]) = v := by simp only [set]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]'(by simp [i.2]) = v",
  "args": "(a : Array Î±)  (i : Fin a.size)  (v : Î±)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = a[j]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j) : (a.set i v)[j]'(by simp [*]) = a[j] := by simp only [set]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "simp only [set]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j) : (a.set i v)[j]'(by simp [*]) = a[j]",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)  (hj : j < a.size)      (h : i.1 â‰  j)"},
 {"type": "(a.set i v)[i.1]? = v",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]? = v := by simp [getElem?_pos]; sorry",
  "name": "get?_set_eq",
  "kind": "theorem",
  "first-tactic": "simp [getElem?_pos]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (v : Î±) : (a.set i v)[i.1]? = v",
  "args": "(a : Array Î±)  (i : Fin a.size)  (v : Î±)"},
 {"type": "(a.set i v)[j]? = a[j]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j) : (a.set i v)[j]? = a[j]? := by by_cases j < a.size; sorry",
  "name": "get?_set_ne",
  "kind": "theorem",
  "first-tactic": "by_cases j < a.size",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j) : (a.set i v)[j]? = a[j]?",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  {j : Nat}  (v : Î±)      (h : i.1 â‰  j)"},
 {"type": "(a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±) : (a.set i v)[j]? = if i.1 = j then some v else a[j]? := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get?_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±) : (a.set i v)[j]? = if i.1 = j then some v else a[j]?",
  "args": "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (v : Î±)"},
 {"type": "(a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j] := by if h : i.1 = j then subst j; simp [*] else simp [*]; sorry",
  "name": "get_set",
  "kind": "theorem",
  "first-tactic": "if h : i.1 = j then subst j; simp [*] else simp [*]",
  "core-prompt":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±) : (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]",
  "args":
  "(a : Array Î±)  (i : Fin a.size)  (j : Nat)  (hj : j < a.size)  (v : Î±)"},
 {"type": "e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ©",
  "tactic-prompt":
  "theorem (e : n = n')  (i : Fin n) : e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ© := by cases e; sorry",
  "name": "fin_cast_val",
  "kind": "theorem",
  "first-tactic": "cases e",
  "core-prompt": "(e : n = n')  (i : Fin n) : e â–¸ i = âŸ¨i.1, e â–¸ i.2âŸ©",
  "args": "(e : n = n')  (i : Fin n)"},
 {"type": "a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i) := by simp [swap]; sorry",
  "name": "swap_def",
  "kind": "theorem",
  "first-tactic": "simp [swap]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size) : a.swap i j = (a.set i (a.get j)).set âŸ¨j.1, by simp [j.2]âŸ© (a.get i)",
  "args": "(a : Array Î±)  (i j : Fin a.size)"},
 {"type": "(a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i) := by simp [swap_def]; sorry",
  "name": "data_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size) : (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)",
  "args": "(a : Array Î±)  (i j : Fin a.size)"},
 {"type":
  "(a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]? := by simp [swap_def]; sorry",
  "name": "get?_swap",
  "kind": "theorem",
  "first-tactic": "simp [swap_def]",
  "core-prompt":
  "(a : Array Î±)  (i j : Fin a.size)  (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?",
  "args": "(a : Array Î±)  (i j : Fin a.size)  (k : Nat)"},
 {"type": "a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v)",
  "tactic-prompt":
  "theorem (a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v) := by simp [swapAt!]; sorry",
  "name": "swapAt!_def",
  "kind": "theorem",
  "first-tactic": "simp [swapAt!]",
  "core-prompt":
  "(a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size) : a.swapAt! i v = (a[i], a.set âŸ¨i, hâŸ© v)",
  "args": "(a : Array Î±)  (i : Nat)  (v : Î±)  (h : i < a.size)"},
 {"type": "a.pop.data = a.data.dropLast",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.pop.data = a.data.dropLast := by simp [pop]; sorry",
  "name": "data_pop",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array Î±) : a.pop.data = a.data.dropLast",
  "args": "(a : Array Î±)"},
 {"type": "(a.push x).pop = a",
  "tactic-prompt":
  "theorem (a : Array Î±) : (a.push x).pop = a := by simp [pop]; sorry",
  "name": "pop_push",
  "kind": "theorem",
  "first-tactic": "simp [pop]",
  "core-prompt": "(a : Array Î±) : (a.push x).pop = a",
  "args": "(a : Array Î±)"},
 {"type": "SatisfiesM (motive 0) (as.foldrM f init)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init) := by let rec go {i b} (hi : i â‰¤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    Â· next hi => exact .pure (hi â–¸ H)\n    Â· next hi =>\n      split; {simp at hi}\n      Â· next i hi' =>\n        exact (hf âŸ¨i, hi'âŸ© b H).bind fun _ => go _; sorry",
  "name": "SatisfiesM_foldrM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {i b} (hi : i â‰¤ as.size) (H : motive i b) :\n    SatisfiesM (motive 0) (foldrM.fold f as 0 i hi b) := by\n    unfold foldrM.fold; simp; split\n    Â· next hi => exact .pure (hi â–¸ H)\n    Â· next hi =>\n      split; {simp at hi}\n      Â· next i hi' =>\n        exact (hf âŸ¨i, hi'âŸ© b H).bind fun _ => go _",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b)) : SatisfiesM (motive 0) (as.foldrM f init)",
  "args":
  "[Monad m]  [LawfulMonad m]      {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)      {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ m Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ SatisfiesM (motive i.1) (f as[i] b))"},
 {"type": "motive 0 (as.foldr f init)",
  "tactic-prompt":
  "theorem {as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b)) : motive 0 (as.foldr f init) := by have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "foldr_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_foldrM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b)) : motive 0 (as.foldr f init)",
  "args":
  "{as : Array Î±}  (motive : Nat â†’ Î² â†’ Prop)  {init : Î²}  (h0 : motive as.size init)  {f : Î± â†’ Î² â†’ Î²}      (hf : âˆ€ i : Fin as.size, âˆ€ b, motive (i.1 + 1) b â†’ motive i.1 (f as[i] b))"},
 {"type": "arr.mapM f = return mk (â† arr.data.mapM f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±) : arr.mapM f = return mk (â† arr.data.mapM f) := by rw [mapM]; sorry",
  "name": "mapM_eq_mapM_data",
  "kind": "theorem",
  "first-tactic": "rw [mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±) : arr.mapM f = return mk (â† arr.data.mapM f)",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (arr : Array Î±)"},
 {"type":
  "SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f)",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f) := by let rec go {bs i j h} (hâ‚ : j = bs.size) (hâ‚‚ : âˆ€ i h h', p âŸ¨i, hâŸ© bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure âŸ¨this â–¸ hm, hâ‚ â–¸ this, fun _ _ => hâ‚‚ ..âŸ©\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [hâ‚]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      Â· next h => exact hâ‚‚ _ _ h\n      Â· next h => cases hâ‚.symm â–¸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1; sorry",
  "name": "SatisfiesM_mapIdxM",
  "kind": "theorem",
  "first-tactic":
  "let rec go {bs i j h} (hâ‚ : j = bs.size) (hâ‚‚ : âˆ€ i h h', p âŸ¨i, hâŸ© bs[i]) (hm : motive j) :\n    SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM.map as f i j h bs) := by\n    induction i generalizing j bs with simp [mapIdxM.map]\n    | zero =>\n      have := (Nat.zero_add _).symm.trans h\n      exact .pure âŸ¨this â–¸ hm, hâ‚ â–¸ this, fun _ _ => hâ‚‚ ..âŸ©\n    | succ i ih =>\n      refine (hs _ (by exact hm)).bind fun b hb => ih (by simp [hâ‚]) (fun i hi hi' => ?_) hb.2\n      simp at hi'; simp [get_push]; split\n      Â· next h => exact hâ‚‚ _ _ h\n      Â· next h => cases hâ‚.symm â–¸ (Nat.le_or_eq_or_le_succ hi').resolve_left h; exact hb.1",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i])) : SatisfiesM\n      (fun arr => motive as.size âˆ§ âˆƒ eq : arr.size = as.size, âˆ€ i h, p âŸ¨i, hâŸ© (arr[i]'(eq â–¸ h)))\n      (Array.mapIdxM as f)",
  "args":
  "[Monad m]  [LawfulMonad m]  (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ m Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ SatisfiesM (p i Â· âˆ§ motive (i + 1)) (f i as[i]))"},
 {"type":
  "motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h))",
  "tactic-prompt":
  "theorem (as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1)) : motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h)) := by have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0; sorry",
  "name": "mapIdx_induction",
  "kind": "theorem",
  "first-tactic":
  "have := SatisfiesM_mapIdxM (m := Id) (as := as) (f := f) motive h0",
  "core-prompt":
  "(as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1)) : motive as.size âˆ§ âˆƒ eq : (Array.mapIdx as f).size = as.size,\n      âˆ€ i h, p âŸ¨i, hâŸ© ((Array.mapIdx as f)[i]'(eq â–¸ h))",
  "args":
  "(as : Array Î±)  (f : Fin as.size â†’ Î± â†’ Î²)      (motive : Nat â†’ Prop)  (h0 : motive 0)      (p : Fin as.size â†’ Î² â†’ Prop)      (hs : âˆ€ i, motive i.1 â†’ p i (f i as[i]) âˆ§ motive (i + 1))"},
 {"type": "a.reverse.size = a.size",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.reverse.size = a.size := by let rec go (as : Array Î±) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go Â· (i+1) âŸ¨j-1]; sorry",
  "name": "size_reverse",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array Î±) (i j) : (reverse.loop as i j).size = as.size := by\n    rw [reverse.loop]\n    if h : i < j then\n      have := reverse.termination h\n      simp [(go Â· (i+1) âŸ¨j-1]",
  "core-prompt": "(a : Array Î±) : a.reverse.size = a.size",
  "args": "(a : Array Î±)"},
 {"type": "a.reverse.data = a.data.reverse",
  "tactic-prompt":
  "theorem (a : Array Î±) : a.reverse.data = a.data.reverse := by let rec go (as : Array Î±) (i j hj)\n      (h : i + j + 1 = a.size) (hâ‚‚ : as.size = a.size)\n      (H : âˆ€ k, as.data.get? k = if i â‰¤ k âˆ§ k â‰¤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i âŸ¨j, hjâŸ©).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split; sorry",
  "name": "reverse_data",
  "kind": "theorem",
  "first-tactic":
  "let rec go (as : Array Î±) (i j hj)\n      (h : i + j + 1 = a.size) (hâ‚‚ : as.size = a.size)\n      (H : âˆ€ k, as.data.get? k = if i â‰¤ k âˆ§ k â‰¤ j then a.data.get? k else a.data.reverse.get? k)\n      (k) : (reverse.loop as i âŸ¨j, hjâŸ©).data.get? k = a.data.reverse.get? k := by\n    rw [reverse.loop]; dsimp; split",
  "core-prompt": "(a : Array Î±) : a.reverse.data = a.data.reverse",
  "args": "(a : Array Î±)"},
 {"type": "(ofFn f).size = n",
  "tactic-prompt":
  "theorem (f : Fin n â†’ Î±) : (ofFn f).size = n := by simp [ofFn]; sorry",
  "name": "size_ofFn",
  "kind": "theorem",
  "first-tactic": "simp [ofFn]",
  "core-prompt": "(f : Fin n â†’ Î±) : (ofFn f).size = n",
  "args": "(f : Fin n â†’ Î±)"},
 {"type": "isEmpty l = l.toList.isEmpty",
  "tactic-prompt":
  "theorem (l : AssocList Î± Î²) : isEmpty l = l.toList.isEmpty := by cases l; sorry",
  "name": "isEmpty_eq",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : AssocList Î± Î²) : isEmpty l = l.toList.isEmpty",
  "args": "(l : AssocList Î± Î²)"},
 {"type": "@toList = @toListTR",
  "tactic-prompt": "theorem  : @toList = @toListTR := by funext Î± Î² as; sorry",
  "name": "toList_eq_toListTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² as",
  "core-prompt": " : @toList = @toListTR",
  "args": ""},
 {"type": "(mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î´)  (l : AssocList Î± Î²) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b)) := by induction l; sorry",
  "name": "mapKey_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î´)  (l : AssocList Î± Î²) : (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))",
  "args": "(f : Î± â†’ Î´)  (l : AssocList Î± Î²)"},
 {"type": "(mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b)) := by induction l; sorry",
  "name": "mapVal_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²) : (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))",
  "args": "(f : Î± â†’ Î² â†’ Î´)  (l : AssocList Î± Î²)"},
 {"type": "findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : findEntryP? p l = l.toList.find? fun (a, b) => p a b := by induction l; sorry",
  "name": "findEntryP?_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : findEntryP? p l = l.toList.find? fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "find? a l = (l.findEntry? a).map (Â·.2)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.findEntry? a).map (Â·.2) := by induction l; sorry",
  "name": "find?_eq_findEntry?",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.findEntry? a).map (Â·.2)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type": "find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2) := by simp [find?_eq_findEntry?]; sorry",
  "name": "find?_eq",
  "kind": "theorem",
  "first-tactic": "simp [find?_eq_findEntry?]",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : find? a l = (l.toList.find? (Â·.1 == a)).map (Â·.2)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type": "any p l = l.toList.any fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : any p l = l.toList.any fun (a, b) => p a b := by induction l; sorry",
  "name": "any_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : any p l = l.toList.any fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "all p l = l.toList.all fun (a, b) => p a b",
  "tactic-prompt":
  "theorem (p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : all p l = l.toList.all fun (a, b) => p a b := by induction l; sorry",
  "name": "all_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²) : all p l = l.toList.all fun (a, b) => p a b",
  "args": "(p : Î± â†’ Î² â†’ Bool)  (l : AssocList Î± Î²)"},
 {"type": "contains a l = l.toList.any (Â·.1 == a)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : contains a l = l.toList.any (Â·.1 == a) := by induction l; sorry",
  "name": "contains_eq",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²) : contains a l = l.toList.any (Â·.1 == a)",
  "args": "[BEq Î±]  (a : Î±)  (l : AssocList Î± Î²)"},
 {"type":
  "(replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none)",
  "tactic-prompt":
  "theorem [BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²) : (replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none) := by induction l; sorry",
  "name": "replace_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "[BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²) : (replace a b l).toList =\n    l.toList.replaceF (bif Â·.1 == a then (a, b) else none)",
  "args": "[BEq Î±]  (a : Î±)  (b : Î²)  (l : AssocList Î± Î²)"},
 {"type": "forIn l init f = forIn l.toList init f",
  "tactic-prompt":
  "theorem [Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´)) : forIn l init f = forIn l.toList init f := by simp [forIn]; sorry",
  "name": "forIn_eq",
  "kind": "theorem",
  "first-tactic": "simp [forIn]",
  "core-prompt":
  "[Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´)) : forIn l init f = forIn l.toList init f",
  "args":
  "[Monad m]  (l : AssocList Î± Î²)  (init : Î´)      (f : (Î± Ã— Î²) â†’ Î´ â†’ m (ForInStep Î´))"},
 {"type": "l.toAssocList.toList = l",
  "tactic-prompt":
  "theorem (l : List (Î± Ã— Î²)) : l.toAssocList.toList = l := by induction l; sorry",
  "name": "_root_.List.toAssocList_toList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List (Î± Ã— Î²)) : l.toAssocList.toList = l",
  "args": "(l : List (Î± Ã— Î²))"},
 {"type": "l.toList.toAssocList = l",
  "tactic-prompt":
  "theorem (l : AssocList Î± Î²) : l.toList.toAssocList = l := by induction l; sorry",
  "name": "toList_toAssocList",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : AssocList Î± Î²) : l.toList.toAssocList = l",
  "args": "(l : AssocList Î± Î²)"},
 {"type": "t.modify cut f = t.alter cut (.map f)",
  "tactic-prompt":
  "theorem (t : RBNode Î±) : t.modify cut f = t.alter cut (.map f) := by simp [modify]; sorry",
  "name": "modify_eq_alter",
  "kind": "theorem",
  "first-tactic": "simp [modify]",
  "core-prompt": "(t : RBNode Î±) : t.modify cut f = t.alter cut (.map f)",
  "args": "(t : RBNode Î±)"},
 {"type": "(balance1 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp := by unfold balance1; sorry",
  "name": "Ordered.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p := by unfold balance1; sorry",
  "name": "balance1_All",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance1 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}"},
 {"type": "(balance2 l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp := by unfold balance2; sorry",
  "name": "Ordered.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p := by unfold balance2; sorry",
  "name": "balance2_All",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±} : (balance2 l v r).All p â†” p v âˆ§ l.All p âˆ§ r.All p",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}"},
 {"type": "(setBlack t).Ordered cmp â†” t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (setBlack t).Ordered cmp â†” t.Ordered cmp := by unfold setBlack; sorry",
  "name": "Ordered.setBlack",
  "kind": "theorem",
  "first-tactic": "unfold setBlack",
  "core-prompt": "{t : RBNode Î±} : (setBlack t).Ordered cmp â†” t.Ordered cmp",
  "args": "{t : RBNode Î±}"},
 {"type": "t.setBlack.setBlack = t.setBlack",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.setBlack.setBlack = t.setBlack := by cases t; sorry",
  "name": "setBlack_idem",
  "kind": "theorem",
  "first-tactic": "cases t",
  "core-prompt": "{t : RBNode Î±} : t.setBlack.setBlack = t.setBlack",
  "args": "{t : RBNode Î±}"},
 {"type": "(t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack := by unfold insert; sorry",
  "name": "insert_setBlack",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode Î±} : (t.insert cmp v).setBlack = (t.ins cmp v).setBlack",
  "args": "{t : RBNode Î±}"},
 {"type": "(ins cmp x t).All p",
  "tactic-prompt":
  "theorem {x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p) : (ins cmp x t).All p := by induction t; sorry",
  "name": "All.ins",
  "kind": "theorem",
  "first-tactic": "induction t",
  "core-prompt":
  "{x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p) : (ins cmp x t).All p",
  "args": "{x : Î±}  {t : RBNode Î±}    (hâ‚ : p x)  (hâ‚‚ : t.All p)"},
 {"type": "(insert cmp t v).Ordered cmp",
  "tactic-prompt":
  "theorem (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp := by unfold RBNode.insert; sorry",
  "name": "Ordered.insert",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.insert",
  "core-prompt": "(h : t.Ordered cmp) : (insert cmp t v).Ordered cmp",
  "args": "(h : t.Ordered cmp)"},
 {"type": "âˆƒ c, (balance1 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : âˆƒ c, (balance1 l v r).Balanced c (n + 1) := by unfold balance1; sorry",
  "name": "RedRed.balance1",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n) : âˆƒ c, (balance1 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.RedRed p n)  (hr : r.Balanced c n)"},
 {"type": "âˆƒ c, (balance2 l v r).Balanced c (n + 1)",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : âˆƒ c, (balance2 l v r).Balanced c (n + 1) := by unfold balance2; sorry",
  "name": "RedRed.balance2",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n) : âˆƒ c, (balance2 l v r).Balanced c (n + 1)",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)  (hr : r.RedRed p n)"},
 {"type": "balance1 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n) : balance1 l v r = node black l v r := by unfold balance1; sorry",
  "name": "balance1_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance1",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n) : balance1 l v r = node black l v r",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hl : l.Balanced c n)"},
 {"type": "balance2 l v r = node black l v r",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n) : balance2 l v r = node black l v r := by unfold balance2; sorry",
  "name": "balance2_eq",
  "kind": "theorem",
  "first-tactic": "unfold balance2",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n) : balance2 l v r = node black l v r",
  "args": "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (hr : r.Balanced c n)"},
 {"type": "âˆƒ c' n', (insert cmp t v).Balanced c' n'",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.Balanced c n) : âˆƒ c' n', (insert cmp t v).Balanced c' n' := by unfold insert; sorry",
  "name": "Balanced.insert",
  "kind": "theorem",
  "first-tactic": "unfold insert",
  "core-prompt":
  "{t : RBNode Î±}  (h : t.Balanced c n) : âˆƒ c' n', (insert cmp t v).Balanced c' n'",
  "args": "{t : RBNode Î±}  (h : t.Balanced c n)"},
 {"type": "(setRed t).All p",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.All p) : (setRed t).All p := by unfold setRed; sorry",
  "name": "All.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode Î±}  (h : t.All p) : (setRed t).All p",
  "args": "{t : RBNode Î±}  (h : t.All p)"},
 {"type": "(setRed t).Ordered cmp â†” t.Ordered cmp",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : (setRed t).Ordered cmp â†” t.Ordered cmp := by unfold setRed; sorry",
  "name": "Ordered.setRed",
  "kind": "theorem",
  "first-tactic": "unfold setRed",
  "core-prompt": "{t : RBNode Î±} : (setRed t).Ordered cmp â†” t.Ordered cmp",
  "args": "{t : RBNode Î±}"},
 {"type": "(balLeft l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p := by unfold balLeft; sorry",
  "name": "All.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balLeft l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balLeft l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp := by unfold balLeft; sorry",
  "name": "Ordered.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balLeft l v r).RedRed (cr = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1) := by unfold balLeft; sorry",
  "name": "Balanced.balLeft",
  "kind": "theorem",
  "first-tactic": "unfold balLeft",
  "core-prompt":
  "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1)) : (balLeft l v r).RedRed (cr = red) (n + 1)",
  "args": "(hl : l.RedRed True n)  (hr : r.Balanced cr (n + 1))"},
 {"type": "(balRight l v r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p := by unfold balRight; sorry",
  "name": "All.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.All p)  (hv : p v)  (hr : r.All p) : (balRight l v r).All p",
  "args": "(hl : l.All p)  (hv : p v)  (hr : r.All p)"},
 {"type": "(balRight l v r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp := by unfold balRight; sorry",
  "name": "Ordered.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(balRight l v r).RedRed (cl = red) (n + 1)",
  "tactic-prompt":
  "theorem (hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1) := by unfold balRight; sorry",
  "name": "Balanced.balRight",
  "kind": "theorem",
  "first-tactic": "unfold balRight",
  "core-prompt":
  "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n) : (balRight l v r).RedRed (cl = red) (n + 1)",
  "args": "(hl : l.Balanced cl (n + 1))  (hr : r.RedRed True n)"},
 {"type": "(append l r).All p",
  "tactic-prompt":
  "theorem (hl : l.All p)  (hr : r.All p) : (append l r).All p := by unfold append; sorry",
  "name": "All.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt": "(hl : l.All p)  (hr : r.All p) : (append l r).All p",
  "args": "(hl : l.All p)  (hr : r.All p)"},
 {"type": "(append l r).Ordered cmp",
  "tactic-prompt":
  "theorem {l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp := by unfold append; sorry",
  "name": "Ordered.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp) : (append l r).Ordered cmp",
  "args":
  "{l : RBNode Î±}  {v : Î±}  {r : RBNode Î±}      (lv : l.All (cmpLt cmp Â· v))  (vr : r.All (cmpLt cmp v Â·))      (hl : l.Ordered cmp)  (hr : r.Ordered cmp)"},
 {"type": "(l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n",
  "tactic-prompt":
  "theorem {l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n) : (l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n := by unfold append; sorry",
  "name": "Balanced.append",
  "kind": "theorem",
  "first-tactic": "unfold append",
  "core-prompt":
  "{l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n) : (l.append r).RedRed (câ‚ = black â†’ câ‚‚ â‰  black) n",
  "args":
  "{l r : RBNode Î±}      (hl : l.Balanced câ‚ n)  (hr : r.Balanced câ‚‚ n)"},
 {"type": "âˆƒ n', RedRed (c = black) t n'",
  "tactic-prompt":
  "theorem (h : DelProp c t n) : âˆƒ n', RedRed (c = black) t n' := by unfold DelProp at h; sorry",
  "name": "DelProp.redred",
  "kind": "theorem",
  "first-tactic": "unfold DelProp at h",
  "core-prompt": "(h : DelProp c t n) : âˆƒ n', RedRed (c = black) t n'",
  "args": "(h : DelProp c t n)"},
 {"type": "(t.del cut).DelProp t.isBlack n",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n := by induction h; sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "{t : RBNode Î±}  (h : t.Balanced c n) : (t.del cut).DelProp t.isBlack n",
  "args": "{t : RBNode Î±}  (h : t.Balanced c n)"},
 {"type": "fill' (zoom cut t path) = path.fill t",
  "tactic-prompt":
  "theorem (cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±) : fill' (zoom cut t path) = path.fill t := by induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; {apply iha}; {apply ihb}; {rfl}; sorry",
  "name": "zoom_fill'",
  "kind": "theorem",
  "first-tactic":
  "induction t generalizing path with\n  | nil => rfl\n  | node _ _ _ _ iha ihb => unfold zoom; split; {apply iha}; {apply ihb}; {rfl}",
  "core-prompt":
  "(cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±) : fill' (zoom cut t path) = path.fill t",
  "args": "(cut : Î± â†’ Ordering)  (t : RBNode Î±)  (path : Path Î±)"},
 {"type":
  "t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "tactic-prompt":
  "theorem {t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering} : t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v) := by unfold RBNode.ins; sorry",
  "name": "zoom_ins",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.ins",
  "core-prompt":
  "{t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering} : t.zoom (cmp v) path = (t', path') â†’\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)",
  "args": "{t : RBNode Î±}  {cmp : Î± â†’ Î± â†’ Ordering}"},
 {"type":
  "t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "tactic-prompt":
  "theorem {t : RBNode Î±} : t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red) := by unfold RBNode.del; sorry",
  "name": "zoom_del",
  "kind": "theorem",
  "first-tactic": "unfold RBNode.del",
  "core-prompt":
  "{t : RBNode Î±} : t.zoom cut path = (t', path') â†’\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)",
  "args": "{t : RBNode Î±}"},
 {"type": "âˆƒ n, (path.ins t).Balanced black n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n) : âˆƒ n, (path.ins t).Balanced black n := by induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have âŸ¨c, hâŸ© := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have âŸ¨c, hâŸ© := ht.balance2 hl; ih (.balanced h); sorry",
  "name": "Balanced.ins",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t with\n  | root => exact ht.setBlack\n  | redL hr hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red .nil hr))\n    | .balanced (.red ha hb) => exact ih (.redred rfl (.red ha hb) hr)\n    | .balanced (.black ha hb) => exact ih (.balanced (.red (.black ha hb) hr))\n  | redR hl hp ih => match ht with\n    | .balanced .nil => exact ih (.balanced (.red hl .nil))\n    | .balanced (.red ha hb) => exact ih (.redred rfl hl (.red ha hb))\n    | .balanced (.black ha hb) => exact ih (.balanced (.red hl (.black ha hb)))\n  | blackL hr hp ih => exact have âŸ¨c, hâŸ© := ht.balance1 hr; ih (.balanced h)\n  | blackR hl hp ih => exact have âŸ¨c, hâŸ© := ht.balance2 hl; ih (.balanced h)",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n) : âˆƒ n, (path.ins t).Balanced black n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.RedRed (c = red) n)"},
 {"type": "(path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack := by have âŸ¨_, _, ht', hp'âŸ© := ht.zoom .root H; sorry",
  "name": "zoom_insert",
  "kind": "theorem",
  "first-tactic": "have âŸ¨_, _, ht', hp'âŸ© := ht.zoom .root H",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path)) : (path.insert t' v).setBlack = (t.insert cmp v).setBlack",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}  {t : RBNode Î±}  (ht : t.Balanced c n)      (H : zoom (cmp v) t = (t', path))"},
 {"type": "âˆƒ n, (path.del t c').Balanced black n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red) : âˆƒ n, (path.del t c').Balanced black n := by induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, âŸ¨_, hâŸ© | black, âŸ¨_, _, hâŸ© => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, âŸ¨_, haâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih âŸ¨_, rfl, (hb.balLeft ha).imp fun _ => âŸ¨âŸ©âŸ© (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, âŸ¨_, hbâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih âŸ¨_, rfl, (ha.balRight hb).imp fun _ => âŸ¨âŸ©âŸ© (fun.); sorry",
  "name": "Balanced.del",
  "kind": "theorem",
  "first-tactic":
  "induction hp generalizing t c' with\n  | root => match c', ht with\n    | red, âŸ¨_, hâŸ© | black, âŸ¨_, _, hâŸ© => exact h.setBlack\n  | @redL _ n _ _ hb hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih ((hb.balLeft ha).of_false (fun.)) (fun.)\n  | @redR _ n _ _ ha hp ih => match c', n, ht with\n    | red, _, _ => cases hc rfl rfl\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih ((ha.balRight hb).of_false (fun.)) (fun.)\n  | @blackL _ _ n _ _ _ hb hp ih => match c', n, ht with\n    | red, _, âŸ¨_, haâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, haâŸ© => exact ih âŸ¨_, rfl, (hb.balLeft ha).imp fun _ => âŸ¨âŸ©âŸ© (fun.)\n  | @blackR _ _ n _ _ _ ha hp ih =>  match c', n, ht with\n    | red, _, âŸ¨_, hbâŸ© => exact ih âŸ¨_, rfl, .redred âŸ¨âŸ© ha hbâŸ© (fun.)\n    | black, _, âŸ¨_, rfl, hbâŸ© => exact ih âŸ¨_, rfl, (ha.balRight hb).imp fun _ => âŸ¨âŸ©âŸ© (fun.)",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red) : âˆƒ n, (path.del t c').Balanced black n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {path : Path Î±}      (hp : path.Balanced câ‚€ nâ‚€ c n)  (ht : t.DelProp c' n)  (hc : c = black â†’ c' â‰  red)"},
 {"type": "âˆƒ c n, (t.alter cut f).Balanced c n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n) : âˆƒ c n, (t.alter cut f).Balanced c n := by simp [alter]; sorry",
  "name": "Balanced.alter",
  "kind": "theorem",
  "first-tactic": "simp [alter]",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n) : âˆƒ c n, (t.alter cut f).Balanced c n",
  "args":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}      (h : t.Balanced c n)"},
 {"type": "t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n",
  "tactic-prompt":
  "theorem (câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}  (h : t.WF cmp) : t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n := by induction h; sorry",
  "name": "WF.out",
  "kind": "theorem",
  "first-tactic": "induction h",
  "core-prompt":
  "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}  (h : t.WF cmp) : t.Ordered cmp âˆ§ âˆƒ c n, t.Balanced c n",
  "args": "(câ‚€ : RBColor)  (nâ‚€ : Nat) {t : RBNode Î±}  (h : t.WF cmp)"},
 {"type": "âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²) : âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚ := by intro lâ‚; sorry",
  "name": "map_append",
  "kind": "theorem",
  "first-tactic": "intro lâ‚",
  "core-prompt":
  "(f : Î± â†’ Î²) : âˆ€ lâ‚ lâ‚‚, map f (lâ‚ ++ lâ‚‚) = map f lâ‚ ++ map f lâ‚‚",
  "args": "(f : Î± â†’ Î²)"},
 {"type": "map id l = l",
  "tactic-prompt":
  "theorem (l : List Î±) : map id l = l := by induction l; sorry",
  "name": "map_id",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : map id l = l",
  "args": "(l : List Î±)"},
 {"type": "map g (map f l) = map (g âˆ˜ f) l",
  "tactic-prompt":
  "theorem (g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±) : map g (map f l) = map (g âˆ˜ f) l := by induction l; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±) : map g (map f l) = map (g âˆ˜ f) l",
  "args": "(g : Î² â†’ Î³)  (f : Î± â†’ Î²)  (l : List Î±)"},
 {"type": "List.bind [] f = []",
  "tactic-prompt":
  "theorem (f : Î± â†’ List Î²) : List.bind [] f = [] := by simp [join]; sorry",
  "name": "nil_bind",
  "kind": "theorem",
  "first-tactic": "simp [join]",
  "core-prompt": "(f : Î± â†’ List Î²) : List.bind [] f = []",
  "args": "(f : Î± â†’ List Î²)"},
 {"type": "List.bind l id = l.join",
  "tactic-prompt":
  "theorem (l : List (List Î±)) : List.bind l id = l.join := by simp [List.bind]; sorry",
  "name": "bind_id",
  "kind": "theorem",
  "first-tactic": "simp [List.bind]",
  "core-prompt": "(l : List (List Î±)) : List.bind l id = l.join",
  "args": "(l : List (List Î±))"},
 {"type": "(l.map f).reverse = l.reverse.map f",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (l : List Î±) : (l.map f).reverse = l.reverse.map f := by induction l; sorry",
  "name": "reverse_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î± â†’ Î²)  (l : List Î±) : (l.map f).reverse = l.reverse.map f",
  "args": "(f : Î± â†’ Î²)  (l : List Î±)"},
 {"type": "take i l = l",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : l.length â‰¤ i) : take i l = l := by have := take_append_drop i l; sorry",
  "name": "take_length_le",
  "kind": "theorem",
  "first-tactic": "have := take_append_drop i l",
  "core-prompt": "{l : List Î±}  (h : l.length â‰¤ i) : take i l = l",
  "args": "{l : List Î±}  (h : l.length â‰¤ i)"},
 {"type": "(l.concat a).reverse = a :: l.reverse",
  "tactic-prompt":
  "theorem (l : List Î±)  (a : Î±) : (l.concat a).reverse = a :: l.reverse := by rw [concat_eq_append]; sorry",
  "name": "reverse_concat",
  "kind": "theorem",
  "first-tactic": "rw [concat_eq_append]",
  "core-prompt":
  "(l : List Î±)  (a : Î±) : (l.concat a).reverse = a :: l.reverse",
  "args": "(l : List Î±)  (a : Î±)"},
 {"type": "l.foldr cons l' = l ++ l'",
  "tactic-prompt":
  "theorem (l : List Î±) : l.foldr cons l' = l ++ l' := by induction l; sorry",
  "name": "foldr_self_append",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "(l : List Î±) : l.foldr cons l' = l ++ l'",
  "args": "(l : List Î±)"},
 {"type": "l.foldr cons [] = l",
  "tactic-prompt":
  "theorem (l : List Î±) : l.foldr cons [] = l := by simp; sorry",
  "name": "foldr_self",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(l : List Î±) : l.foldr cons [] = l",
  "args": "(l : List Î±)"},
 {"type": "mapM' f l = mapM f l",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±) : mapM' f l = mapM f l := by simp [go]; sorry",
  "name": "mapM'_eq_mapM",
  "kind": "theorem",
  "first-tactic": "simp [go]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±) : mapM' f l = mapM f l",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  (l : List Î±)"},
 {"type": "(a :: l).mapM f = (return (â† f a) :: (â† l.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²) : (a :: l).mapM f = (return (â† f a) :: (â† l.mapM f)) := by simp [â† mapM'_eq_mapM]; sorry",
  "name": "mapM_cons",
  "kind": "theorem",
  "first-tactic": "simp [â† mapM'_eq_mapM]",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²) : (a :: l).mapM f = (return (â† f a) :: (â† l.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)"},
 {"type": "(lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f))",
  "tactic-prompt":
  "theorem [Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f)) := by induction lâ‚; sorry",
  "name": "mapM_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).mapM f = (return (â† lâ‚.mapM f) ++ (â† lâ‚‚.mapM f))",
  "args": "[Monad m]  [LawfulMonad m]  (f : Î± â†’ m Î²)  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "@set = @setTR",
  "tactic-prompt": "theorem  : @set = @setTR := by funext Î± l n a; sorry",
  "name": "set_eq_setTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n a",
  "core-prompt": " : @set = @setTR",
  "args": ""},
 {"type": "@List.erase = @eraseTR",
  "tactic-prompt":
  "theorem  : @List.erase = @eraseTR := by funext Î± _ l a; sorry",
  "name": "erase_eq_eraseTR",
  "kind": "theorem",
  "first-tactic": "funext Î± _ l a",
  "core-prompt": " : @List.erase = @eraseTR",
  "args": ""},
 {"type": "@eraseIdx = @eraseIdxTR",
  "tactic-prompt":
  "theorem  : @eraseIdx = @eraseIdxTR := by funext Î± l n; sorry",
  "name": "eraseIdx_eq_eraseIdxTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n",
  "core-prompt": " : @eraseIdx = @eraseIdxTR",
  "args": ""},
 {"type": "@List.bind = @bindTR",
  "tactic-prompt":
  "theorem  : @List.bind = @bindTR := by funext Î± Î² as f; sorry",
  "name": "bind_eq_bindTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² as f",
  "core-prompt": " : @List.bind = @bindTR",
  "args": ""},
 {"type": "@join = @joinTR",
  "tactic-prompt": "theorem  : @join = @joinTR := by funext Î± l; sorry",
  "name": "join_eq_joinTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @join = @joinTR",
  "args": ""},
 {"type": "@List.filterMap = @filterMapTR",
  "tactic-prompt":
  "theorem  : @List.filterMap = @filterMapTR := by funext Î± Î² f l; sorry",
  "name": "filterMap_eq_filterMapTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² f l",
  "core-prompt": " : @List.filterMap = @filterMapTR",
  "args": ""},
 {"type": "@List.replace = @replaceTR",
  "tactic-prompt":
  "theorem  : @List.replace = @replaceTR := by funext Î± _ l b c; sorry",
  "name": "replace_eq_replaceTR",
  "kind": "theorem",
  "first-tactic": "funext Î± _ l b c",
  "core-prompt": " : @List.replace = @replaceTR",
  "args": ""},
 {"type": "@take = @takeTR",
  "tactic-prompt": "theorem  : @take = @takeTR := by funext Î± n l; sorry",
  "name": "take_eq_takeTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n l",
  "core-prompt": " : @take = @takeTR",
  "args": ""},
 {"type": "@takeWhile = @takeWhileTR",
  "tactic-prompt":
  "theorem  : @takeWhile = @takeWhileTR := by funext Î± p l; sorry",
  "name": "takeWhile_eq_takeWhileTR",
  "kind": "theorem",
  "first-tactic": "funext Î± p l",
  "core-prompt": " : @takeWhile = @takeWhileTR",
  "args": ""},
 {"type": "@foldr = @foldrTR",
  "tactic-prompt":
  "theorem  : @foldr = @foldrTR := by funext Î± Î² f init l; sorry",
  "name": "foldr_eq_foldrTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² f init l",
  "core-prompt": " : @foldr = @foldrTR",
  "args": ""},
 {"type": "@zipWith = @zipWithTR",
  "tactic-prompt":
  "theorem  : @zipWith = @zipWithTR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWith_eq_zipWithTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWith = @zipWithTR",
  "args": ""},
 {"type": "@unzip = @unzipTR",
  "tactic-prompt": "theorem  : @unzip = @unzipTR := by funext Î± Î² l; sorry",
  "name": "unzip_eq_unzipTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² l",
  "core-prompt": " : @unzip = @unzipTR",
  "args": ""},
 {"type": "@enumFrom = @enumFromTR",
  "tactic-prompt":
  "theorem  : @enumFrom = @enumFromTR := by funext Î± n l; sorry",
  "name": "enumFrom_eq_enumFromTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n l",
  "core-prompt": " : @enumFrom = @enumFromTR",
  "args": ""},
 {"type": "@dropLast = @dropLastTR",
  "tactic-prompt": "theorem  : @dropLast = @dropLastTR := by funext Î± l; sorry",
  "name": "dropLast_eq_dropLastTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @dropLast = @dropLastTR",
  "args": ""},
 {"type": "@intersperse = @intersperseTR",
  "tactic-prompt":
  "theorem  : @intersperse = @intersperseTR := by funext Î± sep l; sorry",
  "name": "intersperse_eq_intersperseTR",
  "kind": "theorem",
  "first-tactic": "funext Î± sep l",
  "core-prompt": " : @intersperse = @intersperseTR",
  "args": ""},
 {"type": "@intercalate = @intercalateTR",
  "tactic-prompt":
  "theorem  : @intercalate = @intercalateTR := by funext Î± sep l; sorry",
  "name": "intercalate_eq_intercalateTR",
  "kind": "theorem",
  "first-tactic": "funext Î± sep l",
  "core-prompt": " : @intercalate = @intercalateTR",
  "args": ""},
 {"type": "@removeNth = @removeNthTR",
  "tactic-prompt":
  "theorem  : @removeNth = @removeNthTR := by funext Î± l n; sorry",
  "name": "removeNth_eq_removeNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l n",
  "core-prompt": " : @removeNth = @removeNthTR",
  "args": ""},
 {"type": "@replaceF = @replaceFTR",
  "tactic-prompt":
  "theorem  : @replaceF = @replaceFTR := by funext Î± f l; sorry",
  "name": "replaceF_eq_replaceFTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f l",
  "core-prompt": " : @replaceF = @replaceFTR",
  "args": ""},
 {"type": "@modifyNth = @modifyNthTR",
  "tactic-prompt":
  "theorem  : @modifyNth = @modifyNthTR := by funext Î± f n l; sorry",
  "name": "modifyNth_eq_modifyNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @modifyNth = @modifyNthTR",
  "args": ""},
 {"type": "@insertNth = @insertNthTR",
  "tactic-prompt":
  "theorem  : @insertNth = @insertNthTR := by funext Î± f n l; sorry",
  "name": "insertNth_eq_insertNthTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @insertNth = @insertNthTR",
  "args": ""},
 {"type": "@takeD = @takeDTR",
  "tactic-prompt": "theorem  : @takeD = @takeDTR := by funext Î± f n l; sorry",
  "name": "takeD_eq_takeDTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @takeD = @takeDTR",
  "args": ""},
 {"type": "@leftpad = @leftpadTR",
  "tactic-prompt":
  "theorem  : @leftpad = @leftpadTR := by funext Î± n a l; sorry",
  "name": "leftpad_eq_leftpadTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n a l",
  "core-prompt": " : @leftpad = @leftpadTR",
  "args": ""},
 {"type": "@scanl = @scanlTR",
  "tactic-prompt": "theorem  : @scanl = @scanlTR := by funext Î± f n l; sorry",
  "name": "scanl_eq_scanlTR",
  "kind": "theorem",
  "first-tactic": "funext Î± f n l",
  "core-prompt": " : @scanl = @scanlTR",
  "args": ""},
 {"type": "@inits = @initsTR",
  "tactic-prompt": "theorem  : @inits = @initsTR := by funext Î± l; sorry",
  "name": "inits_eq_initsTR",
  "kind": "theorem",
  "first-tactic": "funext Î± l",
  "core-prompt": " : @inits = @initsTR",
  "args": ""},
 {"type": "@tails = @tailsTR",
  "tactic-prompt": "theorem  : @tails = @tailsTR := by funext Î±; sorry",
  "name": "tails_eq_tailsTR",
  "kind": "theorem",
  "first-tactic": "funext Î±",
  "core-prompt": " : @tails = @tailsTR",
  "args": ""},
 {"type": "@sections = @sectionsTR",
  "tactic-prompt": "theorem  : @sections = @sectionsTR := by funext Î± L; sorry",
  "name": "sections_eq_sectionsTR",
  "kind": "theorem",
  "first-tactic": "funext Î± L",
  "core-prompt": " : @sections = @sectionsTR",
  "args": ""},
 {"type": "@eraseP = @erasePTR",
  "tactic-prompt": "theorem  : @eraseP = @erasePTR := by funext Î± p l; sorry",
  "name": "eraseP_eq_erasePTR",
  "kind": "theorem",
  "first-tactic": "funext Î± p l",
  "core-prompt": " : @eraseP = @erasePTR",
  "args": ""},
 {"type": "@product = @productTR",
  "tactic-prompt":
  "theorem  : @product = @productTR := by funext Î± Î² lâ‚ lâ‚‚; sorry",
  "name": "product_eq_productTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² lâ‚ lâ‚‚",
  "core-prompt": " : @product = @productTR",
  "args": ""},
 {"type": "@List.sigma = @sigmaTR",
  "tactic-prompt":
  "theorem  : @List.sigma = @sigmaTR := by funext Î± Î² lâ‚ lâ‚‚; sorry",
  "name": "sigma_eq_sigmaTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² lâ‚ lâ‚‚",
  "core-prompt": " : @List.sigma = @sigmaTR",
  "args": ""},
 {"type": "@range' = @range'TR",
  "tactic-prompt": "theorem  : @range' = @range'TR := by funext s n; sorry",
  "name": "range'_eq_range'TR",
  "kind": "theorem",
  "first-tactic": "funext s n",
  "core-prompt": " : @range' = @range'TR",
  "args": ""},
 {"type": "@dropSlice = @dropSliceTR",
  "tactic-prompt":
  "theorem  : @dropSlice = @dropSliceTR := by funext Î± n m l; sorry",
  "name": "dropSlice_eq_dropSliceTR",
  "kind": "theorem",
  "first-tactic": "funext Î± n m l",
  "core-prompt": " : @dropSlice = @dropSliceTR",
  "args": ""},
 {"type": "@zipWithLeft' = @zipWithLeft'TR",
  "tactic-prompt":
  "theorem  : @zipWithLeft' = @zipWithLeft'TR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWithLeft'_eq_zipWithLeft'TR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWithLeft' = @zipWithLeft'TR",
  "args": ""},
 {"type": "@zipWithLeft = @zipWithLeftTR",
  "tactic-prompt":
  "theorem  : @zipWithLeft = @zipWithLeftTR := by funext Î± Î² Î³ f as bs; sorry",
  "name": "zipWithLeft_eq_zipWithLeftTR",
  "kind": "theorem",
  "first-tactic": "funext Î± Î² Î³ f as bs",
  "core-prompt": " : @zipWithLeft = @zipWithLeftTR",
  "args": ""},
 {"type": "@fillNones = @fillNonesTR",
  "tactic-prompt":
  "theorem  : @fillNones = @fillNonesTR := by funext Î± as as'; sorry",
  "name": "fillNones_eq_fillNonesTR",
  "kind": "theorem",
  "first-tactic": "funext Î± as as'",
  "core-prompt": " : @fillNones = @fillNonesTR",
  "args": ""},
 {"type": "@takeList = @takeListTR",
  "tactic-prompt":
  "theorem  : @takeList = @takeListTR := by funext Î± xs ns; sorry",
  "name": "takeList_eq_takeListTR",
  "kind": "theorem",
  "first-tactic": "funext Î± xs ns",
  "core-prompt": " : @takeList = @takeListTR",
  "args": ""},
 {"type": "a âˆˆ ([] : List Î±) â†” False",
  "tactic-prompt":
  "theorem (a : Î±) : a âˆˆ ([] : List Î±) â†” False := by simp; sorry",
  "name": "mem_nil_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "(a : Î±) : a âˆˆ ([] : List Î±) â†” False",
  "args": "(a : Î±)"},
 {"type": "l â‰  []",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  [] := by cases h; sorry",
  "name": "ne_nil_of_mem",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l) : l â‰  []",
  "args": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "p ++ q = [] â†” p = [] âˆ§ q = []",
  "tactic-prompt":
  "theorem  : p ++ q = [] â†” p = [] âˆ§ q = [] := by cases p; sorry",
  "name": "append_eq_nil",
  "kind": "theorem",
  "first-tactic": "cases p",
  "core-prompt": " : p ++ q = [] â†” p = [] âˆ§ q = []",
  "args": ""},
 {"type": "s â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : s â‰  [] â†’ s ++ t â‰  [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_left",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List Î±) : s â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "t â‰  [] â†’ s ++ t â‰  []",
  "tactic-prompt":
  "theorem (s t : List Î±) : t â‰  [] â†’ s ++ t â‰  [] := by simp_all; sorry",
  "name": "append_ne_nil_of_ne_nil_right",
  "kind": "theorem",
  "first-tactic": "simp_all",
  "core-prompt": "(s t : List Î±) : t â‰  [] â†’ s ++ t â‰  []",
  "args": "(s t : List Î±)"},
 {"type": "[] = a ++ b â†” a = [] âˆ§ b = []",
  "tactic-prompt":
  "theorem  : [] = a ++ b â†” a = [] âˆ§ b = [] := by rw [eq_comm]; sorry",
  "name": "nil_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt": " : [] = a ++ b â†” a = [] âˆ§ b = []",
  "args": ""},
 {"type": "a ++ b â‰  []",
  "tactic-prompt":
  "theorem (a b : List Î±)  (h0 : a â‰  []) : a ++ b â‰  [] := by simp [*]; sorry",
  "name": "append_ne_nil_of_left_ne_nil",
  "kind": "theorem",
  "first-tactic": "simp [*]",
  "core-prompt": "(a b : List Î±)  (h0 : a â‰  []) : a ++ b â‰  []",
  "args": "(a b : List Î±)  (h0 : a â‰  [])"},
 {"type":
  "a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b) := by cases a; sorry",
  "name": "append_eq_cons",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  " : a ++ b = x :: c â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "args": ""},
 {"type":
  "x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "tactic-prompt":
  "theorem  : x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b) := by rw [eq_comm]; sorry",
  "name": "cons_eq_append",
  "kind": "theorem",
  "first-tactic": "rw [eq_comm]",
  "core-prompt":
  " : x :: c = a ++ b â†” (a = [] âˆ§ b = x :: c) âˆ¨ (âˆƒ a', a = x :: a' âˆ§ c = a' ++ b)",
  "args": ""},
 {"type":
  "a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b",
  "tactic-prompt":
  "theorem {a b c d : List Î±} : a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b := by induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun âŸ¨_, âŸ¨e, rflâŸ©, hâŸ© => e â–¸ h.symm).symm\n  | cons a as ih => cases c; sorry",
  "name": "append_eq_append_iff",
  "kind": "theorem",
  "first-tactic":
  "induction a generalizing c with\n  | nil => simp; exact (or_iff_left_of_imp fun âŸ¨_, âŸ¨e, rflâŸ©, hâŸ© => e â–¸ h.symm).symm\n  | cons a as ih => cases c",
  "core-prompt":
  "{a b c d : List Î±} : a ++ b = c ++ d â†” (âˆƒ a', c = a ++ a' âˆ§ b = a' ++ d) âˆ¨ âˆƒ c', a = c ++ c' âˆ§ d = c' ++ b",
  "args": "{a b c d : List Î±}"},
 {"type": "a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "tactic-prompt":
  "theorem {a : Î±}  {s t : List Î±} : a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t := by induction s; sorry",
  "name": "mem_append",
  "kind": "theorem",
  "first-tactic": "induction s",
  "core-prompt": "{a : Î±}  {s t : List Î±} : a âˆˆ s ++ t â†” a âˆˆ s âˆ¨ a âˆˆ t",
  "args": "{a : Î±}  {s t : List Î±}"},
 {"type": "(âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j)",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j) := by simp [mem_map]; sorry",
  "name": "forall_mem_map_iff",
  "kind": "theorem",
  "first-tactic": "simp [mem_map]",
  "core-prompt":
  "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop} : (âˆ€ i âˆˆ l.map f, P i) â†” âˆ€ j âˆˆ l, P (f j)",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}  {P : Î² â†’ Prop}"},
 {"type": "List.map f l = [] â†” l = []",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±} : List.map f l = [] â†” l = [] := by constructor; sorry",
  "name": "map_eq_nil",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt": "{f : Î± â†’ Î²}  {l : List Î±} : List.map f l = [] â†” l = []",
  "args": "{f : Î± â†’ Î²}  {l : List Î±}"},
 {"type": "(âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x := by simp; sorry",
  "name": "exists_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆƒ x âˆˆ a :: l, p x) â†” p a âˆ¨ âˆƒ x âˆˆ l, p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x := by simp; sorry",
  "name": "forall_mem_cons",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±} : (âˆ€ x âˆˆ a :: l, p x) â†” p a âˆ§ âˆ€ x âˆˆ l, p x",
  "args": "{p : Î± â†’ Prop}  {a : Î±}  {l : List Î±}"},
 {"type": "(âˆ€ x âˆˆ [a], p x) â†” p a",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x âˆˆ [a], p x) â†” p a := by simp only [mem_singleton]; sorry",
  "name": "forall_mem_singleton",
  "kind": "theorem",
  "first-tactic": "simp only [mem_singleton]",
  "core-prompt": "{p : Î± â†’ Prop}  {a : Î±} : (âˆ€ x âˆˆ [a], p x) â†” p a",
  "args": "{p : Î± â†’ Prop}  {a : Î±}"},
 {"type": "(âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x)",
  "tactic-prompt":
  "theorem {p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x) := by simp only [mem_append]; sorry",
  "name": "forall_mem_append",
  "kind": "theorem",
  "first-tactic": "simp only [mem_append]",
  "core-prompt":
  "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±} : (âˆ€ x âˆˆ lâ‚ ++ lâ‚‚, p x) â†” (âˆ€ x âˆˆ lâ‚, p x) âˆ§ (âˆ€ x âˆˆ lâ‚‚, p x)",
  "args": "{p : Î± â†’ Prop}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "tactic-prompt":
  "theorem  : a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m := by simp only [subset_def]; sorry",
  "name": "cons_subset",
  "kind": "theorem",
  "first-tactic": "simp only [subset_def]",
  "core-prompt": " : a :: l âŠ† m â†” a âˆˆ m âˆ§ l âŠ† m",
  "args": ""},
 {"type": "lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l := by simp [subset_def]; sorry",
  "name": "append_subset",
  "kind": "theorem",
  "first-tactic": "simp [subset_def]",
  "core-prompt": "{lâ‚ lâ‚‚ l : List Î±} : lâ‚ ++ lâ‚‚ âŠ† l â†” lâ‚ âŠ† l âˆ§ lâ‚‚ âŠ† l",
  "args": "{lâ‚ lâ‚‚ l : List Î±}"},
 {"type":
  "âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±} : âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚ := by induction l; sorry",
  "name": "getLast_cons'",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±} : âˆ€ (hâ‚ : a :: l â‰  nil) (hâ‚‚ : l â‰  nil),\n  getLast (a :: l) hâ‚ = getLast l hâ‚‚",
  "args": "{a : Î±}  {l : List Î±}"},
 {"type": "tailD l l' = (tail? l).getD l'",
  "tactic-prompt":
  "theorem (l l' : List Î±) : tailD l l' = (tail? l).getD l' := by cases l; sorry",
  "name": "tailD_eq_tail?",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l l' : List Î±) : tailD l l' = (tail? l).getD l'",
  "args": "(l l' : List Î±)"},
 {"type": "@getLast! Î± _ (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem [Inhabited Î±] : @getLast! Î± _ (a::l) = getLastD l a := by simp [getLast!]; sorry",
  "name": "getLast!_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast!]",
  "core-prompt": "[Inhabited Î±] : @getLast! Î± _ (a::l) = getLastD l a",
  "args": "[Inhabited Î±]"},
 {"type": "@getLast? Î± (a::l) = getLastD l a",
  "tactic-prompt":
  "theorem  : @getLast? Î± (a::l) = getLastD l a := by simp [getLast?]; sorry",
  "name": "getLast?_cons",
  "kind": "theorem",
  "first-tactic": "simp [getLast?]",
  "core-prompt": " : @getLast? Î± (a::l) = getLastD l a",
  "args": ""},
 {"type": "dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚)",
  "tactic-prompt":
  "theorem  : dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚) := by induction lâ‚; sorry",
  "name": "dropLast_append_cons",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt": " : dropLast (lâ‚ ++ b::lâ‚‚) = lâ‚ ++ dropLast (b::lâ‚‚)",
  "args": ""},
 {"type": "dropLast (lâ‚ ++ [b]) = lâ‚",
  "tactic-prompt": "theorem  : dropLast (lâ‚ ++ [b]) = lâ‚ := by simp; sorry",
  "name": "dropLast_concat",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : dropLast (lâ‚ ++ [b]) = lâ‚",
  "args": ""},
 {"type": "l.get? 0 = l.head?",
  "tactic-prompt":
  "theorem (l : List Î±) : l.get? 0 = l.head? := by cases l; sorry",
  "name": "get?_zero",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List Î±) : l.get? 0 = l.head?",
  "args": "(l : List Î±)"},
 {"type": "l[i]? = l.get? i",
  "tactic-prompt":
  "theorem (l : List Î±)  (i : Nat) : l[i]? = l.get? i := by unfold getElem?; sorry",
  "name": "getElem?_eq_get?",
  "kind": "theorem",
  "first-tactic": "unfold getElem?",
  "core-prompt": "(l : List Î±)  (i : Nat) : l[i]? = l.get? i",
  "args": "(l : List Î±)  (i : Nat)"},
 {"type": "i = j",
  "tactic-prompt":
  "theorem (hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©; sorry",
  "name": "get?_inj",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©",
  "core-prompt":
  "(hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j) : i = j",
  "args":
  "(hâ‚€ : i < xs.length)  (hâ‚ : Nodup xs)  (hâ‚‚ : xs.get? i = xs.get? j)"},
 {"type": "get l i = get l' âŸ¨i, h â–¸ i.2âŸ©",
  "tactic-prompt":
  "theorem {l l' : List Î±}  (h : l = l')  (i : Fin l.length) : get l i = get l' âŸ¨i, h â–¸ i.2âŸ© := by cases h; sorry",
  "name": "get_of_eq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{l l' : List Î±}  (h : l = l')  (i : Fin l.length) : get l i = get l' âŸ¨i, h â–¸ i.2âŸ©",
  "args": "{l l' : List Î±}  (h : l = l')  (i : Fin l.length)"},
 {"type": "n - lâ‚.length < lâ‚‚.length",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length) : n - lâ‚.length < lâ‚‚.length := by rw [length_append] at hâ‚‚; sorry",
  "name": "get_append_right_aux",
  "kind": "theorem",
  "first-tactic": "rw [length_append] at hâ‚‚",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length) : n - lâ‚.length < lâ‚‚.length",
  "args":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}    (hâ‚ : lâ‚.length â‰¤ n)  (hâ‚‚ : n < (lâ‚ ++ lâ‚‚).length)"},
 {"type": "(lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length) : (lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n := by have hn' : n < (lâ‚ ++ lâ‚‚).length := Nat.lt_of_lt_of_le hn <| by\n    rw [length_append]; sorry",
  "name": "get?_append",
  "kind": "theorem",
  "first-tactic":
  "have hn' : n < (lâ‚ ++ lâ‚‚).length := Nat.lt_of_lt_of_le hn <| by\n    rw [length_append]",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length) : (lâ‚ ++ lâ‚‚).get? n = lâ‚.get? n",
  "args": "{lâ‚ lâ‚‚ : List Î±}  {n : Nat}  (hn : n < lâ‚.length)"},
 {"type": "getLast? (l ++ [a]) = some a",
  "tactic-prompt":
  "theorem (l : List Î±) : getLast? (l ++ [a]) = some a := by simp [getLast?_eq_get?]; sorry",
  "name": "getLast?_concat",
  "kind": "theorem",
  "first-tactic": "simp [getLast?_eq_get?]",
  "core-prompt": "(l : List Î±) : getLast? (l ++ [a]) = some a",
  "args": "(l : List Î±)"},
 {"type":
  "(x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs)",
  "tactic-prompt":
  "theorem (x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length) : (x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs) := by rw [getLast_eq_get]; sorry",
  "name": "get_cons_length",
  "kind": "theorem",
  "first-tactic": "rw [getLast_eq_get]",
  "core-prompt":
  "(x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length) : (x :: xs).get âŸ¨n, by simp [h]âŸ© = (x :: xs).getLast (cons_ne_nil x xs)",
  "args": "(x : Î±)  (xs : List Î±)  (n : Nat)  (h : n = xs.length)"},
 {"type": "length (take n l) = n",
  "tactic-prompt":
  "theorem (h : n â‰¤ length l) : length (take n l) = n := by simp [Nat.min_eq_left h]; sorry",
  "name": "length_take_of_le",
  "kind": "theorem",
  "first-tactic": "simp [Nat.min_eq_left h]",
  "core-prompt": "(h : n â‰¤ length l) : length (take n l) = n",
  "args": "(h : n â‰¤ length l)"},
 {"type": "âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚) : âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚ := by have := h; sorry",
  "name": "map_eq_append_split",
  "kind": "theorem",
  "first-tactic": "have := h",
  "core-prompt":
  "{f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚) : âˆƒ lâ‚ lâ‚‚, l = lâ‚ ++ lâ‚‚ âˆ§ map f lâ‚ = sâ‚ âˆ§ map f lâ‚‚ = sâ‚‚",
  "args":
  "{f : Î± â†’ Î²}  {l : List Î±}  {sâ‚ sâ‚‚ : List Î²}      (h : map f l = sâ‚ ++ sâ‚‚)"},
 {"type":
  "âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : n < l.length) : âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚ := by rw [set_eq_modifyNth]; sorry",
  "name": "exists_of_set",
  "kind": "theorem",
  "first-tactic": "rw [set_eq_modifyNth]",
  "core-prompt":
  "{l : List Î±}  (h : n < l.length) : âˆƒ lâ‚ a lâ‚‚, l = lâ‚ ++ a :: lâ‚‚ âˆ§ lâ‚.length = n âˆ§ l.set n a' = lâ‚ ++ a' :: lâ‚‚",
  "args": "{l : List Î±}  (h : n < l.length)"},
 {"type": "(l.set i a).get âŸ¨i, hâŸ© = a",
  "tactic-prompt":
  "theorem (l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length) : (l.set i a).get âŸ¨i, hâŸ© = a := by rw [â† Option.some_inj]; sorry",
  "name": "get_set_eq",
  "kind": "theorem",
  "first-tactic": "rw [â† Option.some_inj]",
  "core-prompt":
  "(l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length) : (l.set i a).get âŸ¨i, hâŸ© = a",
  "args": "(l : List Î±)  (i : Nat)  (a : Î±)  (h : i < (l.set i a).length)"},
 {"type": "(l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ©",
  "tactic-prompt":
  "theorem {l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length) : (l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ© := by rw [â† Option.some_inj]; sorry",
  "name": "get_set_ne",
  "kind": "theorem",
  "first-tactic": "rw [â† Option.some_inj]",
  "core-prompt":
  "{l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length) : (l.set i a).get âŸ¨j, hjâŸ© = l.get âŸ¨j, by simp at hj; exact hjâŸ©",
  "args":
  "{l : List Î±}  {i j : Nat}  (h : i â‰  j)  (a : Î±)      (hj : j < (l.set i a).length)"},
 {"type": "length (tail l) = length l - 1",
  "tactic-prompt":
  "theorem (l : List Î±) : length (tail l) = length l - 1 := by cases l; sorry",
  "name": "length_tail",
  "kind": "theorem",
  "first-tactic": "cases l",
  "core-prompt": "(l : List Î±) : length (tail l) = length l - 1",
  "args": "(l : List Î±)"},
 {"type": "l.all p â†” âˆ€ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {l : List Î±} : l.all p â†” âˆ€ x âˆˆ l, p x := by induction l; sorry",
  "name": "all_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±} : l.all p â†” âˆ€ x âˆˆ l, p x",
  "args": "{l : List Î±}"},
 {"type": "l.any p â†” âˆƒ x âˆˆ l, p x",
  "tactic-prompt":
  "theorem {l : List Î±} : l.any p â†” âˆƒ x âˆˆ l, p x := by induction l; sorry",
  "name": "any_eq_true",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±} : l.any p â†” âˆƒ x âˆˆ l, p x",
  "args": "{l : List Î±}"},
 {"type": "x âˆˆ reverse as â†” x âˆˆ as",
  "tactic-prompt":
  "theorem (x : Î±)  (as : List Î±) : x âˆˆ reverse as â†” x âˆˆ as := by simp [reverse]; sorry",
  "name": "mem_reverse",
  "kind": "theorem",
  "first-tactic": "simp [reverse]",
  "core-prompt": "(x : Î±)  (as : List Î±) : x âˆˆ reverse as â†” x âˆˆ as",
  "args": "(x : Î±)  (as : List Î±)"},
 {"type": "l.insert a = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : l.insert a = l := by simp only [List.insert]; sorry",
  "name": "insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : l.insert a = l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "l.insert a = a :: l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : l.insert a = a :: l := by simp only [List.insert]; sorry",
  "name": "insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp only [List.insert]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : l.insert a = a :: l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l)"},
 {"type": "a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±} : a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l := by if h : b âˆˆ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]; sorry",
  "name": "mem_insert_iff",
  "kind": "theorem",
  "first-tactic":
  "if h : b âˆˆ l then\n    rw [insert_of_mem h]\n    constructor; {apply Or.inr}\n    intro\n    | Or.inl h' => rw [h']; exact h\n    | Or.inr h' => exact h'\n  else rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±} : a âˆˆ l.insert b â†” a = b âˆ¨ a âˆˆ l",
  "args": "[DecidableEq Î±] {l : List Î±}"},
 {"type": "length (l.insert a) = length l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : length (l.insert a) = length l := by rw [insert_of_mem h]; sorry",
  "name": "length_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l) : length (l.insert a) = length l",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "length (l.insert a) = length l + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : length (l.insert a) = length l + 1 := by rw [insert_of_not_mem h]; sorry",
  "name": "length_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "rw [insert_of_not_mem h]",
  "core-prompt":
  "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l) : length (l.insert a) = length l + 1",
  "args": "[DecidableEq Î±] {l : List Î±}  (h : a âˆ‰ l)"},
 {"type": "l.eraseP p = l",
  "tactic-prompt":
  "theorem {l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a) : l.eraseP p = l := by induction l; sorry",
  "name": "eraseP_of_forall_not",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": "{l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a) : l.eraseP p = l",
  "args": "{l : List Î±}  (h : âˆ€ a, a âˆˆ l â†’ Â¬p a)"},
 {"type": "length (l.eraseP p) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem (al : a âˆˆ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l) := by let âŸ¨_, lâ‚, lâ‚‚, _, _, eâ‚, eâ‚‚âŸ© := exists_of_eraseP al pa; sorry",
  "name": "length_eraseP_of_mem",
  "kind": "theorem",
  "first-tactic": "let âŸ¨_, lâ‚, lâ‚‚, _, _, eâ‚, eâ‚‚âŸ© := exists_of_eraseP al pa",
  "core-prompt":
  "(al : a âˆˆ l)  (pa : p a) : length (l.eraseP p) = Nat.pred (length l)",
  "args": "(al : a âˆˆ l)  (pa : p a)"},
 {"type": "a âˆˆ l.eraseP p â†” a âˆˆ l",
  "tactic-prompt":
  "theorem {l : List Î±}  (pa : Â¬p a) : a âˆˆ l.eraseP p â†” a âˆˆ l := by refine âŸ¨mem_of_mem_eraseP, fun al => ?_âŸ©; sorry",
  "name": "mem_eraseP_of_neg",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨mem_of_mem_eraseP, fun al => ?_âŸ©",
  "core-prompt": "{l : List Î±}  (pa : Â¬p a) : a âˆˆ l.eraseP p â†” a âˆˆ l",
  "args": "{l : List Î±}  (pa : Â¬p a)"},
 {"type": "extractP p l = (find? p l, eraseP p l)",
  "tactic-prompt":
  "theorem (l : List Î±) : extractP p l = (find? p l, eraseP p l) := by let rec go (acc) : âˆ€ xs, l = acc.data ++ xs â†’\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x; sorry",
  "name": "extractP_eq_find?_eraseP",
  "kind": "theorem",
  "first-tactic":
  "let rec go (acc) : âˆ€ xs, l = acc.data ++ xs â†’\n    extractP.go p l xs acc = (xs.find? p, acc.data ++ xs.eraseP p)\n  | [] => fun h => by simp [extractP.go, find?, eraseP, h]\n  | x::xs => by\n    simp [extractP.go, find?, eraseP]; cases p x",
  "core-prompt": "(l : List Î±) : extractP p l = (find? p l, eraseP p l)",
  "args": "(l : List Î±)"},
 {"type": "(a :: l).erase a = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a : Î±)  (l : List Î±) : (a :: l).erase a = l := by simp [erase_cons]; sorry",
  "name": "erase_cons_head",
  "kind": "theorem",
  "first-tactic": "simp [erase_cons]",
  "core-prompt": "[DecidableEq Î±] (a : Î±)  (l : List Î±) : (a :: l).erase a = l",
  "args": "[DecidableEq Î±] (a : Î±)  (l : List Î±)"},
 {"type": "(b :: l).erase a = b :: l.erase a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a) : (b :: l).erase a = b :: l.erase a := by simp only [erase_cons]; sorry",
  "name": "erase_cons_tail",
  "kind": "theorem",
  "first-tactic": "simp only [erase_cons]",
  "core-prompt":
  "[DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a) : (b :: l).erase a = b :: l.erase a",
  "args": "[DecidableEq Î±] {a b : Î±}  (l : List Î±)  (h : b â‰  a)"},
 {"type": "âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚ := by let âŸ¨_, lâ‚, lâ‚‚, hâ‚, e, hâ‚‚, hâ‚ƒâŸ© := exists_of_eraseP h (beq_self_eq_true _); sorry",
  "name": "exists_erase_eq",
  "kind": "theorem",
  "first-tactic":
  "let âŸ¨_, lâ‚, lâ‚‚, hâ‚, e, hâ‚‚, hâ‚ƒâŸ© := exists_of_eraseP h (beq_self_eq_true _)",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ lâ‚ lâ‚‚, a âˆ‰ lâ‚ âˆ§ l = lâ‚ ++ a :: lâ‚‚ âˆ§ l.erase a = lâ‚ ++ lâ‚‚",
  "args": "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "length (l.erase a) = Nat.pred (length l)",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : length (l.erase a) = Nat.pred (length l) := by rw [erase_eq_eraseP]; sorry",
  "name": "length_erase_of_mem",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : length (l.erase a) = Nat.pred (length l)",
  "args": "[DecidableEq Î±] {a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "(lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a)",
  "tactic-prompt":
  "theorem [DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚) : (lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a) := by rw [erase_eq_eraseP]; sorry",
  "name": "erase_append_right",
  "kind": "theorem",
  "first-tactic": "rw [erase_eq_eraseP]",
  "core-prompt":
  "[DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚) : (lâ‚ ++ lâ‚‚).erase a = (lâ‚ ++ lâ‚‚.erase a)",
  "args":
  "[DecidableEq Î±] {a : Î±}  {lâ‚ : List Î±}  (lâ‚‚ : List Î±)  (h : a âˆ‰ lâ‚)"},
 {"type": "(l.erase a).erase b = (l.erase b).erase a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a b : Î±)  (l : List Î±) : (l.erase a).erase b = (l.erase b).erase a := by if ab : a = b then rw [ab] else ?_; sorry",
  "name": "erase_comm",
  "kind": "theorem",
  "first-tactic": "if ab : a = b then rw [ab] else ?_",
  "core-prompt":
  "[DecidableEq Î±] (a b : Î±)  (l : List Î±) : (l.erase a).erase b = (l.erase b).erase a",
  "args": "[DecidableEq Î±] (a b : Î±)  (l : List Î±)"},
 {"type": "x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x",
  "tactic-prompt":
  "theorem  : x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x := by induction as; sorry",
  "name": "mem_filter",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt": " : x âˆˆ filter p as â†” x âˆˆ as âˆ§ p x",
  "args": ""},
 {"type": "partition p l = (filter p l, filter (not âˆ˜ p) l)",
  "tactic-prompt":
  "theorem (p : Î± â†’ Bool)  (l : List Î±) : partition p l = (filter p l, filter (not âˆ˜ p) l) := by simp [partition]; sorry",
  "name": "partition_eq_filter_filter",
  "kind": "theorem",
  "first-tactic": "simp [partition]",
  "core-prompt":
  "(p : Î± â†’ Bool)  (l : List Î±) : partition p l = (filter p l, filter (not âˆ˜ p) l)",
  "args": "(p : Î± â†’ Bool)  (l : List Î±)"},
 {"type": "(l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b))",
  "tactic-prompt":
  "theorem {l : List Î±} : (l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b)) := by induction l; sorry",
  "name": "pairwise_map",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List Î±} : (l.map f).Pairwise R â†” l.Pairwise (fun a b => R (f a) (f b))",
  "args": "{l : List Î±}"},
 {"type":
  "(lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b := by induction lâ‚; sorry",
  "name": "pairwise_append",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "{lâ‚ lâ‚‚ : List Î±} : (lâ‚ ++ lâ‚‚).Pairwise R â†” lâ‚.Pairwise R âˆ§ lâ‚‚.Pairwise R âˆ§ âˆ€ a âˆˆ lâ‚, âˆ€ b âˆˆ lâ‚‚, R a b",
  "args": "{lâ‚ lâ‚‚ : List Î±}"},
 {"type": "l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a)",
  "tactic-prompt":
  "theorem {l : List Î±} : l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a) := by induction l; sorry",
  "name": "pairwise_reverse",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{l : List Î±} : l.reverse.Pairwise R â†” l.Pairwise (fun a b => R b a)",
  "args": "{l : List Î±}"},
 {"type": "length (replaceF f l) = length l",
  "tactic-prompt":
  "theorem  : length (replaceF f l) = length l := by induction l; sorry",
  "name": "length_replaceF",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt": " : length (replaceF f l) = length l",
  "args": ""},
 {"type": "Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚",
  "tactic-prompt":
  "theorem  : Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚ := by simp [Disjoint]; sorry",
  "name": "disjoint_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint lâ‚ lâ‚‚ â†” âˆ€ â¦ƒaâ¦„, a âˆˆ lâ‚ â†’ a âˆ‰ lâ‚‚",
  "args": ""},
 {"type": "Disjoint l []",
  "tactic-prompt":
  "theorem (l : List Î±) : Disjoint l [] := by rw [disjoint_comm]; sorry",
  "name": "disjoint_nil_right",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": "(l : List Î±) : Disjoint l []",
  "args": "(l : List Î±)"},
 {"type": "Disjoint [a] l â†” a âˆ‰ l",
  "tactic-prompt":
  "theorem  : Disjoint [a] l â†” a âˆ‰ l := by simp [Disjoint]; sorry",
  "name": "singleton_disjoint",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint [a] l â†” a âˆ‰ l",
  "args": ""},
 {"type": "Disjoint l [a] â†” a âˆ‰ l",
  "tactic-prompt":
  "theorem  : Disjoint l [a] â†” a âˆ‰ l := by rw [disjoint_comm]; sorry",
  "name": "disjoint_singleton",
  "kind": "theorem",
  "first-tactic": "rw [disjoint_comm]",
  "core-prompt": " : Disjoint l [a] â†” a âˆ‰ l",
  "args": ""},
 {"type": "Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l",
  "tactic-prompt":
  "theorem  : Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l := by simp [Disjoint]; sorry",
  "name": "disjoint_append_left",
  "kind": "theorem",
  "first-tactic": "simp [Disjoint]",
  "core-prompt": " : Disjoint (lâ‚ ++ lâ‚‚) l â†” Disjoint lâ‚ l âˆ§ Disjoint lâ‚‚ l",
  "args": ""},
 {"type": "(l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "tactic-prompt":
  "theorem (f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init := by induction l generalizing init; sorry",
  "name": "foldl_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±) : (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init",
  "args": "(f : Î²â‚ â†’ Î²â‚‚)  (g : Î± â†’ Î²â‚‚ â†’ Î±)  (l : List Î²â‚)  (init : Î±)"},
 {"type": "(l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "tactic-prompt":
  "theorem (f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init := by induction l generalizing init; sorry",
  "name": "foldr_map",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²) : (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init",
  "args": "(f : Î±â‚ â†’ Î±â‚‚)  (g : Î±â‚‚ â†’ Î² â†’ Î²)  (l : List Î±â‚)  (init : Î²)"},
 {"type": "l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init)",
  "tactic-prompt":
  "theorem (f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y)) : l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init) := by induction l generalizing init; sorry",
  "name": "foldl_hom",
  "kind": "theorem",
  "first-tactic": "induction l generalizing init",
  "core-prompt":
  "(f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y)) : l.foldl gâ‚‚ (f init) = f (l.foldl gâ‚ init)",
  "args":
  "(f : Î±â‚ â†’ Î±â‚‚)  (gâ‚ : Î±â‚ â†’ Î² â†’ Î±â‚)  (gâ‚‚ : Î±â‚‚ â†’ Î² â†’ Î±â‚‚)  (l : List Î²)  (init : Î±â‚)      (H : âˆ€ x y, gâ‚‚ (f x) y = f (gâ‚ x y))"},
 {"type": "l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init)",
  "tactic-prompt":
  "theorem (f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y)) : l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init) := by induction l; sorry",
  "name": "foldr_hom",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "(f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y)) : l.foldr gâ‚‚ (f init) = f (l.foldr gâ‚ init)",
  "args":
  "(f : Î²â‚ â†’ Î²â‚‚)  (gâ‚ : Î± â†’ Î²â‚ â†’ Î²â‚)  (gâ‚‚ : Î± â†’ Î²â‚‚ â†’ Î²â‚‚)  (l : List Î±)  (init : Î²â‚)      (H : âˆ€ x y, gâ‚‚ x (f y) = f (gâ‚ x y))"},
 {"type": "nil.union l = l",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (l : List Î±) : nil.union l = l := by simp [List.union]; sorry",
  "name": "nil_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt": "[DecidableEq Î±] (l : List Î±) : nil.union l = l",
  "args": "[DecidableEq Î±] (l : List Î±)"},
 {"type": "(a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a",
  "tactic-prompt":
  "theorem [DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : (a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a := by simp [List.union]; sorry",
  "name": "cons_union",
  "kind": "theorem",
  "first-tactic": "simp [List.union]",
  "core-prompt":
  "[DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±) : (a :: lâ‚).union lâ‚‚ = (lâ‚.union lâ‚‚).insert a",
  "args": "[DecidableEq Î±] (a : Î±)  (lâ‚ lâ‚‚ : List Î±)"},
 {"type": "x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚ := by induction lâ‚; sorry",
  "name": "mem_union_iff",
  "kind": "theorem",
  "first-tactic": "induction lâ‚",
  "core-prompt":
  "[DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.union lâ‚‚ â†” x âˆˆ lâ‚ âˆ¨ x âˆˆ lâ‚‚",
  "args": "[DecidableEq Î±] [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚ := by cases lâ‚; sorry",
  "name": "mem_inter_iff",
  "kind": "theorem",
  "first-tactic": "cases lâ‚",
  "core-prompt":
  "[DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±} : x âˆˆ lâ‚.inter lâ‚‚ â†” x âˆˆ lâ‚ âˆ§ x âˆˆ lâ‚‚",
  "args": "[DecidableEq Î±]  {x : Î±}  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "(x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "tactic-prompt":
  "theorem {xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²} : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys := by simp only [List.product]; sorry",
  "name": "pair_mem_product",
  "kind": "theorem",
  "first-tactic": "simp only [List.product]",
  "core-prompt":
  "{xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²} : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "args": "{xs : List Î±}  {ys : List Î²}  {x : Î±}  {y : Î²}"},
 {"type": "(leftpad n a l).length = max n l.length",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : (leftpad n a l).length = max n l.length := by simp only [leftpad]; sorry",
  "name": "leftpad_length",
  "kind": "theorem",
  "first-tactic": "simp only [leftpad]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : (leftpad n a l).length = max n l.length",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type": "isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : isPrefix (replicate (n - length l) a) (leftpad n a l) := by simp only [isPrefix]; sorry",
  "name": "leftpad_prefix",
  "kind": "theorem",
  "first-tactic": "simp only [isPrefix]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : isPrefix (replicate (n - length l) a) (leftpad n a l)",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type": "isSuffix l (leftpad n a l)",
  "tactic-prompt":
  "theorem (n : Nat)  (a : Î±)  (l : List Î±) : isSuffix l (leftpad n a l) := by simp only [isSuffix]; sorry",
  "name": "leftpad_suffix",
  "kind": "theorem",
  "first-tactic": "simp only [isSuffix]",
  "core-prompt":
  "(n : Nat)  (a : Î±)  (l : List Î±) : isSuffix l (leftpad n a l)",
  "args": "(n : Nat)  (a : Î±)  (l : List Î±)"},
 {"type": "some a = some b â†” a = b",
  "tactic-prompt":
  "theorem {a b : Î±} : some a = some b â†” a = b := by simp; sorry",
  "name": "some_inj",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b : Î±} : some a = some b â†” a = b",
  "args": "{a b : Î±}"},
 {"type": "some (x.getD y) = x",
  "tactic-prompt":
  "theorem {x : Option Î±}  (hx : x â‰  none)  (y : Î±) : some (x.getD y) = x := by cases x; sorry",
  "name": "getD_of_ne_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option Î±}  (hx : x â‰  none)  (y : Î±) : some (x.getD y) = x",
  "args": "{x : Option Î±}  (hx : x â‰  none)  (y : Î±)"},
 {"type": "isSome x â†” âˆƒ a, x = some a",
  "tactic-prompt": "theorem  : isSome x â†” âˆƒ a, x = some a := by cases x; sorry",
  "name": "isSome_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : isSome x â†” âˆƒ a, x = some a",
  "args": ""},
 {"type": "isSome a = false â†” a.isNone = true",
  "tactic-prompt":
  "theorem  : isSome a = false â†” a.isNone = true := by cases a; sorry",
  "name": "not_isSome",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": " : isSome a = false â†” a.isNone = true",
  "args": ""},
 {"type": "o = some a â†” âˆƒ h : o.isSome, o.get h = a",
  "tactic-prompt":
  "theorem  : o = some a â†” âˆƒ h : o.isSome, o.get h = a := by cases o; sorry",
  "name": "eq_some_iff_get_eq",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o = some a â†” âˆƒ h : o.isSome, o.get h = a",
  "args": ""},
 {"type": "Â¬o.isSome â†” o = none",
  "tactic-prompt": "theorem  : Â¬o.isSome â†” o = none := by cases o; sorry",
  "name": "not_isSome_iff_eq_none",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : Â¬o.isSome â†” o = none",
  "args": ""},
 {"type": "o â‰  none â†” o.isSome",
  "tactic-prompt": "theorem  : o â‰  none â†” o.isSome := by cases o; sorry",
  "name": "ne_none_iff_isSome",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o â‰  none â†” o.isSome",
  "args": ""},
 {"type": "o â‰  none â†” âˆƒ x, some x = o",
  "tactic-prompt": "theorem  : o â‰  none â†” âˆƒ x, some x = o := by cases o; sorry",
  "name": "ne_none_iff_exists",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt": " : o â‰  none â†” âˆƒ x, some x = o",
  "args": ""},
 {"type": "x.bind some = x",
  "tactic-prompt":
  "theorem (x : Option Î±) : x.bind some = x := by cases x; sorry",
  "name": "bind_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option Î±) : x.bind some = x",
  "args": "(x : Option Î±)"},
 {"type": "x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "tactic-prompt":
  "theorem  : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b := by cases x; sorry",
  "name": "bind_eq_some",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.bind f = some b â†” âˆƒ a, x = some a âˆ§ f a = some b",
  "args": ""},
 {"type": "o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "tactic-prompt":
  "theorem {o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a := by simp only [eq_none_iff_forall_not_mem]; sorry",
  "name": "bind_eq_none",
  "kind": "theorem",
  "first-tactic": "simp only [eq_none_iff_forall_not_mem]",
  "core-prompt":
  "{o : Option Î±}  {f : Î± â†’ Option Î²} : o.bind f = none â†” âˆ€ b a, a âˆˆ o â†’ b âˆ‰ f a",
  "args": "{o : Option Î±}  {f : Î± â†’ Option Î²}"},
 {"type":
  "(a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y := by cases a; sorry",
  "name": "bind_comm",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt":
  "{f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²) : (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y",
  "args": "{f : Î± â†’ Î² â†’ Option Î³}  (a : Option Î±)  (b : Option Î²)"},
 {"type": "(x.bind f).bind g = x.bind fun y => (f y).bind g",
  "tactic-prompt":
  "theorem (x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³) : (x.bind f).bind g = x.bind fun y => (f y).bind g := by cases x; sorry",
  "name": "bind_assoc",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³) : (x.bind f).bind g = x.bind fun y => (f y).bind g",
  "args": "(x : Option Î±)  (f : Î± â†’ Option Î²)  (g : Î² â†’ Option Î³)"},
 {"type": "x.join = some a â†” x = some (some a)",
  "tactic-prompt":
  "theorem  : x.join = some a â†” x = some (some a) := by simp; sorry",
  "name": "join_eq_some",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": " : x.join = some a â†” x = some (some a)",
  "args": ""},
 {"type": "x.join â‰  none â†” âˆƒ z, x = some (some z)",
  "tactic-prompt":
  "theorem  : x.join â‰  none â†” âˆƒ z, x = some (some z) := by simp only [ne_none_iff_exists']; sorry",
  "name": "join_ne_none",
  "kind": "theorem",
  "first-tactic": "simp only [ne_none_iff_exists']",
  "core-prompt": " : x.join â‰  none â†” âˆƒ z, x = some (some z)",
  "args": ""},
 {"type": "x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b",
  "tactic-prompt":
  "theorem  : x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b := by cases x; sorry",
  "name": "map_eq_some'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = some b â†” âˆƒ a, x = some a âˆ§ f a = b",
  "args": ""},
 {"type": "x.map f = none â†” x = none",
  "tactic-prompt": "theorem  : x.map f = none â†” x = none := by cases x; sorry",
  "name": "map_eq_none'",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": " : x.map f = none â†” x = none",
  "args": ""},
 {"type": "x.map f = x.map g",
  "tactic-prompt":
  "theorem {x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a) : x.map f = x.map g := by cases x; sorry",
  "name": "map_congr",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "{x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a) : x.map f = x.map g",
  "args": "{x : Option Î±}  (h : âˆ€ a âˆˆ x, f a = g a)"},
 {"type": "(x.map g).map h = x.map (h âˆ˜ g)",
  "tactic-prompt":
  "theorem (h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±) : (x.map g).map h = x.map (h âˆ˜ g) := by cases x; sorry",
  "name": "map_map",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "(h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±) : (x.map g).map h = x.map (h âˆ˜ g)",
  "args": "(h : Î² â†’ Î³)  (g : Î± â†’ Î²)  (x : Option Î±)"},
 {"type": "Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (g : Î² â†’ Î³) : Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f) := by funext x; sorry",
  "name": "map_comp_map",
  "kind": "theorem",
  "first-tactic": "funext x",
  "core-prompt":
  "(f : Î± â†’ Î²)  (g : Î² â†’ Î³) : Option.map g âˆ˜ Option.map f = Option.map (g âˆ˜ f)",
  "args": "(f : Î± â†’ Î²)  (g : Î² â†’ Î³)"},
 {"type": "(x.map (Option.map f)).join = x.join.map f",
  "tactic-prompt":
  "theorem {f : Î± â†’ Î²}  {x : Option (Option Î±)} : (x.map (Option.map f)).join = x.join.map f := by cases x; sorry",
  "name": "join_map_eq_map_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{f : Î± â†’ Î²}  {x : Option (Option Î±)} : (x.map (Option.map f)).join = x.join.map f",
  "args": "{f : Î± â†’ Î²}  {x : Option (Option Î±)}"},
 {"type": "x.join.join = (x.map join).join",
  "tactic-prompt":
  "theorem {x : Option (Option (Option Î±))} : x.join.join = (x.map join).join := by cases x; sorry",
  "name": "join_join",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{x : Option (Option (Option Î±))} : x.join.join = (x.map join).join",
  "args": "{x : Option (Option (Option Î±))}"},
 {"type": "(x <|> none) = x",
  "tactic-prompt":
  "theorem (x : Option Î±) : (x <|> none) = x := by cases x; sorry",
  "name": "orElse_none",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt": "(x : Option Î±) : (x <|> none) = x",
  "args": "(x : Option Î±)"},
 {"type": "guard p a = some b â†” a = b âˆ§ p a",
  "tactic-prompt":
  "theorem [DecidablePred p] : guard p a = some b â†” a = b âˆ§ p a := by by_cases h : p a; sorry",
  "name": "guard_eq_some",
  "kind": "theorem",
  "first-tactic": "by_cases h : p a",
  "core-prompt": "[DecidablePred p] : guard p a = some b â†” a = b âˆ§ p a",
  "args": "[DecidablePred p]"},
 {"type": "(o.map f).getD (f x) = f (getD o x)",
  "tactic-prompt":
  "theorem (f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±) : (o.map f).getD (f x) = f (getD o x) := by cases o; sorry",
  "name": "getD_map",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "(f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±) : (o.map f).getD (f x) = f (getD o x)",
  "args": "(f : Î± â†’ Î²)  (x : Î±)  (o : Option Î±)"},
 {"type": "choice Î± = some a",
  "tactic-prompt":
  "theorem {Î± : Type _}  [Subsingleton Î±]  (a : Î±) : choice Î± = some a := by simp [choice]; sorry",
  "name": "choice_eq",
  "kind": "theorem",
  "first-tactic": "simp [choice]",
  "core-prompt": "{Î± : Type _}  [Subsingleton Î±]  (a : Î±) : choice Î± = some a",
  "args": "{Î± : Type _}  [Subsingleton Î±]  (a : Î±)"},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by fconstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fconstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "Foo",
  "tactic-prompt": "example  : Foo := by econstructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "econstructor",
  "core-prompt": " : Foo",
  "args": ""},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (foo : False) : a < b := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": "(a b : â„•)  (foo : False) : a < b",
  "args": "(a b : â„•)  (foo : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (h : False) : a < b := by by_contra' foo; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo",
  "core-prompt": "(a b : â„•)  (h : False) : a < b",
  "args": "(a b : â„•)  (h : False)"},
 {"type": "a < b",
  "tactic-prompt":
  "example (a b : â„•)  (h : False) : a < b := by by_contra' foo : Â¬ a < b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : Â¬ a < b",
  "core-prompt": "(a b : â„•)  (h : False) : a < b",
  "args": "(a b : â„•)  (h : False)"},
 {"type": "1 < 2",
  "tactic-prompt": "example  : 1 < 2 := by by_contra'; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra'",
  "core-prompt": " : 1 < 2",
  "args": ""},
 {"type": "Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P := by by_contra' foo : Â¬ Â¬ Â¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' foo : Â¬ Â¬ Â¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type": "Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "tactic-prompt":
  "example (p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P := by by_contra' : Â¬ Â¬ Â¬ P; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "by_contra' : Â¬ Â¬ Â¬ P",
  "core-prompt": "(p : Prop)  (bar : False) : Â¬ Â¬ Â¬ Â¬ Â¬ Â¬ P",
  "args": "(p : Prop)  (bar : False)"},
 {"type":
  "(e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source)",
  "tactic-prompt":
  "example (e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³) : (e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source) := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³) : (e.trans e').source = e.source âˆ© Set.preimage e (e.target âˆ© e'.source)",
  "args": "(e : LocalEquiv Î± Î²)  (e' : LocalEquiv Î² Î³)"},
 {"type": "(e.trans e.symm).source = e.source",
  "tactic-prompt":
  "example (e : LocalEquiv Î± Î²) : (e.trans e.symm).source = e.source := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt": "(e : LocalEquiv Î± Î²) : (e.trans e.symm).source = e.source",
  "args": "(e : LocalEquiv Î± Î²)"},
 {"type":
  "f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s",
  "tactic-prompt":
  "example (s : Set Î±)  (f : LocalHomeomorph Î± Î²) : f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "(s : Set Î±)  (f : LocalHomeomorph Î± Î²) : f.symm.toLocalEquiv.source âˆ© (f.toLocalEquiv.target âˆ© Set.preimage f.symm s)\n  = f.symm.toLocalEquiv.source âˆ© Set.preimage f.symm s",
  "args": "(s : Set Î±)  (f : LocalHomeomorph Î± Î²)"},
 {"type":
  "(Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "tactic-prompt":
  "example {I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''} : (Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y} := by mfld_set_tac; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "mfld_set_tac",
  "core-prompt":
  "{I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''} : (Set.preimage (f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm))\n      (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).source) âŠ†\n    {y : E |\n    ((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv) âˆ˜\n          (g âˆ˜ f) âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y\n    = (((eâ‚ƒ.toLocalEquiv.trans I''.toLocalEquiv : M'' â†’ E'') âˆ˜\n             g âˆ˜ ((eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv).symm)) âˆ˜\n          (eâ‚‚.toLocalEquiv.trans I'.toLocalEquiv : M' â†’ E') âˆ˜\n            f âˆ˜ ((eâ‚.toLocalEquiv.trans I.toLocalEquiv).symm)) y}",
  "args":
  "{I : ModelWithCorners ð•œ E H}    {I' : ModelWithCorners ð•œ E' H'}    {I'' : ModelWithCorners ð•œ E'' H''}    (eâ‚ : LocalHomeomorph M H)    (eâ‚‚ : LocalHomeomorph M' H')    (eâ‚ƒ : LocalHomeomorph M'' H'')    {f : M â†’ M'}    {g : M' â†’ M''}"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h) : True := by choose! i j _x _y using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j _x _y using h",
  "core-prompt":
  "{Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h) : True",
  "args":
  "{Î± : Type}  (h : âˆ€ n m : Î±, âˆ€ (h : n = m), âˆƒ i j : Î±, i â‰  j âˆ§ h = h)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt": "(h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i) : True := by choose! f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h h' using h",
  "core-prompt": "(h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i) : True",
  "args": "(h : âˆ€ i : Nat, i < 7 â†’ âˆƒ j, i < j âˆ§ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True := by choose! i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! i j h using h",
  "core-prompt":
  "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ n m : Nat, n < m â†’ âˆƒ i j, m = n + i âˆ¨ m + j = n)"},
 {"type": "(âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True",
  "tactic-prompt":
  "example  : (âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True := by choose i j h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h",
  "core-prompt":
  " : (âˆ€ m : Nat, âˆƒ i, âˆ€ n : Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) â†’ True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) : True := by choose i j h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose i j h using h",
  "core-prompt":
  "(h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n) : True",
  "args": "(h : âˆ€ _n m : Nat, âˆƒ i, âˆ€ n:Nat, âˆƒ j, m = n + i âˆ¨ m + j = n)"},
 {"type": "âˆ€ _ : Nat, 1 = 1",
  "tactic-prompt":
  "example (h : âˆ€ n, âˆƒ k â‰¥ 0, n = k) : âˆ€ _ : Nat, 1 = 1 := by choose u hu using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose u hu using h",
  "core-prompt": "(h : âˆ€ n, âˆƒ k â‰¥ 0, n = k) : âˆ€ _ : Nat, 1 = 1",
  "args": "(h : âˆ€ n, âˆƒ k â‰¥ 0, n = k)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i) : True := by choose f h h' using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose f h h' using h",
  "core-prompt": "(h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i) : True",
  "args": "(h : âˆ€ i : Nat, âˆƒ j, i < j âˆ§ j < i+i)"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1) : True := by choose! f h using h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "choose! f h using h",
  "core-prompt":
  "{Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1) : True",
  "args":
  "{Î± : Type u}  (p : Î± â†’ Prop)  (h : âˆ€ i : Î±, p i â†’ âˆƒ j : Î± Ã— Î±, p j.1)"},
 {"type": "Â¬(p âˆ§ q) â†’ (p â†’ Â¬q)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬(p âˆ§ q) â†’ (p â†’ Â¬q) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : Â¬(p âˆ§ q) â†’ (p â†’ Â¬q)",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "(Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x)",
  "tactic-prompt":
  "example {Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x) := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop} : (Â¬ âˆ€(x : Î±), p' x) â†’ (âˆƒ(x : Î±), Â¬ p' x)",
  "args": "{Î± Î² : Type}  [LinearOrder Î²]  {p q : Prop}  {p' q' : Î± â†’ Prop}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : True",
  "args": ""},
 {"type": "2 + 2 = 4",
  "tactic-prompt": "example  : 2 + 2 = 4 := by triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "triv",
  "core-prompt": " : 2 + 2 = 4",
  "args": ""},
 {"type": "False",
  "tactic-prompt":
  "example (P : Prop)  (h1 : P)  (h2 : Â¬ P) : False := by fail_if_success triv; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success triv",
  "core-prompt": "(P : Prop)  (h1 : P)  (h2 : Â¬ P) : False",
  "args": "(P : Prop)  (h1 : P)  (h2 : Â¬ P)"},
 {"type":
  "374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤)",
  "tactic-prompt":
  "example  : 374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤) := by norm_num1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num1",
  "core-prompt":
  " : 374 + (32 - (2 * 8123) : â„¤) - 61 * 50 = 86 + 32 * 32 - 4 * 5000\n      âˆ§ 43 â‰¤ 74 + (33 : â„¤)",
  "args": ""},
 {"type": "2 ^ 17 - 1 = 131071",
  "tactic-prompt": "example  : 2 ^ 17 - 1 = 131071 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 2 ^ 17 - 1 = 131071",
  "args": ""},
 {"type": "(5 / 2:â„•) = 2",
  "tactic-prompt": "example  : (5 / 2:â„•) = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / 2:â„•) = 2",
  "args": ""},
 {"type": "(5 / -2:â„¤) < -1",
  "tactic-prompt": "example  : (5 / -2:â„¤) < -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (5 / -2:â„¤) < -1",
  "args": ""},
 {"type": "(0 + 1) / 2 < 0 + 1",
  "tactic-prompt": "example  : (0 + 1) / 2 < 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (0 + 1) / 2 < 0 + 1",
  "args": ""},
 {"type": "Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "tactic-prompt":
  "example  : Nat.succ (Nat.succ (2 ^ 3)) = 10 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : Nat.succ (Nat.succ (2 ^ 3)) = 10",
  "args": ""},
 {"type": "(12321 - 2 : â„¤) = 12319",
  "tactic-prompt": "example  : (12321 - 2 : â„¤) = 12319 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (12321 - 2 : â„¤) = 12319",
  "args": ""},
 {"type": "100 * 30 < x",
  "tactic-prompt":
  "example (x : â„¤)  (h : 1000 + 2000 < x) : 100 * 30 < x := by norm_num at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num at *",
  "core-prompt": "(x : â„¤)  (h : 1000 + 2000 < x) : 100 * 30 < x",
  "args": "(x : â„¤)  (h : 1000 + 2000 < x)"},
 {"type": "(1103 : â„¤) â‰¤ (2102 : â„¤)",
  "tactic-prompt": "example  : (1103 : â„¤) â‰¤ (2102 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (1103 : â„¤) â‰¤ (2102 : â„¤)",
  "args": ""},
 {"type": "(110474 : â„¤) â‰¤ (210485 : â„¤)",
  "tactic-prompt":
  "example  : (110474 : â„¤) â‰¤ (210485 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (110474 : â„¤) â‰¤ (210485 : â„¤)",
  "args": ""},
 {"type": "(11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤)",
  "tactic-prompt":
  "example  : (11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (11047462383473829263 : â„¤) â‰¤ (21048574677772382462 : â„¤)",
  "args": ""},
 {"type": "(210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤)",
  "tactic-prompt":
  "example  : (210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485742382937847263 : â„¤) â‰¤ (1104857462382937847262 : â„¤)",
  "args": ""},
 {"type": "(210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•)",
  "tactic-prompt":
  "example  : (210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  " : (210485987642382937847263 : â„•) â‰¤ (11048512347462382937847262 : â„•)",
  "args": ""},
 {"type": "(2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868",
  "tactic-prompt":
  "example  : (2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : (2 * 12868 + 25705) * 11621 ^ 2 â‰¤ 23235 ^ 2 * 12868",
  "args": ""},
 {"type": "true",
  "tactic-prompt": "example  : true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true",
  "args": ""},
 {"type": "true âˆ§ true",
  "tactic-prompt": "example  : true âˆ§ true := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : true âˆ§ true",
  "args": ""},
 {"type": "10 + 2 = 1 + 11",
  "tactic-prompt": "example  : 10 + 2 = 1 + 11 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 + 2 = 1 + 11",
  "args": ""},
 {"type": "10 - 1 = 9",
  "tactic-prompt": "example  : 10 - 1 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 1 = 9",
  "args": ""},
 {"type": "12 - 5 = 3 + 4",
  "tactic-prompt": "example  : 12 - 5 = 3 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 12 - 5 = 3 + 4",
  "args": ""},
 {"type": "5 - 20 = 0",
  "tactic-prompt": "example  : 5 - 20 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 - 20 = 0",
  "args": ""},
 {"type": "0 - 2 = 0",
  "tactic-prompt": "example  : 0 - 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 2 = 0",
  "args": ""},
 {"type": "4 - (5 - 10) = 2 + (3 - 1)",
  "tactic-prompt":
  "example  : 4 - (5 - 10) = 2 + (3 - 1) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 4 - (5 - 10) = 2 + (3 - 1)",
  "args": ""},
 {"type": "0 - 0 = 0",
  "tactic-prompt": "example  : 0 - 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 0 - 0 = 0",
  "args": ""},
 {"type": "100 - 100 = 0",
  "tactic-prompt": "example  : 100 - 100 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 100 - 100 = 0",
  "args": ""},
 {"type": "5 * (2 - 3) = 0",
  "tactic-prompt": "example  : 5 * (2 - 3) = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 5 * (2 - 3) = 0",
  "args": ""},
 {"type": "10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "tactic-prompt":
  "example  : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 10 - 5 * 5 + (7 - 3) * 6 = 27 - 3",
  "args": ""},
 {"type": "foo = 1",
  "tactic-prompt": "example  : foo = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : foo = 1",
  "args": ""},
 {"type": "(1 + 0 : Î±) = (0 + 1 : Î±)",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (1 + 0 : Î±) = (0 + 1 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (1 + 0 : Î±) = (0 + 1 : Î±)",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(0 + (2 + 3) + 1 : Î±) = 6",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (0 + (2 + 3) + 1 : Î±) = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (0 + (2 + 3) + 1 : Î±) = 6",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(70 * (33 + 2) : Î±) = 2450",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (70 * (33 + 2) : Î±) = 2450 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (70 * (33 + 2) : Î±) = 2450",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(8 + 2 ^ 2 * 3 : Î±) = 20",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : (8 + 2 ^ 2 * 3 : Î±) = 20 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "(Î± : Type u)  [Semiring Î±] : (8 + 2 ^ 2 * 3 : Î±) = 20",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±)",
  "tactic-prompt":
  "example (Î± : Type u)  [Semiring Î±] : ((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "(Î± : Type u)  [Semiring Î±] : ((2 * 1 + 1) ^ 2 : Î±) = (3 * 3 : Î±)",
  "args": "(Î± : Type u)  [Semiring Î±]"},
 {"type": "(-1 : Î±) * 1 = -1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-1 : Î±) * 1 = -1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-1 : Î±) * 1 = -1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * 1 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * 1 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * 1 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * -1 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * -1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * -1 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(-2 : Î±) * -2 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (-2 : Î±) * -2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (-2 : Î±) * -2 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "((1 : Î±) + 1) * 5 = 6 + 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : ((1 : Î±) + 1) * 5 = 6 + 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : ((1 : Î±) + 1) * 5 = 6 + 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) = 0 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) = 0 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) = 0 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) = 1 + 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) = 1 + 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) = 1 + 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) = 1 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) = 1 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) = 1 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) = 0 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) = 0 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) = 0 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) = 1 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) = 1 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) = 1 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) = 2 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) = 2 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) = 2 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) = 3 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) = 3 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) = 3 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) = 2 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) = 2 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) = 2 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 4 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 4 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 4 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 3 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 3 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 3 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(5 : Î±) = 2 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (5 : Î±) = 2 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (5 : Î±) = 2 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 0 + 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 0 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 0 + 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 3 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 3 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 3 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 4 + 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 4 + 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 4 + 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(6 : Î±) = 5 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (6 : Î±) = 5 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (6 : Î±) = 5 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 4 + 3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 4 + 3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 4 + 3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 1 + 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 1 + 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 1 + 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(7 : Î±) = 6 + 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (7 : Î±) = 6 + 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (7 : Î±) = 6 + 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "33 = 5 + (28 : Î±)",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : 33 = 5 + (28 : Î±) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : 33 = 5 + (28 : Î±)",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) = 0 + (2 + 3) + 7",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) = 0 + (2 + 3) + 7 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) = 0 + (2 + 3) + 7",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(105 : Î±) = 70 + (33 + 2)",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (105 : Î±) = 70 + (33 + 2) := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (105 : Î±) = 70 + (33 + 2)",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(45000000000 : Î±) = 23000000000 + 22000000000",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (45000000000 : Î±) = 23000000000 + 22000000000 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt":
  "{Î± : Type} [Ring Î±] : (45000000000 : Î±) = 23000000000 + 22000000000",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 2 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 2 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 2 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) - 3 = -2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) - 3 = -2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) - 3 = -2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) - 1 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) - 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) - 1 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) - 3 = -3",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) - 3 = -3",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) - 4 - (5 + -2) = 5",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) = 5 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) = 5",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(12 : Î±) - 4 - (5 + -2) - 20 = -15",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) - 20 = -15 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (12 : Î±) - 4 - (5 + -2) - 20 = -15",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 1 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 1 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 1 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(0 : Î±) * 2 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (0 : Î±) * 2 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (0 : Î±) * 2 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 0 = 0",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 0 = 0",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 1 = 1",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 1 = 1",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 1 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 1 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 1 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 2 = 2",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 2 = 2 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 2 = 2",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 2 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 2 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 2 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 2 = 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 2 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 2 = 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(2 : Î±) * 3 = 6",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (2 : Î±) * 3 = 6 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (2 : Î±) * 3 = 6",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) * 1 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) * 1 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) * 1 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(1 : Î±) * 4 = 4",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (1 : Î±) * 4 = 4 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (1 : Î±) * 4 = 4",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 3 = 9",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 3 = 9 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 3 = 9",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(3 : Î±) * 4 = 12",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (3 : Î±) * 4 = 12 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (3 : Î±) * 4 = 12",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(4 : Î±) * 4 = 16",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (4 : Î±) * 4 = 16 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (4 : Î±) * 4 = 16",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(11 : Î±) * 2 = 22",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (11 : Î±) * 2 = 22 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (11 : Î±) * 2 = 22",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(15 : Î±) * 6 = 90",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (15 : Î±) * 6 = 90 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (15 : Î±) * 6 = 90",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "(123456 : Î±) * 123456 = 15241383936",
  "tactic-prompt":
  "example {Î± : Type} [Ring Î±] : (123456 : Î±) * 123456 = 15241383936 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": "{Î± : Type} [Ring Î±] : (123456 : Î±) * 123456 = 15241383936",
  "args": "{Î± : Type} [Ring Î±]"},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by norm_num; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_num",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "x â‰¤ 57",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ [0, 2, 37]) : x â‰¤ 57 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ [0, 2, 37]) : x â‰¤ 57",
  "args": "{x : Nat}  (h : x âˆˆ [0, 2, 37])"},
 {"type": "x = 0 âˆ¨ x = 2 âˆ¨ x = 37",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ [0, 2, 37]) : x = 0 âˆ¨ x = 2 âˆ¨ x = 37 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ [0, 2, 37]) : x = 0 âˆ¨ x = 2 âˆ¨ x = 37",
  "args": "{x : Nat}  (h : x âˆˆ [0, 2, 37])"},
 {"type": "x â‰¤ 4",
  "tactic-prompt":
  "example {x : Nat}  (h : x âˆˆ List.range 5) : x â‰¤ 4 := by fin_cases h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases h",
  "core-prompt": "{x : Nat}  (h : x âˆˆ List.range 5) : x â‰¤ 4",
  "args": "{x : Nat}  (h : x âˆˆ List.range 5)"},
 {"type": "p i",
  "tactic-prompt":
  "example {p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i) : p i := by fin_cases i; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases i",
  "core-prompt": "{p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i) : p i",
  "args": "{p : Fin 4 â†’ Prop}  (i : Fin 4)  (h : p i)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt":
  "(f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2) : f p.val",
  "args": "(f : Nat â†’ Prop)  (p : Fin 3)  (h0 : f 0)  (h1 : f 1)  (h2 : f 2)"},
 {"type": "f p.val",
  "tactic-prompt":
  "example (f : Nat â†’ Prop)  (p : Fin 0) : f p.val := by fin_cases p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases p",
  "core-prompt": "(f : Nat â†’ Prop)  (p : Fin 0) : f p.val",
  "args": "(f : Nat â†’ Prop)  (p : Fin 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3) : True := by fin_cases x2, x3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2, x3",
  "core-prompt": "(x2 : Fin 2)  (x3 : Fin 3) : True",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)"},
 {"type": "x2.val * x3.val = x3.val * x2.val",
  "tactic-prompt":
  "example (x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val := by fin_cases x2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fin_cases x2",
  "core-prompt":
  "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n) : x2.val * x3.val = x3.val * x2.val",
  "args": "(x2 : Fin 2)  (x3 : Fin 3)  (n : Nat)  (y : Fin n)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f) : True := by casesm* _âˆ¨_, _âˆ§_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ¨_, _âˆ§_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ§ d)  (h2 : e âˆ§ f)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ§ d) : True := by casesm* _âˆ§_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ§_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ§ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ§ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by casesm* _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm* _âˆ¨_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt": "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by casesm _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "casesm _âˆ¨_",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type And; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type And",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type* Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type* Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ¨ c âˆ¨ d) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a âˆ§ b âˆ¨ c âˆ¨ d) : True",
  "args": "(h : a âˆ§ b âˆ¨ c âˆ¨ d)"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True := by cases_type! And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type! And Or",
  "core-prompt": "(h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True",
  "args": "(h : a âˆ§ b âˆ§ (c âˆ¨ d))"},
 {"type": "True",
  "tactic-prompt":
  "example (h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True := by cases_type!* And Or; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases_type!* And Or",
  "core-prompt": "(h : a âˆ§ b âˆ§ (c âˆ¨ d)) : True",
  "args": "(h : a âˆ§ b âˆ§ (c âˆ¨ d))"},
 {"type": "True âˆ§ True âˆ§ True",
  "tactic-prompt":
  "example  : True âˆ§ True âˆ§ True := by constructorm True, _âˆ¨_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructorm True, _âˆ¨_",
  "core-prompt": " : True âˆ§ True âˆ§ True",
  "args": ""},
 {"type": "P",
  "tactic-prompt": "example (P : Prop)  (h : P) : P := by convert h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert h",
  "core-prompt": "(P : Prop)  (h : P) : P",
  "args": "(P : Prop)  (h : P)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Î± := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²) : Î± := by convert b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert b",
  "core-prompt": "(Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²) : Î±",
  "args": "(Î± Î² : Type)  (h : âˆ€ Î± Î² : Type, Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Î± := by convert (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î² = Î±)  (b : Î²) : Nat Ã— Î± := by convert â† (37, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert â† (37, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î² = Î±)  (b : Î²) : Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î² = Î±)  (b : Î²)"},
 {"type": "Nat Ã— Nat Ã— Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î± := by convert (37, 57, 2, b); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b)",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "Nat Ã— Nat Ã— Nat Ã— Î±",
  "tactic-prompt":
  "example (Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î± := by convert (37, 57, 2, b) using 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "convert (37, 57, 2, b) using 3",
  "core-prompt": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²) : Nat Ã— Nat Ã— Nat Ã— Î±",
  "args": "(Î± Î² : Type)  (h : Î± = Î²)  (b : Î²)"},
 {"type": "bar0 3 4 = 7",
  "tactic-prompt": "theorem  : bar0 3 4 = 7 := by decide; sorry",
  "name": "bar0_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar0 3 4 = 7",
  "args": ""},
 {"type": "foo1 3 4 = Nat.pow 3 4",
  "tactic-prompt": "theorem  : foo1 3 4 = Nat.pow 3 4 := by decide; sorry",
  "name": "foo1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo1 3 4 = Nat.pow 3 4",
  "args": ""},
 {"type": "bar1 3 4 = 3 * 4",
  "tactic-prompt": "theorem  : bar1 3 4 = 3 * 4 := by decide; sorry",
  "name": "bar1_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar1 3 4 = 3 * 4",
  "args": ""},
 {"type": "foo2 2 3 (PLift.up 2) = Nat.pow 2 0",
  "tactic-prompt":
  "theorem  : foo2 2 3 (PLift.up 2) = Nat.pow 2 0 := by decide; sorry",
  "name": "foo2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo2 2 3 (PLift.up 2) = Nat.pow 2 0",
  "args": ""},
 {"type": "bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3)",
  "tactic-prompt":
  "theorem  : bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3) := by decide; sorry",
  "name": "bar2_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt":
  " : bar2 2 3 (PLift.up 2) =  2 * (dummy_smul.1 (PLift.up 2) 3)",
  "args": ""},
 {"type": "foo3 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo3 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo3 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar3 2 3 =  2 * 3",
  "tactic-prompt": "theorem  : bar3 2 3 =  2 * 3 := by decide; sorry",
  "name": "bar3_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : bar3 2 3 =  2 * 3",
  "args": ""},
 {"type": "foo7 2 3 = Nat.pow 2 3",
  "tactic-prompt": "theorem  : foo7 2 3 = Nat.pow 2 3 := by decide; sorry",
  "name": "foo7_works",
  "kind": "theorem",
  "first-tactic": "decide",
  "core-prompt": " : foo7 2 3 = Nat.pow 2 3",
  "args": ""},
 {"type": "bar7 2 3 =  2 * 3",
  "tactic-prompt":
  "theorem  : bar7 2 3 =  2 * 3 := by decide\n\n/- test the eta-expansion applied on `foo6`. -/; sorry",
  "name": "bar7_works",
  "kind": "theorem",
  "first-tactic": "decide\n\n/- test the eta-expansion applied on `foo6`. -/",
  "core-prompt": " : bar7 2 3 =  2 * 3",
  "args": ""},
 {"type": "true",
  "tactic-prompt":
  "def {I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L] : true := by trivial; sorry",
  "name": "foo_mul",
  "kind": "def",
  "first-tactic": "trivial",
  "core-prompt":
  "{I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L] : true",
  "args":
  "{I J K : Type}  (n : â„•)  {f : I â†’ Type}  (L : Type)  [âˆ€ i, One (f i)]    [Add I]  [Mul L]"},
 {"type": "One ((x : Nat) â†’ Î±)",
  "tactic-prompt":
  "def {Î± : Type}  [One Î±] : One ((x : Nat) â†’ Î±) := by infer_instance; sorry",
  "name": "nat_pi_has_one",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt": "{Î± : Type}  [One Î±] : One ((x : Nat) â†’ Î±)",
  "args": "{Î± : Type}  [One Î±]"},
 {"type": "true",
  "tactic-prompt": "example  : true := by guard_hyp_nums 1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "guard_hyp_nums 1",
  "core-prompt": " : true",
  "args": ""},
 {"type": "Int Ã— Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int Ã— Nat := by rename' a => c, b => d; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => c, b => d",
  "core-prompt": "(a : Nat)  (b : Int) : Int Ã— Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "Int Ã— Nat",
  "tactic-prompt":
  "example (a : Nat)  (b : Int) : Int Ã— Nat := by rename' a => b, b => a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rename' a => b, b => a",
  "core-prompt": "(a : Nat)  (b : Int) : Int Ã— Nat",
  "args": "(a : Nat)  (b : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    let t : Option Bool := (â† Lean.MonadOptions.getOptions).get? `pp.all",
  "core-prompt": " : True",
  "args": ""},
 {"type": "False â†’ Î±",
  "tactic-prompt": "example  : False â†’ Î± := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : False â†’ Î±",
  "args": ""},
 {"type": "Â¬ False",
  "tactic-prompt": "example  : Â¬ False := by intro.; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro.",
  "core-prompt": " : Â¬ False",
  "args": ""},
 {"type": "P âˆ§ Q",
  "tactic-prompt":
  "example {P Q : Prop}  (q : P)  (p : Q) : P âˆ§ Q := by swap_var p â†” q; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "swap_var p â†” q",
  "core-prompt": "{P Q : Prop}  (q : P)  (p : Q) : P âˆ§ Q",
  "args": "{P Q : Prop}  (q : P)  (p : Q)"},
 {"type": "frobnicate a 0 = a",
  "tactic-prompt":
  "example  : frobnicate a 0 = a := by simp [frobnicate_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp [frobnicate_def]",
  "core-prompt": " : frobnicate a 0 = a",
  "args": ""},
 {"type": "withUniv.{u, v} = (Type v, Type u)",
  "tactic-prompt":
  "example  : withUniv.{u, v} = (Type v, Type u) := by rw [withUniv_def]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [withUniv_def]",
  "core-prompt": " : withUniv.{u, v} = (Type v, Type u)",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := {}) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := {}) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := { newGoals := .nonDependentOnly }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .nonDependentOnly }) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "Î±",
  "tactic-prompt":
  "example (f : âˆ€ x : Nat, x = x â†’ Î±) : Î± := by apply (config := { newGoals := .all }) f; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply (config := { newGoals := .all }) f",
  "core-prompt": "(f : âˆ€ x : Nat, x = x â†’ Î±) : Î±",
  "args": "(f : âˆ€ x : Nat, x = x â†’ Î±)"},
 {"type": "P",
  "tactic-prompt":
  "example (p : P) : P := by expect_failure_msg \"unknown identifier 'x'\" have h := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "expect_failure_msg \"unknown identifier 'x'\" have h := x",
  "core-prompt": "(p : P) : P",
  "args": "(p : P)"},
 {"type": "x + 0 = y â†’ x = y",
  "tactic-prompt": "example  : x + 0 = y â†’ x = y := by simp_intro hâ‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚",
  "core-prompt": " : x + 0 = y â†’ x = y",
  "args": ""},
 {"type": "x + 0 â‰  y â†’ x â‰  y",
  "tactic-prompt": "example  : x + 0 â‰  y â†’ x â‰  y := by simp_intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚ hâ‚‚",
  "core-prompt": " : x + 0 â‰  y â†’ x â‰  y",
  "args": ""},
 {"type": "x + 0 â‰  y â†’ x â‰  y",
  "tactic-prompt":
  "example  : x + 0 â‰  y â†’ x â‰  y := by simp_intro hâ‚ hâ‚‚ hâ‚ƒ; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro hâ‚ hâ‚‚ hâ‚ƒ",
  "core-prompt": " : x + 0 â‰  y â†’ x â‰  y",
  "args": ""},
 {"type": "x + 0 = y â†’ x = z",
  "tactic-prompt":
  "example (h : x = z) : x + 0 = y â†’ x = z := by simp_intro [h]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro [h]",
  "core-prompt": "(h : x = z) : x + 0 = y â†’ x = z",
  "args": "(h : x = z)"},
 {"type": "x + 0 = y â†’ x = z",
  "tactic-prompt":
  "example (h : y = z) : x + 0 = y â†’ x = z := by simp_intro _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_intro _",
  "core-prompt": "(h : y = z) : x + 0 = y â†’ x = z",
  "args": "(h : y = z)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace 2 + 2 + 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace 2 + 2 + 3",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by trace \"hello\" ++ \" world\"; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trace \"hello\" ++ \" world\"",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example (_delete_this : Nat) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat) : Nat",
  "args": "(_delete_this : Nat)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [_dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "[_dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[_dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt": "(_delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(_delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep) : Nat",
  "args":
  "(_delete_this : Type)  (_delete_this_dep : _delete_this)  (_delete_this_rw : _delete_this = Nat)    (_delete_this_dep_dep : _delete_this_dep = _delete_this_dep)"},
 {"type": "_dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (dep : _dont_delete_this) : _dont_delete_this",
  "args": "(_dont_delete_this : Type)  (dep : _dont_delete_this)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type) : _dont_delete_this = _dont_delete_this",
  "args": "(_dont_delete_this : Type)"},
 {"type": "_dont_delete_this = _dont_delete_this",
  "tactic-prompt":
  "example (_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this := by clear_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear_",
  "core-prompt":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this) : _dont_delete_this = _dont_delete_this",
  "args":
  "(_dont_delete_this : Type)  (_delete_this : _dont_delete_this = _dont_delete_this)"},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by existsi 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "tactic-prompt":
  "example  : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by existsi 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "existsi 42, 42",
  "core-prompt": " : âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "args": ""},
 {"type": "âˆ€ a b : Nat, a = b â†’ b = a",
  "tactic-prompt":
  "example  : âˆ€ a b : Nat, a = b â†’ b = a := by introv h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "introv h",
  "core-prompt": " : âˆ€ a b : Nat, a = b â†’ b = a",
  "args": ""},
 {"type": "n = n",
  "tactic-prompt": "example (n : Nat) : n = n := by induction n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction n",
  "core-prompt": "(n : Nat) : n = n",
  "args": "(n : Nat)"},
 {"type": "a â‰  b â†’ Â¬ a = b",
  "tactic-prompt": "example (a b : Nat) : a â‰  b â†’ Â¬ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a â‰  b â†’ Â¬ a = b",
  "args": "(a b : Nat)"},
 {"type": "Â¬Â¬ a = b â†’ a = b",
  "tactic-prompt": "example (a b : Nat) : Â¬Â¬ a = b â†’ a = b := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : Â¬Â¬ a = b â†’ a = b",
  "args": "(a b : Nat)"},
 {"type": "Â¬Â¬ p â†’ p",
  "tactic-prompt": "example (p q : Prop) : Â¬Â¬ p â†’ p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : Â¬Â¬ p â†’ p",
  "args": "(p q : Prop)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Unit",
  "tactic-prompt": "example (n m : Nat) : Unit := by cases n; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases n",
  "core-prompt": "(n m : Nat) : Unit",
  "args": "(n m : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (n : Nat) : Nat := by iterate exact (); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "iterate exact ()",
  "core-prompt": "(n : Nat) : Nat",
  "args": "(n : Nat)"},
 {"type": "p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q)",
  "tactic-prompt":
  "example (p q r s : Prop) : p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt":
  "(p q r s : Prop) : p â†’ q â†’ r â†’ s â†’ (p âˆ§ q) âˆ§ (r âˆ§ s âˆ§ p) âˆ§ (p âˆ§ r âˆ§ q)",
  "args": "(p q r s : Prop)"},
 {"type": "p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p)",
  "tactic-prompt":
  "example (p q : Prop) : p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p) := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p q : Prop) : p â†’ q â†’ (p âˆ§ q) âˆ§ (p âˆ§ q âˆ§ p)",
  "args": "(p q : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop) : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]  (dont_delete_this2 : Prop)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat := by clear * - dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : delete_this = delete_this)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat := by clear * - dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this2",
  "core-prompt":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (dont_delete_this2 : dont_delete_this = dont_delete_this)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat := by clear * - dont_delete_this dont_delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear * - dont_delete_this dont_delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int) : Nat",
  "args":
  "(delete_this : Nat)  (dont_delete_this : Int)  (dont_delete_this2 : Int)"},
 {"type": "(Î± : Type) Ã— List Î±",
  "tactic-prompt": "example  : (Î± : Type) Ã— List Î± := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (Î± : Type) Ã— List Î±",
  "args": ""},
 {"type": "true âˆ§ true",
  "tactic-prompt": "example  : true âˆ§ true := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : true âˆ§ true",
  "args": ""},
 {"type": "(true âˆ§ true) âˆ§ (true âˆ§ true)",
  "tactic-prompt":
  "example  : (true âˆ§ true) âˆ§ (true âˆ§ true) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (true âˆ§ true) âˆ§ (true âˆ§ true)",
  "args": ""},
 {"type": "x = if p then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x := by split_ifs with h1; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if p then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "x = y",
  "tactic-prompt":
  "example (x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x) : x = y",
  "args":
  "(x y : Nat)  (p : Prop)  [Decidable p]  (h : if p then x = y else y = x)"},
 {"type": "x = if p then (if q then x else x) else x",
  "tactic-prompt":
  "example (x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q] : x = if p then (if q then x else x) else x",
  "args": "(x : Nat)  (p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "x = if (if p then False else True) then x else x",
  "tactic-prompt":
  "example (x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(x : Nat)  (p : Prop)  [Decidable p] : x = if (if p then False else True) then x else x",
  "args": "(x : Nat)  (p : Prop)  [Decidable p]"},
 {"type": "if if Â¬p then p else True then p else Â¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p := by split_ifs with h1 h2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q := by split_ifs with h1 h2 h3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs with h1 h2 h3",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "False",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False := by split_ifs at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at h",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3) : False",
  "args": "(p : Prop)  [Decidable p]  (h : (if p then 1 else 2) > 3)"},
 {"type": "x < (if Â¬p then 1 else 0) + 1",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if Â¬p then 1 else 0) + 1 := by split_ifs at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs at *",
  "core-prompt":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x) : x < (if Â¬p then 1 else 0) + 1",
  "args":
  "(p : Prop)  [Decidable p]  (x : Nat)  (h : (if p then 1 else 2) > x)"},
 {"type": "if if Â¬p then p else True then p else Â¬p",
  "tactic-prompt":
  "example (p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p : Prop)  [Decidable p] : if if Â¬p then p else True then p else Â¬p",
  "args": "(p : Prop)  [Decidable p]"},
 {"type": "if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "tactic-prompt":
  "example (p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q := by split_ifs; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "split_ifs",
  "core-prompt":
  "(p q : Prop)  [Decidable p]  [Decidable q] : if if if p then Â¬p else q then p else q then q else Â¬p âˆ¨ Â¬q",
  "args": "(p q : Prop)  [Decidable p]  [Decidable q]"},
 {"type": "True",
  "tactic-prompt": "example  : True := by fail_if_success { split_ifs }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { split_ifs }",
  "core-prompt": " : True",
  "args": ""},
 {"type": "a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e)"},
 {"type": "a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "tactic-prompt":
  "example {a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e := by apply_rules [add_le_add]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [add_le_add]",
  "core-prompt":
  "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e) : a + c * e + a + c + 0 â‰¤ b + d * e + b + d + e",
  "args": "{a b c d e : Nat}  (h1 : a â‰¤ b)  (h2 : c â‰¤ d)  (h3 : 0 â‰¤ e)"},
 {"type": "P 2",
  "tactic-prompt":
  "example (P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0) : P 2 := by apply_rules [f]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [f]",
  "core-prompt":
  "(P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0) : P 2",
  "args": "(P : Nat â†’ Type)  (f : {n : Nat} â†’ P n â†’ P (n + 1))  (g : P 0)"},
 {"type": "Int Ã— Q",
  "tactic-prompt":
  "example (Q : Type)  (f : Nat â†’ Q) : Int Ã— Q := by apply_rules [Prod.mk]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply_rules [Prod.mk]",
  "core-prompt": "(Q : Type)  (f : Nat â†’ Q) : Int Ã— Q",
  "args": "(Q : Type)  (f : Nat â†’ Q)"},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by left; sorry",
  "name": "zero",
  "kind": "def",
  "first-tactic": "left",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def  : Nat := by right; sorry",
  "name": "two",
  "kind": "def",
  "first-tactic": "right",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "Sum Nat (List Nat)",
  "tactic-prompt": "example  : Sum Nat (List Nat) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : Sum Nat (List Nat)",
  "args": ""},
 {"type": "(1 = 1) âˆ¨ (2 = 3)",
  "tactic-prompt": "example  : (1 = 1) âˆ¨ (2 = 3) := by left; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "left",
  "core-prompt": " : (1 = 1) âˆ¨ (2 = 3)",
  "args": ""},
 {"type": "(1 = 2) âˆ¨ (3 = 3)",
  "tactic-prompt": "example  : (1 = 2) âˆ¨ (3 = 3) := by right; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "right",
  "core-prompt": " : (1 = 2) âˆ¨ (3 = 3)",
  "args": ""},
 {"type": "p",
  "tactic-prompt":
  "example (p : Prop)  (h : p) : p := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p : Prop)  (h : p) : p",
  "args": "(p : Prop)  (h : p)"},
 {"type": "p â†’ q",
  "tactic-prompt":
  "example (p q : Type)  (h : p â†’ q) : p â†’ q := by fail_if_success { contrapose }; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success { contrapose }",
  "core-prompt": "(p q : Type)  (h : p â†’ q) : p â†’ q",
  "args": "(p q : Type)  (h : p â†’ q)"},
 {"type": "a = b â†’ b = a",
  "tactic-prompt": "example (a b : Nat) : a = b â†’ b = a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : a = b â†’ b = a",
  "args": "(a b : Nat)"},
 {"type": "a = b â†’ True â†’ b = a",
  "tactic-prompt":
  "example (a b : Nat) : a = b â†’ True â†’ b = a := by intro h _; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h _",
  "core-prompt": "(a b : Nat) : a = b â†’ True â†’ b = a",
  "args": "(a b : Nat)"},
 {"type": "sameParity a b â†’ sameParity b a",
  "tactic-prompt":
  "example (a b : Nat) : sameParity a b â†’ sameParity b a := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b : Nat) : sameParity a b â†’ sameParity b a",
  "args": "(a b : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by run_tac\n    evalApplyLikeTactic MVarId.apply (â† `(True.intro)); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "run_tac\n    evalApplyLikeTactic MVarId.apply (â† `(True.intro))",
  "core-prompt": " : True",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "def (h : Nat) : Nat := by solve_by_elim; sorry",
  "name": "test1",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Î²",
  "tactic-prompt":
  "def {Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim; sorry",
  "name": "test2",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î²",
  "tactic-prompt":
  "def {Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î² := by solve_by_elim; sorry",
  "name": "test3",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±) : Î²",
  "args": "{Î± Î² : Type}  (f : Î± â†’ Î± â†’ Î²)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "def {Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³ := by solve_by_elim; sorry",
  "name": "test4",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±) : Î³",
  "args": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (a : Î±)"},
 {"type": "Î³",
  "tactic-prompt":
  "def {Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³ := by solve_by_elim; sorry",
  "name": "test5",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²) : Î³",
  "args": "{Î± Î² Î³ : Type}  (f : Î± â†’ Î²)  (g : Î² â†’ Î³)  (b : Î²)"},
 {"type": "Î± 5",
  "tactic-prompt":
  "def {Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5 := by solve_by_elim; sorry",
  "name": "test6",
  "kind": "def",
  "first-tactic": "solve_by_elim",
  "core-prompt":
  "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0) : Î± 5",
  "args": "{Î± : Nat â†’ Type}  (f : (n : Nat) â†’ Î± n â†’ Î± (n+1))  (a : Î± 0)"},
 {"type": "x + y = y + x",
  "tactic-prompt":
  "example (x y : Nat) : x + y = y + x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(x y : Nat) : x + y = y + x",
  "args": "(x y : Nat)"},
 {"type": "n â‰¤ m â†’ n + k â‰¤ m + k",
  "tactic-prompt":
  "example (n m k : Nat) : n â‰¤ m â†’ n + k â‰¤ m + k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : Nat) : n â‰¤ m â†’ n + k â‰¤ m + k",
  "args": "(n m k : Nat)"},
 {"type": "a * b âˆ£ a * c",
  "tactic-prompt":
  "example (ha : a > 0)  (w : b âˆ£ c) : a * b âˆ£ a * c := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(ha : a > 0)  (w : b âˆ£ c) : a * b âˆ£ a * c",
  "args": "(ha : a > 0)  (w : b âˆ£ c)"},
 {"type": "Int",
  "tactic-prompt": "example  : Int := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : Int",
  "args": ""},
 {"type": "P",
  "tactic-prompt":
  "example (P : Prop)  (p : P) : P := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P) : P",
  "args": "(P : Prop)  (p : P)"},
 {"type": "false",
  "tactic-prompt":
  "example (P : Prop)  (p : P)  (np : Â¬P) : false := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(P : Prop)  (p : P)  (np : Â¬P) : false",
  "args": "(P : Prop)  (p : P)  (np : Â¬P)"},
 {"type": "Î± â†’ Î±",
  "tactic-prompt": "example (Î± : Prop) : Î± â†’ Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(Î± : Prop) : Î± â†’ Î±",
  "args": "(Î± : Prop)"},
 {"type": "(Â¬Â¬p) â†’ p",
  "tactic-prompt": "example (p : Prop) : (Â¬Â¬p) â†’ p := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(p : Prop) : (Â¬Â¬p) â†’ p",
  "args": "(p : Prop)"},
 {"type": "a + b = b + a",
  "tactic-prompt":
  "example (a b : â„•) : a + b = b + a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : â„•) : a + b = b + a",
  "args": "(a b : â„•)"},
 {"type": "n * (m - k) = n * m - n * k",
  "tactic-prompt":
  "example (n m k : â„•) : n * (m - k) = n * m - n * k := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(n m k : â„•) : n * (m - k) = n * m - n * k",
  "args": "(n m k : â„•)"},
 {"type": "x = y â†” y = x",
  "tactic-prompt":
  "example {Î± : Type}  (x y : Î±) : x = y â†” y = x := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Type}  (x y : Î±) : x = y â†” y = x",
  "args": "{Î± : Type}  (x y : Î±)"},
 {"type": "a â‰¤ b",
  "tactic-prompt":
  "example (a b : â„•)  (h : a âˆ£ b)  (w : b > 0) : a â‰¤ b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : â„•)  (h : a âˆ£ b)  (w : b > 0) : a â‰¤ b",
  "args": "(a b : â„•)  (h : a âˆ£ b)  (w : b > 0)"},
 {"type": "Â¬ (a < 0)",
  "tactic-prompt": "example (a : â„•) : Â¬ (a < 0) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : â„•) : Â¬ (a < 0)",
  "args": "(a : â„•)"},
 {"type": "0 > a",
  "tactic-prompt": "theorem (a : â„•)  (h : P a) : 0 > a := by cases h; sorry",
  "name": "lemma_with_gt_in_head",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt": "(a : â„•)  (h : P a) : 0 > a",
  "args": "(a : â„•)  (h : P a)"},
 {"type": "False",
  "tactic-prompt":
  "theorem (a b : â„•)  (h1 : a < b)  (h2 : P a) : False := by apply Nat.not_lt_zero; sorry",
  "name": "lemma_with_false_in_head",
  "kind": "theorem",
  "first-tactic": "apply Nat.not_lt_zero",
  "core-prompt": "(a b : â„•)  (h1 : a < b)  (h2 : P a) : False",
  "args": "(a b : â„•)  (h1 : a < b)  (h2 : P a)"},
 {"type": "0 > a",
  "tactic-prompt":
  "example (a : â„•)  (h : P a) : 0 > a := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a : â„•)  (h : P a) : 0 > a",
  "args": "(a : â„•)  (h : P a)"},
 {"type": "âˆ€ P : Prop, Â¬(P â†” Â¬P)",
  "tactic-prompt":
  "example  : âˆ€ P : Prop, Â¬(P â†” Â¬P) := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": " : âˆ€ P : Prop, Â¬(P â†” Â¬P)",
  "args": ""},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Sort u}  (h : Empty) : Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Sort u}  (h : Empty) : Î±",
  "args": "{Î± : Sort u}  (h : Empty)"},
 {"type": "Î±",
  "tactic-prompt":
  "example {Î± : Type _}  (h : Empty) : Î± := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "{Î± : Type _}  (h : Empty) : Î±",
  "args": "{Î± : Type _}  (h : Empty)"},
 {"type": "f a â‰¤ f b",
  "tactic-prompt":
  "example (a b : â„•)  (h : a â‰¤ b) : f a â‰¤ f b := by library_search; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "library_search",
  "core-prompt": "(a b : â„•)  (h : a â‰¤ b) : f a â‰¤ f b",
  "args": "(a b : â„•)  (h : a â‰¤ b)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this_dep : delete_this = delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(delete_this : Nat)  (delete_this_dep : delete_this = delete_this) : Nat",
  "args": "(delete_this : Nat)  (delete_this_dep : delete_this = delete_this)"},
 {"type": "Inhabited Nat",
  "tactic-prompt":
  "example [dont_delete_this : Inhabited Nat] : Inhabited Nat := by clear! dont_delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! dont_delete_this",
  "core-prompt": "[dont_delete_this : Inhabited Nat] : Inhabited Nat",
  "args": "[dont_delete_this : Inhabited Nat]"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2) : Nat := by clear! delete_this delete_this2; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this delete_this2",
  "core-prompt":
  "(delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2) : Nat",
  "args":
  "(delete_this : Nat)  (delete_this2 : Nat)  (delete_this_dep : delete_this = delete_this2)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (delete_this : Nat)  (dont_delete_this : Int) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt": "(delete_this : Nat)  (dont_delete_this : Int) : Nat",
  "args": "(delete_this : Nat)  (dont_delete_this : Int)"},
 {"type": "Nat",
  "tactic-prompt":
  "example (dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat := by clear! delete_this; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "clear! delete_this",
  "core-prompt":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this) : Nat",
  "args":
  "(dont_delete_this : Nat)  (delete_this : dont_delete_this = dont_delete_this)"},
 {"type": "foo.rfl.toFun n = n",
  "tactic-prompt":
  "example (n : â„•) : foo.rfl.toFun n = n := by rw [foo.rfl_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo.rfl_toFun]",
  "core-prompt": "(n : â„•) : foo.rfl.toFun n = n",
  "args": "(n : â„•)"},
 {"type": "foo.rfl.invFun n = n",
  "tactic-prompt":
  "example (n : â„•) : foo.rfl.invFun n = n := by rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/; sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "rw [foo.rfl_invFun]\n\n/- the declarations are `simp` lemmas -/",
  "core-prompt": "(n : â„•) : foo.rfl.invFun n = n",
  "args": "(n : â„•)"},
 {"type": "foo.1 = 1",
  "tactic-prompt": "example  : foo.1 = 1 := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": " : foo.1 = 1",
  "args": ""},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : â„•}  {h : 1 = a} : foo.1 = a := by rw [foo_fst]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rw [foo_fst]",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt": "example {a : â„•}  {h : 1 = a} : foo.1 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt": "example {a : â„¤}  {h : 2 = a} : foo.2 = a := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "{a : â„¤}  {h : 2 = a} : foo.2 = a",
  "args": "{a : â„¤}  {h : 2 = a}"},
 {"type": "foo.1 = a",
  "tactic-prompt":
  "example {a : â„•}  {h : 1 = a} : foo.1 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : â„•}  {h : 1 = a} : foo.1 = a",
  "args": "{a : â„•}  {h : 1 = a}"},
 {"type": "foo.2 = a",
  "tactic-prompt":
  "example {a : â„¤}  {h : 2 = a} : foo.2 = a := by dsimp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp",
  "core-prompt": "{a : â„¤}  {h : 2 = a} : foo.2 = a",
  "args": "{a : â„¤}  {h : 2 = a}"},
 {"type": "(f.trans g).toFun x = z",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z := by dsimp only [Equiv'.trans_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv'.trans_toFun]",
  "core-prompt":
  "{Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z) : (f.trans g).toFun x = z",
  "args":
  "{Î± Î² Î³ : Type}  (f : Î± â‰ƒ Î²)  (g : Î² â‰ƒ Î³)  (x : Î±)  {z : Î³}  (h : g.toFun (f.toFun x) = z)"},
 {"type": "myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "tactic-prompt":
  "example (n : â„•) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n := by simp only [myNatEquiv_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [myNatEquiv_toFun]",
  "core-prompt":
  "(n : â„•) : myNatEquiv.toFun (myNatEquiv.toFun $ myNatEquiv.invFun n) = n",
  "args": "(n : â„•)"},
 {"type": "(X âŸ¶ X) = x",
  "tactic-prompt":
  "example (X : Type u)  {x : Type u}  (h : (X â†’ X) = x) : (X âŸ¶ X) = x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(X : Type u)  {x : Type u}  (h : (X â†’ X) = x) : (X âŸ¶ X) = x",
  "args": "(X : Type u)  {x : Type u}  (h : (X â†’ X) = x)"},
 {"type": "ðŸ™ X = f",
  "tactic-prompt":
  "example (X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x) : ðŸ™ X = f := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt": "(X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x) : ðŸ™ X = f",
  "args": "(X : Type u)  {f : X â†’ X}  (h : âˆ€ x, f x = x)"},
 {"type": "f â‰« g = k",
  "tactic-prompt":
  "example (X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x) : f â‰« g = k := by ext; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ext",
  "core-prompt":
  "(X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x) : f â‰« g = k",
  "args":
  "(X Y Z : Type u)  (f : X âŸ¶ Y)  (g : Y âŸ¶ Z)  {k : X â†’ Z}  (h : âˆ€ x, g (f x) = k x)"},
 {"type": "foo = x",
  "tactic-prompt":
  "example {x : Type}  (h : â„• = x) : foo = x := by simp only [foo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_c]",
  "core-prompt": "{x : Type}  (h : â„• = x) : foo = x",
  "args": "{x : Type}  (h : â„• = x)"},
 {"type": "foo.x = x",
  "tactic-prompt":
  "example {x : â„•}  (h : (3 : â„•) = x) : foo.x = x := by simp only [foo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [foo_x]",
  "core-prompt": "{x : â„•}  (h : (3 : â„•) = x) : foo.x = x",
  "args": "{x : â„•}  (h : (3 : â„•) = x)"},
 {"type": "voo = x",
  "tactic-prompt":
  "example {x : Type}  (h : â„• = x) : voo = x := by simp only [voo_c]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_c]",
  "core-prompt": "{x : Type}  (h : â„• = x) : voo = x",
  "args": "{x : Type}  (h : â„• = x)"},
 {"type": "voo.x = x",
  "tactic-prompt":
  "example {x : â„•}  (h : (3 : â„•) = x) : voo.x = x := by simp only [voo_x]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp only [voo_x]",
  "core-prompt": "{x : â„•}  (h : (3 : â„•) = x) : voo.x = x",
  "args": "{x : â„•}  (h : (3 : â„•) = x)"},
 {"type": "x * - 0 âŠ† - x",
  "tactic-prompt": "example (x : â„•) : x * - 0 âŠ† - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : â„•) : x * - 0 âŠ† - x",
  "args": "(x : â„•)"},
 {"type": "x * - 0 âŠ† - x",
  "tactic-prompt": "example (x : â„•) : x * - 0 âŠ† - x := by simp; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp",
  "core-prompt": "(x : â„•) : x * - 0 âŠ† - x",
  "args": "(x : â„•)"},
 {"type": "Nat.SetPlus1.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus1.s = x := by dsimp only [Nat.SetPlus1_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus1_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus1.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus2.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus2.s = x := by dsimp only [Nat.SetPlus2_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus2_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus2.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "Nat.SetPlus3.s = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus3.s = x := by dsimp only [Nat.SetPlus3_s]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Nat.SetPlus3_s]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x) : Nat.SetPlus3.s = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {x : Set â„•}  (h : Set.univ = x)"},
 {"type": "(Equiv.symm2.invFun e).toFun = x",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x := by dsimp only [Equiv.symm2_invFun_toFun]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp only [Equiv.symm2_invFun_toFun]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x) : (Equiv.symm2.invFun e).toFun = x",
  "args":
  "{Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} {Î± Î² Î³ : Sort _} (e : Î± â‰ƒ Î²)  {x : Î² â†’ Î±}  (h : e.invFun = x)"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type}  [Nonempty Î±] : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": "{Î± : Type}  [Nonempty Î±] : Inhabited Î±",
  "args": "{Î± : Type}  [Nonempty Î±]"},
 {"type": "Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type 3}  [Nonempty Î±] : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": "{Î± : Type 3}  [Nonempty Î±] : Inhabited Î±",
  "args": "{Î± : Type 3}  [Nonempty Î±]"},
 {"type": "Nonempty Î± â†’ Inhabited Î±",
  "tactic-prompt":
  "example {Î± : Type} : Nonempty Î± â†’ Inhabited Î± := by intro nonempty_Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro nonempty_Î±",
  "core-prompt": "{Î± : Type} : Nonempty Î± â†’ Inhabited Î±",
  "args": "{Î± : Type}"},
 {"type": "Inhabited p",
  "tactic-prompt":
  "example {p : Prop}  [Nonempty p] : Inhabited p := by inhabit p_inhabited : p; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit p_inhabited : p",
  "core-prompt": "{p : Prop}  [Nonempty p] : Inhabited p",
  "args": "{p : Prop}  [Nonempty p]"},
 {"type": "Inhabited Î±",
  "tactic-prompt": "example  : Inhabited Î± := by inhabit Î±; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "inhabit Î±",
  "core-prompt": " : Inhabited Î±",
  "args": ""},
 {"type": "True",
  "tactic-prompt": "example  : True := by type_check Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "type_check Nat",
  "core-prompt": " : True",
  "args": ""},
 {"type": "(an : â„¤) = bn â†’ an = bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) = bn â†’ an = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) = bn â†’ an = bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "an = bn â†’ (an : â„¤) = bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : an = bn â†’ (an : â„¤) = bn := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : an = bn â†’ (an : â„¤) = bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) < bn â†” an < bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) < bn â†” an < bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) < bn â†” an < bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  (bn : â„¤) â†” an â‰  bn",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "az > (1 : â„•) â†” az > 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (1 : â„•) â†” az > 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (1 : â„•) â†” az > 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "az > (0 : â„•) â†” az > 0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (0 : â„•) â†” az > 0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : az > (0 : â„•) â†” az > 0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) â‰  0 â†” an â‰  0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  0 â†” an â‰  0 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) â‰  0 â†” an â‰  0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "(an : â„¤) + bn = (an + bn : â„•)",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) + bn = (an + bn : â„•) := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : (an : â„¤) + bn = (an + bn : â„•)",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "((42 : â„•) : â„¤) = 42",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : ((42 : â„•) : â„¤) = 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : ((42 : â„•) : â„¤) = 42",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "p 42",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : p 42 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) : p 42",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚)"},
 {"type": "an - bn = 1 â†” (an - bn : â„¤) = 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an) : an - bn = 1 â†” (an - bn : â„¤) = 1 := by norm_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "norm_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an) : an - bn = 1 â†” (an - bn : â„¤) = 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h : bn â‰¤ an)"},
 {"type": "x * y = 1",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1) : x * y = 1 := by exact_mod_cast h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "exact_mod_cast h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1) : x * y = 1",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) [Mul Î±]  [One Î±]  (x y : Î±)  (h : (x : WithZero Î±) * y = 1)"},
 {"type":
  "(x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k)",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•} : (x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k) := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•} : (x * x + y * y : â„¤) - â†‘((x * y + 1) * k) = â†‘y * â†‘y - â†‘k * â†‘x * â†‘y + (â†‘x * â†‘x - â†‘k)",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}"},
 {"type": "x + y + k = 0",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0) : x + y + k = 0 := by push_cast at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast at h",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0) : x + y + k = 0",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (k : â„•)  {x y : â„•}  (h : ((x + y + k : â„•) : â„¤) = 0)"},
 {"type": "((a + b : â„•) : â„¤) = 10",
  "tactic-prompt":
  "example (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10) : ((a + b : â„•) : â„¤) = 10 := by push_cast; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "push_cast",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10) : ((a + b : â„•) : â„¤) = 10",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (a b : â„•)  (h2 : ((a + b + 0 : â„•) : â„¤) = 10)"},
 {"type": "true âˆ§ true",
  "tactic-prompt":
  "lemma (an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true) : true âˆ§ true := by constructor; sorry",
  "name": "b",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true) : true âˆ§ true",
  "args":
  "(an bn cn dn : â„•)  (az bz cz dz : â„¤) -- variable (aq bq cq dq : â„š) -- variable (ar br cr dr : â„) (ac bc cc dc : â„‚) (h g : true)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by cases' x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example {Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³) : True := by cases' h: x with a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x with a b",
  "core-prompt": "{Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³) : True",
  "args": "{Î± Î² Î³ : Type u}  (x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : â„•) : True := by cases' h: x using my_rec with y; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' h: x using my_rec with y",
  "core-prompt": "(x : â„•) : True",
  "args": "(x : â„•)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo Î± Î²) : True := by cases' x with aâ‚€ aâ‚ _ aâ‚‚ bâ‚‚ câ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with aâ‚€ aâ‚ _ aâ‚‚ bâ‚‚ câ‚‚",
  "core-prompt": "(x : Foo Î± Î²) : True",
  "args": "(x : Foo Î± Î²)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Bar 0) : True := by cases' x with a b c d h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases' x with a b c d h",
  "core-prompt": "(x : Bar 0) : True",
  "args": "(x : Bar 0)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Foo Î± Nat) : True := by induction' x with a a' b' a'' b'' c'' ih; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "induction' x with a a' b' a'' b'' c'' ih",
  "core-prompt": "(x : Foo Î± Nat) : True",
  "args": "(x : Foo Î± Nat)"},
 {"type": "3 < 4",
  "tactic-prompt": "example  : 3 < 4 := by recover decide; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover decide",
  "core-prompt": " : 3 < 4",
  "args": ""},
 {"type": "1 = 1",
  "tactic-prompt": "example  : 1 = 1 := by recover skip ; rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip ; rfl",
  "core-prompt": " : 1 = 1",
  "args": ""},
 {"type": "2 = 2",
  "tactic-prompt": "example  : 2 = 2 := by recover skip; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "recover skip",
  "core-prompt": " : 2 = 2",
  "args": ""},
 {"type": "x + y = y + x",
  "tactic-prompt": "example (x y : â„•) : x + y = y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„•) : x + y = y + x",
  "args": "(x y : â„•)"},
 {"type": "x + y + y = 2 * y + x",
  "tactic-prompt":
  "example (x y : â„•) : x + y + y = 2 * y + x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„•) : x + y + y = 2 * y + x",
  "args": "(x y : â„•)"},
 {"type": "x + id y = y + id x",
  "tactic-prompt": "example (x y : â„•) : x + id y = y + id x := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(x y : â„•) : x + id y = y + id x",
  "args": "(x y : â„•)"},
 {"type": "(x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "tactic-prompt":
  "example (x y : â„•) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt":
  "(x y : â„•) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y)",
  "args": "(x y : â„•)"},
 {"type": "(n / 2) + (n / 2) = 2 * (n / 2)",
  "tactic-prompt":
  "example (n : â„•) : (n / 2) + (n / 2) = 2 * (n / 2) := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(n : â„•) : (n / 2) + (n / 2) = 2 * (n / 2)",
  "args": "(n : â„•)"},
 {"type": "a * (n - s) = (n - s) * a",
  "tactic-prompt":
  "example (a n s: â„•) : a * (n - s) = (n - s) * a := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(a n s: â„•) : a * (n - s) = (n - s) * a",
  "args": "(a n s: â„•)"},
 {"type": "(2 * A) ^ 2 = (2 * A) ^ 2",
  "tactic-prompt":
  "example (A : â„•) : (2 * A) ^ 2 = (2 * A) ^ 2 := by ring; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "ring",
  "core-prompt": "(A : â„•) : (2 * A) ^ 2 = (2 * A) ^ 2",
  "args": "(A : â„•)"},
 {"type": "nleq a b â†’ nleq b c â†’ nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "nleq a b â†’ nleq b c â†’ nleq a c",
  "tactic-prompt":
  "example (a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : nleq a b â†’ nleq b c â†’ nleq a c",
  "args": "(a b c : Nat)"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "def {a b c : Î±} : a = b â†’ b = c â†’ a = c := by intro hâ‚ hâ‚‚; sorry",
  "name": "eq_trans",
  "kind": "def",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "{a b c : Î±} : a = b â†’ b = c â†’ a = c",
  "args": "{a b c : Î±}"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b â†’ b = c â†’ a = c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a = b â†’ b = c â†’ a = c",
  "args": "(a b c : Nat)"},
 {"type": "a = b â†’ b = c â†’ a = c",
  "tactic-prompt":
  "example (a b c : Nat) : a = b â†’ b = c â†’ a = c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a = b â†’ b = c â†’ a = c",
  "args": "(a b c : Nat)"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "R a b â†’ R b c â†’ R a c",
  "tactic-prompt":
  "example (a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R] : R a b â†’ R b c â†’ R a c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt":
  "(a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R] : R a b â†’ R b c â†’ R a c",
  "args": "(a b c : Î±)  (R : Î± â†’ Î± â†’ Prop)  [Trans R R R]"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "tactic-prompt":
  "example (a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
  "args": "(a b c : Nat)"},
 {"type": "a < b â†’ b < c â†’ a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b â†’ b < c â†’ a < c := by intro hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro hâ‚ hâ‚‚",
  "core-prompt": "(a b c : Nat) : a < b â†’ b < c â†’ a < c",
  "args": "(a b c : Nat)"},
 {"type": "a < b â†’ b < c â†’ a < c",
  "tactic-prompt":
  "example (a b c : Nat) : a < b â†’ b < c â†’ a < c := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(a b c : Nat) : a < b â†’ b < c â†’ a < c",
  "args": "(a b c : Nat)"},
 {"type": "n * p â‰¤ x",
  "tactic-prompt":
  "example (x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x) : n * p â‰¤ x := by trans; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "trans",
  "core-prompt": "(x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x) : n * p â‰¤ x",
  "args": "(x n p : Nat)  (hâ‚ : n * Nat.succ p â‰¤ x)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x = x) : x = x := by set! p := h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set! p := h",
  "core-prompt": "(x : Nat)  (h : x = x) : x = x",
  "args": "(x : Nat)  (h : x = x)"},
 {"type": "x = x",
  "tactic-prompt":
  "example (x : Nat)  (h : x - x = 0) : x = x := by set y : Nat := x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "set y : Nat := x",
  "core-prompt": "(x : Nat)  (h : x - x = 0) : x = x",
  "args": "(x : Nat)  (h : x - x = 0)"},
 {"type": "(Î» (x y : Nat) => x + y) = (Î» x y => y + x)",
  "tactic-prompt":
  "example  : (Î» (x y : Nat) => x + y) = (Î» x y => y + x) := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": " : (Î» (x y : Nat) => x + y) = (Î» x y => y + x)",
  "args": ""},
 {"type": "a = c",
  "tactic-prompt":
  "example (f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c := by simp_rw [â† ha]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [â† ha]",
  "core-prompt":
  "(f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c) : a = c",
  "args": "(f : Nat â†’ Nat)  {a b c : Nat}  (ha : f b = a)  (hc : f b = c)"},
 {"type": "a + (b + (c + d)) = ((d + c) + b) + a",
  "tactic-prompt":
  "example (a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a := by simp_rw [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm]",
  "core-prompt": "(a b c d : Nat) : a + (b + (c + d)) = ((d + c) + b) + a",
  "args": "(a b c d : Nat)"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at h",
  "core-prompt": "(p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b)) : p (b + a)",
  "args": "(p : Nat â†’ Prop)  (a b : Nat)  (h : p (a + b))"},
 {"type": "p (b + a)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (b + a) := by simp_rw [Nat.add_comm a b] at hâ‚ hâ‚‚; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at hâ‚ hâ‚‚",
  "core-prompt":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (b + a)",
  "args":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b))"},
 {"type": "p (a + b)",
  "tactic-prompt":
  "example (p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (a + b) := by simp_rw [Nat.add_comm a b] at *; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [Nat.add_comm a b] at *",
  "core-prompt":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b)) : p (a + b)",
  "args":
  "(p : Nat â†’ Prop)  (a b : Nat)  (hâ‚ : p (b + a) â†’ p (a + b))   (hâ‚‚ : p (a + b))"},
 {"type": "(âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1",
  "tactic-prompt":
  "example {a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b) : (âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1 := by simp_rw [h1]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp_rw [h1]",
  "core-prompt":
  "{a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b) : (âˆ€ b, a - 1 â‰¤ b) = âˆ€ b c : Nat, c < a â†’ c < b + 1",
  "args":
  "{a : Nat}    (h1 : âˆ€ a b : Nat, a - 1 â‰¤ b â†” a â‰¤ b + 1)    (h2 : âˆ€ a b : Nat, a â‰¤ b â†” âˆ€ c, c < a â†’ c < b)"},
 {"type": "p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "tactic-prompt":
  "example (p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r := by intros a b c; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b c",
  "core-prompt": "(p q r : Prop) : p â†’ q â†’ r â†’ p âˆ§ q âˆ§ r",
  "args": "(p q r : Prop)"},
 {"type": "p â†’ q â†’ p âˆ§ q",
  "tactic-prompt":
  "example (p q : Prop) : p â†’ q â†’ p âˆ§ q := by intros a b; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros a b",
  "core-prompt": "(p q : Prop) : p â†’ q â†’ p âˆ§ q",
  "args": "(p q : Prop)"},
 {"type": "p â†’ p",
  "tactic-prompt": "example (p : Prop) : p â†’ p := by intros; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intros",
  "core-prompt": "(p : Prop) : p â†’ p",
  "args": "(p : Prop)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Int) : Nat := by replace h : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Nat := 0",
  "core-prompt": "(h : Int) : Nat",
  "args": "(h : Int)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by have h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example (h : Nat) : Nat := by replace h : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace h : Int := 0",
  "core-prompt": "(h : Nat) : Nat",
  "args": "(h : Nat)"},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Int := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat := 0",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt":
  "example {a : Nat} : a = a := by replace a : Int := 0; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace a : Int := 0",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "Nat",
  "tactic-prompt": "example (z : Int) : Nat := by replace z : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "replace z : Nat",
  "core-prompt": "(z : Int) : Nat",
  "args": "(z : Int)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by have : 1 + 1 = 2 := by simp_arith; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : 1 + 1 = 2 := by simp_arith",
  "core-prompt": " : True",
  "args": ""},
 {"type": "x + 1 = 1 + x",
  "tactic-prompt": "example  : x + 1 = 1 + x := by simp? [Nat.add_comm]; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "simp? [Nat.add_comm]",
  "core-prompt": " : x + 1 = 1 + x",
  "args": ""},
 {"type": "1 + 1 = 2",
  "tactic-prompt": "example  : 1 + 1 = 2 := by dsimp?; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "dsimp?",
  "core-prompt": " : 1 + 1 = 2",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt": "example  : foo x y = 1 + y := by cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "foo x y = 1 + y",
  "tactic-prompt":
  "example  : foo x y = 1 + y := by squeeze_scope\n    cases x; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "squeeze_scope\n    cases x",
  "core-prompt": " : foo x y = 1 + y",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have h : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "Nat",
  "tactic-prompt": "example  : Nat := by have : Nat; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : Nat",
  "core-prompt": " : Nat",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have h : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have h : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "a = a",
  "tactic-prompt": "example {a : Nat} : a = a := by have : a = a; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "have : a = a",
  "core-prompt": "{a : Nat} : a = a",
  "args": "{a : Nat}"},
 {"type": "True",
  "tactic-prompt": "example  : True := by (let N); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(let N)",
  "core-prompt": " : True",
  "args": ""},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "tactic-prompt":
  "example  : âˆƒ x : Nat, âˆƒ y : Nat, x = y := by use 42, 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42, 42",
  "core-prompt": " : âˆƒ x : Nat, âˆƒ y : Nat, x = y",
  "args": ""},
 {"type": "âˆƒ x : String Ã— String, x.1 = x.2",
  "tactic-prompt":
  "example  : âˆƒ x : String Ã— String, x.1 = x.2 := by use (\"a\", \"a\"); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use (\"a\", \"a\")",
  "core-prompt": " : âˆƒ x : String Ã— String, x.1 = x.2",
  "args": ""},
 {"type": "âˆƒ x : Nat, x = x",
  "tactic-prompt": "example  : âˆƒ x : Nat, x = x := by use ?_; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use ?_",
  "core-prompt": " : âˆƒ x : Nat, x = x",
  "args": ""},
 {"type": "âˆƒ S : List Î±, S = S",
  "tactic-prompt":
  "example (Î± : Type) : âˆƒ S : List Î±, S = S := by use âˆ…; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use âˆ…",
  "core-prompt": "(Î± : Type) : âˆƒ S : List Î±, S = S",
  "args": "(Î± : Type)"},
 {"type": "âˆƒ x : Int, x = x",
  "tactic-prompt": "example  : âˆƒ x : Int, x = x := by use 42; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 42",
  "core-prompt": " : âˆƒ x : Int, x = x",
  "args": ""},
 {"type": "âˆƒ a b c : Int, a + b + c = 6",
  "tactic-prompt":
  "example  : âˆƒ a b c : Int, a + b + c = 6 := by use 1, 2, 3; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use 1, 2, 3",
  "core-prompt": " : âˆƒ a b c : Int, a + b + c = 6",
  "args": ""},
 {"type": "âˆƒ p : Int Ã— Int, p.1 = 1",
  "tactic-prompt":
  "example  : âˆƒ p : Int Ã— Int, p.1 = 1 := by use âŸ¨1, 42âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "use âŸ¨1, 42âŸ©",
  "core-prompt": " : âˆƒ p : Int Ã— Int, p.1 = 1",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by rcases x with âŸ¨a, b, câŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with âŸ¨a, b, câŸ©",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : Î± Ã— Î² Ã— Î³) : True := by rcases x with âŸ¨(a : Î±) : id Î±, -, c : id Î³âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with âŸ¨(a : Î±) : id Î±, -, c : id Î³âŸ©",
  "core-prompt": "(x : Î± Ã— Î² Ã— Î³) : True",
  "args": "(x : Î± Ã— Î² Ã— Î³)"},
 {"type": "True",
  "tactic-prompt":
  "example (x : (Î± Ã— Î²) Ã— Î³) : True := by fail_if_success rcases x with âŸ¨a, b, câŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success rcases x with âŸ¨a, b, câŸ©",
  "core-prompt": "(x : (Î± Ã— Î²) Ã— Î³) : True",
  "args": "(x : (Î± Ã— Î²) Ã— Î³)"},
 {"type": "@Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True",
  "tactic-prompt":
  "example  : @Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True := by rintro (âŸ¨âŸ¨aâŸ©, _ | bâŸ© | c); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (âŸ¨âŸ¨aâŸ©, _ | bâŸ© | c)",
  "core-prompt": " : @Inhabited.{1} Î± Ã— Option Î² âŠ• Î³ â†’ True",
  "args": ""},
 {"type": "cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True",
  "tactic-prompt":
  "example  : cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True := by rintro (x y : Int) (z | u); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro (x y : Int) (z | u)",
  "core-prompt":
  " : cond false Nat Int â†’ cond true Int Nat â†’ Nat âŠ• Unit â†’ True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Nat)  (h : x = y) : True := by rcases x with _|âŸ¨âŸ©|z; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x with _|âŸ¨âŸ©|z",
  "core-prompt": "(x y : Nat)  (h : x = y) : True",
  "args": "(x y : Nat)  (h : x = y)"},
 {"type": "True",
  "tactic-prompt":
  "example (s : Î± âŠ• Empty) : True := by rcases s with s|âŸ¨âŸ¨âŸ©âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases s with s|âŸ¨âŸ¨âŸ©âŸ©",
  "core-prompt": "(s : Î± âŠ• Empty) : True",
  "args": "(s : Î± âŠ• Empty)"},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain âŸ¨n : Nat, h : n = n, -âŸ© : âˆƒ n : Nat, n = n âˆ§ True; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain âŸ¨n : Nat, h : n = n, -âŸ© : âˆƒ n : Nat, n = n âˆ§ True",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain (h : True) | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain (h : True) | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain h | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False := Or.inl trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain h | âŸ¨âŸ¨âŸ©âŸ© : True âˆ¨ False := Or.inl trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by obtain âŸ¨h, h2âŸ© := And.intro trivial trivial; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "obtain âŸ¨h, h2âŸ© := And.intro trivial trivial",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example  : True := by fail_if_success obtain âŸ¨h, h2âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "fail_if_success obtain âŸ¨h, h2âŸ©",
  "core-prompt": " : True",
  "args": ""},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Î± Ã— Î²) : True := by rcases x, y with âŸ¨âŸ¨a, bâŸ©, c, dâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with âŸ¨âŸ¨a, bâŸ©, c, dâŸ©",
  "core-prompt": "(x y : Î± Ã— Î²) : True",
  "args": "(x y : Î± Ã— Î²)"},
 {"type": "True",
  "tactic-prompt":
  "example (x y : Î± âŠ• Î²) : True := by rcases x, y with âŸ¨a|b, c|dâŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rcases x, y with âŸ¨a|b, c|dâŸ©",
  "core-prompt": "(x y : Î± âŠ• Î²) : True",
  "args": "(x y : Î± âŠ• Î²)"},
 {"type": "(Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j",
  "tactic-prompt":
  "example (i j : Nat) : (Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j := by intro h; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "intro h",
  "core-prompt": "(i j : Nat) : (Î£' x, i â‰¤ x âˆ§ x â‰¤ j) â†’ i â‰¤ j",
  "args": "(i j : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain one_lt_n | n_le_one : 1 < n + 1 âˆ¨ n + 1 â‰¤ 1 := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain one_lt_n | n_le_one : 1 < n + 1 âˆ¨ n + 1 â‰¤ 1 := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "True",
  "tactic-prompt":
  "example (n : Nat) : True := by obtain one_lt_n | (n_le_one : n + 1 â‰¤ 1) := Nat.lt_or_ge 1 (n + 1); sorry",
  "name": "",
  "kind": "example",
  "first-tactic":
  "obtain one_lt_n | (n_le_one : n + 1 â‰¤ 1) := Nat.lt_or_ge 1 (n + 1)",
  "core-prompt": "(n : Nat) : True",
  "args": "(n : Nat)"},
 {"type": "(b : Bool) â†’ cond b False False â†’ True",
  "tactic-prompt":
  "example  : (b : Bool) â†’ cond b False False â†’ True := by rintro âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt": " : (b : Bool) â†’ cond b False False â†’ True",
  "args": ""},
 {"type": "a = a",
  "tactic-prompt": "example (a : Nat) : a = a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "(a : Nat) : a = a",
  "args": "(a : Nat)"},
 {"type": "a â‰ˆ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Î±) : a â‰ˆ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Î±) : a â‰ˆ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Î±)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a := by (fail_if_success rfl); sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "(fail_if_success rfl)",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Nat)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Nat) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Nat)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a := by apply Foo.le_refl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "apply Foo.le_refl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Foo)"},
 {"type": "a â‰¤ a",
  "tactic-prompt":
  "example {Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a := by rfl; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "rfl",
  "core-prompt": "{Î± : Sort u}  [Setoid Î±] (a : Foo) : a â‰¤ a",
  "args": "{Î± : Sort u}  [Setoid Î±] (a : Foo)"},
 {"type": "(True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "tactic-prompt":
  "example  : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "args": ""},
 {"type": "((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x))",
  "tactic-prompt":
  "example  : ((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x)) := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt":
  " : ((True âˆ§ True) âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ (True âˆ§ (âˆƒ x : Nat, x = x))",
  "args": ""},
 {"type": "(True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "tactic-prompt":
  "example  : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True := by constructor; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "constructor",
  "core-prompt": " : (True âˆ§ (âˆƒ x : Nat, x = x)) âˆ§ True",
  "args": ""},
 {"type": "IsEmpty (Î± â†’ Î²)",
  "tactic-prompt":
  "example {Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²] : IsEmpty (Î± â†’ Î²) := by infer_instance; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²] : IsEmpty (Î± â†’ Î²)",
  "args": "{Î± Î² Î³ : Sort _} [h : Nonempty Î±]  [IsEmpty Î²]"},
 {"type": "IsEmpty p â†” Â¬p",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop} : IsEmpty p â†” Â¬p := by simp only [â† not_nonempty_iff]; sorry",
  "name": "is_empty_Prop",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop} : IsEmpty p â†” Â¬p",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {p : Prop}"},
 {"type": "IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a)",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _} : IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a) := by simp only [â† not_nonempty_iff]; sorry",
  "name": "is_empty_pi",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _} : IsEmpty (âˆ€ a, Ï€ a) â†” âˆƒ a, IsEmpty (Ï€ a)",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Ï€ : Î± â†’ Sort _}"},
 {"type": "IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop) : IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x := by simp only [â† not_nonempty_iff]; sorry",
  "name": "is_empty_subtype",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop) : IsEmpty (Subtype p) â†” âˆ€ x, Â¬p x",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] (p : Î± â†’ Prop)"},
 {"type": "IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _} : IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î² := by simp only [â† not_nonempty_iff]; sorry",
  "name": "is_empty_prod",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _} : IsEmpty (Î± Ã— Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±] {Î± Î² : Type _}"},
 {"type": "IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _} [IsEmpty Î±] : IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î² := by simp only [â† not_nonempty_iff]; sorry",
  "name": "is_empty_pprod",
  "kind": "theorem",
  "first-tactic": "simp only [â† not_nonempty_iff]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _} [IsEmpty Î±] : IsEmpty (PProd Î± Î²) â†” IsEmpty Î± âˆ¨ IsEmpty Î²",
  "args": "{Î± Î² Î³ : Sort _} [IsEmpty Î±]"},
 {"type": "HEq f f'",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a')) : HEq f f' := by subst hÎ±; sorry",
  "name": "hfunext",
  "kind": "lemma",
  "first-tactic": "subst hÎ±",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a')) : HEq f f'",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {Î± Î±': Sort u}  {Î² : Î± â†’ Sort v}  {Î²' : Î±' â†’ Sort v}  {f : âˆ€a, Î² a}  {f' : âˆ€a, Î²' a}    (hÎ± : Î± = Î±')  (h : âˆ€a a', HEq a a' â†’ HEq (f a) (f' a'))"},
 {"type": "Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©)",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©) : Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©) := by intros xâ‚ xâ‚‚ h; sorry",
  "name": "Injective.dite",
  "kind": "lemma",
  "first-tactic": "intros xâ‚ xâ‚‚ h",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©) : Function.Injective (Î» x => if h : p x then f âŸ¨x, hâŸ© else f' âŸ¨x, hâŸ©)",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} (p : Î± â†’ Prop)  [DecidablePred p]    {f : {a : Î± // p a} â†’ Î²}  {f' : {a : Î± // Â¬ p a} â†’ Î²}    (hf : Injective f)  (hf' : Injective f')    (im_disj : âˆ€ {x x' : Î±} {hx : p x} {hx' : Â¬ p x'}, f âŸ¨x, hxâŸ© â‰  f' âŸ¨x', hx'âŸ©)"},
 {"type": "gâ‚ = gâ‚‚",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {f : Î± â†’ Î²}  {gâ‚ gâ‚‚ : Î² â†’ Î±}  (hâ‚ : LeftInverse gâ‚ f)    (hâ‚‚ : Function.RightInverse gâ‚‚ f) : gâ‚ = gâ‚‚ := by have hâ‚ƒ : gâ‚ = gâ‚ âˆ˜ f âˆ˜ gâ‚‚ := by rw [hâ‚‚.comp_eq_id]; sorry",
  "name": "LeftInverse.eq_RightInverse",
  "kind": "theorem",
  "first-tactic": "have hâ‚ƒ : gâ‚ = gâ‚ âˆ˜ f âˆ˜ gâ‚‚ := by rw [hâ‚‚.comp_eq_id]",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {f : Î± â†’ Î²}  {gâ‚ gâ‚‚ : Î² â†’ Î±}  (hâ‚ : LeftInverse gâ‚ f)    (hâ‚‚ : Function.RightInverse gâ‚‚ f) : gâ‚ = gâ‚‚",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î²} {f : Î± â†’ Î²}  {gâ‚ gâ‚‚ : Î² â†’ Î±}  (hâ‚ : LeftInverse gâ‚ f)    (hâ‚‚ : Function.RightInverse gâ‚‚ f)"},
 {"type": "inv_fun_on f s b âˆˆ s âˆ§ f (inv_fun_on f s b) = b",
  "tactic-prompt":
  "theorem {Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : âˆƒaâˆˆs, f a = b) : inv_fun_on f s b âˆˆ s âˆ§ f (inv_fun_on f s b) = b := by have h1 : inv_fun_on f s b =\n     if h : âˆƒa, a âˆˆ s âˆ§ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_pos",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : âˆƒa, a âˆˆ s âˆ§ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : âˆƒaâˆˆs, f a = b) : inv_fun_on f s b âˆˆ s âˆ§ f (inv_fun_on f s b) = b",
  "args":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : âˆƒaâˆˆs, f a = b)"},
 {"type": "inv_fun_on f s b = Classical.choice n",
  "tactic-prompt":
  "theorem {Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒaâˆˆs, f a = b) : inv_fun_on f s b = Classical.choice n := by have h1 : inv_fun_on f s b =\n     if h : âˆƒa, a âˆˆ s âˆ§ f a = b then Classical.choose h else Classical.choice n := rfl; sorry",
  "name": "inv_fun_on_neg",
  "kind": "theorem",
  "first-tactic":
  "have h1 : inv_fun_on f s b =\n     if h : âˆƒa, a âˆˆ s âˆ§ f a = b then Classical.choose h else Classical.choice n := rfl",
  "core-prompt":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒaâˆˆs, f a = b) : inv_fun_on f s b = Classical.choice n",
  "args":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒaâˆˆs, f a = b)"},
 {"type": "inv_fun f b = Classical.choice n",
  "tactic-prompt":
  "lemma {Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒ a, f a = b) : inv_fun f b = Classical.choice n := by refine inv_fun_on_neg (mt ?_ h); sorry",
  "name": "inv_fun_neg",
  "kind": "lemma",
  "first-tactic": "refine inv_fun_on_neg (mt ?_ h)",
  "core-prompt":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒ a, f a = b) : inv_fun f b = Classical.choice n",
  "args":
  "{Î± : Type u}  [n : Nonempty Î±]  {Î² : Sort v}  {f : Î± â†’ Î²}  {s : Set Î±}  {a : Î±}  {b : Î²} (h : Â¬ âˆƒ a, f a = b)"},
 {"type": "update f a' b a = if a = a' then b else f a",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±) : update f a' b a = if a = a' then b else f a := by have h2 : (h : a = a') â†’ Eq.rec (motive := Î» _ _ => Î²) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]; sorry",
  "name": "update_apply",
  "kind": "lemma",
  "first-tactic":
  "have h2 : (h : a = a') â†’ Eq.rec (motive := Î» _ _ => Î²) b h.symm = b :=\n     by intro h\n        rw [eq_rec_constant]",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±) : update f a' b a = if a = a' then b else f a",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î² : Sort _}  (f : Î± â†’ Î²)  (a' : Î±)  (b : Î²)  (a : Î±)"},
 {"type": "Injective (update f a')",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] (f : âˆ€a, Î² a)  (a' : Î±) : Injective (update f a') := by intros v v' h; sorry",
  "name": "update_injective",
  "kind": "lemma",
  "first-tactic": "intros v v' h",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] (f : âˆ€a, Î² a)  (a' : Î±) : Injective (update f a')",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] (f : âˆ€a, Î² a)  (a' : Î±)"},
 {"type": "f j (update g i v j) = update (Î» k => f k (g k)) i (f i v) j",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}    (f : âˆ€i, Î± i â†’ Î² i)  (g : âˆ€i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹) : f j (update g i v j) = update (Î» k => f k (g k)) i (f i v) j := by by_cases h : j = i; sorry",
  "name": "apply_update",
  "kind": "lemma",
  "first-tactic": "by_cases h : j = i",
  "core-prompt":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}    (f : âˆ€i, Î± i â†’ Î² i)  (g : âˆ€i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹) : f j (update g i v j) = update (Î» k => f k (g k)) i (f i v) j",
  "args":
  "{Î± : Sort u}  {Î² : Î± â†’ Sort v}  {Î±' : Sort w}  [DecidableEq Î±]  [DecidableEq Î±'] {Î¹ : Sort _}  [DecidableEq Î¹]  {Î± Î² : Î¹ â†’ Sort _}    (f : âˆ€i, Î± i â†’ Î² i)  (g : âˆ€i, Î± i)  (i : Î¹)  (v : Î± i)  (j : Î¹)"},
 {"type":
  "extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [hd : Decidable (âˆƒ a, f a = b)] : extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b := by rw [Subsingleton.elim hd]; sorry",
  "name": "extend_def",
  "kind": "lemma",
  "first-tactic": "rw [Subsingleton.elim hd]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [hd : Decidable (âˆƒ a, f a = b)] : extend f g e' b = if h : âˆƒ a, f a = b then g (Classical.choose h) else e' b",
  "args":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (f : Î± â†’ Î²)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  [hd : Decidable (âˆƒ a, f a = b)]"},
 {"type": "extend f g e' (f a) = g a",
  "tactic-prompt":
  "lemma {Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (a : Î±) : extend f g e' (f a) = g a := by simp only [extend_def]; sorry",
  "name": "extend_apply",
  "kind": "lemma",
  "first-tactic": "simp only [extend_def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (a : Î±) : extend f g e' (f a) = g a",
  "args":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (hf : Injective f)  (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (a : Î±)"},
 {"type": "extend f g e' b = e' b",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b) : extend f g e' b = e' b := by simp [Function.extend_def]; sorry",
  "name": "extend_apply'",
  "kind": "theorem",
  "first-tactic": "simp [Function.extend_def]",
  "core-prompt":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b) : extend f g e' b = e' b",
  "args":
  "{Î± Î² Î³ : Type _}  {f : Î± â†’ Î²} (g : Î± â†’ Î³)  (e' : Î² â†’ Î³)  (b : Î²)  (hb : Â¬âˆƒ a, f a = b)"},
 {"type": "uncurry (bicompl f g h) = (uncurry f) âˆ˜ (Prod.map g h)",
  "tactic-prompt":
  "lemma {Î± Î² Î³ Î´ Îµ : Type _} (f : Î³ â†’ Î´ â†’ Îµ)  (g : Î± â†’ Î³)  (h : Î² â†’ Î´) : uncurry (bicompl f g h) = (uncurry f) âˆ˜ (Prod.map g h) := by ext âŸ¨x, yâŸ©; sorry",
  "name": "uncurry_bicompl",
  "kind": "lemma",
  "first-tactic": "ext âŸ¨x, yâŸ©",
  "core-prompt":
  "{Î± Î² Î³ Î´ Îµ : Type _} (f : Î³ â†’ Î´ â†’ Îµ)  (g : Î± â†’ Î³)  (h : Î² â†’ Î´) : uncurry (bicompl f g h) = (uncurry f) âˆ˜ (Prod.map g h)",
  "args": "{Î± Î² Î³ Î´ Îµ : Type _} (f : Î³ â†’ Î´ â†’ Îµ)  (g : Î± â†’ Î³)  (h : Î² â†’ Î´)"},
 {"type": "f (ite P x (f x)) = ite (Â¬ P) x (f x)",
  "tactic-prompt":
  "lemma {Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±) : f (ite P x (f x)) = ite (Â¬ P) x (f x) := by rw [apply_ite f]; sorry",
  "name": "ite_not",
  "kind": "lemma",
  "first-tactic": "rw [apply_ite f]",
  "core-prompt":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±) : f (ite P x (f x)) = ite (Â¬ P) x (f x)",
  "args":
  "{Î± : Sort u}  {f : Î± â†’ Î±}  (h : Involutive f) (P : Prop)  [Decidable P]  (x : Î±)"},
 {"type": "f x = g y",
  "tactic-prompt":
  "theorem {Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y) : f x = g y := by cases hâ‚‚; sorry",
  "name": "congr_heq",
  "kind": "theorem",
  "first-tactic": "cases hâ‚‚",
  "core-prompt":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y) : f x = g y",
  "args":
  "{Î± Î² Î³ : Sort _}  {f : Î± â†’ Î³}  {g : Î² â†’ Î³}  {x : Î±}  {y : Î²}      (hâ‚ : HEq f g)  (hâ‚‚ : HEq x y)"},
 {"type": "Eq True = id",
  "tactic-prompt": "theorem  : Eq True = id := by funext _; sorry",
  "name": "eq_true_eq_id",
  "kind": "theorem",
  "first-tactic": "funext _",
  "core-prompt": " : Eq True = id",
  "args": ""},
 {"type": "Xor' True = Not",
  "tactic-prompt": "theorem  : Xor' True = Not := by simp [Xor']; sorry",
  "name": "xor_true",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": " : Xor' True = Not",
  "args": ""},
 {"type": "Xor' False = id",
  "tactic-prompt": "theorem  : Xor' False = id := by ext; sorry",
  "name": "xor_false",
  "kind": "theorem",
  "first-tactic": "ext",
  "core-prompt": " : Xor' False = id",
  "args": ""},
 {"type": "Xor' a a = False",
  "tactic-prompt":
  "theorem (a : Prop) : Xor' a a = False := by simp [Xor']; sorry",
  "name": "xor_self",
  "kind": "theorem",
  "first-tactic": "simp [Xor']",
  "core-prompt": "(a : Prop) : Xor' a a = False",
  "args": "(a : Prop)"},
 {"type": "p âˆ§ a = b â†” p âˆ§ b = a",
  "tactic-prompt":
  "theorem (a b : Î±)  (p : Prop) : p âˆ§ a = b â†” p âˆ§ b = a := by simp [eq_comm]; sorry",
  "name": "and_symm_right",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : Î±)  (p : Prop) : p âˆ§ a = b â†” p âˆ§ b = a",
  "args": "(a b : Î±)  (p : Prop)"},
 {"type": "a = b âˆ§ p â†” b = a âˆ§ p",
  "tactic-prompt":
  "theorem (a b : Î±)  (p : Prop) : a = b âˆ§ p â†” b = a âˆ§ p := by simp [eq_comm]; sorry",
  "name": "and_symm_left",
  "kind": "theorem",
  "first-tactic": "simp [eq_comm]",
  "core-prompt": "(a b : Î±)  (p : Prop) : a = b âˆ§ p â†” b = a âˆ§ p",
  "args": "(a b : Î±)  (p : Prop)"},
 {"type": "Â¬Xor' P Q â†” (P â†” Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : Â¬Xor' P Q â†” (P â†” Q) := by simp only [not_and]; sorry",
  "name": "not_xor",
  "kind": "theorem",
  "first-tactic": "simp only [not_and]",
  "core-prompt": "(P Q : Prop) : Â¬Xor' P Q â†” (P â†” Q)",
  "args": "(P Q : Prop)"},
 {"type": "Xor' P Q â†” Â¬(P â†” Q)",
  "tactic-prompt":
  "theorem (P Q : Prop) : Xor' P Q â†” Â¬(P â†” Q) := by rw [iff_not_comm]; sorry",
  "name": "xor_iff_not_iff",
  "kind": "theorem",
  "first-tactic": "rw [iff_not_comm]",
  "core-prompt": "(P Q : Prop) : Xor' P Q â†” Â¬(P â†” Q)",
  "args": "(P Q : Prop)"},
 {"type": "HEq (@Eq.ndrec Î± a C x b e) y",
  "tactic-prompt":
  "theorem {C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec Î± a C x b e) y := by subst e; sorry",
  "name": "rec_heq_of_heq",
  "kind": "theorem",
  "first-tactic": "subst e",
  "core-prompt":
  "{C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y) : HEq (@Eq.ndrec Î± a C x b e) y",
  "args": "{C : Î± â†’ Sort _}  {x : C a}  {y : Î²}  (e : a = b)  (h : HEq x y)"},
 {"type": "xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚",
  "tactic-prompt":
  "theorem (hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚) : xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚ := by subst hâ‚; sorry",
  "name": "Eq.congr",
  "kind": "theorem",
  "first-tactic": "subst hâ‚",
  "core-prompt": "(hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚) : xâ‚ = xâ‚‚ â†” yâ‚ = yâ‚‚",
  "args": "(hâ‚ : xâ‚ = yâ‚)  (hâ‚‚ : xâ‚‚ = yâ‚‚)"},
 {"type": "x = z â†” y = z",
  "tactic-prompt":
  "theorem {x y z : Î±}  (h : x = y) : x = z â†” y = z := by rw [h]; sorry",
  "name": "Eq.congr_left",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : Î±}  (h : x = y) : x = z â†” y = z",
  "args": "{x y z : Î±}  (h : x = y)"},
 {"type": "z = x â†” z = y",
  "tactic-prompt":
  "theorem {x y z : Î±}  (h : x = y) : z = x â†” z = y := by rw [h]; sorry",
  "name": "Eq.congr_right",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt": "{x y z : Î±}  (h : x = y) : z = x â†” z = y",
  "args": "{x y z : Î±}  (h : x = y)"},
 {"type": "(Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)] : (Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x := by simp only [not_exists]; sorry",
  "name": "Decidable.not_exists_not",
  "kind": "theorem",
  "first-tactic": "simp only [not_exists]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)] : (Â¬âˆƒ x, Â¬p x) â†” âˆ€ x, p x",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [âˆ€ x, Decidable (p x)]"},
 {"type": "(âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±] : (âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b := by let âŸ¨aâŸ© := ha; sorry",
  "name": "forall_imp_iff_exists_imp",
  "kind": "theorem",
  "first-tactic": "let âŸ¨aâŸ© := ha",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±] : (âˆ€ x, p x) â†’ b â†” âˆƒ x, p x â†’ b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} [ha : Nonempty Î±]"},
 {"type": "(âˆ€ a, Î² a â†’ True) â†” True",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _} : (âˆ€ a, Î² a â†’ True) â†” True := by simp; sorry",
  "name": "forallâ‚‚_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _} : (âˆ€ a, Î² a â†’ True) â†” True",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}"},
 {"type": "(âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _} : (âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True := by simp; sorry",
  "name": "forallâ‚ƒ_true_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _} : (âˆ€ (a) (b : Î² a), Î³ a b â†’ True) â†” True",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}"},
 {"type": "(p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±) : (p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b := by simp only [â† @forall_eq _ p a]; sorry",
  "name": "and_forall_ne",
  "kind": "theorem",
  "first-tactic": "simp only [â† @forall_eq _ p a]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±) : (p a âˆ§ âˆ€ (b) (_ : b â‰  a), p b) â†” âˆ€ b, p b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} (a : Î±)"},
 {"type": "âˆƒ! a, a = a'",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a = a' := by simp only [eq_comm]; sorry",
  "name": "exists_unique_eq",
  "kind": "theorem",
  "first-tactic": "simp only [eq_comm]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a = a'",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "âˆƒ! a, a' = a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a' = a := by simp only [ExistsUnique]; sorry",
  "name": "exists_unique_eq'",
  "kind": "theorem",
  "first-tactic": "simp only [ExistsUnique]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : âˆƒ! a, a' = a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "(âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a) := by simp; sorry",
  "name": "forall_apply_eq_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_apply_eq_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, f a = b â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a) := by simp; sorry",
  "name": "forall_eq_apply_imp_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ a b, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a) := by simp [forall_swap]; sorry",
  "name": "forall_eq_apply_imp_iff'",
  "kind": "theorem",
  "first-tactic": "simp [forall_swap]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop} : (âˆ€ b a, b = f a â†’ p b) â†” âˆ€ a, p (f a)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {f : Î± â†’ Î²}  {p : Î² â†’ Prop}"},
 {"type": "(âˆƒ a, p a âˆ§ a' = a) â†” p a'",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : (âˆƒ a, p a âˆ§ a' = a) â†” p a' := by simp [@eq_comm _ a']; sorry",
  "name": "exists_eq_right'",
  "kind": "theorem",
  "first-tactic": "simp [@eq_comm _ a']",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±} : (âˆƒ a, p a âˆ§ a' = a) â†” p a'",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {a' : Î±}"},
 {"type": "(âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop} : (âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚ := by simp only [@exists_comm (Îºâ‚ _)]; sorry",
  "name": "existsâ‚‚_comm",
  "kind": "theorem",
  "first-tactic": "simp only [@exists_comm (Îºâ‚ _)]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop} : (âˆƒ iâ‚ jâ‚ iâ‚‚ jâ‚‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚) â†” âˆƒ iâ‚‚ jâ‚‚ iâ‚ jâ‚, p iâ‚ jâ‚ iâ‚‚ jâ‚‚",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Îºâ‚ : Î¹â‚ â†’ Sort _}  {Îºâ‚‚ : Î¹â‚‚ â†’ Sort _}  {p : âˆ€ iâ‚, Îºâ‚ iâ‚ â†’ âˆ€ iâ‚‚, Îºâ‚‚ iâ‚‚ â†’ Prop}"},
 {"type": "(âˆƒ! _ : p, q) â†” p âˆ§ q",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop} : (âˆƒ! _ : p, q) â†” p âˆ§ q := by simp; sorry",
  "name": "exists_unique_prop",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop} : (âˆƒ! _ : p, q) â†” p âˆ§ q",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {p q : Prop}"},
 {"type": "b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b) : b := by simp only [exists_unique_iff_exists] at hâ‚‚; sorry",
  "name": "ExistsUnique.elimâ‚‚",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at hâ‚‚",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b) : b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x) (_ : p x), Prop}  {b : Prop}  (hâ‚‚ : âˆƒ! (x : _) (h : p x), q x h)      (hâ‚ : âˆ€ (x) (h : p x), q x h â†’ (âˆ€ (y) (hy : p y), q y hy â†’ y = x) â†’ b)"},
 {"type": "âˆƒ! (x : _) (hx : p x), q x hx",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w) : âˆƒ! (x : _) (hx : p x), q x hx := by simp only [exists_unique_iff_exists]; sorry",
  "name": "ExistsUnique.intro2",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w) : âˆƒ! (x : _) (hx : p x), q x hx",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (w : Î±)  (hp : p w)  (hq : q w hp)      (H : âˆ€ (y) (hy : p y), q y hy â†’ y = w)"},
 {"type": "yâ‚ = yâ‚‚",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚) : yâ‚ = yâ‚‚ := by simp only [exists_unique_iff_exists] at h; sorry",
  "name": "ExistsUnique.unique2",
  "kind": "theorem",
  "first-tactic": "simp only [exists_unique_iff_exists] at h",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚) : yâ‚ = yâ‚‚",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _}  {Îº : Î¹ â†’ Sort _}  {p q : Î± â†’ Prop} {Î± : Sort _}  {p : Î± â†’ Sort _}  [âˆ€ x, Subsingleton (p x)]      {q : âˆ€ (x : Î±) (_ : p x), Prop}  (h : âˆƒ! (x : _) (hx : p x), q x hx)  {yâ‚ yâ‚‚ : Î±}      (hpyâ‚ : p yâ‚)  (hqyâ‚ : q yâ‚ hpyâ‚)  (hpyâ‚‚ : p yâ‚‚)  (hqyâ‚‚ : q yâ‚‚ hpyâ‚‚)"},
 {"type": "Decidable p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p := by infer_instance; sorry",
  "name": "dec",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop) : Decidable p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Prop)"},
 {"type": "DecidablePred p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop) : DecidablePred p := by infer_instance; sorry",
  "name": "decPred",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop) : DecidablePred p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Prop)"},
 {"type": "DecidableRel p",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop) : DecidableRel p := by infer_instance; sorry",
  "name": "decRel",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop) : DecidableRel p",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (p : Î± â†’ Î± â†’ Prop)"},
 {"type": "DecidableEq Î±",
  "tactic-prompt":
  "def {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort _) : DecidableEq Î± := by infer_instance; sorry",
  "name": "decEq",
  "kind": "def",
  "first-tactic": "infer_instance",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort _) : DecidableEq Î±",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open. (Î± : Sort _)"},
 {"type": "(âˆƒ (x : _) (_ : x = a), p x) â†” p a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±} : (âˆƒ (x : _) (_ : x = a), p x) â†” p a := by simp only [exists_prop]; sorry",
  "name": "bex_eq_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±} : (âˆƒ (x : _) (_ : x = a), p x) â†” p a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} {a : Î±}"},
 {"type": "(âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b := by simp; sorry",
  "name": "bex_imp",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ x h, P x h) â†’ b â†” âˆ€ x h, P x h â†’ b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop}"},
 {"type":
  "(âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x := by simp only [exists_prop]; sorry",
  "name": "bex_or_left",
  "kind": "theorem",
  "first-tactic": "simp only [exists_prop]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop} : (âˆƒ (x : _) (_ : p x âˆ¨ q x), r x) â†” (âˆƒ (x : _) (_ : p x), r x) âˆ¨ âˆƒ (x : _) (_ : q x), r x",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {r p q : Î± â†’ Prop}  {P Q : âˆ€ x, p x â†’ Prop}  {b : Prop}"},
 {"type": "dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c := by by_cases P; sorry",
  "name": "dite_eq_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P A B = c â†” (âˆƒ h, A h = c) âˆ¨ âˆƒ h, B h = c",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "dite P (fun _ => a) B = a â†” âˆ€ h, B h = a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ => a) B = a â†” âˆ€ h, B h = a := by by_cases P; sorry",
  "name": "dite_eq_left_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ => a) B = a â†” âˆ€ h, B h = a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "(dite P A fun _ => b) = b â†” âˆ€ h, A h = b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ => b) = b â†” âˆ€ h, A h = b := by by_cases P; sorry",
  "name": "dite_eq_right_iff",
  "kind": "theorem",
  "first-tactic": "by_cases P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ => b) = b â†” âˆ€ h, A h = b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "dite P (fun _ => a) B â‰  a â†” âˆƒ h, a â‰  B h",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ => a) B â‰  a â†” âˆƒ h, a â‰  B h := by rw [Ne.def]; sorry",
  "name": "dite_ne_left_iff",
  "kind": "theorem",
  "first-tactic": "rw [Ne.def]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : dite P (fun _ => a) B â‰  a â†” âˆƒ h, a â‰  B h",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "(dite P A fun _ => b) â‰  b â†” âˆƒ h, A h â‰  b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ => b) â‰  b â†” âˆƒ h, A h â‰  b := by simp only [Ne.def]; sorry",
  "name": "dite_ne_right_iff",
  "kind": "theorem",
  "first-tactic": "simp only [Ne.def]",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : (dite P A fun _ => b) â‰  b â†” âˆƒ h, A h â‰  b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type":
  "f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h)",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h) := by by_cases h : P; sorry",
  "name": "apply_diteâ‚‚",
  "kind": "theorem",
  "first-tactic": "by_cases h : P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²) : f (dite P a b) (dite P c d) = dite P (fun h => f (a h) (c h)) fun h => f (b h) (d h)",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : Î± â†’ Î² â†’ Î³)  (P : Prop)  [Decidable P]  (a : P â†’ Î±)  (b : Â¬P â†’ Î±)      (c : P â†’ Î²)  (d : Â¬P â†’ Î²)"},
 {"type": "(dite P f g) a = dite P (fun h => f h a) fun h => g h a",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±) : (dite P f g) a = dite P (fun h => f h a) fun h => g h a := by by_cases h:P; sorry",
  "name": "dite_apply",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±) : (dite P f g) a = dite P (fun h => f h a) fun h => g h a",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} (f : P â†’ âˆ€ a, Ïƒ a)  (g : Â¬P â†’ âˆ€ a, Ïƒ a)  (a : Î±)"},
 {"type": "ite (P âˆ§ Q) a b = ite P (ite Q a b) b",
  "tactic-prompt":
  "theorem {Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : ite (P âˆ§ Q) a b = ite P (ite Q a b) b := by by_cases hp : P; sorry",
  "name": "ite_and",
  "kind": "theorem",
  "first-tactic": "by_cases hp : P",
  "core-prompt":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±} : ite (P âˆ§ Q) a b = ite P (ite Q a b) b",
  "args":
  "{Î² : Î± â†’ Sort _}  {Î³ : âˆ€ a, Î² a â†’ Sort _}  {Î´ : âˆ€ a b, Î³ a b â†’ Sort _} {p : Î± â†’ Prop}  -- use shortened names to avoid conflict when classical namespace is open.  {Ïƒ : Î± â†’ Sort _}  (f : Î± â†’ Î²)  {P Q : Prop}  [Decidable P]  [Decidable Q]    {a b c : Î±}  {A : P â†’ Î±}  {B : Â¬P â†’ Î±}"},
 {"type": "decide True = true",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable True) : decide True = true := by simp; sorry",
  "name": "decide_True'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "{a b c d : Prop} (h : Decidable True) : decide True = true",
  "args": "{a b c d : Prop} (h : Decidable True)"},
 {"type": "decide False = false",
  "tactic-prompt":
  "theorem {a b c d : Prop} (h : Decidable False) : decide False = false := by simp; sorry",
  "name": "decide_False'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{a b c d : Prop} (h : Decidable False) : decide False = false",
  "args": "{a b c d : Prop} (h : Decidable False)"},
 {"type": "t",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t := by have := if_pos hc â–¸ h; sorry",
  "name": "imp_of_if_pos",
  "kind": "theorem",
  "first-tactic": "have := if_pos hc â–¸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c) : t",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hc : c)"},
 {"type": "e",
  "tactic-prompt":
  "theorem {a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c) : e := by have := if_neg hnc â–¸ h; sorry",
  "name": "imp_of_if_neg",
  "kind": "theorem",
  "first-tactic": "have := if_neg hnc â–¸ h",
  "core-prompt":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c) : e",
  "args":
  "{a b c d : Prop} {c t e : Prop}  [Decidable c]  (h : ite c t e)  (hnc : Â¬c)"},
 {"type": "HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚) : HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x) := by cases h; sorry",
  "name": "let_value_heq",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚) : HEq (let x : Î± := aâ‚; b x) (let x : Î± := aâ‚‚; b x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  {aâ‚ aâ‚‚ : Î±}  (b : âˆ€ x : Î±, Î² x)      (h : aâ‚ = aâ‚‚)"},
 {"type": "(let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x) := by exact h _ â–¸ rfl; sorry",
  "name": "let_body_eq",
  "kind": "theorem",
  "first-tactic": "exact h _ â–¸ rfl",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := a; bâ‚ x) = (let x : Î± := a; bâ‚‚ x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Î± â†’ Sort u}  (a : Î±)  {bâ‚ bâ‚‚ : âˆ€ x : Î±, Î² x}      (h : âˆ€ x, bâ‚ x = bâ‚‚ x)"},
 {"type": "(let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x)",
  "tactic-prompt":
  "theorem {a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x) := by simp [hâ‚]; sorry",
  "name": "let_eq",
  "kind": "theorem",
  "first-tactic": "simp [hâ‚]",
  "core-prompt":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x) : (let x : Î± := aâ‚; bâ‚ x) = (let x : Î± := aâ‚‚; bâ‚‚ x)",
  "args":
  "{a b c d : Prop} {Î± : Sort v}  {Î² : Sort u}  {aâ‚ aâ‚‚ : Î±}  {bâ‚ bâ‚‚ : Î± â†’ Î²}      (hâ‚ : aâ‚ = aâ‚‚)  (hâ‚‚ : âˆ€ x, bâ‚ x = bâ‚‚ x)"},
 {"type": "min a b â‰¤ a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ a := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "min_le_left",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "min a b â‰¤ b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ b := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "min_le_right",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : min a b â‰¤ b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "c â‰¤ min a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b) : c â‰¤ min a b := by if h : a â‰¤ b\n  then simp [min_def]; sorry",
  "name": "le_min",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [min_def]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b) : c â‰¤ min a b",
  "args":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : c â‰¤ a)  (hâ‚‚ : c â‰¤ b)"},
 {"type": "a â‰¤ max a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : a â‰¤ max a b := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "le_max_left",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : a â‰¤ max a b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "b â‰¤ max a b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b : Î±) : b â‰¤ max a b := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "le_max_right",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±) : b â‰¤ max a b",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b : Î±)"},
 {"type": "max a b â‰¤ c",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c) : max a b â‰¤ c := by if h : a â‰¤ b\n  then simp [max_def]; sorry",
  "name": "max_le",
  "kind": "lemma",
  "first-tactic": "if h : a â‰¤ b\n  then simp [max_def]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c) : max a b â‰¤ c",
  "args":
  "{Î± : Type u}  [LinearOrder Î±] {a b c : Î±}  (hâ‚ : a â‰¤ c)  (hâ‚‚ : b â‰¤ c)"},
 {"type": "min (min a b) c = min a (min b c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : min (min a b) c = min a (min b c) := by apply eq_min; sorry",
  "name": "min_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_min",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : min (min a b) c = min a (min b c)",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±)"},
 {"type": "min a a = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a : Î±) : min a a = a := by simp [min_def]; sorry",
  "name": "min_self",
  "kind": "lemma",
  "first-tactic": "simp [min_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a : Î±) : min a a = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a : Î±)"},
 {"type": "min a b = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : min a b = a := by apply Eq.symm; sorry",
  "name": "min_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : min a b = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "min a b = b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : min a b = b := by rw [min_comm]; sorry",
  "name": "min_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [min_comm]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : min a b = b",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "max (max a b) c = max a (max b c)",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : max (max a b) c = max a (max b c) := by apply eq_max; sorry",
  "name": "max_assoc",
  "kind": "lemma",
  "first-tactic": "apply eq_max",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±) : max (max a b) c = max a (max b c)",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a b c : Î±)"},
 {"type": "max a a = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] (a : Î±) : max a a = a := by simp [max_def]; sorry",
  "name": "max_self",
  "kind": "lemma",
  "first-tactic": "simp [max_def]",
  "core-prompt": "{Î± : Type u}  [LinearOrder Î±] (a : Î±) : max a a = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] (a : Î±)"},
 {"type": "max a b = a",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : max a b = a := by apply Eq.symm; sorry",
  "name": "max_eq_left",
  "kind": "lemma",
  "first-tactic": "apply Eq.symm",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a) : max a b = a",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : b â‰¤ a)"},
 {"type": "max a b = b",
  "tactic-prompt":
  "lemma {Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : max a b = b := by rw [â†max_comm b a]; sorry",
  "name": "max_eq_right",
  "kind": "lemma",
  "first-tactic": "rw [â†max_comm b a]",
  "core-prompt":
  "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b) : max a b = b",
  "args": "{Î± : Type u}  [LinearOrder Î±] {a b : Î±}  (h : a â‰¤ b)"},
 {"type": "âˆ€ a b, min a b = if a â‰¤ b then a else b",
  "tactic-prompt":
  "def {Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, min a b = if a â‰¤ b then a else b := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, min a b = if a â‰¤ b then a else b",
  "args": "{Î± : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "âˆ€ a b, max a b = if a â‰¤ b then b else a",
  "tactic-prompt":
  "def {Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, max a b = if a â‰¤ b then b else a := by intros; sorry",
  "name": "",
  "kind": "def",
  "first-tactic": "intros",
  "core-prompt":
  "{Î± : Type u}  -- set_option auto_param.check_exists false : âˆ€ a b, max a b = if a â‰¤ b then b else a",
  "args": "{Î± : Type u}  -- set_option auto_param.check_exists false"},
 {"type": "WellFounded (lbp p)",
  "tactic-prompt":
  "def (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) : WellFounded (lbp p) := by refine âŸ¨let âŸ¨n, pnâŸ© := H; ?_âŸ©; sorry",
  "name": "wf_lbp",
  "kind": "def",
  "first-tactic": "refine âŸ¨let âŸ¨n, pnâŸ© := H; ?_âŸ©",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) : WellFounded (lbp p)",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n)"},
 {"type":
  "âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by induction f; sorry",
  "name": "to_digits_core_lens_eq_aux",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (l1 l2 : List Char), l1.length = l2.length â†’\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat)"},
 {"type":
  "âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by induction f; sorry",
  "name": "to_digits_core_lens_eq",
  "kind": "lemma",
  "first-tactic": "induction f",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat) : âˆ€ (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b f : Nat)"},
 {"type": "n < b ^ e.succ â†’ n / b < b ^ e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ â†’ n / b < b ^ e := by simp only [Nat.pow_succ]; sorry",
  "name": "nat_repr_len_aux",
  "kind": "lemma",
  "first-tactic": "simp only [Nat.pow_succ]",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b) : n < b ^ e.succ â†’ n / b < b ^ e",
  "args":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n b e : Nat)  (h_b_pos : 0 < b)"},
 {"type": "(Nat.toDigitsCore b f n []).length <= e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]; sorry",
  "name": "to_digits_core_length",
  "kind": "lemma",
  "first-tactic":
  "induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore]",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e",
  "args":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (b : Nat)  (h : 2 <= b)  (f n e : Nat)      (hlt : n < b ^ e)  (h_e_pos: 0 < e)"},
 {"type": "0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e",
  "tactic-prompt":
  "lemma (p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat) : 0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e := by cases n; sorry",
  "name": "repr_length",
  "kind": "lemma",
  "first-tactic": "cases n",
  "core-prompt":
  "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat) : 0 < e â†’ n < 10 ^ e â†’ (Nat.repr n).length <= e",
  "args": "(p : â„• â†’ Prop) [DecidablePred p]  (H : âˆƒ n, p n) (n e : Nat)"},
 {"type": "(m * n).cast = (m.cast * n.cast : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : â„•} : (m * n).cast = (m.cast * n.cast : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_mul",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt":
  "[Semiring R]  {m n : â„•} : (m * n).cast = (m.cast * n.cast : R)",
  "args": "[Semiring R]  {m n : â„•}"},
 {"type": "(m ^ n).cast = (m.cast ^ n : R)",
  "tactic-prompt":
  "lemma [Semiring R]  {m n : â„•} : (m ^ n).cast = (m.cast ^ n : R) := by induction n generalizing m; sorry",
  "name": "Nat.cast_pow",
  "kind": "lemma",
  "first-tactic": "induction n generalizing m",
  "core-prompt": "[Semiring R]  {m n : â„•} : (m ^ n).cast = (m.cast ^ n : R)",
  "args": "[Semiring R]  {m n : â„•}"},
 {"type": "(a - b) * c = a * c - b * c",
  "tactic-prompt":
  "theorem [Ring R]  (a b c : R) : (a - b) * c = a * c - b * c := by simpa only [sub_eq_add_neg]; sorry",
  "name": "mul_sub_right_distrib",
  "kind": "theorem",
  "first-tactic": "simpa only [sub_eq_add_neg]",
  "core-prompt": "[Ring R]  (a b c : R) : (a - b) * c = a * c - b * c",
  "args": "[Ring R]  (a b c : R)"},
 {"type": "âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚",
  "tactic-prompt":
  "theorem {G : Type _} {M : Type u} : âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚ := by rintro âŸ¨âŸ¨oneâ‚âŸ©, âŸ¨mulâ‚âŸ©, one_mulâ‚, mul_oneâ‚âŸ© âŸ¨âŸ¨oneâ‚‚âŸ©, âŸ¨mulâ‚‚âŸ©, one_mulâ‚‚, mul_oneâ‚‚âŸ© âŸ¨rflâŸ©; sorry",
  "name": "MulOneClass.ext",
  "kind": "theorem",
  "first-tactic":
  "rintro âŸ¨âŸ¨oneâ‚âŸ©, âŸ¨mulâ‚âŸ©, one_mulâ‚, mul_oneâ‚âŸ© âŸ¨âŸ¨oneâ‚‚âŸ©, âŸ¨mulâ‚‚âŸ©, one_mulâ‚‚, mul_oneâ‚‚âŸ© âŸ¨rflâŸ©",
  "core-prompt":
  "{G : Type _} {M : Type u} : âˆ€ â¦ƒmâ‚ mâ‚‚ : MulOneClass Mâ¦„, mâ‚.mul = mâ‚‚.mul â†’ mâ‚ = mâ‚‚",
  "args": "{G : Type _} {M : Type u}"},
 {"type": "b = c",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c := by rw [â† one_mul c]; sorry",
  "name": "left_inv_eq_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† one_mul c]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1) : b = c",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a b c : M}  (hba : b * a = 1)  (hac : a * c = 1)"},
 {"type": "a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹",
  "tactic-prompt":
  "theorem {G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : â„•) : a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹ := by rw [â† zpow_coe_nat]; sorry",
  "name": "zpow_neg_succ_of_nat",
  "kind": "theorem",
  "first-tactic": "rw [â† zpow_coe_nat]",
  "core-prompt":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : â„•) : a ^ (Int.negSucc n) = (a ^ (n + 1))â»Â¹",
  "args":
  "{G : Type _}  [DivInvMonoid G]  {a b : G}  -- TODO restore @[to_additive zsmul_eq_smul] (a : G)  (n : â„•)"},
 {"type": "a * aâ»Â¹ = 1",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a : G) : a * aâ»Â¹ = 1 := by rw [â† mul_left_inv aâ»Â¹]; sorry",
  "name": "mul_right_inv",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_left_inv aâ»Â¹]",
  "core-prompt": "{G : Type _}  [Group G]  {a b c : G} (a : G) : a * aâ»Â¹ = 1",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a : G)"},
 {"type": "aâ»Â¹ * (a * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : aâ»Â¹ * (a * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "inv_mul_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : aâ»Â¹ * (a * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * (aâ»Â¹ * b) = b",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (aâ»Â¹ * b) = b := by rw [â† mul_assoc]; sorry",
  "name": "mul_inv_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * (aâ»Â¹ * b) = b",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * b * bâ»Â¹ = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * bâ»Â¹ = a := by rw [mul_assoc]; sorry",
  "name": "mul_inv_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * b * bâ»Â¹ = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "a * bâ»Â¹ * b = a",
  "tactic-prompt":
  "theorem {G : Type _}  [Group G]  {a b c : G} (a b : G) : a * bâ»Â¹ * b = a := by rw [mul_assoc]; sorry",
  "name": "inv_mul_cancel_right",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{G : Type _}  [Group G]  {a b c : G} (a b : G) : a * bâ»Â¹ * b = a",
  "args": "{G : Type _}  [Group G]  {a b c : G} (a b : G)"},
 {"type": "Function.Injective (@Group.toDivInvMonoid G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G) := by rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "Group.toDivInvMonoid_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt":
  "{G : Type _} {G : Type _} : Function.Injective (@Group.toDivInvMonoid G)",
  "args": "{G : Type _} {G : Type _}"},
 {"type": "Function.Injective (@CommGroup.toGroup G)",
  "tactic-prompt":
  "theorem {G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G) := by rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©; sorry",
  "name": "CommGroup.toGroup_injective",
  "kind": "theorem",
  "first-tactic": "rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ©",
  "core-prompt":
  "{G : Type _} {G : Type u} : Function.Injective (@CommGroup.toGroup G)",
  "args": "{G : Type _} {G : Type u}"},
 {"type": "SemiconjBy a (x * x') (y * y')",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y') := by unfold SemiconjBy; sorry",
  "name": "mul_right",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y') : SemiconjBy a (x * x') (y * y')",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (h : SemiconjBy a x y)  (h' : SemiconjBy a x' y')"},
 {"type": "SemiconjBy (a * b) x z",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z := by unfold SemiconjBy; sorry",
  "name": "mul_left",
  "kind": "theorem",
  "first-tactic": "unfold SemiconjBy",
  "core-prompt":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z",
  "args":
  "{G : Type _}  {S : Type u}  [Semigroup S]  {a b x y z x' y' : S} (ha : SemiconjBy a y z)  (hb : SemiconjBy b x y)"},
 {"type": "SemiconjBy a 1 1",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1 := by rw [SemiconjBy]; sorry",
  "name": "one_right",
  "kind": "theorem",
  "first-tactic": "rw [SemiconjBy]",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M) : SemiconjBy a 1 1",
  "args": "{G : Type _}  {M : Type u}  [MulOneClass M] (a : M)"},
 {"type": "SemiconjBy a (x ^ n) (y ^ n)",
  "tactic-prompt":
  "theorem {G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•) : SemiconjBy a (x ^ n) (y ^ n) := by induction' n with n ih; sorry",
  "name": "pow_right",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•) : SemiconjBy a (x ^ n) (y ^ n)",
  "args":
  "{G : Type _}  {M : Type u}  [Monoid M] {a x y : M}  (h : SemiconjBy a x y)  (n : â„•)"},
 {"type": "a * b * c = a * c * b",
  "tactic-prompt":
  "theorem {G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b := by simp only [mul_assoc]; sorry",
  "name": "right_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S) : a * b * c = a * c * b",
  "args":
  "{G : Type _}  {S : Type _}  [Semigroup S]  {a b c : S} (h : Commute b c)  (a : S)"},
 {"type": "(x * Â·) âˆ˜ (y * Â·) = (x * y * Â·)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (x * Â·) âˆ˜ (y * Â·) = (x * y * Â·) := by ext z; sorry",
  "name": "comp_mul_left",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (x * Â·) âˆ˜ (y * Â·) = (x * y * Â·)",
  "args": "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±)"},
 {"type": "(Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x))",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x)) := by ext z; sorry",
  "name": "comp_mul_right",
  "kind": "theorem",
  "first-tactic": "ext z",
  "core-prompt":
  "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±) : (Â· * x) âˆ˜ (Â· * y) = (Â· * (y * x))",
  "args": "{Î± Î² G : Type _}  [Semigroup Î±]  (x y : Î±)"},
 {"type": "ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1 := by by_cases h:P; sorry",
  "name": "ite_mul_one",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P (a * b) 1 = ite P a 1 * ite P b 1",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b := by by_cases h:P; sorry",
  "name": "ite_one_mul",
  "kind": "theorem",
  "first-tactic": "by_cases h:P",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M} : ite P 1 (a * b) = ite P 1 a * ite P 1 b",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {P : Prop}  [Decidable P]  {a b : M}"},
 {"type": "a = 1 â†” b = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 â†” b = 1 := by constructor; sorry",
  "name": "eq_one_iff_eq_one_of_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1) : a = 1 â†” b = 1",
  "args":
  "{Î± Î² G : Type _}  {M : Type u}  [MulOneClass M] {a b : M}  (h : a * b = 1)"},
 {"type": "a * b * (c * d) = a * c * (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d) := by simp only [mul_left_comm]; sorry",
  "name": "mul_mul_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G) : a * b * (c * d) = a * c * (b * d)",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c d : G)"},
 {"type": "a * b * c = b * c * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * b * c = b * c * a",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "a * (b * c) = b * (c * a)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a) := by simp only [mul_left_comm]; sorry",
  "name": "mul_rotate'",
  "kind": "theorem",
  "first-tactic": "simp only [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G) : a * (b * c) = b * (c * a)",
  "args": "{Î± Î² G : Type _}  [CommSemigroup G] (a b c : G)"},
 {"type": "b = aâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = bâ»Â¹) : b = aâ»Â¹ := by simp [h]; sorry",
  "name": "eq_inv_of_eq_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = bâ»Â¹) : b = aâ»Â¹",
  "args": "{Î± Î² G : Type _}  [HasInvolutiveInv G]  {a b : G} (h : a = bâ»Â¹)"},
 {"type": "xâ»Â¹ = 1 / x",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : xâ»Â¹ = 1 / x := by rw [div_eq_mul_inv]; sorry",
  "name": "inv_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G) : xâ»Â¹ = 1 / x",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x : G)"},
 {"type": "x * (1 / y) = x / y",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G) : x * (1 / y) = x / y",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (x y : G)"},
 {"type": "a * b / c = a * (b / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c) := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_assoc",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * b / c = a * (b / c)",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a * (b / c) = a * b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c := by simp only [mul_assoc]; sorry",
  "name": "mul_div",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G) : a * (b / c) = a * b / c",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b c : G)"},
 {"type": "a / b = a * (1 / b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b) := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_mul_one_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G) : a / b = a * (1 / b)",
  "args": "{Î± Î² G : Type _}  [DivInvMonoid G]  {a b c : G} (a b : G)"},
 {"type": "a / 1 = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a := by simp [div_eq_mul_inv]; sorry",
  "name": "div_one",
  "kind": "theorem",
  "first-tactic": "simp [div_eq_mul_inv]",
  "core-prompt": "{Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G) : a / 1 = a",
  "args": "{Î± Î² G : Type _}  [DivInvOneMonoid G] (a : G)"},
 {"type": "bâ»Â¹ = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : bâ»Â¹ = a := by rw [â† inv_eq_of_mul_eq_one_right h]; sorry",
  "name": "inv_eq_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_eq_of_mul_eq_one_right h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : bâ»Â¹ = a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_left h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_left",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_left h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1) : b = 1 / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : b * a = 1)"},
 {"type": "b = 1 / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : b = 1 / a := by rw [eq_inv_of_mul_eq_one_right h]; sorry",
  "name": "eq_one_div_of_mul_eq_one_right",
  "kind": "theorem",
  "first-tactic": "rw [eq_inv_of_mul_eq_one_right h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1) : b = 1 / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : a * b = 1)"},
 {"type": "1 / a * (1 / b) = 1 / (b * a)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / a * (1 / b) = 1 / (b * a) := by simp; sorry",
  "name": "one_div_mul_one_div_rev",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / a * (1 / b) = 1 / (b * a)",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "aâ»Â¹ / b = (b * a)â»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : aâ»Â¹ / b = (b * a)â»Â¹ := by simp; sorry",
  "name": "inv_div_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : aâ»Â¹ / b = (b * a)â»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "(a / b)â»Â¹ = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : (a / b)â»Â¹ = b / a := by simp; sorry",
  "name": "inv_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : (a / b)â»Â¹ = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "1 / (a / b) = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (a / b) = b / a := by simp; sorry",
  "name": "one_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (a / b) = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "1 / (1 / a) = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (1 / a) = a := by simp; sorry",
  "name": "one_div_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : 1 / (1 / a) = a",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b) : a = b := by rw [â† one_div_one_div a]; sorry",
  "name": "eq_of_one_div_eq_one_div",
  "kind": "theorem",
  "first-tactic": "rw [â† one_div_one_div a]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b) : a = b",
  "args":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} (h : 1 / a = 1 / b)"},
 {"type": "a / (b / c) = a * c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b / c) = a * c / b := by simp; sorry",
  "name": "div_div_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b / c) = a * c / b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a / bâ»Â¹ = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / bâ»Â¹ = a * b := by simp; sorry",
  "name": "div_inv_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / bâ»Â¹ = a * b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "a / (b * c) = a / c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b * c) = a / c / b := by simp only [mul_assoc]; sorry",
  "name": "div_mul_eq_div_div_swap",
  "kind": "theorem",
  "first-tactic": "simp only [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±} : a / (b * c) = a / c / b",
  "args": "{Î± Î² G : Type _}  [DivisionMonoid Î±]  {a b c : Î±}"},
 {"type": "(a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹ := by simp; sorry",
  "name": "mul_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ * bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹ := by simp; sorry",
  "name": "inv_div'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a / b)â»Â¹ = aâ»Â¹ / bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b = bâ»Â¹ * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b = bâ»Â¹ * a := by simp; sorry",
  "name": "div_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b = bâ»Â¹ * a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "aâ»Â¹ * b = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ * b = b / a := by simp; sorry",
  "name": "inv_mul_eq_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ * b = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(a * b)â»Â¹ = aâ»Â¹ / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ / b := by simp; sorry",
  "name": "inv_mul'",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (a * b)â»Â¹ = aâ»Â¹ / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "aâ»Â¹ / bâ»Â¹ = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ / bâ»Â¹ = b / a := by simp; sorry",
  "name": "inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : aâ»Â¹ / bâ»Â¹ = b / a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "(aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b := by simp; sorry",
  "name": "inv_inv_div_inv",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : (aâ»Â¹ / bâ»Â¹)â»Â¹ = a / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "1 / a * (1 / b) = 1 / (a * b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : 1 / a * (1 / b) = 1 / (a * b) := by simp; sorry",
  "name": "one_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : 1 / a * (1 / b) = 1 / (a * b)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / c = a / c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / c / b := by simp; sorry",
  "name": "div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / c / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / c = a / (b * c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / (b * c) := by simp; sorry",
  "name": "div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / c = a / (b * c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a / (b / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a / (b / c) := by simp; sorry",
  "name": "div_mul",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a / (b / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * (b / c) = b * (a / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * (b / c) = b * (a / c) := by simp; sorry",
  "name": "mul_div_left_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * (b / c) = b * (a / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * b / c = a / c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / c = a / c * b := by simp; sorry",
  "name": "mul_div_right_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / c = a / c * b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / (b * c) = a / b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b / c := by simp; sorry",
  "name": "div_mul_eq_div_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b / c",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a * c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * c / b := by simp; sorry",
  "name": "div_mul_eq_mul_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * c / b",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = a * (c / b)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * (c / b) := by simp; sorry",
  "name": "mul_comm_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = a * (c / b)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * c = c / b * a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = c / b * a := by simp; sorry",
  "name": "div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * c = c / b * a",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / (b * c) = a / b * (1 / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b * (1 / c) := by simp; sorry",
  "name": "div_mul_eq_div_mul_one_div",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / (b * c) = a / b * (1 / c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / (c / d) = a * d / (b * c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a * d / (b * c) := by simp; sorry",
  "name": "div_div_div_eq",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a * d / (b * c)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b / (c / d) = a / c / (b / d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a / c / (b / d) := by simp; sorry",
  "name": "div_div_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b / (c / d) = a / c / (b / d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b * (c / d) = a * c / (b * d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * (c / d) = a * c / (b * d) := by simp; sorry",
  "name": "div_mul_div_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a / b * (c / d) = a * c / (b * d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a * b / (c * d) = a / c * (b / d)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / (c * d) = a / c * (b / d) := by simp; sorry",
  "name": "mul_div_mul_comm",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±) : a * b / (c * d) = a / c * (b / d)",
  "args": "{Î± Î² G : Type _}  [DivisionCommMonoid Î±]  (a b c d : Î±)"},
 {"type": "a / b = bâ»Â¹ â†” a = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = bâ»Â¹ â†” a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_inv_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = bâ»Â¹ â†” a = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b * câ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * câ»Â¹ := by simp [h.symm]; sorry",
  "name": "eq_mul_inv_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b * câ»Â¹",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a = bâ»Â¹ * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = bâ»Â¹ * c := by simp [h.symm]; sorry",
  "name": "eq_inv_mul_of_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c) : a = bâ»Â¹ * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b * a = c)"},
 {"type": "aâ»Â¹ * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : aâ»Â¹ * b = c := by simp [h]; sorry",
  "name": "inv_mul_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c) : aâ»Â¹ * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = a * c)"},
 {"type": "a * bâ»Â¹ = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * bâ»Â¹ = c := by simp [h]; sorry",
  "name": "mul_inv_eq_of_eq_mul",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a * bâ»Â¹ = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_mul_inv_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * câ»Â¹ = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_inv_mul_eq",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : bâ»Â¹ * a = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c) : a * b = c := by rw [h]; sorry",
  "name": "mul_eq_of_eq_inv_mul",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : b = aâ»Â¹ * c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_mul_inv",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * bâ»Â¹)"},
 {"type": "a * b = 1 â†” aâ»Â¹ = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * b = 1 â†” aâ»Â¹ = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_eq_one_iff_inv_eq",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * b = 1 â†” aâ»Â¹ = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a * bâ»Â¹ = 1 â†” a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * bâ»Â¹ = 1 â†” a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "mul_inv_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a * bâ»Â¹ = 1 â†” a = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "aâ»Â¹ * b = 1 â†” a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : aâ»Â¹ * b = 1 â†” a = b := by rw [mul_eq_one_iff_eq_inv]; sorry",
  "name": "inv_mul_eq_one",
  "kind": "theorem",
  "first-tactic": "rw [mul_eq_one_iff_eq_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : aâ»Â¹ * b = 1 â†” a = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a => a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => a / b := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_left_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "Function.Injective fun a => b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => b / a := by simp only [div_eq_mul_inv]; sorry",
  "name": "div_right_injective",
  "kind": "theorem",
  "first-tactic": "simp only [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : Function.Injective fun a => b / a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * b = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "div_mul_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a / b * b = a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a / a = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_self'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G) : a / a = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a : G)"},
 {"type": "a * b / b = a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G) : a * b / b = a",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b : G)"},
 {"type": "a * c / (b * c) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b := by rw [div_mul_eq_div_div_swap]; sorry",
  "name": "mul_div_mul_right_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_mul_eq_div_div_swap]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a * c / (b * c) = a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c := by simp [â† h]; sorry",
  "name": "eq_div_of_mul_eq'",
  "kind": "theorem",
  "first-tactic": "simp [â† h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b) : a = b / c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a * c = b)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c := by simp [h]; sorry",
  "name": "div_eq_of_eq_mul''",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b) : a / b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c * b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c := by simp [â† h]; sorry",
  "name": "eq_mul_of_div_eq",
  "kind": "theorem",
  "first-tactic": "simp [â† h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b) : a = b * c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a / c = b)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b) : a * b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (h : a = c / b)"},
 {"type": "b / a = c / a â†” b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : b / a = c / a â†” b = c := by rw [div_eq_mul_inv]; sorry",
  "name": "div_left_inj",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : b / a = c / a â†” b = c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b * (b / c) = a / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c := by rw [â† mul_div_assoc]; sorry",
  "name": "div_mul_div_cancel'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / b * (b / c) = a / c",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c / (b / c) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b := by rw [â† inv_div c b]; sorry",
  "name": "div_div_div_cancel_right'",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div c b]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G) : a / c / (b / c) = a / b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = a â†” b = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = a â†” b = 1 := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_self",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = a â†” b = 1",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b / c â†” a * c = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a = b / c â†” a * c = b := by rw [div_eq_mul_inv]; sorry",
  "name": "eq_div_iff_mul_eq'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a = b / c â†” a * c = b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a / b = c â†” a = c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = c â†” a = c * b := by rw [div_eq_mul_inv]; sorry",
  "name": "div_eq_iff_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} : a / b = c â†” a = c * b",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G}"},
 {"type": "a = b â†” c = d",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b â†” c = d := by rw [â† div_eq_one]; sorry",
  "name": "eq_iff_eq_of_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [â† div_eq_one]",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d) : a = b â†” c = d",
  "args": "{Î± Î² G : Type _}  [Group G]  {a b c d : G} (H : a / b = c / d)"},
 {"type": "âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1) : âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1 := by cases' n with n n; sorry",
  "name": "exists_npow_eq_one_of_zpow_eq_one",
  "kind": "theorem",
  "first-tactic": "cases' n with n n",
  "core-prompt":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1) : âˆƒ n : â„•, 0 < n âˆ§ x ^ n = 1",
  "args":
  "{Î± Î² G : Type _}  [Group G]  {a b c d : G} {n : â„¤}  (hn : n â‰  0)  {x : G}  (h : x ^ n = 1)"},
 {"type": "a / b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c := by rw [h]; sorry",
  "name": "div_eq_of_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c) : a / b = c",
  "args":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} {a b c : G}  (h : a = b * c)"},
 {"type": "c * a / (c * b) = a / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b := by rw [div_eq_mul_inv]; sorry",
  "name": "mul_div_mul_left_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c * a / (c * b) = a / b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a = b / c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c := by simp [h.symm]; sorry",
  "name": "eq_div_of_mul_eq''",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b) : a = b / c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : c * a = b)"},
 {"type": "a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c := by simp [h.symm]; sorry",
  "name": "eq_mul_of_div_eq'",
  "kind": "theorem",
  "first-tactic": "simp [h.symm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c) : a = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : a / b = c)"},
 {"type": "a * b = c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c := by simp [h]; sorry",
  "name": "mul_eq_of_eq_div'",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a) : a * b = c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (h : b = c / a)"},
 {"type": "a / (a / b) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b := by simpa using mul_inv_cancel_left a b; sorry",
  "name": "div_div_self'",
  "kind": "theorem",
  "first-tactic": "simpa using mul_inv_cancel_left a b",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a / b) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / b = c / b * (a / c)",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c) := by simp [mul_left_comm c]; sorry",
  "name": "div_eq_div_mul_div",
  "kind": "theorem",
  "first-tactic": "simp [mul_left_comm c]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b = c / b * (a / c)",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b / a = bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = bâ»Â¹ := by simp; sorry",
  "name": "div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / b / a = bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a = b / c â†” c * a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c â†” c * a = b := by rw [eq_div_iff_mul_eq']; sorry",
  "name": "eq_div_iff_mul_eq''",
  "kind": "theorem",
  "first-tactic": "rw [eq_div_iff_mul_eq']",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a = b / c â†” c * a = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c â†” a = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c â†” a = b * c := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_iff_eq_mul'",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c â†” a = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a * b / a = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b := by rw [div_eq_inv_mul]; sorry",
  "name": "mul_div_cancel'''",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_inv_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * b / a = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b / a) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b := by rw [â† mul_div_assoc]; sorry",
  "name": "mul_div_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_div_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b / a) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a / (a * b) = bâ»Â¹",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = bâ»Â¹ := by rw [â† inv_div]; sorry",
  "name": "div_mul_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a / (a * b) = bâ»Â¹",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * (b * aâ»Â¹) = b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * aâ»Â¹) = b := by rw [â† div_eq_mul_inv]; sorry",
  "name": "mul_mul_inv_cancel'_right",
  "kind": "theorem",
  "first-tactic": "rw [â† div_eq_mul_inv]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G) : a * (b * aâ»Â¹) = b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b : G)"},
 {"type": "a * c * (b / c) = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b := by rw [mul_assoc]; sorry",
  "name": "mul_mul_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_assoc]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * c * (b / c) = a * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / c * (b * c) = a * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b := by rw [mul_left_comm]; sorry",
  "name": "div_mul_mul_cancel",
  "kind": "theorem",
  "first-tactic": "rw [mul_left_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / c * (b * c) = a * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b * (c / a) = c / b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b := by rw [mul_comm]; sorry",
  "name": "div_mul_div_cancel''",
  "kind": "theorem",
  "first-tactic": "rw [mul_comm]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a / b * (c / a) = c / b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a * b / (a / c) = b * c",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c := by rw [â† div_mul]; sorry",
  "name": "mul_div_div_cancel",
  "kind": "theorem",
  "first-tactic": "rw [â† div_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : a * b / (a / c) = b * c",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "c / a / (c / b) = b / a",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a := by rw [â† inv_div b c]; sorry",
  "name": "div_div_div_cancel_left",
  "kind": "theorem",
  "first-tactic": "rw [â† inv_div b c]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G) : c / a / (c / b) = b / a",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} (a b c : G)"},
 {"type": "a / b = c / d â†” a * d = c * b",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a * d = c * b := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_mul_eq_mul",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a * d = c * b",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "a / b = c / d â†” a / c = b / d",
  "tactic-prompt":
  "theorem {Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a / c = b / d := by rw [div_eq_iff_eq_mul]; sorry",
  "name": "div_eq_div_iff_div_eq_div",
  "kind": "theorem",
  "first-tactic": "rw [div_eq_iff_eq_mul]",
  "core-prompt":
  "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G} : a / b = c / d â†” a / c = b / d",
  "args": "{Î± Î² G : Type _}  [CommGroup G]  {a b c d : G}"},
 {"type": "Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r := by refine âŸ¨fun h a b c bc => ?_, fun h a b c bc => ?_âŸ©; sorry",
  "name": "Group.covariant_iff_contravariant",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h a b c bc => ?_, fun h a b c bc => ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (Â· * Â·) r â†” Contravariant N N (Â· * Â·) r",
  "args": "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N]"},
 {"type": "Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r := by refine âŸ¨fun h a b c bc => ?_, fun h a b c bc => ?_âŸ©; sorry",
  "name": "Group.covariant_swap_iff_contravariant_swap",
  "kind": "theorem",
  "first-tactic": "refine âŸ¨fun h a b c bc => ?_, fun h a b c bc => ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N] : Covariant N N (swap (Â· * Â·)) r â†” Contravariant N N (swap (Â· * Â·)) r",
  "args": "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [Group N]"},
 {"type": "Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·) := by intro h a b c bc; sorry",
  "name": "covariant_le_of_covariant_lt",
  "kind": "theorem",
  "first-tactic": "intro h a b c bc",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Covariant M N Î¼ (Â· < Â·) â†’ Covariant M N Î¼ (Â· â‰¤ Â·)",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N]"},
 {"type": "Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·)",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·) := by refine fun h a b c bc => lt_iff_le_and_ne.mpr âŸ¨h a bc.le, ?_âŸ©; sorry",
  "name": "contravariant_lt_of_contravariant_le",
  "kind": "theorem",
  "first-tactic":
  "refine fun h a b c bc => lt_iff_le_and_ne.mpr âŸ¨h a bc.le, ?_âŸ©",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N] : Contravariant M N Î¼ (Â· â‰¤ Â·) â†’ Contravariant M N Î¼ (Â· < Â·)",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [PartialOrder N]"},
 {"type": "Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r := by rw [flip_mul]; sorry",
  "name": "covariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Covariant N N (flip (Â· * Â·)) r â†” Covariant N N (Â· * Â·) r",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N]"},
 {"type": "Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r",
  "tactic-prompt":
  "theorem {M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r := by rw [flip_mul]; sorry",
  "name": "contravariant_flip_mul_iff",
  "kind": "theorem",
  "first-tactic": "rw [flip_mul]",
  "core-prompt":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N] : Contravariant N N (flip (Â· * Â·)) r â†” Contravariant N N (Â· * Â·) r",
  "args":
  "{M N : Type _}  (Î¼ : M â†’ N â†’ N)  (r : N â†’ N â†’ Prop)  [CommSemigroup N]"},
 {"type": "a ^ 1 = a",
  "tactic-prompt":
  "theorem [Monoid M] (a : M) : a ^ 1 = a := by rw [pow_succ]; sorry",
  "name": "pow_one",
  "kind": "theorem",
  "first-tactic": "rw [pow_succ]",
  "core-prompt": "[Monoid M] (a : M) : a ^ 1 = a",
  "args": "[Monoid M] (a : M)"},
 {"type": "a ^ (m + n) = a ^ m * a ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : â„•) : a ^ (m + n) = a ^ m * a ^ n := by induction' n with n ih; sorry",
  "name": "pow_add",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : â„•) : a ^ (m + n) = a ^ m * a ^ n",
  "args": "[Monoid M] (a : M)  (m n : â„•)"},
 {"type": "a ^ (m * n) = (a ^ m) ^ n",
  "tactic-prompt":
  "theorem [Monoid M] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ m) ^ n := by induction' n with n ih; sorry",
  "name": "pow_mul",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt": "[Monoid M] (a : M)  (m n : â„•) : a ^ (m * n) = (a ^ m) ^ n",
  "args": "[Monoid M] (a : M)  (m n : â„•)"},
 {"type": "(a * b) ^ n = a ^ n * b ^ n",
  "tactic-prompt":
  "theorem [Monoid M] {a b : M}  (h : Commute a b)  (n : â„•) : (a * b) ^ n = a ^ n * b ^ n := by induction' n with n ih; sorry",
  "name": "Commute.mul_pow",
  "kind": "theorem",
  "first-tactic": "induction' n with n ih",
  "core-prompt":
  "[Monoid M] {a b : M}  (h : Commute a b)  (n : â„•) : (a * b) ^ n = a ^ n * b ^ n",
  "args": "[Monoid M] {a b : M}  (h : Commute a b)  (n : â„•)"},
 {"type": "1 < aâ»Â¹ â†” a < 1",
  "tactic-prompt":
  "theorem [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1 := by rw [â† mul_lt_mul_iff_left a]; sorry",
  "name": "Left.one_lt_inv_iff",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_left a]",
  "core-prompt":
  "[Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±} : 1 < aâ»Â¹ â†” a < 1",
  "args":
  "[Group Î±]  [LT Î±]  [CovariantClass Î± Î± (Â· * Â·) (Â· < Â·)]  {a b c : Î±}"},
 {"type": "1 < a / b â†” b < a",
  "tactic-prompt":
  "theorem [Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}  -- FIXME: restore @[to_additive sub_pos] : 1 < a / b â†” b < a := by rw [â† mul_lt_mul_iff_right b]; sorry",
  "name": "one_lt_div'",
  "kind": "theorem",
  "first-tactic": "rw [â† mul_lt_mul_iff_right b]",
  "core-prompt":
  "[Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}  -- FIXME: restore @[to_additive sub_pos] : 1 < a / b â†” b < a",
  "args":
  "[Group Î±]  [LT Î±]  [CovariantClass Î± Î± (swap (Â· * Â·)) (Â· < Â·)]  {a b c d : Î±}  -- FIXME: restore @[to_additive sub_pos]"},
 {"type": "((1 : â„•) : R) = 1",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((1 : â„•) : R) = 1 := by simp; sorry",
  "name": "Nat.cast_one",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt": "[AddMonoidWithOne R] : ((1 : â„•) : R) = 1",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((m + n : â„•) : R) = (m : R) + n",
  "tactic-prompt":
  "theorem [AddMonoidWithOne R] : ((m + n : â„•) : R) = (m : R) + n := by induction n; sorry",
  "name": "Nat.cast_add",
  "kind": "theorem",
  "first-tactic": "induction n",
  "core-prompt": "[AddMonoidWithOne R] : ((m + n : â„•) : R) = (m : R) + n",
  "args": "[AddMonoidWithOne R]"},
 {"type": "((0 : â„¤) : R) = 0",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((0 : â„¤) : R) = 0 := by erw [cast_ofNat]; sorry",
  "name": "cast_zero",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt": "[AddGroupWithOne R] : ((0 : â„¤) : R) = 0",
  "args": "[AddGroupWithOne R]"},
 {"type": "((1 : â„¤) : R) = 1",
  "tactic-prompt":
  "theorem [AddGroupWithOne R] : ((1 : â„¤) : R) = 1 := by erw [cast_ofNat]; sorry",
  "name": "cast_one",
  "kind": "theorem",
  "first-tactic": "erw [cast_ofNat]",
  "core-prompt": "[AddGroupWithOne R] : ((1 : â„¤) : R) = 1",
  "args": "[AddGroupWithOne R]"},
 {"type": "Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b)",
  "tactic-prompt":
  "theorem (hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b) : Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b) := by refine âŸ¨fun H => by_contra fun hn => H âŸ¨fun c h => by_contra fun hn' => ?_âŸ©âŸ©; sorry",
  "name": "Fmla.reify_or",
  "kind": "theorem",
  "first-tactic":
  "refine âŸ¨fun H => by_contra fun hn => H âŸ¨fun c h => by_contra fun hn' => ?_âŸ©âŸ©",
  "core-prompt":
  "(hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b) : Fmla.reify v (fâ‚.and fâ‚‚) (a âˆ¨ b)",
  "args": "(hâ‚ : Fmla.reify v fâ‚ a)  (hâ‚‚ : Fmla.reify v fâ‚‚ b)"},
 {"type": "True",
  "tactic-prompt": "example  : True := by find; sorry",
  "name": "",
  "kind": "example",
  "first-tactic": "find",
  "core-prompt": " : True",
  "args": ""},
 {"type": "HEq a b â†” HEq (a : Î±) (b : Î²)",
  "tactic-prompt":
  "lemma {Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q) : HEq a b â†” HEq (a : Î±) (b : Î²) := by subst h; sorry",
  "name": "heq_iff_coe_heq",
  "kind": "lemma",
  "first-tactic": "subst h",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q) : HEq a b â†” HEq (a : Î±) (b : Î²)",
  "args":
  "{Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop} {Î± Î² : Sort _}  {p : Î± â†’ Prop}  {q : Î² â†’ Prop}  {a : {x // p x}}    {b : {y // q y}}  (h : Î± = Î²)  (h' : HEq p q)"},
 {"type": "Injective ((â†‘Â·) : Subtype p â†’ Î±)",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop} : Injective ((â†‘Â·) : Subtype p â†’ Î±) := by intros a b hab; sorry",
  "name": "coe_injective",
  "kind": "theorem",
  "first-tactic": "intros a b hab",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop} : Injective ((â†‘Â·) : Subtype p â†’ Î±)",
  "args":
  "{Î± : Sort _}  {Î² : Sort _}  {Î³ : Sort _}  {p : Î± â†’ Prop}  {q : Î± â†’ Prop}"},
 {"type": "C z",
  "tactic-prompt":
  "def {C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1)) : C z := by rw [â† sub_add_cancel (G := â„¤) z b]; sorry",
  "name": "inductionOn'",
  "kind": "def",
  "first-tactic": "rw [â† sub_add_cancel (G := â„¤) z b]",
  "core-prompt":
  "{C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1)) : C z",
  "args":
  "{C : â„¤ â†’ Sort _}      (z : â„¤)  (b : â„¤)  (H0 : C b)  (Hs : âˆ€ k, b â‰¤ k â†’ C k â†’ C (k + 1))      (Hp : âˆ€ k â‰¤ b, C k â†’ C (k - 1))"},
 {"type": "xâ‚€ = xâ‚",
  "tactic-prompt":
  "theorem {Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚ := by cases xâ‚€; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚",
  "args":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2)"},
 {"type": "xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "tactic-prompt":
  "theorem {Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2 := by cases xâ‚€; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "args":
  "{Î± Î±â‚ Î±â‚‚ : Type _}  {Î² : Î± â†’ Type _}  {Î²â‚ : Î±â‚ â†’ Type _}  {Î²â‚‚ : Î±â‚‚ â†’ Type _} {xâ‚€ xâ‚ : Sigma Î²}"},
 {"type": "Function.Surjective (Sigma.map fâ‚ fâ‚‚)",
  "tactic-prompt":
  "theorem {fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a)) : Function.Surjective (Sigma.map fâ‚ fâ‚‚) := by simp only [Function.Surjective]; sorry",
  "name": "Function.Surjective.sigma_map",
  "kind": "theorem",
  "first-tactic": "simp only [Function.Surjective]",
  "core-prompt":
  "{fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a)) : Function.Surjective (Sigma.map fâ‚ fâ‚‚)",
  "args":
  "{fâ‚ : Î±â‚ â†’ Î±â‚‚}  {fâ‚‚ : âˆ€ a, Î²â‚ a â†’ Î²â‚‚ (fâ‚ a)}    (hâ‚ : Function.Surjective fâ‚)  (hâ‚‚ : âˆ€ a, Function.Surjective (fâ‚‚ a))"},
 {"type": "xâ‚€ = xâ‚",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚ := by cases xâ‚€; sorry",
  "name": "ext",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2) : xâ‚€ = xâ‚",
  "args":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}  (hâ‚€ : xâ‚€.1 = xâ‚.1)  (hâ‚ : HEq xâ‚€.2 xâ‚.2)"},
 {"type": "xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "tactic-prompt":
  "theorem {Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2 := by cases xâ‚€; sorry",
  "name": "ext_iff",
  "kind": "theorem",
  "first-tactic": "cases xâ‚€",
  "core-prompt":
  "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²} : xâ‚€ = xâ‚ â†” xâ‚€.1 = xâ‚.1 âˆ§ HEq xâ‚€.2 xâ‚.2",
  "args": "{Î± : Sort _}  {Î² : Î± â†’ Sort _} {xâ‚€ xâ‚ : PSigma Î²}"},
 {"type": "n = arr.size",
  "tactic-prompt":
  "theorem {arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m) : n = arr.size := by cases H; sorry",
  "name": "size_eq",
  "kind": "theorem",
  "first-tactic": "cases H",
  "core-prompt":
  "{arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m) : n = arr.size",
  "args": "{arr : Array Î±}  {m : Fin n â†’ Î²}  (H : Agrees arr f m)"},
 {"type": "âˆƒ (m : UFModel self.arr.size), m.Models self.arr",
  "tactic-prompt":
  "theorem (self : UnionFind Î±) : âˆƒ (m : UFModel self.arr.size), m.Models self.arr := by let âŸ¨n, m, hmâŸ© := self.model; sorry",
  "name": "model'",
  "kind": "theorem",
  "first-tactic": "let âŸ¨n, m, hmâŸ© := self.model",
  "core-prompt":
  "(self : UnionFind Î±) : âˆƒ (m : UFModel self.arr.size), m.Models self.arr",
  "args": "(self : UnionFind Î±)"},
 {"type": "self.rank i < self.rankMax",
  "tactic-prompt":
  "theorem (self : UnionFind Î±)  (i : Nat) : self.rank i < self.rankMax := by simp [rank]; sorry",
  "name": "lt_rankMax",
  "kind": "theorem",
  "first-tactic": "simp [rank]",
  "core-prompt": "(self : UnionFind Î±)  (i : Nat) : self.rank i < self.rankMax",
  "args": "(self : UnionFind Î±)  (i : Nat)"},
 {"type":
  "(s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root",
  "tactic-prompt":
  "def (self : UnionFind Î±)  (x : Fin self.size) : (s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root := by have : x < self.arr.size := x.2; sorry",
  "name": "findAux",
  "kind": "def",
  "first-tactic": "have : x < self.arr.size := x.2",
  "core-prompt":
  "(self : UnionFind Î±)  (x : Fin self.size) : (s : Array (UFNode Î±)) Ã—' (root : Fin s.size) Ã—'\n    âˆƒ n, âˆƒ (m : UFModel n) (m' : UFModel n),\n      m.Models self.arr âˆ§ m'.Models s âˆ§ m'.rank = m.rank âˆ§\n      (âˆƒ hr, (m'.parent âŸ¨root, hrâŸ©).1 = root) âˆ§\n      m.rank x â‰¤ m.rank root",
  "args": "(self : UnionFind Î±)  (x : Fin self.size)"},
 {"type": "UnionFind Î±",
  "tactic-prompt":
  "def (self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind Î± := by refine if ne : x.1 = y then self else\n    have hx : x < self.arr.size := x.2\n    have hy : y < self.arr.size := y.2\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      âŸ¨self.arr.set y {ny with parent := x}]; sorry",
  "name": "link",
  "kind": "def",
  "first-tactic":
  "refine if ne : x.1 = y then self else\n    have hx : x < self.arr.size := x.2\n    have hy : y < self.arr.size := y.2\n    let nx := self.arr[x]\n    let ny := self.arr[y]\n    if h : ny.rank < nx.rank then\n      âŸ¨self.arr.set y {ny with parent := x}]",
  "core-prompt":
  "(self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y) : UnionFind Î±",
  "args":
  "(self : UnionFind Î±)  (x y : Fin self.size)    (yroot : (self.arr.get y).parent = y)"},
 {"type": "x.getLeft = none â†” x.isRight",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getLeft = none â†” x.isRight := by cases x; sorry",
  "name": "getLeft_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getLeft = none â†” x.isRight",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "x.getRight = none â†” x.isLeft",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getRight = none â†” x.isLeft := by cases x; sorry",
  "name": "getRight_eq_none_iff",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²} : x.getRight = none â†” x.isLeft",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {x y : Sum Î± Î²}"},
 {"type": "Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚)",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ} : Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚) := by ext (_ | _); sorry",
  "name": "elim_comp_map",
  "kind": "theorem",
  "first-tactic": "ext (_ | _)",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ} : Sum.elim fâ‚‚ gâ‚‚ âˆ˜ Sum.map fâ‚ gâ‚ = Sum.elim (fâ‚‚ âˆ˜ fâ‚) (gâ‚‚ âˆ˜ gâ‚)",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} {Î± Î² Î³ Î´ Îµ : Sort _}  {fâ‚ : Î± â†’ Î²}  {fâ‚‚ : Î² â†’ Îµ}  {gâ‚ : Î³ â†’ Î´}  {gâ‚‚ : Î´ â†’ Îµ}"},
 {"type": "update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³} : update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j := by rw [â† update_inl_comp_inl]; sorry",
  "name": "update_inl_apply_inl",
  "kind": "theorem",
  "first-tactic": "rw [â† update_inl_comp_inl]",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³} : update f (inl i) x (inl j) = update (f âˆ˜ inl) i x j",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î±}      {x : Î³}"},
 {"type": "update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³} : update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j := by rw [â† update_inr_comp_inr]; sorry",
  "name": "update_inr_apply_inr",
  "kind": "theorem",
  "first-tactic": "rw [â† update_inr_comp_inr]",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³} : update f (inr i) x (inr j) = update (f âˆ˜ inr) i x j",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î²]  [DecidableEq (Sum Î± Î²)]  {f : Sum Î± Î² â†’ Î³}  {i j : Î²}      {x : Î³}"},
 {"type": "swap (swap x) = x",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : swap (swap x) = x := by cases x; sorry",
  "name": "swap_swap",
  "kind": "theorem",
  "first-tactic": "cases x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²) : swap (swap x) = x",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (x : Sum Î± Î²)"},
 {"type": "LiftRel râ‚‚ sâ‚‚ x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y) : LiftRel râ‚‚ sâ‚‚ x y := by cases h; sorry",
  "name": "LiftRel.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y) : LiftRel râ‚‚ sâ‚‚ x y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)    (h : LiftRel râ‚ sâ‚ x y)"},
 {"type": "LiftRel s r x.swap y.swap",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap := by cases h; sorry",
  "name": "LiftRel.swap",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y) : LiftRel s r x.swap y.swap",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î³ â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î´ â†’ Prop}  {a : Î±}  {b : Î²}  {c : Î³}  {d : Î´}    {x : Sum Î± Î²}  {y : Sum Î³ Î´} (h : LiftRel r s x y)"},
 {"type": "Lex r s a b",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b) : Lex r s a b := by cases h; sorry",
  "name": "LiftRel.lex",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b) : Lex r s a b",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} {a b : Sum Î± Î²}  (h : LiftRel r s a b)"},
 {"type": "Lex râ‚‚ sâ‚‚ x y",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y) : Lex râ‚‚ sâ‚‚ x y := by cases h; sorry",
  "name": "Lex.mono",
  "kind": "theorem",
  "first-tactic": "cases h",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y) : Lex râ‚‚ sâ‚‚ x y",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _}  {r râ‚ râ‚‚ : Î± â†’ Î± â†’ Prop}  {s sâ‚ sâ‚‚ : Î² â†’ Î² â†’ Prop}  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}    {x y : Sum Î± Î²} (hr : âˆ€ a b, râ‚ a b â†’ râ‚‚ a b)  (hs : âˆ€ a b, sâ‚ a b â†’ sâ‚‚ a b)  (h : Lex râ‚ sâ‚ x y)"},
 {"type": "Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³) : Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c := by ext x; sorry",
  "name": "elim_const_const",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³) : Sum.elim (const _ c : Î± â†’ Î³) (const _ c : Î² â†’ Î³) = const _ c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} (c : Î³)"},
 {"type":
  "Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c := by ext x; sorry",
  "name": "elim_update_left",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³) : Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î±)  (c : Î³)"},
 {"type":
  "Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c := by ext x; sorry",
  "name": "elim_update_right",
  "kind": "theorem",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³) : Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c",
  "args":
  "{Î± : Type u}  {Î±' : Type w}  {Î² : Type v}  {Î²' : Type x}  {Î³ Î´ : Type _} [DecidableEq Î±]  [DecidableEq Î²]  (f : Î± â†’ Î³)  (g : Î² â†’ Î³)  (i : Î²)  (c : Î³)"},
 {"type": "a.val = b.val â†’ a = b",
  "tactic-prompt":
  "lemma {a b : Fin n} : a.val = b.val â†’ a = b := by cases a; sorry",
  "name": "Fin.ext",
  "kind": "lemma",
  "first-tactic": "cases a",
  "core-prompt": "{a b : Fin n} : a.val = b.val â†’ a = b",
  "args": "{a b : Fin n}"},
 {"type": "(âŸ¨(a : â„•), hâŸ© : Fin n) = a",
  "tactic-prompt":
  "theorem (a : Fin n)  (h : (a : â„•) < n) : (âŸ¨(a : â„•), hâŸ© : Fin n) = a := by cases a; sorry",
  "name": "Fin.eta",
  "kind": "theorem",
  "first-tactic": "cases a",
  "core-prompt": "(a : Fin n)  (h : (a : â„•) < n) : (âŸ¨(a : â„•), hâŸ© : Fin n) = a",
  "args": "(a : Fin n)  (h : (a : â„•) < n)"},
 {"type": "(Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "tactic-prompt":
  "lemma {n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a := by simp only [Fin.ofNat']; sorry",
  "name": "Fin.val_eq_of_lt",
  "kind": "lemma",
  "first-tactic": "simp only [Fin.ofNat']",
  "core-prompt":
  "{n a : Nat}  (h : a < n) : (Fin.ofNat' a (zero_lt_of_lt h)).val = a",
  "args": "{n a : Nat}  (h : a < n)"},
 {"type": "(1 : Fin (n + 2)).val = 1",
  "tactic-prompt":
  "lemma  : (1 : Fin (n + 2)).val = 1 := by simp only [OfNat.ofNat]; sorry",
  "name": "Fin.one_val",
  "kind": "lemma",
  "first-tactic": "simp only [OfNat.ofNat]",
  "core-prompt": " : (1 : Fin (n + 2)).val = 1",
  "args": ""},
 {"type": "a % b = a",
  "tactic-prompt":
  "theorem {a b : Fin n}  (h : a < b) : a % b = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mod_eq_of_lt",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{a b : Fin n}  (h : a < b) : a % b = a",
  "args": "{a b : Fin n}  (h : a < b)"},
 {"type": "(Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n := by by_cases n <= a.val + b.val; sorry",
  "name": "Fin.checked_add_spec",
  "kind": "lemma",
  "first-tactic": "by_cases n <= a.val + b.val",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedAdd a b).isSome = true â†” a.val + b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedMul a b).isSome = true â†” a.val * b.val < n",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true â†” a.val * b.val < n := by simp only [checkedMul]; sorry",
  "name": "Fin.checked_mul_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedMul]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedMul a b).isSome = true â†” a.val * b.val < n",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(Fin.checkedSub a b).isSome = true â†” b.val <= a.val",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true â†” b.val <= a.val := by simp only [checkedSub]; sorry",
  "name": "Fin.checked_sub_spec",
  "kind": "lemma",
  "first-tactic": "simp only [checkedSub]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : (Fin.checkedSub a b).isSome = true â†” b.val <= a.val",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "a * 1 = a",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_one",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : a * 1 = a",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a * (b + c) = a * b + a * c",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c := by apply Fin.eq_of_val_eq; sorry",
  "name": "Fin.mul_add",
  "kind": "theorem",
  "first-tactic": "apply Fin.eq_of_val_eq",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n) : a * (b + c) = a * b + a * c",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b c : Fin n)"},
 {"type": "âˆ€ (a b : Fin n), a - b = a + -b",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] : âˆ€ (a b : Fin n), a - b = a + -b := by simp [Fin.add_def]; sorry",
  "name": "Fin.sub_eq_add_neg",
  "kind": "theorem",
  "first-tactic": "simp [Fin.add_def]",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] : âˆ€ (a b : Fin n), a - b = a + -b",
  "args": "{n : Nat}  [Nonempty (Fin n)]"},
 {"type": "-a + a = 0",
  "tactic-prompt":
  "theorem {n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0 := by rw [add_comm]; sorry",
  "name": "Fin.add_left_neg",
  "kind": "theorem",
  "first-tactic": "rw [add_comm]",
  "core-prompt": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n) : -a + a = 0",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a : Fin n)"},
 {"type": "a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "tactic-prompt":
  "lemma {n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a â‰¤ b â†’ b â‰¤ a â†’ a = b := by intro h1 h2; sorry",
  "name": "Fin.le_antisymm",
  "kind": "lemma",
  "first-tactic": "intro h1 h2",
  "core-prompt":
  "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n) : a â‰¤ b â†’ b â‰¤ a â†’ a = b",
  "args": "{n : Nat}  [Nonempty (Fin n)] (a b : Fin n)"},
 {"type": "(replicate n c).length = n",
  "tactic-prompt":
  "lemma (n : â„•)  (c : Char) : (replicate n c).length = n := by simp only [String.length]; sorry",
  "name": "length_replicate",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(n : â„•)  (c : Char) : (replicate n c).length = n",
  "args": "(n : â„•)  (c : Char)"},
 {"type": "(String.mk l).length = l.length",
  "tactic-prompt":
  "lemma (l : List Char) : (String.mk l).length = l.length := by simp only [String.length]; sorry",
  "name": "length_eq_list_length",
  "kind": "lemma",
  "first-tactic": "simp only [String.length]",
  "core-prompt": "(l : List Char) : (String.mk l).length = l.length",
  "args": "(l : List Char)"},
 {"type": "Prod.map f g p = (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : Prod.map f g p = (f p.1, g p.2) := by cases p; sorry",
  "name": "prod_map",
  "kind": "lemma",
  "first-tactic": "cases p",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : Prod.map f g p = (f p.1, g p.2)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²)"},
 {"type": "(map f g p).1 = f (p.1)",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : (map f g p).1 = f (p.1) := by simp; sorry",
  "name": "map_fst",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : (map f g p).1 = f (p.1)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²)"},
 {"type": "(map f g p).2 = g (p.2)",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : (map f g p).2 = g (p.2) := by simp; sorry",
  "name": "map_snd",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²) : (map f g p).2 = g (p.2)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} (f : Î± â†’ Î³)  (g : Î² â†’ Î´)  (p : Î± Ã— Î²)"},
 {"type": "Prod.map g g' âˆ˜ Prod.map f f' = Prod.map (g âˆ˜ f) (g' âˆ˜ f')",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶) : Prod.map g g' âˆ˜ Prod.map f f' = Prod.map (g âˆ˜ f) (g' âˆ˜ f') := by ext x; sorry",
  "name": "map_comp_map",
  "kind": "lemma",
  "first-tactic": "ext x",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶) : Prod.map g g' âˆ˜ Prod.map f f' = Prod.map (g âˆ˜ f) (g' âˆ˜ f')",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶)"},
 {"type": "Prod.map g g' (Prod.map f f' x) = Prod.map (g âˆ˜ f) (g' âˆ˜ f') x",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶)  (x : Î± Ã— Î³) : Prod.map g g' (Prod.map f f' x) = Prod.map (g âˆ˜ f) (g' âˆ˜ f') x := by simp; sorry",
  "name": "map_map",
  "kind": "lemma",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶)  (x : Î± Ã— Î³) : Prod.map g g' (Prod.map f f' x) = Prod.map (g âˆ˜ f) (g' âˆ˜ f') x",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {Îµ Î¶ : Type _}    (f : Î± â†’ Î²)  (f' : Î³ â†’ Î´)  (g : Î² â†’ Îµ)  (g' : Î´ â†’ Î¶)  (x : Î± Ã— Î³)"},
 {"type": "p = q â†” p.1 = q.1 âˆ§ p.2 = q.2",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²} : p = q â†” p.1 = q.1 âˆ§ p.2 = q.2 := by rw [â† @mk.eta _ _ p]; sorry",
  "name": "ext_iff",
  "kind": "lemma",
  "first-tactic": "rw [â† @mk.eta _ _ p]",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²} : p = q â†” p.1 = q.1 âˆ§ p.2 = q.2",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {p q : Î± Ã— Î²}"},
 {"type": "Prod.map f g = Î» p => (f p.1, g p.2)",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´} : Prod.map f g = Î» p => (f p.1, g p.2) := by ext; sorry",
  "name": "map_def",
  "kind": "lemma",
  "first-tactic": "ext",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´} : Prod.map f g = Î» p => (f p.1, g p.2)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´}"},
 {"type": "Injective (Prod.map f g)",
  "tactic-prompt":
  "lemma {Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´}  (hf : Injective f)  (hg : Injective g) : Injective (Prod.map f g) := by intros x y h; sorry",
  "name": "Function.Injective.prod_map",
  "kind": "lemma",
  "first-tactic": "intros x y h",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´}  (hf : Injective f)  (hg : Injective g) : Injective (Prod.map f g)",
  "args":
  "{Î± : Type _}  {Î² : Type _}  {Î³ : Type _}  {Î´ : Type _} {f : Î± â†’ Î³}  {g : Î² â†’ Î´}  (hf : Injective f)  (hg : Injective g)"},
 {"type": "0 < UInt8.size",
  "tactic-prompt": "lemma  : 0 < UInt8.size := by decide; sorry",
  "name": "UInt8.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt8.size",
  "args": ""},
 {"type": "0 < UInt16.size",
  "tactic-prompt": "lemma  : 0 < UInt16.size := by decide; sorry",
  "name": "UInt16.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt16.size",
  "args": ""},
 {"type": "0 < UInt32.size",
  "tactic-prompt": "lemma  : 0 < UInt32.size := by decide; sorry",
  "name": "UInt32.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt32.size",
  "args": ""},
 {"type": "0 < UInt64.size",
  "tactic-prompt": "lemma  : 0 < UInt64.size := by decide; sorry",
  "name": "UInt64.size_positive",
  "kind": "lemma",
  "first-tactic": "decide",
  "core-prompt": " : 0 < UInt64.size",
  "args": ""},
 {"type": "Nat.isValidChar (UInt32.ofNat n).1",
  "tactic-prompt":
  "theorem (n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1 := by rw [UInt32.val_eq_of_lt]; sorry",
  "name": "toChar_aux",
  "kind": "theorem",
  "first-tactic": "rw [UInt32.val_eq_of_lt]",
  "core-prompt":
  "(n : Nat)  (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1",
  "args": "(n : Nat)  (h : n < size)"},
 {"type": "0 < c.utf8Size",
  "tactic-prompt":
  "theorem (c : Char) : 0 < c.utf8Size := by simp only [utf8Size]; sorry",
  "name": "Char.utf8Size_pos",
  "kind": "theorem",
  "first-tactic": "simp only [utf8Size]",
  "core-prompt": "(c : Char) : 0 < c.utf8Size",
  "args": "(c : Char)"},
 {"type": "m âˆˆ range n â†” m < n",
  "tactic-prompt":
  "theorem {m n : â„•} : m âˆˆ range n â†” m < n := by simp only [range_eq_range']; sorry",
  "name": "mem_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "{m n : â„•} : m âˆˆ range n â†” m < n",
  "args": "{m n : â„•}"},
 {"type": "Nodup (range n)",
  "tactic-prompt":
  "theorem (n : â„•) : Nodup (range n) := by simp only [range_eq_range']; sorry",
  "name": "nodup_range",
  "kind": "theorem",
  "first-tactic": "simp only [range_eq_range']",
  "core-prompt": "(n : â„•) : Nodup (range n)",
  "args": "(n : â„•)"},
 {"type": "âˆƒ s t : List Î±, l = s ++ a :: t",
  "tactic-prompt":
  "theorem {a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ s t : List Î±, l = s ++ a :: t := by induction l; sorry",
  "name": "mem_split",
  "kind": "theorem",
  "first-tactic": "induction l",
  "core-prompt":
  "{a : Î±}  {l : List Î±}  (h : a âˆˆ l) : âˆƒ s t : List Î±, l = s ++ a :: t",
  "args": "{a : Î±}  {l : List Î±}  (h : a âˆˆ l)"},
 {"type": "Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î±",
  "tactic-prompt":
  "lemma  : Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î± := by constructor; sorry",
  "name": "length_injective_iff",
  "kind": "lemma",
  "first-tactic": "constructor",
  "core-prompt": " : Injective (List.length : List Î± â†’ â„•) â†” Subsingleton Î±",
  "args": ""},
 {"type": "i = j",
  "tactic-prompt":
  "theorem {Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j) : i = j := by induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©; sorry",
  "name": "get?_injective",
  "kind": "theorem",
  "first-tactic":
  "induction xs generalizing i j with\n  | nil => cases hâ‚€\n  | cons x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases hâ‚ with\n      | cons ha hâ‚ => exact ih (Nat.lt_of_succ_lt_succ hâ‚€) hâ‚ hâ‚‚\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at hâ‚‚\n      cases hâ‚; rename_i h' h\n      have := h x ?_ rfl; cases this\n      rw [mem_iff_get?]\n    exact âŸ¨_, hâ‚‚âŸ©; exact âŸ¨_ , hâ‚‚.symmâŸ©",
  "core-prompt":
  "{Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j) : i = j",
  "args":
  "{Î± : Type u}  {xs : List Î±}  {i j : â„•}    (hâ‚€ : i < xs.length)    (hâ‚ : Nodup xs)    (hâ‚‚ : xs.get? i = xs.get? j)"},
 {"type": "(x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "tactic-prompt":
  "theorem (xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²) : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys := by constructor; sorry",
  "name": "product_spec",
  "kind": "theorem",
  "first-tactic": "constructor",
  "core-prompt":
  "(xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²) : (x, y) âˆˆ product xs ys â†” x âˆˆ xs âˆ§ y âˆˆ ys",
  "args": "(xs : List Î±)  (ys : List Î²)  (x : Î±)  (y : Î²)"},
 {"type": "l.attach.map Subtype.val = l",
  "tactic-prompt":
  "theorem (l : List Î±) : l.attach.map Subtype.val = l := by rw [attach]; sorry",
  "name": "attach_map_val",
  "kind": "theorem",
  "first-tactic": "rw [attach]",
  "core-prompt": "(l : List Î±) : l.attach.map Subtype.val = l",
  "args": "(l : List Î±)"},
 {"type": "lâ‚‚ ~ lâ‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚‚ ~ lâ‚ := by induction p; sorry",
  "name": "Perm.symm",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚‚ ~ lâ‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "lâ‚ âŠ† lâ‚‚",
  "tactic-prompt":
  "theorem {Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚ âŠ† lâ‚‚ := by induction p; sorry",
  "name": "Perm.subset",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : lâ‚ âŠ† lâ‚‚",
  "args": "{Î± : Type u}  {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚",
  "tactic-prompt":
  "theorem {a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±} : lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚ := by generalize eâ‚ : lâ‚ ++ a :: râ‚ = sâ‚; sorry",
  "name": "perm_inv_core",
  "kind": "theorem",
  "first-tactic": "generalize eâ‚ : lâ‚ ++ a :: râ‚ = sâ‚",
  "core-prompt":
  "{a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±} : lâ‚ ++ a :: râ‚ ~ lâ‚‚ ++ a :: râ‚‚ â†’ lâ‚ ++ râ‚ ~ lâ‚‚ ++ râ‚‚",
  "args": "{a : Î±}  {lâ‚ lâ‚‚ râ‚ râ‚‚ : List Î±}"},
 {"type": "length lâ‚ = length lâ‚‚",
  "tactic-prompt":
  "theorem {lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : length lâ‚ = length lâ‚‚ := by induction p; sorry",
  "name": "Perm.length_eq",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚) : length lâ‚ = length lâ‚‚",
  "args": "{lâ‚ lâ‚‚ : List Î±}  (p : lâ‚ ~ lâ‚‚)"},
 {"type": "âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚)",
  "tactic-prompt":
  "theorem {R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R) : âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚) := by suffices âˆ€ {lâ‚ lâ‚‚}, lâ‚ ~ lâ‚‚ â†’ Pairwise R lâ‚ â†’ Pairwise R lâ‚‚ from\n    fun lâ‚ lâ‚‚ p => âŸ¨this p, this p.symmâŸ©; sorry",
  "name": "Perm.pairwise_iff",
  "kind": "theorem",
  "first-tactic":
  "suffices âˆ€ {lâ‚ lâ‚‚}, lâ‚ ~ lâ‚‚ â†’ Pairwise R lâ‚ â†’ Pairwise R lâ‚‚ from\n    fun lâ‚ lâ‚‚ p => âŸ¨this p, this p.symmâŸ©",
  "core-prompt":
  "{R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R) : âˆ€ {lâ‚ lâ‚‚ : List Î±}, lâ‚ ~ lâ‚‚ â†’ (Pairwise R lâ‚ â†” Pairwise R lâ‚‚)",
  "args": "{R : Î± â†’ Î± â†’ Prop}  (S : Symmetric R)"},
 {"type": "Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚)",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±} : Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚) := by have : âˆ€ lâ‚ lâ‚‚ : List Î±, (âˆ€ x : Î±, x âˆˆ lâ‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚‚ â†’ R x y) â†’\n    âˆ€ x : Î±, x âˆˆ lâ‚‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚ â†’ R x y := fun lâ‚ lâ‚‚ a x xm y ym => s (a y ym x xm); sorry",
  "name": "pairwise_append_comm",
  "kind": "theorem",
  "first-tactic":
  "have : âˆ€ lâ‚ lâ‚‚ : List Î±, (âˆ€ x : Î±, x âˆˆ lâ‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚‚ â†’ R x y) â†’\n    âˆ€ x : Î±, x âˆˆ lâ‚‚ â†’ âˆ€ y : Î±, y âˆˆ lâ‚ â†’ R x y := fun lâ‚ lâ‚‚ a x xm y ym => s (a y ym x xm)",
  "core-prompt":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±} : Pairwise R (lâ‚ ++ lâ‚‚) â†” Pairwise R (lâ‚‚ ++ lâ‚)",
  "args":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} (s : Symmetric R)  {lâ‚ lâ‚‚ : List Î±}"},
 {"type": "Pairwise S l",
  "tactic-prompt":
  "theorem {Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l) : Pairwise S l := by induction p; sorry",
  "name": "Pairwise.imp_of_mem",
  "kind": "theorem",
  "first-tactic": "induction p",
  "core-prompt":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l) : Pairwise S l",
  "args":
  "{Î± Î² : Type _}  {R S T : Î± â†’ Î± â†’ Prop}  {a : Î±}  {l : List Î±} {S : Î± â†’ Î± â†’ Prop}  {l : List Î±}      (H : âˆ€ {a b}, a âˆˆ l â†’ b âˆˆ l â†’ R a b â†’ S a b)  (p : Pairwise R l)"},
 {"type": "b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±} : b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a := by induction as; sorry",
  "name": "mem_remove_iff",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±} : b âˆˆ remove a as â†” b âˆˆ as âˆ§ b â‰  a",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}"},
 {"type": "b âˆˆ as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as) : b âˆˆ as := by rw [mem_remove_iff] at h; sorry",
  "name": "mem_of_mem_remove",
  "kind": "theorem",
  "first-tactic": "rw [mem_remove_iff] at h",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as) : b âˆˆ as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a b : Î±}  {as : List Î±}  (h : b âˆˆ remove a as)"},
 {"type": "card (a :: as) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (a :: as) = card as := by simp [card]; sorry",
  "name": "card_cons_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (a :: as) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as)"},
 {"type": "card (a :: as) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (a :: as) = card as + 1 := by simp [card]; sorry",
  "name": "card_cons_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [card]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (a :: as) = card as + 1",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as)"},
 {"type": "card as â‰¤ card (a :: as)",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±) : card as â‰¤ card (a :: as) := by cases Decidable.em (a âˆˆ as); sorry",
  "name": "card_le_card_cons",
  "kind": "theorem",
  "first-tactic": "cases Decidable.em (a âˆˆ as)",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±) : card as â‰¤ card (a :: as)",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (a : Î±)  (as : List Î±)"},
 {"type": "card (as.insert a) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (as.insert a) = card as := by simp [h]; sorry",
  "name": "card_insert_of_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as) : card (as.insert a) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆˆ as)"},
 {"type": "card (as.insert a) = card as + 1",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (as.insert a) = card as + 1 := by simp [h]; sorry",
  "name": "card_insert_of_not_mem",
  "kind": "theorem",
  "first-tactic": "simp [h]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as) : card (as.insert a) = card as + 1",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {a : Î±}  {as : List Î±}  (h : a âˆ‰ as)"},
 {"type": "card (as.map f) â‰¤ card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±) : card (as.map f) â‰¤ card as := by induction as; sorry",
  "name": "card_map_le",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±) : card (as.map f) â‰¤ card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ (f : Î± â†’ Î²)  (as : List Î±)"},
 {"type": "inj_on f as â†’  card (as.map f) = card as",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±} : inj_on f as â†’  card (as.map f) = card as := by induction as; sorry",
  "name": "card_map_eq_of_inj_on",
  "kind": "theorem",
  "first-tactic": "induction as",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±} : inj_on f as â†’  card (as.map f) = card as",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {f : Î± â†’ Î²}  {as : List Î±}"},
 {"type": "card (as.union bs) = card as + card bs",
  "tactic-prompt":
  "theorem [DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs := by rw [card_eq_of_equiv (union_equiv_append as bs)]; sorry",
  "name": "card_union_disjoint",
  "kind": "theorem",
  "first-tactic": "rw [card_eq_of_equiv (union_equiv_append as bs)]",
  "core-prompt":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs) : card (as.union bs) = card as + card bs",
  "args":
  "[DecidableEq Î±]  [DecidableEq Î²]  /- remove -/ {as bs : List Î±}  (h : Disjoint as bs)"},
 {"type": "Chain S b l",
  "tactic-prompt":
  "theorem {R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l) : Chain S b l := by induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    Â· exact Hab r\n    Â· exact ih (@HRS _); sorry",
  "name": "Chain.imp'",
  "kind": "theorem",
  "first-tactic":
  "induction p generalizing b with\n  | nil => constructor\n  | cons r _ ih =>\n    constructor\n    Â· exact Hab r\n    Â· exact ih (@HRS _)",
  "core-prompt":
  "{R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l) : Chain S b l",
  "args":
  "{R S : Î± â†’ Î± â†’ Prop}  (HRS : âˆ€ â¦ƒa bâ¦„, R a b â†’ S a b)  {a b : Î±}      (Hab : âˆ€ â¦ƒcâ¦„, R a c â†’ S b c)  {l : List Î±}  (p : Chain R a l)"},
 {"type": "Chain R a l",
  "tactic-prompt":
  "theorem (p : Pairwise R (a :: l)) : Chain R a l := by rcases Pairwise_cons.1 p with âŸ¨r,p'âŸ©; sorry",
  "name": "Pairwise.chain",
  "kind": "theorem",
  "first-tactic": "rcases Pairwise_cons.1 p with âŸ¨r,p'âŸ©",
  "core-prompt": "(p : Pairwise R (a :: l)) : Chain R a l",
  "args": "(p : Pairwise R (a :: l))"},
 {"type": "a âˆˆ some b â†” b = a",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±} : a âˆˆ some b â†” b = a := by simp; sorry",
  "name": "mem_some_iff",
  "kind": "theorem",
  "first-tactic": "simp",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±} : a âˆˆ some b â†” b = a",
  "args":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {Î± : Type _}  {a b : Î±}"},
 {"type": "a âˆˆ toList o â†” a âˆˆ o",
  "tactic-prompt":
  "theorem {Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±} : a âˆˆ toList o â†” a âˆˆ o := by cases o; sorry",
  "name": "mem_toList",
  "kind": "theorem",
  "first-tactic": "cases o",
  "core-prompt":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±} : a âˆˆ toList o â†” a âˆˆ o",
  "args":
  "{Î± : Type _}  {Î² : Type _}  -- Porting note: Would need to add the attribute directly in `Init.Prelude`. -- attribute [inline] Option.isSome Option.isNone {a : Î±}  {o : Option Î±}"},
 {"type": "x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i",
  "tactic-prompt":
  "theorem {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î±: Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i} : x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i := by simp ( config := { contextual := true } ) [lt_iff_le_not_le]; sorry",
  "name": "Pi.lt_def",
  "kind": "theorem",
  "first-tactic":
  "simp ( config := { contextual := true } ) [lt_iff_le_not_le]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î±: Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i} : x < y â†” x â‰¤ y âˆ§ âˆƒ i, x i < y i",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î±: Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  {x y : âˆ€ i, Î± i}"},
 {"type":
  "Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ j, j â‰  i â†’ x j â‰¤ y j",
  "tactic-prompt":
  "lemma {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  [DecidableEq Î¹]    {x y : âˆ€ i, Î± i}  {i : Î¹}  {a b : Î± i} : Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ j, j â‰  i â†’ x j â‰¤ y j := by simp (config := {contextual := true}) [update_le_iff]; sorry",
  "name": "update_le_update_iff",
  "kind": "lemma",
  "first-tactic": "simp (config := {contextual := true}) [update_le_iff]",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  [DecidableEq Î¹]    {x y : âˆ€ i, Î± i}  {i : Î¹}  {a b : Î± i} : Function.update x i a â‰¤ Function.update y i b â†” a â‰¤ b âˆ§ âˆ€ j, j â‰  i â†’ x j â‰¤ y j",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±} {Î¹ : Type u}  {Î± : Î¹ â†’ Type v}  [âˆ€ i, Preorder (Î± i)]  [DecidableEq Î¹]    {x y : âˆ€ i, Î± i}  {i : Î¹}  {a b : Î± i}"},
 {"type":
  "(instPreorderProd _ _).lt x y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2",
  "tactic-prompt":
  "lemma {Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²} : (instPreorderProd _ _).lt x y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2 := by refine Iff.intro ?_ ?_; sorry",
  "name": "lt_iff",
  "kind": "lemma",
  "first-tactic": "refine Iff.intro ?_ ?_",
  "core-prompt":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²} : (instPreorderProd _ _).lt x y â†” x.1 < y.1 âˆ§ x.2 â‰¤ y.2 âˆ¨ x.1 â‰¤ y.1 âˆ§ x.2 < y.2",
  "args":
  "{Î± : Type u}  {Î² : Type v}  {Î³ : Type w}  {r : Î± â†’ Î± â†’ Prop} [Preorder Î±]  {x y z : Î±}  [Preorder Î±]  [Preorder Î²]  {a aâ‚ aâ‚‚ : Î±}  {b bâ‚ bâ‚‚ : Î²}  {x y : Î± Ã— Î²}"}]