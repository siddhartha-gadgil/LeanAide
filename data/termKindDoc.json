[{"name": "Â«term_â†’â‹†â‚™â‚_Â»",
  "doc":
  "A *non-unital â‹†-algebra homomorphism* `A â†’â‹†â‚™â‚ B` is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. "},
 {"name": "Functor.Â«term_$>_Â»",
  "doc":
  "If `f` is a functor, if `fb : f Î²` and `a : Î±`, then `mapConstRev fb a` is the result of\napplying `f.map` to the constant function `Î² â†’ Î±` sending everything to `a`, and then\nevaluating at `fb`. In other words it's `const a <$> fb`. "},
 {"name": "MeasureTheory.Â«termâˆ«â»_,_âˆ‚_Â»",
  "doc":
  "The **lower Lebesgue integral** `âˆ«â»_,fâˆ‚Î¼` of a function `f` with respect to a measure `Î¼`. "},
 {"name": "Submodule.Â«term_âŸ‚_Â»",
  "doc":
  "The proposition that two submodules are orthogonal. Has notation `U âŸ‚ V`. "},
 {"name": "Sym.Â«term_::â‚›_Â»",
  "doc":
  "Inserts an element into the term of `Sym Î± n`, increasing the length by one, notated `Î±::â‚›n`.\n"},
 {"name": "Hyperreal.Â«termâ„*Â»",
  "doc": "Hyperreal numbers `â„*` on the ultrafilter extending the cofinite filter "},
 {"name": "Â«term_%_Â»",
  "doc":
  "`a % b` computes the remainder upon dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For `Nat` and `Int`, `a % 0` is defined to be `a`. "},
 {"name": "termDepIfThenElse",
  "doc":
  "\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h => t(h)) (fun h => e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : Â¬c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr âŸ¨i, hâŸ©` expects a proof `h : i < arr.size` in order to\navoid a bounds check, so you can write `if h : i < arr.size then arr.get âŸ¨i, hâŸ© else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i < arr.size` from some other proposition that we are checking in the `if`.)\n"},
 {"name": "Class.Â«termâ‹ƒâ‚€_Â»",
  "doc":
  "The union `â‹ƒâ‚€_` of a class is the class of all members of ZFC sets in the class "},
 {"name": "Â«term_âŠ•_Â»",
  "doc":
  "`Sum Î± Î²`, or `Î± âŠ• Î²`, is the disjoint union of types `Î±` and `Î²`.\nAn element of `Î± âŠ• Î²` is either of the form `.inl a` where `a : Î±`,\nor `.inr b` where `b : Î²`.\n"},
 {"name": "termWithout_expected_type_",
  "doc":
  "`without_expected_type t` instructs Lean to elaborate `t` without an expected type.\nRecall that terms such as `match ... with ...` and `âŸ¨...âŸ©` will postpone elaboration until\nexpected type is known. So, `without_expected_type` is not effective in this case.\n"},
 {"name": "CategoryTheory.Â«term_âŠ£_Â»",
  "doc":
  "The notation `F âŠ£ G` stands for `Adjunction F G` representing that `F` is left adjoint to `G` "},
 {"name": "Polynomial.Â«term_/â‚˜_Â»",
  "doc": "`divByMonic` denoted `p/â‚˜q` gives the quotient of `p` by a monic polynomial `q`. "},
 {"name": "ProofWidgets.Â«termMk_rpc_widget%_Â»",
  "doc":
  "The elaborator `mk_rpc_widget%` allows writing certain widgets in Lean instead of JavaScript.\nSpecifically, it translates an RPC method of type `MyProps â†’ RequestM (RequestTask Html)`\ninto a widget component of type `Component MyProps`.\n\nEven more specifically, we can write:\n```lean\nopen Lean Server\n\nstructure MyProps where\n  ...\n  deriving RpcEncodable\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  ...\n\n@[widget_module]\ndef MyComponent : Component MyProps :=\n  mk_rpc_widget% MyComponent.rpc\n```\n\nThis is convenient because we can program the logic that computes an output HTML tree\ngiven input props in Lean directly.\n\nâš ï¸ However, note that there are several limitations on what such component can do\ncompared to ones written natively in TypeScript or JavaScript:\n- It must be pure, i.e. cannot directly store any React state.\n  Child components may store state as usual.\n- It cannot pass closures as props to the child components that it returns.\n  For example, it is not currently possible to write click event handlers in Lean\n  and pass them to a `<button onClick={..}>` child.\n- Every time the input props change, the infoview has to send a message to the Lean server\n  in order to invoke the RPC method.\n  Thus there can be a noticeable visual delay between the input props changing\n  and the display updating.\n  Consequently, components whose props change at a high frequency\n  (e.g. depending on the mouse position)\n  should not be implemented using this method.\n\nğŸ’¡ Note that an inverse transformation is already possible.\nGiven `MyComponent : Component MyProps`, we can write:\n```lean\nopen Lean Server\n\n@[server_rpc_method]\ndef MyComponent.rpc (ps : MyProps) : RequestM (RequestTask Html) :=\n  RequestM.asTask do\n    return Html.ofComponent MyComponent ps #[]\n```\n"},
 {"name": "CategoryTheory.Limits.Â«termâ¨_Â»",
  "doc":
  "`biproduct f` denoted `â¨f` computes the biproduct of a family of elements `f`. (It is defined as an\nabbreviation for `limit (Discrete.functor f)`, so for most facts about `biproduct f`, you will\njust use general facts about limits and colimits.) "},
 {"name": "Lean.Parser.Term.tuple",
  "doc":
  "Tuple notation; `()` is short for `Unit.unit`, `(a, b, c)` for `Prod.mk a (Prod.mk b c)`, etc. "},
 {"name": "Filter.Â«termâˆƒá¶ _In_,_Â»",
  "doc":
  "`f.Frequently p` or `âˆƒá¶  x in f, p x` mean that `{x | Â¬p x} âˆ‰ f`. E.g., `âˆƒá¶  x in atTop, p x`\nmeans that there exist arbitrarily large `x` for which `p` holds true. "},
 {"name": "AlgebraicGeometry.Â«term_âˆ£_áµ¤_Â»",
  "doc":
  "`X âˆ£_áµ¤ U` is notation for `X.restrict U.openEmbedding`, the restriction of `X` to an open set\n`U` of `X`. "},
 {"name": "LinearMap.compNotation",
  "doc":
  "`âˆ˜â‚—` is notation for composition of two linear (not semilinear!) maps into a linear map.\nThis is useful when Lean is struggling to infer the `RingHomCompTriple` instance. "},
 {"name": "Â«termÂ¬_Â»",
  "doc":
  "`Not p`, or `Â¬p`, is the negation of `p`. It is defined to be `p â†’ False`,\nso if your goal is `Â¬p` you can use `intro h` to turn the goal into\n`h : p âŠ¢ False`, and if you have `hn : Â¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n"},
 {"name": "MeasureTheory.Â«termâˆ«â»_In_,_Â»",
  "doc":
  "The **lower Lebesgue integral** `âˆ«â»_In Î¼, f` of a function `f` with respect to a measure `Î¼`. "},
 {"name": "CategoryTheory.Limits.Â«termâˆ_Â»",
  "doc": "`âˆ f` denotes the categorical coproduct of a family of elements `f`. Requires `f` to have the instance `[HasCoproduct f]`. "},
 {"name": "MeasureTheory.Â«termâˆ«_In_,_Â»", 
  "doc": "The Bochner integral `âˆ« a in s, f a` denotes the integral of `f` with respect to `volume`, the default measure on the ambient type, restricted to the set `s`. "},
 {"name": "CategoryTheory.MonoidalFunctor.Â«term_âŠ—â‹™_Â»",
  "doc": "The composition `comp` denoted `F âŠ—â‹™ G` of two monoidal functors is again monoidal. "},
 {"name": "Relator.Â«term_â‡’_Â»",
  "doc": "`(R â‡’ S) f g` means `LiftFun R S f g`. "},
 {"name": "Â«term_â‰ƒáµ_Â»",
  "doc": "`Î± â‰ƒáµ Î²` denotes an equivalence between measurable spaces `Î±` and `Î²`. Requires the conditions `[MeasurableSpace Î±]` and `[MeasurableSpace Î²]`. Main application is the simplification of measurability\nstatements along measurable equivalences. "},
 {"name": "Int.Â«termâŒˆ_âŒ‰Â»",
  "doc": "`Int.ceil a` is the smallest integer `z` such that `a â‰¤ z`. It is denoted with `âŒˆaâŒ‰`. "},
 {"name": "Â«term_âŠ‡_Â»", 
  "doc": "Superset relation: `a âŠ‡ b` implies that `a` contains `b`. It is equivalent to `b âŠ† a`. "},
 {"name": "Â«termâ€–_â€–â‚ŠÂ»", 
  "doc": "`â€–eâ€–â‚Š` denotes the `â„â‰¥0`-valued norm function `nnnorm` on `e`. "},
 {"name": "Â«termâ€–_â€–Â»", 
  "doc": "`â€–eâ€–` denotes the `â„`-valued norm function `norm` on `e`. "},
 {"name": "Bundle.Â«term_Ã—áµ‡_Â»",
  "doc": "Notation for the direct sum of two bundles over the same base. `Eâ‚ Ã—áµ‡ Eâ‚‚` take `x` to `Eâ‚ x Ã— Eâ‚‚ x`. "},
 {"name": "Â«AddFreimanHomLocalâ‰ºÂ»",
  "doc": "An additive `n`-Freiman homomorphism is a map which preserves sums of `n` elements. `AddFreimanHomLocalâ‰º A â†’+[n] Î²` denotes `AddFreimanHom A Î² n`. "},
 {"name": "MeasureTheory.Â«termâˆ«_,_âˆ‚_Â»", 
  "doc": "The Bochner integral `âˆ« a, f a âˆ‚Î¼` denotes the integral of `f` with respect to a measure `Î¼`, also given as `integral f Î¼`. "},
 {"name": "Nat.Â«termâŒˆ_âŒ‰â‚ŠÂ»",
  "doc": "`âŒˆaâŒ‰â‚Š` is `Nat.ceil a`, the least natural `n` such that `a â‰¤ n` "},
 {"name": "Â«termC(_,_)Â»",
  "doc": "The type of continuous maps from `Î±` to `Î²` is denoted `C(Î±, Î²)`. "},
 {"name": "Â«term_â†’â‚™+*_Â»",
  "doc": "`Î± â†’â‚™+* Î²` denotes the type of non-unital ring homomorphisms from `Î±` to `Î²`. "},
 {"name": "Â«term_âŠ”_Â»", 
  "doc": "`a âŠ” b` is the least upper bound of `a` and `b`. "},
 {"name": "MeasureTheory.Â«termâˆ«â»_,_Â»",
  "doc": "`âˆ«â» a in s, f a` denotes `lintegral volume f`, the lower Lebesgue integral of `f` with respect to `volume`, the default measure on the ambient type, restricted to the set `s`. "},
 {"name": "Set.Â«termâ‹ƒâ‚€_Â»",
  "doc": "Notation for `Set.sUnion`. `â‹ƒâ‚€ S` denotes the union of a set `S` of sets. "},
 {"name": "Â«term_!=_Â»",
  "doc": "`x != y` is boolean not-equal. It is the negation of `x == y` which is supplied by\nthe `BEq` typeclass.\n\nUnlike `x â‰  y` (which is notation for `Ne x y`), this is `Bool` valued instead of\n`Prop` valued. It is mainly intended for programming applications.\n"},
 {"name": "Â«term_[Ã—_]â†’L[_]_Â»",
  "doc": "`M [Ã— n]â†’L[R] M'` is notation for `ContinuousMultilinearMap R (fun i : Fin n => M) M'`. It denotes continuous multilinear maps over the ring `R`, from `âˆ€ i, Mâ‚ i` to `Mâ‚‚` where `Mâ‚ i` and `Mâ‚‚`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. "},
 {"name": "Lean.Elab.Command.Â«termDelta%_Â»",
  "doc": "`delta% t` elaborates to a head-delta reduced version of `t`. "},
 {"name": "Set.macroPattSetBuilder",
  "doc": "* `{ pat : X | p }` is notation for pattern matching in set-builder notation,\n  where `pat` is a pattern that is matched by all objects of type `X`\n  and `p` is a proposition that can refer to variables in the pattern.\n  It is the set of all objects of type `X` which, when matched with the pattern `pat`,\n  make `p` come out true.\n* `{ pat | p }` is the same, but in the case when the type `X` can be inferred.\n\nFor example, `{ (m, n) : â„• Ã— â„• | m * n = 12 }` denotes the set of all ordered pairs of\nnatural numbers whose product is 12.\n\nNote that if the type ascription is left out and `p` can be interpreted as an extended binder,\nthen the extended binder interpretation will be used.  For example, `{ n + 1 | n < 3 }` will\nbe interpreted as `{ x : Nat | âˆƒ n < 3, n + 1 = x }` rather than using pattern matching.\n"},
 {"name": "Â«termâˆ‘'_,_Â»",
  "doc": "`âˆ‘' i, f i` is the sum of `f` it exists, or 0 otherwise. "},
 {"name": "Std.Tactic.Â«termÎ».Â»",
  "doc": "The syntax  `fun.` or `Î».` (dot required) is shorthand for an empty pattern match function,\ni.e. `fun x y z => match x, y, z with.` for an appropriate number of arguments.\n"},
 {"name": "Â«term_â†’áµƒ[_]_Â»",
  "doc": "An `AffineMap k P1 P2` (notation: `P1 â†’áµƒ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. "},
 {"name": "Â«term_â‰ƒ+*o_Â»",
  "doc": "`Î± â‰ƒ+*o Î²` is notation for `OrderRingHom Î± Î²`. It is the type of order-preserving semiring isomorphisms between `Î±` and `Î²`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso Î± Î²)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. "},
 {"name": "MeasureTheory.Â«termâ¨_In_,_Â»",
  "doc": "`â¨ a in s, f a` denotes `average (Measure.restrict volume s) f)`. It is the average value of a function `f` with respect to `volume`, the default measure on the ambient type, restricted to the set `s`. "},
 {"name": "Â«termâŸª_,_âŸ«_â„Â»", 
  "doc": "`âŸªx, yâŸ«_â„` is notation for `inner x y`. It denotes the inner product with values in `â„`. "},
 {"name": "Â«term_\/_Â»",
  "doc": "`Or a b`, or `a âˆ¨ b` or `a \/ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a â†’ a âˆ¨ b` and `Or.inr : b â†’ a âˆ¨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},
 {"name": "Â«term_-_Â»",
  "doc": "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a â‰¤ b`. "},
 {"name": "Std.ExtendedBinder.Â«termâˆ€__,_Â»",
  "doc": "The notation `âˆ€ x < 2, p x` is shorthand for `âˆ€ x, x < 2 â†’ p x`,\nand similarly for other binary operators.\n"},
 {"name": "Lean.Parser.Term.paren",
  "doc": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `Â·`. Here are some examples:\n  - `(Â· + 1)` is shorthand for `fun x => x + 1`\n  - `(Â· + Â·)` is shorthand for `fun x y => x + y`\n  - `(f Â· a b)` is shorthand for `fun x => f x a b`\n  - `(h (Â· + 1) Â·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(Â·, 1)`\n"},
 {"name": "Â«term_â†”_Â»",
  "doc": "If and only if, or logical bi-implication. `a â†” b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},
 {"name": "Mathlib.Tactic.TermCongr.termCongr",
  "doc": "`congr(expr)` generates a congruence from an expression containing\ncongruence holes of the form `$h` or `$(h)`.\nIn these congruence holes, `h : a = b` indicates that, in the generated congruence,\non the left-hand side `a` is substituted for `$h`\nand on the right-hand side `b` is substituted for `$h`.\n\nFor example, if `h : a = b` then `congr(1 + $h) : 1 + a = 1 + b`.\n\nThis is able to make use of the expected type, for example `(congr(_ + $h) : 1 + _ = _)`\nwith `h : x = y` gives `1 + x = 1 + y`.\nThe expected type can be an `Iff`, `Eq`, or `HEq`.\nIf there is no expected type, then it generates an equality.\n\nNote: the process of generating a congruence lemma involves elaborating the pattern\nusing terms with attached metadata and a reducible wrapper.\nWe try to avoid doing so, but these terms can leak into the local context through unification.\nThis can potentially break tactics that are sensitive to metadata or reducible functions.\nPlease report anything that goes wrong with `congr(...)` lemmas on Zulip.\n\nFor debugging, you can set `set_option trace.Elab.congr true`.\n"},
 {"name": "TypeVec.Â«term_:::_Â»",
  "doc": "`a ::: b` is notation for `append1 a b`. It denotes extending a `TypeVec` `a` by one element `b`. "},
 {"name": "Std.Tactic.NormCast.termMod_cast_",
  "doc": "`mod_cast` is a term elaborator which uses the expected type to insert coercions. "},
 {"name": "Lean.termThrowErrorAt____",
  "doc": "Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe first argument must be a `Syntax` that provides position information for\nthe error message.\n`throwErrorAt ref msg` is equivalent to `withRef ref <| throwError msg`\n"},
 {"name": "Lean.Parser.Term.nomatch",
  "doc": "Empty match/ex falso. `nomatch e` is of arbitrary type `Î± : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},
 {"name": "termSudoSet_option___In_",
  "doc": "The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n"},
 {"name": "Lean.Parser.Term.byTactic",
  "doc": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},
 {"name": "Lean.Parser.Term.let",
  "doc": "`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat Ã— Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},
 {"name": "Â«term_â¤³_Â»",
  "doc": "`x` specializes to `y` (notation: `x â¤³ y`) if either of the following equivalent properties\nhold:\n\n* `ğ“ x â‰¤ ğ“ y`; this property is used as the definition;\n* `pure x â‰¤ ğ“ y`; in other words, any neighbourhood of `y` contains `x`;\n* `y âˆˆ closure {x}`;\n* `closure {y} âŠ† closure {x}`;\n* for any closed set `s` we have `x âˆˆ s â†’ y âˆˆ s`;\n* for any open set `s` we have `y âˆˆ s â†’ x âˆˆ s`;\n* `y` is a cluster point of the filter `pure x = ğ“Ÿ {x}`.\n\nThis relation defines a `Preorder` on `X`. If `X` is a Tâ‚€ space, then this preorder is a partial\norder. If `X` is a Tâ‚ space, then this partial order is trivial : `x â¤³ y â†” x = y`. "},
 {"name": "Lean.Parser.Term.dbgTrace",
  "doc": "`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},
 {"name": "CategoryTheory.LaxMonoidalFunctor.Â«term_âŠ—â‹™_Â»",
  "doc": "The composition `comp` denoted `F âŠ—â‹™ G` of two lax monoidal functors is again lax monoidal. "},
 {"name": "Â«term%[_|_]Â»",
  "doc": "Auxiliary syntax for implementing `[$elem,*]` list literal syntax.\nThe syntax `%[a,b,c|tail]` constructs a value equivalent to `a::b::c::tail`.\nIt uses binary partitioning to construct a tree of intermediate let bindings as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\n"},
 {"name": "Â«termâ„š_[_]Â»", 
  "doc": "`â„š_[p]` is notation for `Padic p`, the p-adic rationals. "},
 {"name": "Mathlib.Tactic.cleanStx",
  "doc": "`clean% t` fully elaborates `t` and then eliminates all identity functions from it.\n\nIdentity functions are normally generated with terms like `show t from p`,\nwhich translate to some variant on `@id t p` in order to retain the type.\nThese are also generated by tactics such as `dsimp` to insert type hints.\n\nExample:\n```lean\ndef x : Id Nat := by dsimp [Id]; exact 1\n#print x\n-- def x : Id Nat := id 1\n\ndef x' : Id Nat := clean% by dsimp [Id]; exact 1\n#print x'\n-- def x' : Id Nat := 1\n```\n"},
 {"name": "Â«MulSemiringActionHomLocalâ‰ºÂ»",
  "doc": "`R â†’+*[M] S` is notation for `MulSemiringActionHom M R S`. These are equivariant ring homomorphisms. "},
 {"name": "Submodule.Â«term_á—®Â»",
  "doc": "`Vá—®` denotes the subspace of vectors orthogonal to a given subspace `V`. "},
 {"name": "LinearEquiv.transNotation",
  "doc": "The notation `eâ‚ â‰ªâ‰«â‚— eâ‚‚` denotes the composition of the linear equivalences `eâ‚` and `eâ‚‚`. "},
 {"name": "termIfLet",
  "doc": "`if let pat := d then t else e` is a shorthand syntax for:\n```\nmatch d with\n| pat => t\n| _ => e\n```\nIt matches `d` against the pattern `pat` and the bindings are available in `t`.\nIf the pattern does not match, it returns `e` instead.\n"},
 {"name": "Set.Â«termâ‹ƒ_,_Â»",
  "doc": "Notation for `Set.iUnion`. `â‹ƒ i : Î¹, f i` denotes the union of `f i` as `i` varies in the index `Î¹`. It is the indexed union of a family of sets. "},
 {"name": "Lean.Parser.Term.unreachable",
  "doc": "`unreachable` is a shorthand for `panic! \"unreachable code has been reached\"`. "},
 {"name": "Lean.Parser.Term.binrel_no_prop",
  "doc": "`binrel_no_prop% r a b` is similar to `binrel% r a b`, but it coerces `Prop` arguments into `Bool`. "},
 {"name": "Mathlib.ProxyType.proxy_equiv",
  "doc": "The term elaborator `proxy_equiv% Î±` for a type `Î±` elaborates to an equivalence `Î² â‰ƒ Î±`\nfor a \"proxy type\" `Î²` composed out of basic type constructors `Unit`, `PLift`, `Sigma`,\n`Empty`, and `Sum`.\n\nThis only works for inductive types `Î±` that are neither recursive nor have indices.\nIf `Î±` is an inductive type with name `I`, then as a side effect this elaborator defines\n`I.proxyType` and `I.proxyTypeEquiv`.\n\nThe elaborator makes use of the expected type, so `(proxy_equiv% _ : _ â‰ƒ Î±)` works.\n\nFor example, given this inductive type\n```\ninductive foo (n : Nat) (Î± : Type)\n  | a\n  | b : Bool â†’ foo n Î±\n  | c (x : Fin n) : Fin x â†’ foo n Î±\n  | d : Bool â†’ Î± â†’ foo n Î±\n```\nthe proxy type it generates is `Unit âŠ• Bool âŠ• (x : Fin n) Ã— Fin x âŠ• (_ : Bool) Ã— Î±` and\nin particular we have that\n```\nproxy_equiv% (foo n Î±) : Unit âŠ• Bool âŠ• (x : Fin n) Ã— Fin x âŠ• (_ : Bool) Ã— Î± â‰ƒ foo n Î±\n```\n"},
 {"name": "Bundle.Â«term_*áµ–_Â»",
  "doc": "The pullback of a bundle `E` over a base `B` under a map `f : B' â†’ B`, denoted by\n`Bundle.Pullback f E` or `f *áµ– E`, is the bundle over `B'` whose fiber over `b'` is `E (f b')`. "},
 {"name": "Lean.Parser.Term.syntheticHole",
  "doc": "Parses a \"synthetic hole\", that is, `?foo` or `?_`.\nThis syntax is used to construct named metavariables. "},
 {"name": "Â«term_++_Â»",
  "doc": "`a ++ b` is the result of concatenation of `a` and `b`, usually read \"append\".\nThe meaning of this notation is type-dependent. "},
 {"name": "Â«term_â‰¥_Â»", 
  "doc": "`a â‰¥ b` is an abbreviation for `b â‰¤ a`, which denotes `b` being less than or equal to `a`. "},
 {"name": "Â«term_â‰¼i_Â»",
  "doc": "If `r` is a relation on `Î±` and `s` in a relation on `Î²`, then `f : r â‰¼i s` is an order\nembedding whose range is an initial segment. That is, whenever `b < f a` in `Î²` then `b` is in the\nrange of `f`. "},
 {"name": "Std.Tactic.Coe.coeSortNotation",
  "doc": "`â†¥ t` coerces `t` to a type. "},
 {"name": "Â«termâ„•âˆÂ»", 
  "doc": "Extended natural numbers `â„•âˆ` is notation for `WithTop â„•`. "},
 {"name": "Std.ExtendedBinder.Â«termâˆƒ__,_Â»",
  "doc": "The notation `âˆƒ x < 2, p x` is shorthand for `âˆƒ x, x < 2 âˆ§ p x`,\nand similarly for other binary operators.\n"},
 {"name": "Â«term_â‰ˆ_Â»",
  "doc": "`x â‰ˆ y` says that `x` and `y` are equivalent. Because this is a typeclass,\nthe notion of equivalence is type-dependent. "},
 {"name": "CategoryTheory.exp.Â«term_^^_Â»",
  "doc": "`B^^A` is notation for `(exp A).obj B`. It denotes the morphisms from an exponentiable object. "},
 {"name": "Function.Â«term_â†ª_Â»",
  "doc": "`f : A â†ª B` is notation for `Embedding f`. It denotes an embedding, that is, a bundled injective function from `A` to `B`. "},
 {"name": "FirstOrder.Language.Â«term_âŠ¨__1Â»",
  "doc": "`M âŠ¨ T` denotes a model `M` of a theory `T`, which is a structure in which every sentence is realized as true. "},
 {"name": "Â«term_==_Â»", 
  "doc": "Boolean equality, notated as `a == b`. "},
 {"name": "Lean.Elab.Term.CoeImpl.Â«term(â†¥)Â»",
  "doc": "`â†¥f` is a partially applied type coercion of `f`. It is equivalent to the Î·-reduction of `(â†¥ Â·)` "},
 {"name": "CategoryTheory.Limits.Â«term_â¨¿_Â»",
  "doc": "`â¨¿ f` denotes the categorical coproduct of a family of elements `f`. Requires `f` to have the instance `[HasCoproduct f]`. "},
 {"name": "Â«term_â†’*_Â»",
  "doc": "`M â†’* N` denotes the type of monoid homomorphisms from `M` to `N`. "},
 {"name": "Â«termLine[_,_,_]Â»",
  "doc": "`[k, pâ‚, pâ‚‚]` is notation for `affineSpan k (insert pâ‚ (@singleton _ _ Set.instSingletonSet pâ‚‚))`. It denotes the line between two points `pâ‚` and `pâ‚‚`, as an affine subspace of `k`. "},
 {"name": "Â«termâˆ…Â»",
  "doc": "`âˆ…` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},
 {"name": "CategoryTheory.ihom.Â«term_âŸ¶[_]_Â»",
  "doc": "`A âŸ¶[C] B` denotes the internal hom from `A` to `B` "},
 {"name": "Lean.Parser.Term.quotedName", "doc": "A literal of type `Name`. "},
 {"name": "Â«term_+_Â»",
  "doc": "`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Cardinal.Â«term_^<_Â»",
  "doc": "The function `a ^< b`, defined as the supremum of `a ^ c` for `c < b`. "},
 {"name": "BigOperators.bigsum",
  "doc": "`âˆ‘ x, f x` is notation for `Finset.sum Finset.univ f`. It is the sum of `f x`,\nwhere `x` ranges over the finite domain of `f`. "},
 {"name": "Â«term_â†’â‚™â‚_Â»",
  "doc": "`A â†’â‚™â‚ B` is notation for `NonUnitalAlgHom _`. It denotes a morphism from `A` to `B` respecting addition, multiplication, and scalar multiplication. When these arise from\nalgebra structures, this is the same as a not-necessarily-unital morphism of algebras. "},
 {"name": "CategoryTheory.Â«term_â¥¤â‚—_Â»",
  "doc": "`C â¥¤â‚— D` denotes left exact functors `C â¥¤ D` "},
 {"name": "TopCat.Presheaf.Â«term__*_Â»", 
  "doc": "`f _* â„±` is the push forward of a presheaf `â„±` along `f`. "},
 {"name": "Mathlib.Notation3.Â«termExpand_binders%(_=>_)_,_Â»",
  "doc": "Expands binders into nested combinators.\nFor example, the familiar exists is given by:\n`expand_binders% (p => Exists p) x y : Nat, x < y`\nwhich expands to the same expression as\n`âˆƒ x y : Nat, x < y`\n"},
 {"name": "BigOperators.bigprodin",
  "doc": "`âˆ x in s, f x` is notation for `Finset.prod s f`. It is the product of `f x`,\nwhere `x` ranges over the finite set `s`. "},
 {"name": "Mathlib.Util.includeStr",
  "doc": "A term macro that includes the content of a file, as a string. "},
 {"name": "Â«term_â‰¤â‚_Â»",
  "doc": "`p â‰¤â‚ q` is notation for `OneOneReducible`. `p` is one-one reducible to `q`, if there is an injective computable function translating questions\nabout `p` to questions about `q`.\n"},
 {"name": "PSigma.Â«termÎ£â‚—'_,_Â»",
  "doc": "The notation `Î£â‚—' i, Î± i` refers to a sigma type which is locally equipped with the\nlexicographic order."},
 {"name": "BigOperators.Â«termâˆá¶ _,_Â»",
  "doc": "`âˆá¶  x, f x` is notation for `finprod f`. It is the sum of `f x`, where `x` ranges over the\nmultiplicative support of `f`, if it's finite, one otherwise. Taking the product over multiple\narguments or conditions is possible, e.g. `âˆá¶  (x) (y), f x y` and `âˆá¶  (x) (h: x âˆˆ s), f x`"},
 {"name": "Â«term_<|_Â»",
  "doc": "Haskell-like pipe operator `<|`. `f <| x` means the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f <| g <| x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},
 {"name": "Â«term_â‰ _Â»",
  "doc": "`a â‰  b`, or `Ne a b` is defined as `Â¬ (a = b)` or `a = b â†’ False`,\nand asserts that `a` and `b` are not equal.\n"},
 {"name": "Â«term_â†’â‚—â…_â†_Â»",
  "doc": "`L â†’â‚—â…Râ† L'` is notation for `LieHom R L L'`. It denotes a morphism of Lie algebras from `L` to `L'`, which is a `R`-linear map respecting the bracket operations. "},
 {"name": "Matrix.vecNotation",
  "doc": "`![...]` notation is used to construct a vector `Fin n â†’ Î±` using `Matrix.vecEmpty` and\n`Matrix.vecCons`.\n\nFor instance, `![a, b, c] : Fin 3` is syntax for `vecCons a (vecCons b (vecCons c vecEmpty))`.\n\nNote that this should not be used as syntax for `Matrix` as it generates a term with the wrong type.\nThe `!![a, b; c, d]` syntax (provided by `Matrix.matrixNotation`) should be used instead.\n"},
 {"name": "Lean.Parser.Term.anonymousCtor",
  "doc": "The *anonymous constructor* `âŸ¨e, ...âŸ©` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`âŸ¨a, b, câŸ© : Î± Ã— (Î² Ã— Î³)` is equivalent to `âŸ¨a, âŸ¨b, câŸ©âŸ©`.\n"},
 {"name": "List.Â«term_<:+_Â»",
  "doc": "`IsSuffix lâ‚ lâ‚‚`, or `lâ‚ <:+ lâ‚‚`, means that `lâ‚` is a suffix of `lâ‚‚`,\nthat is, `lâ‚‚` has the form `t ++ lâ‚` for some `t`.\n"},
 {"name": "Â«term_â»Â¹'o_Â»",
  "doc": "Given a relation `R` on `Î²` and a function `f : Î± â†’ Î²`, the preimage relation `fâ»Â¹'o R` on `Î±` is defined\nby `x â‰¤ y â†” f x â‰¤ f y`. It is the unique relation on `Î±` making `f` a `RelEmbedding` (assuming `f`\nis injective). "},
 {"name": "Â«term_â‰ƒâ‚—â…_â†_Â»",
  "doc": "An `R`-equivalence of Lie algebras `L` and `L'` denoted `L â‰ƒâ‚—â…Râ† L'` is a morphism which is also a linear `R`-equivalence. We could\ninstead define an equivalence to be a morphism which is also a (plain) equivalence. However it is\nmore convenient to define via linear equivalence to get `.toLinearEquiv` for free. "},
 {"name": "CategoryTheory.Limits.Â«termâŠ¥__Â»",
  "doc": "`âŠ¥_ C` is notation for the initial object in `C`. "},
 {"name": "Â«termâ…_,_â†Â»",
  "doc": "`â…x, yâ†` is the result of a bracket operation on elements `x` and `y`.\nIt is supported by the `Bracket` typeclass. "},
 {"name": "Â«termCompile_time_search_path%Â»",
  "doc": "Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n"},
 {"name": "Â«term_<|>_Â»",
  "doc": "`a <|> b` executes `a` and returns the result, unless it fails in which\ncase it executes and returns `b`. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},
 {"name": "Lean.Parser.Term.cdot",
  "doc": "A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(Â· + Â·)` is equivalent to `fun x y => x + y`.\n"},
 {"name": "MeasureTheory.Â«term_â†’â‚˜[_]_Â»",
  "doc": "`Î± â†’â‚˜[Î¼] Î²` is notation for `AEEqFun Î± Î² Î¼`. It denotes the space of equivalence classes of almost everywhere strongly measurable functions, where two\nstrongly measurable functions are equivalent if they agree almost everywhere, i.e.,\nthey differ on a set of measure `0`.  "},
 {"name": "Â«term_â‹–_Â»", "doc": "Notation for `Covby a b`. "},
 {"name": "Lean.Parser.Term.typeAscription",
  "doc": "Type ascription notation: `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\nAn empty type ascription `(e :)` elaborates `e` without the expected type.\nThis is occasionally useful when Lean's heuristics for filling arguments from the expected type\ndo not yield the right result.\n"},
 {"name": "Sum.Lex.Â«term_âŠ•â‚—_Â»", 
  "doc": "`Î± âŠ•â‚— Î²` is notation for `_root_.Lex (Sum Î± Î²)`. It denotes the linear sum of two orders `Î±` and `Î²`. "},
 {"name": "Â«term_â†ªr_Â»",
  "doc": "A relation embedding `f : Î± â†ªr Î²` with respect to a given pair of relations `r` and `s`\nis an embedding `f : Î± â†ª Î²` such that `r a b â†” s (f a) (f b)`. "},
 {"name": "FirstOrder.Language.Â«term_â†’á´¸_Â»",
  "doc": "`L â†’á´¸ L'` denotes a language homomorphism that maps the symbols of one language `L` to symbols of another `L'`. "},
 {"name": "Mathlib.Deriving.Fintype.Â«termDerive_fintype%_Â»",
  "doc": "The term elaborator `derive_fintype% Î±` tries to synthesize a `Fintype Î±` instance\nusing all the assumptions in the local context; this can be useful, for example, if one\nneeds an extra `DecidableEq` instance. It works only if `Î±` is an inductive\ntype that `proxy_equiv% Î±` can handle. The elaborator makes use of the\nexpected type, so `(derive_fintype% _ : Fintype Î±)` works.\n\nThis uses `proxy_equiv% Î±`, so as a side effect it defines `proxyType` and `proxyTypeEquiv` in\nthe namespace associated to the inductive type `Î±`.\n"},
 {"name": "Â«term_â†’â‹†â‚™â‚[_]_Â»",
  "doc": "`A â†’â‹†â‚™â‚[R] B` denotes a *non-unital â‹†-algebra homomorphism*. It is a non-unital algebra homomorphism between\nnon-unital `R`-algebras `A` and `B` equipped with a `star` operation, and this homomorphism is\nalso `star`-preserving. "},
 {"name": "Mathlib.Tactic.Sat.termFrom_lrat___",
  "doc": "A macro for producing SAT proofs from CNF / LRAT files.\nThese files are commonly used in the SAT community for writing proofs.\n\nThe input to the `from_lrat` term syntax is two string expressions with\nthe statement (written in CNF format) and the proof (in LRAT format).\nFor example:\n```\ndef foo := from_lrat\n  \"p cnf 2 4  1 2 0  -1 2 0  1 -2 0  -1 -2 0\"\n  \"5 -2 0 4 3 0  5 d 3 4 0  6 1 0 5 1 0  6 d 1 0  7 0 5 2 6 0\"\n```\nproduces a theorem:\n```\nfoo : âˆ€ (a a_1 : Prop), (Â¬a âˆ§ Â¬a_1 âˆ¨ a âˆ§ Â¬a_1) âˆ¨ Â¬a âˆ§ a_1 âˆ¨ a âˆ§ a_1\n```\n\n* You can use this term after `have :=` or in `def foo :=` to produce the term\n  without constraining the type.\n* You can use it when a specific type is expected, but it currently does not\n  pay any attention to the shape of the goal and always produces the same theorem,\n  so you can only use this to do alpha renaming.\n* You can use the `include_str` macro in place of the two strings\n  to load CNF / LRAT files from disk.\n"},
 {"name": "Â«term_â†’+o_Â»", 
  "doc": "`Î± â†’+o Î²` is infix notation for `OrderAddMonoidHom` from `Î±` to `Î²`. "},
 {"name": "CategoryTheory.Â«term_âŸ¦_âŸ§Â»",
  "doc": "Shifting an object `X` by `n` is obtained by the notation `XâŸ¦nâŸ§` "},
 {"name": "CategoryTheory.Â«termReassoc_of%_Â»",
  "doc": "`reassoc_of% t`, where `t` is\nan equation `f = g` between morphisms `X âŸ¶ Y` in a category (possibly after a `âˆ€` binder),\nproduce the equation `âˆ€ {Z} (h : Y âŸ¶ Z), f â‰« h = g â‰« h`,\nbut with compositions fully right associated and identities removed.\n"},
 {"name": "Â«term[_]Â»",
  "doc": "The syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n"},
 {"name": "PiTensorProduct.Â«termâ¨‚â‚œ[_]_,_Â»",
  "doc": "`â¨‚â‚œ[R] i, f i` is notation for `tprod R f`. It denotes a pure `R`-tensor in tensor product over some index type. "},
 {"name": "Mathlib.RunCmd.byElab",
  "doc": "* The `by_elab doSeq` expression runs the `doSeq` as a `TermElabM Expr` to\n  synthesize the expression.\n* `by_elab fun expectedType? â†¦ do doSeq` receives the expected type (an `Option Expr`)\n  as well.\n"},
 {"name": "ZFSet.Â«termâ‹ƒâ‚€_Â»",
  "doc": "`â‹ƒâ‚€ x` is notation for `ZFSet.sUnion x`. It denotes the collection of elements of elements of a ZFC set `x`. "},
 {"name": "Â«term_â†’*â‚€o_Â»",
  "doc": "`Î± â†’*â‚€o Î²` is infix notation for `OrderMonoidWithZeroHom` from `Î±` to `Î²`. "},
 {"name": "Std.ExtendedBinder.Â«termâˆ€áµ‰_,_Â»",
  "doc": "The syntax `âˆ€áµ‰ (x < 2) (y < 3), p x y` is shorthand for `âˆ€ x < 2, âˆ€ y < 3, p x y`. "},
 {"name": "Std.ExtendedBinder.Â«termâˆƒáµ‰_,_Â»",
  "doc": "The syntax `âˆƒáµ‰ (x < 2) (y < 3), p x y` is shorthand for `âˆƒ x < 2, âˆƒ y < 3, p x y`. "},
 {"name": "OmegaCompletePartialOrder.Â«term_â†’ğ’„_Â»",
  "doc": "A monotone function on `Ï‰`-continuous partial orders `Î± â†’ğ’„ Î²` is said to be continuous\nif for every chain `c : chain Î±`, `f (âŠ” i, c i) = âŠ” i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. "},
 {"name": "ContinuousLinearMap.Â«term_âˆ˜L_Â»",
  "doc": "`f âˆ˜L g` denotes composition of bounded linear maps `f` and `g`. "},
 {"name": "Â«term_â†’â‚€_Â»",
  "doc": "`Finsupp Î± M`, denoted `Î± â†’â‚€ M`, is the type of functions `f : Î± â†’ M` such that\n`f x = 0` for all but finitely many `x`. "},
 {"name": "Â«term_â‰ƒL[_]_Â»",
  "doc": "`M â‰ƒL[R] Mâ‚‚` denotes continuous linear equivalences between `R`-modules `M` and `Mâ‚‚`. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `Mâ‚‚` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "Â«term_áµ’áµˆÂ»",
  "doc": "`Î±áµ’áµˆ` is notation for `OrderDual Î±`. It denotes a type synonym \nto equip a type with the dual order: `â‰¤` means `â‰¥` and `<` means `>`. "},
 {"name": "Â«term_<*>_Â»",
  "doc": "If `mf : F (Î± â†’ Î²)` and `mx : F Î±`, then `mf <*> mx : F Î²`.\nIn a monad this is the same as `do let f â† mf; x â† mx; pure (f x)`:\nit evaluates first the function, then the argument, and applies one to the other.\n\nTo avoid surprising evaluation semantics, `mx` is taken \"lazily\", using a\n`Unit â†’ f Î±` function. "},
 {"name": "Lean.withAnnotateTerm",
  "doc": "`with_annotate_term stx e` annotates the lexical range of `stx : Syntax` with term info for `e`. "},
 {"name": "Â«termâ€¹_â€ºÂ»",
  "doc": "`â€¹tâ€º` resolves to an (arbitrary) hypothesis of type `t`.\nIt is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type;\nin particular, `â€¹_â€º` is a shortcut for `by assumption`.\n"},
 {"name": "Â«term_>_Â»", 
  "doc": "`a > b` is an abbreviation for `b < a`. "},
 {"name": "Filter.Â«termâˆ€á¶ _In_,_Â»",
  "doc": "`f.Eventually p` or `âˆ€á¶  x in f, p x` mean that `{x | p x} âˆˆ f`. E.g., `âˆ€á¶  x in atTop, p x`\nmeans that `p` holds true for sufficiently large `x`. "},
 {"name": "Â«term__[_]'_Â»",
  "doc": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : Î±` where `arr : Array Î±` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : Î±` where `l : List Î±` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n"},
 {"name": "Â«term_â‰ƒâ‹†â‚_Â»",
  "doc": "`A â‰ƒâ‹†â‚ B` is notation for `StarAlgEquiv _ A B`. It denotes a *â‹†-algebra* \nequivalence. A *â‹†-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. "},
 {"name": "Lean.Parser.Term.let_fun",
  "doc": "`let_fun x := v; b` is syntax sugar for `(fun x => b) v`.\nIt is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},
 {"name": "BigOperators.bigprod",
  "doc": "`âˆ x, f x` is notation for `Finset.prod Finset.univ f`. It is the product of `f x`,\nwhere `x` ranges over the finite domain of `f`. "},
 {"name": "Â«term_âˆ§_Â»",
  "doc": "`a âˆ§ b` is notation for `And a b`. It denotes the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`âŸ¨ha, hbâŸ© : a âˆ§ b`, and if `h : a âˆ§ b` then `h.left : a` and `h.right : b`.\n"},
 {"name": "Â«term_|>_Â»",
  "doc": "Haskell-like pipe operator `|>`. `x |> f` means the same as the same as `f x`,\nand it chains such that `x |> f |> g` is interpreted as `g (f x)`.\n"},
 {"name": "BigOperators.bigsumin",
  "doc": "`âˆ‘ x in s, f x` is notation for `Finset.sum s f`. It is the sum of `f x`,\nwhere `x` ranges over the finite set `s`. "},
 {"name": "Â«term_â‰ƒáµ¤_Â»", 
  "doc": "`Î± â‰ƒáµ¤ Î²` is notation for `UniformEquiv`. It denotes a uniform isomorphism between `Î±` and `Î²` "},
 {"name": "MeasureTheory.Â«term_â†’â‚â‚›[_]_Â»",
  "doc": "`Î± â†’â‚â‚›[Î¼] E` is notation for `@MeasureTheory.Lp.simpleFunc Î± E _ _ 1 Î¼`. `Lp.simpleFunc` is a subspace of Lp consisting of equivalence classes of an integrable simple\nfunction. "},
 {"name": "Set.term_''_",
  "doc": "`f '' s` denotes the image of `s : Set Î±` under the function `f : Î± â†’ Î²`. "},
 {"name": "Â«term_áµˆáµáµƒÂ»",
  "doc": "`Máµˆáµáµƒ` is notation for `DomMulAct M`. If `M` multiplicatively acts on `Î±`, then `DomMulAct M` acts on `Î± â†’ Î²` as well as some\nbundled maps from `Î±`. This is a type synonym for `MulOpposite M`, so this corresponds to a right\naction of `M`. "},
 {"name": "Â«term_â‰ƒâ‹†â‚[_]_Â»",
  "doc": "`A â‰ƒâ‹†â‚[R] B` is notation for `StarAlgEquiv R A B`. A *â‹†-algebra* equivalence is an equivalence preserving addition, multiplication, scalar\nmultiplication and the star operation, which allows for considering both unital and non-unital\nequivalences with a single structure. Currently, `AlgEquiv` requires unital algebras, which is\nwhy this structure does not extend it. "},
 {"name": "Â«term_::_Â»",
  "doc": "If `a : Î±` and `l : List Î±`, then `cons a l`, or `a :: l`, is the\nlist whose first element is `a` and with `l` as the rest of the list. "},
 {"name": "CategoryTheory.Â«term_â‰…_Â»",
  "doc": "`X â‰… Y` is notation `Iso X Y`. It denotes an isomorphism in a category. "},
 {"name": "Â«term_â†’â‚—â‹†[_]_Â»",
  "doc": "`M â†’â‚—â‹†[R] N` is notation for `LinearMap (starRingEnd R) M N`. It denotes the type of `R`-conjugate-linear maps from `M` to `N`. "},
 {"name": "FirstOrder.Language.Â«term_âŠ¨_Â»",
  "doc": "`M âŠ¨ Ï†` is notation for `Sentence.Realize M Ï†`.A sentence can be evaluated as true or false in a structure. "},
 {"name": "Â«term_â‹Š[_]_Â»",
  "doc": "`N â‹Š[Ï†] G` is notation for `SemidirectProduct N G Ï†`. It denotes the semidirect product of groups `N` and `G`, given a map `Ï†` from `G` to the automorphism\ngroup of `N`. It is the product of sets with the group operation\n`âŸ¨nâ‚, gâ‚âŸ© * âŸ¨nâ‚‚, gâ‚‚âŸ© = âŸ¨nâ‚ * Ï† gâ‚ nâ‚‚, gâ‚ * gâ‚‚âŸ©` "},
 {"name": "Â«term_â†ªo_Â»", 
  "doc": "`f : Î± â†ªo Î²` is notation for `OrderEmbedding Î± Î²`. \nAn order embedding is an embedding `f : Î± â†ª Î²` such that `a â‰¤ b â†” (f a) â‰¤ (f b)`. \nThis definition is an abbreviation of `RelEmbedding (â‰¤) (â‰¤)`. "},
 {"name": "Â«term_<=<_Â»",
  "doc": "`fâ‚‚ <=< fâ‚ a` is notation for `Bind.kleisliLeft fâ‚‚ fâ‚ a`. It denotes right-to-left composition of Kleisli arrows. "},
 {"name": "Â«term_â†’SL[_]_Â»",
  "doc": "`_â†’SL[_]_` is notation for ``. Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `Mâ‚‚` will be topological modules over the topological\nring `R`. "},
 {"name": "Lean.Parser.Term.inaccessible",
  "doc":
  "`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},
 {"name": "Â«term_â†’â‚š_Â»",
  "doc":
  "A dependent function `Î  i, Î² i` with finite support, with notation `Î â‚€ i, Î² i`.\n\nNote that `DFinsupp.support` is the preferred API for accessing the support of the function,\n`DFinsupp.support'` is an implementation detail that aids computability; see the implementation\nnotes in this file for more information. "},
 {"name": "Std.Tactic.haveI",
  "doc":
  "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. "},
 {"name": "Lean.Parser.Term.rightact",
  "doc":
  "`rightact% f a b` elaborates `f a b` as a right action using the type propogation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `b`, where only the left argument `a` participates in the operator coercion elaborator. "},
 {"name": "PSet.Â«termâ‹ƒâ‚€_Â»", "doc": "The pre-set union operator "},
 {"name": "Â«term_$__Â»",
  "doc":
  "Alternative syntax for `<|`. `f $ x` means the same as the same as `f x`,\nexcept that it parses `x` with lower precedence, which means that `f $ g $ x`\nis interpreted as `f (g x)` rather than `(f g) x`.\n"},
 {"name": "CategoryTheory.Iso.Â«term_â‰ªâ‰«_Â»",
  "doc": "Notation for composition of isomorphisms. "},
 {"name": "Lean.Parser.Term.let_tmp",
  "doc":
  "`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},
 {"name": "BigOperators.Â«termâˆ‘á¶ _,_Â»",
  "doc":
  "`âˆ‘á¶  x, f x` is notation for `finsum f`. It is the sum of `f x`, where `x` ranges over the\nsupport of `f`, if it's finite, zero otherwise. Taking the sum over multiple arguments or\nconditions is possible, e.g. `âˆá¶  (x) (y), f x y` and `âˆá¶  (x) (h: x âˆˆ s), f x`"},
 {"name": "Â«term_/_Â»",
  "doc":
  "`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat` and `Int`, `a / b` rounds toward 0.\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. "},
 {"name": "Â«term_>>_Â»",
  "doc":
  "`a >> b` executes `a`, ignores the result, and then executes `b`.\nIf `a` fails then `b` is not executed. Because `b` is not always executed, it\nis passed as a thunk so it can be forced only when needed.\nThe meaning of this notation is type-dependent. "},
 {"name": "Lean.Parser.Term.structInst",
  "doc":
  "Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},
 {"name": "FirstOrder.Language.Theory.Â«term_âŠ¨áµ‡_Â»",
  "doc":
  "A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs."},
 {"name": "Â«term_â†’â‚›â‚—[_]_Â»",
  "doc": "`M â†’â‚›â‚—[Ïƒ] N` is the type of `Ïƒ`-semilinear maps from `M` to `N`. "},
 {"name": "Nat.Â«term_â‰¡_[MOD_]Â»",
  "doc":
  "Modular equality. `n.ModEq a b`, or `a â‰¡ b [MOD n]`, means that `a - b` is a multiple of `n`. "},
 {"name": "Â«termÎ â‚€_,_Â»",
  "doc":
  "`Î â‚€ i, Î² i` denotes the type of dependent functions with finite support `DFinsupp Î²`. "},
 {"name": "Â«term_â†’o_Â»", "doc": "Notation for an `OrderHom`. "},
 {"name": "Class.Â«termâ‹‚â‚€_Â»",
  "doc":
  "The intersection of a class is the class of all members of ZFC sets in the class "},
 {"name": "Â«term_â‰ƒSL[_]_Â»",
  "doc":
  "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `Mâ‚‚` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "Â«term_âˆ©_Â»", "doc": "`a âˆ© b` is the intersection of`a` and `b`. "},
 {"name": "Â«term_â‰ƒo_Â»", "doc": "Notation for an `OrderIso`. "},
 {"name": "Â«term_âŠƒ_Â»", "doc": "Strict superset relation: `a âŠƒ b`  "},
 {"name": "MeasureTheory.Â«termâ¨_In_,_âˆ‚_Â»",
  "doc":
  "Average value of a function `f` w.r.t. a measure `Î¼`, notation: `â¨ x, f x âˆ‚Î¼`. It is defined as\n`(Î¼ univ).toRealâ»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼`, so it is equal to zero if `f` is not integrable or if `Î¼` is an\ninfinite measure. If `Î¼` is a probability measure, then the average of any function is equal to its\nintegral.\n\nFor the average on a set, use `â¨ x in s, f x âˆ‚Î¼` (defined as `â¨ x, f x âˆ‚(Î¼.restrict s)`). For\naverage w.r.t. the volume, one can omit `âˆ‚volume`. "},
 {"name": "term!_",
  "doc":
  "`not x`, or `!x`, is the boolean \"not\" operation (not to be confused\nwith `Not : Prop â†’ Prop`, which is the propositional connective).\n"},
 {"name": "Â«term_âˆ‰_Â»",
  "doc": "`a âˆ‰ b` is negated elementhood. It is notation for `Â¬ (a âˆˆ b)`. "},
 {"name": "Â«term_â‰ƒâ‚—â…_,_â†_Â»",
  "doc":
  "An equivalence of Lie algebra modules is a linear equivalence which is also a morphism of\nLie algebra modules. "},
 {"name": "Lean.Parser.Term.quot", "doc": "Syntax quotation for terms. "},
 {"name": "Lean.Parser.Term.declName",
  "doc":
  "A macro which evaluates to the name of the currently elaborating declaration. "},
 {"name": "Â«termâ…Ÿ_Â»", "doc": "The inverse of an `Invertible` element "},
 {"name": "CategoryTheory.Â«term_â¥¤+_Â»",
  "doc": "the category of additive functors is denoted `C â¥¤+ D` "},
 {"name": "PiNotation.Â«termÎ __,_Â»",
  "doc":
  "Dependent function type (a \"pi type\"). The notation `Î  x âˆˆ s, Î² x` is\nshort for `Î  x, x âˆˆ s â†’ Î² x`. "},
 {"name": "Â«term_\\_Â»",
  "doc":
  "`a \\ b` is the set difference of `a` and `b`,\nconsisting of all elements in `a` that are not in `b`.\n"},
 {"name": "Lean.Parser.Term.binrel",
  "doc":
  "`binrel% r a b` elaborates `r a b` as a binary relation using the type propogation protocol in `Lean.Elab.Extra`. "},
 {"name": "Â«termâ¨…_,_Â»", "doc": "Indexed infimum. "},
 {"name": "Â«term_â†’*o_Â»", "doc": "Infix notation for `OrderMonoidHom`. "},
 {"name": "Â«termâ¨†_,_Â»", "doc": "Indexed supremum. "},
 {"name": "Â«term_âŠ†_Â»", "doc": "Subset relation: `a âŠ† b`  "},
 {"name": "Std.Json.Â«termJson%_Â»",
  "doc": "Allows to use Json syntax in a Lean file. "},
 {"name": "Lean.Parser.Term.termUnless",
  "doc": "`unless e do s` is a nicer way to write `if !e do s`. "},
 {"name": "Â«term_âˆˆ_Â»",
  "doc": "The membership relation `a âˆˆ s : Prop` where `a : Î±`, `s : Î³`. "},
 {"name": "Â«term_â‰ƒâ‚—â‹†[_]_Â»",
  "doc":
  "The notation `M â‰ƒâ‚—â‹†[R] Mâ‚‚` denotes the type of star-linear equivalences between `M` and `Mâ‚‚`\nover the `â‹†` endomorphism of the underlying starred ring `R`. "},
 {"name": "Asymptotics.Â«term_=o[_]_Â»",
  "doc":
  "The Landau notation `f =o[l] g` where `f` and `g` are two functions on a type `Î±` and `l` is\na filter on `Î±`, means that eventually for `l`, `â€–fâ€–` is bounded by an arbitrarily small constant\nmultiple of `â€–gâ€–`. In other words, `â€–fâ€– / â€–gâ€–` tends to `0` along `l`, modulo division by zero\nissues that are avoided by this definition. "},
 {"name": "CategoryTheory.Limits.Â«term_âŠ_Â»",
  "doc": "An arbitrary choice of biproduct of a pair of objects. "},
 {"name": "Â«term_â†’+_Â»",
  "doc":
  "`M â†’+ N` denotes the type of additive monoid homomorphisms from `M` to `N`. "},
 {"name": "Std.Tactic.Coe.coeFunNotation",
  "doc": "`â‡‘ t` coerces `t` to a function. "},
 {"name": "Std.Tactic.by?",
  "doc":
  "The command `by?` will print a suggestion for replacing the proof block with a proof term\nusing `show_term`.\n"},
 {"name": "Â«term_^^^_Â»",
  "doc":
  "`a ^^^ b` computes the bitwise XOR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Lean.Expr.Â«termProd_assoc%Â»",
  "doc":
  "`prod_assoc%` elaborates to the \"obvious\" equivalence between iterated products of types,\nregardless of how the products are parenthesized.\nThe `prod_assoc%` term uses the expected type when elaborating.\nFor example, `(prod_assoc% : (Î± Ã— Î²) Ã— (Î³ Ã— Î´) â‰ƒ Î± Ã— (Î² Ã— Î³) Ã— Î´)`.\n\nThe elaborator can handle holes in the expected type,\nso long as they eventually get filled by unification.\n```lean\nexample : (Î± Ã— Î²) Ã— (Î³ Ã— Î´) â‰ƒ Î± Ã— (Î² Ã— Î³) Ã— Î´ :=\n  (prod_assoc% : _ â‰ƒ Î± Ã— Î² Ã— Î³ Ã— Î´).trans prod_assoc%\n```\n"},
 {"name": "Prefunctor.Â«termğŸ­qÂ»",
  "doc": "Notation for the identity prefunctor on a quiver. "},
 {"name": "List.Â«term_~r_Â»",
  "doc":
  "`IsRotated lâ‚ lâ‚‚` or `lâ‚ ~r lâ‚‚` asserts that `lâ‚` and `lâ‚‚` are cyclic permutations\nof each other. This is defined by claiming that `âˆƒ n, l.rotate n = l'`. "},
 {"name": "Lean.Elab.Term.CoeImpl.Â«term(â†‘)Â»",
  "doc":
  "Partially applied coercion.  Equivalent to the Î·-reduction of `(â†‘ Â·)` "},
 {"name": "Lean.Parser.Command.quot",
  "doc":
  "Syntax quotation for (sequences of) commands.\nThe identical syntax for term quotations takes priority,\nso ambiguous quotations like `` `($x $y) `` will be parsed as an application,\nnot two commands. Use `` `($x:command $y:command) `` instead.\nMultiple commands will be put in a `` `null `` node,\nbut a single command will not (so that you can directly\nmatch against a quotation in a command kind's elaborator). "},
 {"name": "Â«term_âºÂ»", "doc": "The positive part function. "},
 {"name": "Nat.Â«termâŒŠ_âŒ‹â‚ŠÂ»",
  "doc":
  "`âŒŠaâŒ‹â‚Š` is the greatest natural `n` such that `n â‰¤ a`. If `a` is negative, then `âŒŠaâŒ‹â‚Š = 0`. "},
 {"name": "Â«term_â†’â‹†â‚[_]_Â»",
  "doc":
  "A *â‹†-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. "},
 {"name": "Â«term_â‰¤_Â»", "doc": "The less-equal relation: `x â‰¤ y` "},
 {"name": "termMax_prec",
  "doc":
  "`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n"},
 {"name": "Â«term_[Î›^_]â†’â‚—[_]_Â»",
  "doc":
  "An alternating map is a multilinear map that vanishes when two of its arguments are equal.\n"},
 {"name": "Â«term_<*_Â»",
  "doc":
  "If `x : F Î±` and `y : F Î²`, then `x <* y` evaluates `x`, then `y`,\nand returns the result of `x`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit â†’ f Î²` function. "},
 {"name": "Std.Tactic.noMatch",
  "doc":
  "The syntax `match x with.` is a variant of `nomatch x` which supports pattern matching on multiple\ndiscriminants, like regular `match`, and simply has no alternatives in the match.\n"},
 {"name": "Lean.Parser.Term.binop",
  "doc":
  "`binop% f a b` elaborates `f a b` as a binary operation using the type propogation protocol in `Lean.Elab.Extra`. "},
 {"name": "CategoryTheory.Â«term_âŠ—_Â»",
  "doc": "Notation for `tensorIso`, the tensor product of isomorphisms "},
 {"name": "Int.Â«term_â‰¡_[ZMOD_]Â»",
  "doc": "`a â‰¡ b [ZMOD n]` when `a % n = b % n`. "},
 {"name": "Â«term_/â‚š_Â»",
  "doc":
  "Partial division. It is defined when the\nsecond argument is invertible, and unlike the division operator\nin `DivisionRing` it is not totalized at zero. "},
 {"name": "Â«term_>>=_Â»",
  "doc":
  "If `x : m Î±` and `f : Î± â†’ m Î²`, then `x >>= f : m Î²` represents the\nresult of executing `x` to get a value of type `Î±` and then passing it to `f`. "},
 {"name": "termâ„",
  "doc":
  "The type `â„` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. "},
 {"name": "Tactic.Elementwise.Â«termElementwise_of%_Â»",
  "doc":
  "`elementwise_of% h`, where `h` is a proof of an equation `f = g` between\nmorphisms `X âŸ¶ Y` in a concrete category (possibly after a `âˆ€` binder),\nproduces a proof of equation `âˆ€ (x : X), f x = g x`, but with compositions fully\nright associated and identities removed.\n\nA typical example is using `elementwise_of%` to dynamically generate rewrite lemmas:\n```lean\nexample (M N K : MonCat) (f : M âŸ¶ N) (g : N âŸ¶ K) (h : M âŸ¶ K) (w : f â‰« g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n```\nIn this case, `elementwise_of% w` generates the lemma `âˆ€ (x : M), f (g x) = h x`.\n\nLike the `@[elementwise]` attribute, `elementwise_of%` inserts a `ConcreteCategory`\ninstance argument if it can't synthesize a relevant `ConcreteCategory` instance.\n(Technical note: The forgetful functor's universe variable is instantiated with a\nfresh level metavariable in this case.)\n\nOne difference between `elementwise_of%` and `@[elementwise]` is that `@[elementwise]` by\ndefault applies `simp` to both sides of the generated lemma to get something that is in simp\nnormal form. `elementwise_of%` does not do this.\n"},
 {"name": "CategoryTheory.Limits.Â«termâŠ¤__Â»",
  "doc": "Notation for the terminal object in `C` "},
 {"name": "Set.Â«term_â»Â¹'_Â»",
  "doc":
  "`f â»Â¹' t` denotes the preimage of `t : Set Î²` under the function `f : Î± â†’ Î²`. "},
 {"name": "Lean.Parser.Term.explicitUniv",
  "doc":
  "`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},
 {"name": "Â«termÎ±â‰¥0Â»",
  "doc":
  "Local notation for the nonnegative elements of a type `Î±`. TODO: actually make local. "},
 {"name": "Â«term_<->_Â»",
  "doc":
  "If and only if, or logical bi-implication. `a â†” b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n"},
 {"name": "Â«term_â‰¤â‚€_Â»",
  "doc":
  "`p` is many-one reducible to `q` if there is a computable function translating questions about `p`\nto questions about `q`.\n"},
 {"name": "Std.TermUnsafe.termUnsafe_",
  "doc":
  "`unsafe t : Î±` is an expression constructor which allows using unsafe declarations inside the\nbody of `t : Î±`, by creating an auxiliary definition containing `t` and using `implementedBy` to\nwrap it in a safe interface. It is required that `Î±` is nonempty for this to be sound,\nbut even beyond that, an `unsafe` block should be carefully inspected for memory safety because\nthe compiler is unable to guarantee the safety of the operation.\n\nFor example, the `evalExpr` function is unsafe, because the compiler cannot guarantee that when\nyou call ```evalExpr Foo ``Foo e``` that the type `Foo` corresponds to the name `Foo`, but in a\nparticular use case, we can ensure this, so `unsafe (evalExpr Foo ``Foo e)` is a correct usage.\n"},
 {"name": "Prefunctor.Â«term_â¥¤q_Â»",
  "doc": "Notation for a prefunctor between quivers. "},
 {"name": "Â«term_â‡”_Â»", "doc": "Notation for bihimp "},
 {"name": "Â«term_áµƒáµ’áµ–Â»", "doc": "Additive opposite of a type. "},
 {"name": "MeasureTheory.Â«termâˆ«â»_In_,_âˆ‚_Â»",
  "doc":
  "The **lower Lebesgue integral** of a function `f` with respect to a measure `Î¼`. "},
 {"name": "Â«term-_Â»",
  "doc":
  "`-a` computes the negative or opposite of `a`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Function.term_On_",
  "doc":
  "Given functions `f : Î² â†’ Î² â†’ Ï†` and `g : Î± â†’ Î²`, produce a function `Î± â†’ Î± â†’ Ï†` that evaluates\n`g` on each argument, then applies `f` to the results. Can be used, e.g., to transfer a relation\nfrom `Î²` to `Î±`. "},
 {"name": "Matrix.matrixNotation",
  "doc":
  "Notation for mÃ—n matrices, aka `Matrix (Fin m) (Fin n) Î±`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) Î±`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) Î±` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) Î±` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) Î±`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) Î±`\n* `![]` is the 0Ã—0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "Mathlib.Tactic.Â«termType*Â»",
  "doc":
  "The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`> 0` for each variable in the sequence. "},
 {"name": "CategoryTheory.Â«term_â¥¤â‚‘_Â»",
  "doc": "`C â¥¤â‚‘ D` denotes exact functors `C â¥¤ D` "},
 {"name": "CategoryTheory.Limits.Â«term_â¨¯_Â»",
  "doc": "Notation for the product "},
 {"name": "Lean.Parser.Term.open",
  "doc":
  "`open Foo in e` is like `open Foo` but scoped to a single term.\nIt makes the given namespaces available in the term `e`.\n"},
 {"name": "Asymptotics.Â«term_=O[_]_Â»",
  "doc":
  "The Landau notation `f =O[l] g` where `f` and `g` are two functions on a type `Î±` and `l` is\na filter on `Î±`, means that eventually for `l`, `â€–fâ€–` is bounded by a constant multiple of `â€–gâ€–`.\nIn other words, `â€–fâ€– / â€–gâ€–` is eventually bounded, modulo division by zero issues that are avoided\nby this definition. "},
 {"name": "Â«term_â‰ƒâ‚—[_]_Â»",
  "doc":
  "The notation `M â‰ƒâ‚— [R] Mâ‚‚` denotes the type of linear equivalences between `M` and `Mâ‚‚` over\na plain linear map `M â†’â‚— Mâ‚‚`. "},
 {"name": "Lean.Parser.Term.explicit",
  "doc":
  "`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},
 {"name": "Â«term~~~_Â»", "doc": "The implementation of `~~~a : Î±`. "},
 {"name": "Â«term_Ã—_Â»",
  "doc":
  "Product type (aka pair). You can use `Î± Ã— Î²` as notation for `Prod Î± Î²`.\nGiven `a : Î±` and `b : Î²`, `Prod.mk a b : Prod Î± Î²`. You can use `(a, b)`\nas notation for `Prod.mk a b`. Moreover, `(a, b, c)` is notation for\n`Prod.mk a (Prod.mk b c)`.\nGiven `p : Prod Î± Î²`, `p.1 : Î±` and `p.2 : Î²`. They are short for `Prod.fst p`\nand `Prod.snd p` respectively. You can also write `p.fst` and `p.snd`.\nFor more information: [Constructors with Arguments](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments)\n"},
 {"name": "Â«term_â†’â‚—â…_,_â†_Â»",
  "doc":
  "A morphism of Lie algebra modules is a linear map which commutes with the action of the Lie\nalgebra. "},
 {"name": "Std.Tactic.RunCmd.byElab",
  "doc":
  "* The `by_elab doSeq` expression runs the `doSeq` as a `TermElabM Expr` to\n  synthesize the expression.\n* `by_elab fun expectedType? => do doSeq` receives the expected type (an `Option Expr`)\n  as well.\n"},
 {"name": "Â«term_âŠ•'_Â»",
  "doc":
  "`PSum Î± Î²`, or `Î± âŠ•' Î²`, is the disjoint union of types `Î±` and `Î²`.\nIt differs from `Î± âŠ• Î²` in that it allows `Î±` and `Î²` to have arbitrary sorts\n`Sort u` and `Sort v`, instead of restricting to `Type u` and `Type v`. This means\nthat it can be used in situations where one side is a proposition, like `True âŠ•' Nat`.\n\nThe reason this is not the default is that this type lives in the universe `Sort (max 1 u v)`,\nwhich can cause problems for universe level unification,\nbecause the equation `max 1 u v = ?u + 1` has no solution in level arithmetic.\n`PSum` is usually only used in automation that constructs sums of arbitrary types.\n"},
 {"name": "Â«term_âˆ†_Â»", "doc": "Notation for symmDiff "},
 {"name": "Mathlib.Util.TermBeta.betaStx",
  "doc":
  "`beta% t` elaborates `t` and then if the result is in the form\n`f x1 ... xn` where `f` is a (nested) lambda expression,\nit will substitute all of its arguments by beta reduction.\nThis does not recursively do beta reduction, nor will it do\nbeta reduction of subexpressions.\n\nIn particular, `t` is elaborated, its metavariables are instantiated,\nand then `Lean.Expr.headBeta` is applied. "},
 {"name": "Â«term_>=>_Â»",
  "doc": "Left-to-right composition of Kleisli arrows. "},
 {"name": "Â«term_âˆ¨_Â»",
  "doc":
  "`Or a b`, or `a âˆ¨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a â†’ a âˆ¨ b` and `Or.inr : b â†’ a âˆ¨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n"},
 {"name": "List.Â«term_<+:_Â»",
  "doc":
  "`IsPrefix lâ‚ lâ‚‚`, or `lâ‚ <+: lâ‚‚`, means that `lâ‚` is a prefix of `lâ‚‚`,\nthat is, `lâ‚‚` has the form `lâ‚ ++ t` for some `t`.\n"},
 {"name": "Pi.Â«termÎ â‚—_,_Â»",
  "doc":
  "The notation `Î â‚— i, Î± i` refers to a pi type equipped with the lexicographic order. "},
 {"name": "Â«termâŠ¥Â»", "doc": "The bot (`âŠ¥`, `\\bot`) element "},
 {"name": "Â«term{}Â»",
  "doc":
  "`âˆ…` or `{}` is the empty set or empty collection.\nIt is supported by the `EmptyCollection` typeclass. "},
 {"name": "Â«term{_:_//_}Â»",
  "doc":
  "`Subtype p`, usually written as `{x : Î± // p x}`, is a type which\nrepresents all the elements `x : Î±` for which `p x` is true. It is structurally\na pair-like type, so if you have `x : Î±` and `h : p x` then\n`âŸ¨x, hâŸ© : {x // p x}`. An element `s : {x // p x}` will coerce to `Î±` but\nyou can also make it explicit using `s.1` or `s.val`.\n"},
 {"name": "rawNatLit",
  "doc":
  "The `nat_lit n` macro constructs \"raw numeric literals\". This corresponds to the\n`Expr.lit (.natVal n)` constructor in the `Expr` data type.\n\nNormally, when you write a numeral like `#check 37`, the parser turns this into\nan application of `OfNat.ofNat` to the raw literal `37` to cast it into the\ntarget type, even if this type is `Nat` (so the cast is the identity function).\nBut sometimes it is necessary to talk about the raw numeral directly,\nespecially when proving properties about the `ofNat` function itself.\n"},
 {"name": "Â«term_>=_Â»", "doc": "`a â‰¥ b` is an abbreviation for `b â‰¤ a`. "},
 {"name": "Â«term_â‰ƒ_Â»",
  "doc":
  "`Î± â‰ƒ Î²` is the type of functions from `Î± â†’ Î²` with a two-sided inverse. "},
 {"name": "Â«term_â†’+*_Â»",
  "doc": "`Î± â†’+* Î²` denotes the type of ring homomorphisms from `Î±` to `Î²`. "},
 {"name": "Â«term_âˆ˜_Â»",
  "doc":
  "Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.\nExample:\n```\n#eval Function.comp List.reverse (List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nYou can use the notation `f âˆ˜ g` as shorthand for `Function.comp f g`.\n```\n#eval (List.reverse âˆ˜ List.drop 2) [3, 2, 4, 1]\n-- [1, 4]\n```\nA simpler way of thinking about it, is that `List.reverse âˆ˜ List.drop 2`\nis equivalent to `fun xs => List.reverse (List.drop 2 xs)`,\nthe benefit is that the meaning of composition is obvious,\nand the representation is compact.\n"},
 {"name": "Vector.Â«term_::áµ¥_Â»",
  "doc":
  "If `a : Î±` and `l : Vector Î± n`, then `cons a l`, is the vector of length `n + 1`\nwhose first element is a and with l as the rest of the list. "},
 {"name": "Lean.Parser.Term.withDeclName",
  "doc":
  "* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},
 {"name": "Lean.Parser.Term.leftact",
  "doc":
  "`leftact% f a b` elaborates `f a b` as a left action using the type propogation protocol in `Lean.Elab.Extra`.\nIn particular, it is like a unary operation with a fixed parameter `a`, where only the right argument `b` participates in the operator coercion elaborator. "},
 {"name": "Lean.Expr.prodAssocStx",
  "doc":
  "IMPLEMENTATION: Syntax used in the implementation of `prod_assoc%`.\nThis elaborator postpones if there are metavariables in the expected type,\nand to propagate the fact that this elaborator produces an `Equiv`,\nthe `prod_assoc%` macro sets things up with a type ascription.\nThis enables using `prod_assoc%` with, for example `Equiv.trans` dot notation. "},
 {"name": "Lean.Parser.Term.sort",
  "doc": "A specific universe in Lean's infinite hierarchy of universes. "},
 {"name": "Â«term_â†’*â‚€_Â»",
  "doc":
  "`M â†’*â‚€ N` denotes the type of zero-preserving monoid homomorphisms from `M` to `N`. "},
 {"name": "Â«term_|||_Â»",
  "doc":
  "`a ||| b` computes the bitwise OR of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Prod.Lex.Â«term_Ã—â‚—_Â»",
  "doc": "A type synonym to equip a type with its lexicographic order. "},
 {"name": "Â«termâ„•+Â»",
  "doc":
  "`â„•+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `â„•+` is the same as `â„•` because the proof\nis not stored. "},
 {"name": "FBinopElab.prodSyntax",
  "doc":
  "`fbinop% f x y` elaborates `f x y` for `x : S Î±` and `y : S' Î²`, taking into account\nany coercions that the \"functors\" `S` and `S'` possess. "},
 {"name": "Â«term_â‰ƒâ‚[_]_Â»",
  "doc":
  "An equivalence of algebras is an equivalence of rings commuting with the actions of scalars. "},
 {"name": "Â«term_â†’r_Â»",
  "doc":
  "A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : Î± â†’ Î²` such that `r a b â†’ s (f a) (f b)`. "},
 {"name": "Â«term_||_Â»",
  "doc":
  "`or x y`, or `x || y`, is the boolean \"or\" operation (not to be confused\nwith `Or : Prop â†’ Prop â†’ Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is true then `y` is not evaluated.\n"},
 {"name": "MeasureTheory.Â«termâ¨_,_Â»",
  "doc":
  "Average value of a function `f` w.r.t. a measure `Î¼`, notation: `â¨ x, f x âˆ‚Î¼`. It is defined as\n`(Î¼ univ).toRealâ»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼`, so it is equal to zero if `f` is not integrable or if `Î¼` is an\ninfinite measure. If `Î¼` is a probability measure, then the average of any function is equal to its\nintegral.\n\nFor the average on a set, use `â¨ x in s, f x âˆ‚Î¼` (defined as `â¨ x, f x âˆ‚(Î¼.restrict s)`). For\naverage w.r.t. the volume, one can omit `âˆ‚volume`. "},
 {"name": "Â«term_Ë£Â»",
  "doc":
  "Units of a `Monoid`, bundled version. Notation: `Î±Ë£`.\n\nAn element of a `Monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `IsUnit`. "},
 {"name": "calc",
  "doc":
  "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` has term mode and tactic mode variants. This is the term mode variant.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n"},
 {"name": "Rat.termâ„š",
  "doc":
  "Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n"},
 {"name": "boolIfThenElse",
  "doc":
  "`cond b x y` is the same as `if b then x else y`, but optimized for a\nboolean condition. It can also be written as `bif b then x else y`.\nThis is `@[macro_inline]` because `x` and `y` should not\nbe eagerly evaluated (see `ite`).\n"},
 {"name": "Std.Tactic.showTerm",
  "doc":
  "`show_term e` elaborates `e`, then prints the generated term.\n\n(For some tactics, the printed term will not be human readable.)\n"},
 {"name": "Â«term_â‰ƒ+_Â»", "doc": "Notation for an `AddEquiv`. "},
 {"name": "CategoryTheory.Â«term_â‰Œ_Â»",
  "doc": "We infix the usual notation for an equivalence "},
 {"name": "Set.Â«term{_|_}_1Â»",
  "doc":
  "`{ f x y | (x : X) (y : Y) }` is notation for the set of elements `f x y` constructed from the\nbinders `x` and `y`, equivalent to `{z : Z | âˆƒ x y, f x y = z}`.\n\nIf `f x y` is a single identifier, it must be parenthesized to avoid ambiguity with `{x | p x}`;\nfor instance, `{(x) | (x : Nat) (y : Nat) (_hxy : x = y^2)}`.\n"},
 {"name": "Lean.Parser.Term.sorry",
  "doc": "A temporary placeholder for a missing proof or value. "},
 {"name": "Â«term_â»Â¹Â»", "doc": "Invert an element of Î±. "},
 {"name": "Â«term_>>>_Â»",
  "doc":
  "`a >>> b` computes `a` shifted to the right by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat` and fixed width unsigned types like `UInt8`,\n  this is equivalent to `a / 2 ^ b`. "},
 {"name": "Int.Â«termâŒŠ_âŒ‹Â»",
  "doc":
  "`Int.floor a` is the greatest integer `z` such that `z â‰¤ a`. It is denoted with `âŒŠaâŒ‹`. "},
 {"name": "Â«term_âˆª_Â»", "doc": "`a âˆª b` is the union of`a` and `b`. "},
 {"name": "GradedTensorProduct.Â«term_áµâŠ—â‚œ[_]_Â»",
  "doc": "The graded tensor product of two elements of graded rings. "},
 {"name": "Matrix.matrixNotation0xC",
  "doc":
  "Notation for mÃ—n matrices, aka `Matrix (Fin m) (Fin n) Î±`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) Î±`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) Î±` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) Î±` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) Î±`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) Î±`\n* `![]` is the 0Ã—0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "Â«term_âŠ“_Â»", "doc": "Greatest lower bound (`\\glb` notation) "},
 {"name": "MeasureTheory.Â«termâˆ«_In_,_âˆ‚_Â»", "doc": "The Bochner integral "},
 {"name": "Lean.Parser.Term.set_option",
  "doc":
  "`set_option opt val in e` is like `set_option opt val` but scoped to a single term.\nIt sets the option `opt` to the value `val` in the term `e`.\n"},
 {"name": "Lean.Parser.Term.subst",
  "doc":
  "`h â–¸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h â–¸ e` has type `p b`.\nYou can also view `h â–¸ e` as a \"type casting\" operation\nwhere you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual\n\"Theorem Proving in Lean\" for additional information.\n"},
 {"name": "Â«term_Ã—Ë¢_Â»",
  "doc":
  "The cartesian product `s Ã—Ë¢ t` is the set of `(a, b)` such that `a âˆˆ s` and `b âˆˆ t`. "},
 {"name": "Â«term_áµáµ’áµ–Â»", "doc": "Multiplicative opposite of a type. "},
 {"name": "CategoryTheory.Limits.Â«termâˆ_Â»",
  "doc": "notation for categorical products "},
 {"name": "OreLocalization.Â«term_/â‚’_Â»",
  "doc":
  "The division in the ore localization `R[Sâ»Â¹]`, as a fraction of an element of `R` and `S`. "},
 {"name": "Lean.Parser.Term.match",
  "doc":
  "Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... => f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},
 {"name": "Set.Â«termâ‹‚_,_Â»",
  "doc":
  "Notation for `Set.iInter`. Indexed intersection of a family of sets "},
 {"name": "Lean.Parser.Term.panic",
  "doc":
  "`panic! msg` formally evaluates to `@Inhabited.default Î±` if the expected type\n`Î±` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},
 {"name": "CategoryTheory.exp.Â«term_âŸ¹_Â»",
  "doc": "Morphisms obtained using an exponentiable object. "},
 {"name": "SimpleGraph.Â«term_â–¡_Â»",
  "doc":
  "Box product of simple graphs. It relates `(aâ‚, b)` and `(aâ‚‚, b)` if `G` relates `aâ‚` and `aâ‚‚`,\nand `(a, bâ‚)` and `(a, bâ‚‚)` if `H` relates `bâ‚` and `bâ‚‚`. "},
 {"name": "Â«term_â‡¨_Â»", "doc": "Heyting implication "},
 {"name": "MeasureTheory.Â«termâˆ«â‹¯âˆ«â»__,_Â»",
  "doc":
  "Integrate `f(xâ‚,â€¦,xâ‚™)` over all variables `xáµ¢` where `i âˆˆ s`. Return a function in the\nremaining variables (it will be constant in the `xáµ¢` for `i âˆˆ s`).\nThis is the marginal distribution of all variables not in `s` when the considered measure\nis the product measure. "},
 {"name": "Lean.Parser.Term.pipeProj",
  "doc":
  "`e |>.x` is a shorthand for `(e).x`.\nIt is especially useful for avoiding parentheses with repeated applications.\n"},
 {"name": "Â«term_áµˆáµƒáµƒÂ»",
  "doc":
  "If `M` additively acts on `Î±`, then `DomAddAct M` acts on `Î± â†’ Î²` as\nwell as some bundled maps from `Î±`. This is a type synonym for `AddOpposite M`, so this corresponds\nto a right action of `M`."},
 {"name": "Lean.Parser.Term.prop",
  "doc": "The universe of propositions. `Prop â‰¡ Sort 0`. "},
 {"name": "Â«term_â‰ƒâ‚›â‚—[_]_Â»",
  "doc":
  "The notation `M â‰ƒâ‚›â‚—[Ïƒ] Mâ‚‚` denotes the type of linear equivalences between `M` and `Mâ‚‚` over a\nring homomorphism `Ïƒ`. "},
 {"name": "Â«term_âˆ£_Â»",
  "doc":
  "Divisibility. `a âˆ£ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. "},
 {"name": "Â«termâ„“Â²(_,_)Â»",
  "doc":
  "`â„“Â²(Î¹, ğ•œ)` is the Hilbert space of square-summable functions `Î¹ â†’ ğ•œ`, herein implemented\nas `lp (fun i : Î¹ => ğ•œ) 2`. "},
 {"name": "CategoryTheory.Â«term_âŸ¦_âŸ§'Â»",
  "doc": "shifting a morphism `f` by `n` is obtained by the notation `fâŸ¦nâŸ§'` "},
 {"name": "Â«termâ„¤_[_]Â»", "doc": "The ring of `p`-adic integers. "},
 {"name": "Â«term_=<<_Â»",
  "doc": "Same as `Bind.bind` but with arguments swapped. "},
 {"name": "Â«term_âŠ‚_Â»", "doc": "Strict subset relation: `a âŠ‚ b`  "},
 {"name": "Â«term_â‰ƒr_Â»",
  "doc":
  "A relation isomorphism is an equivalence that is also a relation embedding. "},
 {"name": "Class.Â«term_â€²_Â»", "doc": "Function value "},
 {"name": "coeNotation",
  "doc":
  "`â†‘x` represents a coercion, which converts `x` of type `Î±` to type `Î²`, using\ntypeclasses to resolve a suitable conversion function. You can often leave the\n`â†‘` off entirely, since coercion is triggered implicitly whenever there is a\ntype error, but in ambiguous cases it can be useful to use `â†‘` to disambiguate\nbetween e.g. `â†‘x + â†‘y` and `â†‘(x + y)`.\n"},
 {"name": "Std.Tactic.noFun",
  "doc":
  "The syntax  `fun.` or `Î».` (dot required) is shorthand for an empty pattern match function,\ni.e. `fun x y z => match x, y, z with.` for an appropriate number of arguments.\n"},
 {"name": "Â«termâŸª_,_âŸ«_â„‚Â»", "doc": "The inner product with values in `â„‚`. "},
 {"name": "Â«term_=_Â»",
  "doc":
  "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (Î± : Type) (a b c d : Î±)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (Î± : Type) (a b : Î±) (p : Î± â†’ Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (Î± : Type) (a b : Î±) (p : Î± â†’ Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 â–¸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},
 {"name": "Â«term_âŸ¶_Â»",
  "doc":
  "Notation for the type of edges/arrows/morphisms between a given source and target\nin a quiver or category.\n"},
 {"name": "Multiset.Â«term_::â‚˜_Â»",
  "doc":
  "`cons a s` is the multiset which contains `s` plus one more instance of `a`. "},
 {"name": "Â«term_â†’Lâ‹†[_]_Â»",
  "doc":
  "Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `Mâ‚‚` will be topological modules over the topological\nring `R`. "},
 {"name": "Sigma.Lex.Â«termÎ£â‚—_,_Â»",
  "doc":
  "The notation `Î£â‚— i, Î± i` refers to a sigma type equipped with the lexicographic order. "},
 {"name": "Â«term_â©¿_Â»", "doc": "Notation for `Wcovby a b`. "},
 {"name": "Mathlib.Tactic.TermCongr.cHoleExpand",
  "doc":
  "(Internal for `congr(...)`)\nElaborates to an expression satisfying `cHole?` that equals the LHS or RHS of `h`,\nif the LHS or RHS is available after elaborating `h`. Uses the expected type as a hint. "},
 {"name": "Lean.Parser.Term.hole",
  "doc": "A placeholder term, to be synthesized by unification. "},
 {"name": "Â«term_â†’â‚™â‚[_]_Â»",
  "doc":
  "A morphism respecting addition, multiplication, and scalar multiplication. When these arise from\nalgebra structures, this is the same as a not-necessarily-unital morphism of algebras. "},
 {"name": "Â«term_^_Â»",
  "doc":
  "`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Polynomial.Â«term_%â‚˜_Â»",
  "doc": "`modByMonic` gives the remainder of `p` by a monic polynomial `q`. "},
 {"name": "Set.termÎ™",
  "doc":
  "`Î™ a b` denotes the open-closed interval with unordered bounds. Here, `Î™` is a capital iota,\ndistinguished from a capital `i`. "},
 {"name": "Lean.Parser.Term.termReturn",
  "doc":
  "`return` used outside of `do` blocks creates an implicit block around it\nand thus is equivalent to `pure e`, but helps with avoiding parentheses.\n"},
 {"name": "Â«term_â†’â‚[_]_Â»",
  "doc": "Defining the homomorphism in the category R-Alg. "},
 {"name": "Lean.Parser.Term.clear",
  "doc":
  "`clear% x; e` elaborates `x` after clearing the free variable `x` from the local context.\nIf `x` cannot be cleared (due to dependencies), it will keep `x` without failing.\n"},
 {"name": "Lean.Parser.Term.proj",
  "doc":
  "The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},
 {"name": "Â«term_^[_]Â»", "doc": "Iterate a function. "},
 {"name": "Mathlib.Tactic.Â«termSort*Â»",
  "doc":
  "The syntax `variable (X Y ... Z : Sort*)` creates a new distinct implicit universe variable\nfor each variable in the sequence. "},
 {"name": "Matrix.matrixNotationRx0",
  "doc":
  "Notation for mÃ—n matrices, aka `Matrix (Fin m) (Fin n) Î±`.\n\nFor instance:\n* `!![a, b, c; d, e, f]` is the matrix with two rows and three columns, of type\n  `Matrix (Fin 2) (Fin 3) Î±`\n* `!![a, b, c]` is a row vector of type `Matrix (Fin 1) (Fin 3) Î±` (see also `Matrix.row`).\n* `!![a; b; c]` is a column vector of type `Matrix (Fin 3) (Fin 1) Î±` (see also `Matrix.col`).\n\nThis notation implements some special cases:\n\n* `![,,]`, with `n` `,`s, is a term of type `Matrix (Fin 0) (Fin n) Î±`\n* `![;;]`, with `m` `;`s, is a term of type `Matrix (Fin m) (Fin 0) Î±`\n* `![]` is the 0Ã—0 matrix\n\nNote that vector notation is provided elsewhere (by `Matrix.vecNotation`) as `![a, b, c]`.\nUnder the hood, `!![a, b, c; d, e, f]` is syntax for `Matrix.of ![![a, b, c], ![d, e, f]]`.\n"},
 {"name": "Â«term__[_]Â»",
  "doc":
  "The syntax `arr[i]` gets the `i`'th element of the collection `arr`.\nIf there are proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\nThe actual behavior of this class is type-dependent,\nbut here are some important implementations:\n* `arr[i] : Î±` where `arr : Array Î±` and `i : Nat` or `i : USize`:\n  does array indexing with no bounds check and a proof side goal `i < arr.size`.\n* `l[i] : Î±` where `l : List Î±` and `i : Nat`: index into a list,\n  with proof side goal `i < l.length`.\n* `stx[i] : Syntax` where `stx : Syntax` and `i : Nat`: get a syntax argument,\n  no side goal (returns `.missing` out of range)\n\nThere are other variations on this syntax:\n* `arr[i]`: proves the proof side goal by `get_elem_tactic`\n* `arr[i]!`: panics if the side goal is false\n* `arr[i]?`: returns `none` if the side goal is false\n* `arr[i]'h`: uses `h` to prove the side goal\n"},
 {"name": "Filter.Â«term_=á¶ [_]_Â»",
  "doc":
  "Two functions `f` and `g` are *eventually equal* along a filter `l` if the set of `x` such that\n`f x = g x` belongs to `l`. "},
 {"name": "Quotient.Â«termâŸ¦_âŸ§Â»",
  "doc": "The canonical quotient map into a `Quotient`. "},
 {"name": "Â«term_&&_Â»",
  "doc":
  "`and x y`, or `x && y`, is the boolean \"and\" operation (not to be confused\nwith `And : Prop â†’ Prop â†’ Prop`, which is the propositional connective).\nIt is `@[macro_inline]` because it has C-like short-circuiting behavior:\nif `x` is false then `y` is not evaluated.\n"},
 {"name": "MeasureTheory.Â«termâˆ«â‹¯âˆ«â»__,_âˆ‚_Â»",
  "doc":
  "Integrate `f(xâ‚,â€¦,xâ‚™)` over all variables `xáµ¢` where `i âˆˆ s`. Return a function in the\nremaining variables (it will be constant in the `xáµ¢` for `i âˆˆ s`).\nThis is the marginal distribution of all variables not in `s` when the considered measure\nis the product measure. "},
 {"name": "Â«term_*_Â»",
  "doc":
  "`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Â«termï¿¢_Â»", "doc": "Heyting negation "},
 {"name": "Filter.Â«term_â‰¤á¶ [_]_Â»",
  "doc":
  "A function `f` is eventually less than or equal to a function `g` at a filter `l`. "},
 {"name": "CategoryTheory.NatTrans.Â«term_â—«_Â»",
  "doc": "Notation for horizontal composition of natural transformations. "},
 {"name": "Â«FreimanHomLocalâ‰ºÂ»",
  "doc":
  "An `n`-Freiman homomorphism on a set `A` is a map which preserves products of `n` elements. "},
 {"name": "Â«term_â‰ƒ._Â»",
  "doc":
  "A `PEquiv` is a partial equivalence, a representation of a bijection between a subset\n  of `Î±` and a subset of `Î²`. See also `PartialEquiv` for a version that requires `toFun` and\n`invFun` to be globally defined functions and has `source` and `target` sets as extra fields. "},
 {"name": "Lean.includeStr",
  "doc":
  "When `parent_dir` contains the current Lean file, `include_str \"path\" / \"to\" / \"file\"` becomes\na string literal with the contents of the file at `\"parent_dir\" / \"path\" / \"to\" / \"file\"`. If this\nfile cannot be read, elaboration fails.\n"},
 {"name": "QuadraticForm.Isometry.Â«term_â†’qáµ¢_Â»",
  "doc":
  "An isometry between two quadratic spaces `Mâ‚, Qâ‚` and `Mâ‚‚, Qâ‚‚` over a ring `R`,\nis a linear map between `Mâ‚` and `Mâ‚‚` that commutes with the quadratic forms. "},
 {"name": "List.Â«term_<:+:_Â»",
  "doc":
  "`IsInfix lâ‚ lâ‚‚`, or `lâ‚ <:+: lâ‚‚`, means that `lâ‚` is a contiguous\nsubstring of `lâ‚‚`, that is, `lâ‚‚` has the form `s ++ lâ‚ ++ t` for some `s, t`.\n"},
 {"name": "PiNotation.piNotation",
  "doc":
  "Dependent function type (a \"pi type\"). The notation `Î  x : Î±, Î² x` can\nalso be written as `(x : Î±) â†’ Î² x`. "},
 {"name": "Â«term_<<<_Â»",
  "doc":
  "`a <<< b` computes `a` shifted to the left by `b` places.\nThe meaning of this notation is type-dependent.\n* On `Nat`, this is equivalent to `a * 2 ^ b`.\n* On `UInt8` and other fixed width unsigned types, this is the same but\n  truncated to the bit width. "},
 {"name": "Â«termâŠ¤Â»", "doc": "The top (`âŠ¤`, `\\top`) element "},
 {"name": "Â«term_â†’+*o_Â»",
  "doc":
  "`OrderRingHom Î± Î²` is the type of monotone semiring homomorphisms from `Î±` to `Î²`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom Î± Î²)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. "},
 {"name": "Matroid.Â«term_ï¹¡Â»",
  "doc":
  "The `ï¹¡` symbol, which denotes matroid duality.\n(This is distinct from the usual `*` symbol for multiplication, due to precedence issues. )"},
 {"name": "Â«term_â†’L[_]_Â»",
  "doc":
  "Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `Mâ‚‚` will be topological modules over the topological\nring `R`. "},
 {"name": "Â«term_â†’â‚—[_]_Â»",
  "doc": "`M â†’â‚—[R] N` is the type of `R`-linear maps from `M` to `N`. "},
 {"name": "Â«term|___|Â»", "doc": "The absolute value function. "},
 {"name": "Â«term_â‰ƒâ‚œ_Â»",
  "doc":
  "Homeomorphism between `X` and `Y`, also called topological isomorphism "},
 {"name": "TypeVec.Â«term_:::__1Â»",
  "doc":
  "append an arrow and a function as well as their respective source and target types / typevecs "},
 {"name": "MeasureTheory.Â«termâ¨_,_âˆ‚_Â»",
  "doc":
  "Average value of a function `f` w.r.t. a measure `Î¼`, notation: `â¨ x, f x âˆ‚Î¼`. It is defined as\n`(Î¼ univ).toRealâ»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼`, so it is equal to zero if `f` is not integrable or if `Î¼` is an\ninfinite measure. If `Î¼` is a probability measure, then the average of any function is equal to its\nintegral.\n\nFor the average on a set, use `â¨ x in s, f x âˆ‚Î¼` (defined as `â¨ x, f x âˆ‚(Î¼.restrict s)`). For\naverage w.r.t. the volume, one can omit `âˆ‚volume`. "},
 {"name": "AlgebraicGeometry.Â«term_âˆ£__Â»",
  "doc":
  "the notation for restricting a morphism of scheme to an open subset of the target scheme "},
 {"name": "AlgebraicGeometry.Â«term_â»Â¹áµ_Â»",
  "doc":
  "`f â»Â¹áµ U` is notation for `(Opens.map f.1.base).obj U`,\nthe preimage of an open set `U` under `f`. "},
 {"name": "Â«term_<=_Â»", "doc": "The less-equal relation: `x â‰¤ y` "},
 {"name": "Lean.Parser.Term.unop",
  "doc":
  "`unop% f a` elaborates `f a` as a unary operation using the type propogation protocol in `Lean.Elab.Extra`. "},
 {"name": "Â«MulActionHomLocalâ‰ºÂ»", "doc": "Equivariant functions. "},
 {"name": "Â«term_â‰ƒáµ¢_Â»",
  "doc":
  "`Î±` and `Î²` are isometric if there is an isometric bijection between them. "},
 {"name": "MeasureTheory.Â«termâˆ«_,_Â»", "doc": "The Bochner integral "},
 {"name": "Â«term_â†’â‚™*_Â»",
  "doc":
  "`M â†’â‚™* N` denotes the type of multiplication-preserving maps from `M` to `N`. "},
 {"name": "Â«term_â»Â»", "doc": "The negative part function. "},
 {"name": "CategoryTheory.Â«term_â¥¤áµ£_Â»",
  "doc": "`C â¥¤áµ£ D` denotes right exact functors `C â¥¤ D` "},
 {"name": "Lean.Parser.Term.binop_lazy",
  "doc":
  "`binop_lazy%` is similar to `binop% f a b`, but it wraps `b` as a function from `Unit`. "},
 {"name": "Â«term_â‰ºi_Â»",
  "doc":
  "If `r` is a relation on `Î±` and `s` in a relation on `Î²`, then `f : r â‰ºi s` is an order\nembedding whose range is an open interval `(-âˆ, top)` for some element `top` of `Î²`. Such order\nembeddings are called principal segments "},
 {"name": "ZFSet.Â«termâ‹‚â‚€_Â»",
  "doc":
  "The intersection operator, the collection of elements in all of the elements of a ZFC set. We\nspecial-case `â‹‚â‚€ âˆ… = âˆ…`. "},
 {"name": "Std.ExtendedBinder.Â«termSatisfies_binder_pred%__Â»",
  "doc":
  "`satisfies_binder_pred% t pred` expands to a proposition expressing that `t` satisfies `pred`.\n"},
 {"name": "Â«term_â‰ƒLâ‹†[_]_Â»",
  "doc":
  "Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `Mâ‚‚` will be topological modules over the\ntopological semiring `R`. "},
 {"name": "Â«term_â‰ƒ*_Â»", "doc": "Notation for a `MulEquiv`. "},
 {"name": "Â«term_/\\_Â»",
  "doc":
  "`And a b`, or `a âˆ§ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`âŸ¨ha, hbâŸ© : a âˆ§ b`, and if `h : a âˆ§ b` then `h.left : a` and `h.right : b`.\n"},
 {"name": "Std.Tactic.letI",
  "doc":
  "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. "},
 {"name": "Â«termÎ©[_â„_]Â»",
  "doc":
  "The module of KÃ¤hler differentials (Kahler differentials, Kaehler differentials).\nThis is implemented as `I / I ^ 2` with `I` the kernel of the multiplication map `S âŠ—[R] S â†’â‚[R] S`.\nTo view elements as a linear combination of the form `s â€¢ D s'`, use\n`KaehlerDifferential.tensorProductTo_surjective` and `Derivation.tensorProductTo_tmul`.\n\nWe also provide the notation `Î©[Sâ„R]` for `KaehlerDifferential R S`.\nNote that the slash is `\\textfractionsolidus`.\n"},
 {"name": "Lean.Elab.Term.CoeImpl.Â«term(â‡‘)Â»",
  "doc":
  "Partially applied function coercion.  Equivalent to the Î·-reduction of `(â‡‘ Â·)` "},
 {"name": "Lean.Parser.Term.doubleQuotedName",
  "doc":
  "A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},
 {"name": "Finsupp.funâ‚€",
  "doc":
  "`funâ‚€ | i => a` is notation for `Finsupp.single i a`, and with multiple match arms,\n`funâ‚€ ... | i => a` is notation for `Finsupp.update (funâ‚€ ...) i a`.\n\nAs a result, if multiple match arms coincide, the last one takes precedence. "},
 {"name": "Â«DistribMulActionHomLocalâ‰ºÂ»",
  "doc": "Equivariant additive monoid homomorphisms. "},
 {"name": "Â«term_â§¸_Â»",
  "doc": "Quotient notation based on the `HasQuotient` typeclass "},
 {"name": "Â«term_&&&_Â»",
  "doc":
  "`a &&& b` computes the bitwise AND of `a` and `b`.\nThe meaning of this notation is type-dependent. "},
 {"name": "Â«term_â‰ƒ+*_Â»", "doc": "Notation for `RingEquiv`. "},
 {"name": "Lean.Parser.Term.let_delayed",
  "doc":
  "`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},
 {"name": "Â«term{_}Â»",
  "doc":
  "`{ a, b, c }` is a set with elements `a`, `b`, and `c`.\n\nThis notation works for all types that implement `Insert` and `Singleton`.\n"},
 {"name": "Lean.Parser.Term.namedPattern",
  "doc":
  "`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},
 {"name": "Lean.Parser.Term.noErrorIfUnused",
  "doc":
  "Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},
 {"name": "Set.Â«term{_|_}_2Â»",
  "doc":
  "* `{ pat : X | p }` is notation for pattern matching in set-builder notation,\n  where `pat` is a pattern that is matched by all objects of type `X`\n  and `p` is a proposition that can refer to variables in the pattern.\n  It is the set of all objects of type `X` which, when matched with the pattern `pat`,\n  make `p` come out true.\n* `{ pat | p }` is the same, but in the case when the type `X` can be inferred.\n\nFor example, `{ (m, n) : â„• Ã— â„• | m * n = 12 }` denotes the set of all ordered pairs of\nnatural numbers whose product is 12.\n\nNote that if the type ascription is left out and `p` can be interpreted as an extended binder,\nthen the extended binder interpretation will be used.  For example, `{ n + 1 | n < 3 }` will\nbe interpreted as `{ x : Nat | âˆƒ n < 3, n + 1 = x }` rather than using pattern matching.\n"},
 {"name": "Lean.termThrowError__",
  "doc":
  "Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe result of `getRef` is used as position information.\nRecall that `getRef` returns the current \"reference\" syntax.\n"},
 {"name": "termIfThenElse",
  "doc":
  "`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n\nBecause lean uses a strict (call-by-value) evaluation strategy, the signature of this\nfunction is problematic in that it would require `t` and `e` to be evaluated before\ncalling the `ite` function, which would cause both sides of the `if` to be evaluated.\nEven if the result is discarded, this would be a big performance problem,\nand is undesirable for users in any case. To resolve this, `ite` is marked as\n`@[macro_inline]`, which means that it is unfolded during code generation, and\nthe definition of the function uses `fun _ => t` and `fun _ => e` so this recovers\nthe expected \"lazy\" behavior of `if`: the `t` and `e` arguments delay evaluation\nuntil `c` is known.\n"},
 {"name": "Â«term_*>_Â»",
  "doc":
  "If `x : F Î±` and `y : F Î²`, then `x *> y` evaluates `x`, then `y`,\nand returns the result of `y`.\n\nTo avoid surprising evaluation semantics, `y` is taken \"lazily\", using a\n`Unit â†’ f Î²` function. "},
 {"name": "Lean.Parser.Term.assert",
  "doc": "`assert! cond` panics if `cond` evaluates to `false`. "},
 {"name": "Â«term_áµ’áµ–Â»",
  "doc":
  "The type of objects of the opposite of `Î±`; used to define the opposite category.\n\nNow that Lean 4 supports definitional eta equality for records,\nboth `unop (op X) = X` and `op (unop X) = X` are definitional equalities.\n\n"},
 {"name": "Â«term_â†’â‹†â‚_Â»",
  "doc":
  "A *â‹†-algebra homomorphism* is an algebra homomorphism between `R`-algebras `A` and `B`\nequipped with a `star` operation, and this homomorphism is also `star`-preserving. "},
 {"name": "Â«term_á¶œÂ»", "doc": "Set / lattice complement "},
 {"name": "Prefunctor.Â«term_â‹™q_Â»",
  "doc": "Notation for composition of prefunctors. "},
 {"name": "Â«term_â†’._Â»",
  "doc":
  "`Î± â†’. Î²` is notation for the type `PFun Î± Î²` of partial functions from `Î±` to `Î²`.  "},
 {"name": "Â«term_â†’â‚_Â»",
  "doc": "Defining the homomorphism in the category R-Alg. "},
 {"name": "Set.Â«termâ‹‚â‚€_Â»",
  "doc": "Notation for `Set.sInter` Intersection of a set of sets. "},
 {"name": "Â«term_<_Â»", "doc": "The less-than relation: `x < y` "},
 {"name": "Â«term_<$>_Â»",
  "doc": "If `f : Î± â†’ Î²` and `x : F Î±` then `f <$> x : F Î²`. "},
 {"name": "CategoryTheory.Pretriangulated.termDistTriang_",
  "doc": "distinguished triangles in a pretriangulated category "},
 {"name": "GradedTensorProduct.Â«term_áµâŠ—â‚œ_Â»",
  "doc": "The graded tensor product of two elements of graded rings. "},
 {"name": "Â«termÎ±>0Â»",
  "doc":
  "Local notation for the positive elements of a type `Î±`. TODO: actually make local. "},
 {"name": "Lean.Parser.Term.type",
  "doc": "A type universe. `Type â‰¡ Type 0`, `Type u â‰¡ Sort (u + 1)`. "}]