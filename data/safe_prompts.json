[
  {
    "name": "sub_lt_zero",
    "statement": "theorem sub_lt_zero {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†” a < b",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of sub_neg`.",
    "type": "a - b < 0 â†” a < b"
  },
  {
    "name": "add_units.is_add_regular",
    "statement": "theorem add_units.is_add_regular {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a",
    "theorem": "{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a",
    "args": "{R : Type u_1} [add_monoid R] (a : add_units R)",
    "doc_string": "If `R` is an additive monoid, an element in `add_units R` is add-regular.",
    "type": "is_add_regular â†‘a"
  },
  {
    "name": "exists_prime_add_order_of_dvd_card",
    "statement": "theorem exists_prime_add_order_of_dvd_card {G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p",
    "theorem": "{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), add_order_of x = p",
    "args": "{G : Type u_1} [add_group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem.",
    "type": "âˆƒ (x : G), add_order_of x = p"
  },
  {
    "name": "lt_add_of_sub_right_lt",
    "statement": "theorem lt_add_of_sub_right_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a - c < b â†’ a < b + c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add`.",
    "type": "a - c < b â†’ a < b + c"
  },
  {
    "name": "continuous.fst'",
    "statement": "theorem continuous.fst' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.fst)",
    "theorem": "{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.fst)",
    "args": "{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î± â†’ Î³} (hf : continuous f)",
    "doc_string": "Precomposing `f` with `prod.fst` is continuous",
    "type": "continuous (Î» (x : Î± Ã— Î²), f x.fst)"
  },
  {
    "name": "ennreal.coe_sub",
    "statement": "theorem ennreal.coe_sub {r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p",
    "theorem": "{r p : nnreal} : â†‘(r - p) = â†‘r - â†‘p",
    "args": "{r p : nnreal}",
    "doc_string": "This is a special case of `with_top.coe_sub` in the `ennreal` namespace",
    "type": "â†‘(r - p) = â†‘r - â†‘p"
  },
  {
    "name": "descending_central_series_ge_lower",
    "statement": "theorem descending_central_series_ge_lower {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n",
    "theorem": "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n",
    "args": "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•)",
    "doc_string": "Any descending central series for a group is bounded below by the lower central series.",
    "type": "lower_central_series G n â‰¤ H n"
  },
  {
    "name": "antitone.ne_of_lt_of_lt_int",
    "statement": "theorem antitone.ne_of_lt_of_lt_int {Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x",
    "theorem": "{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤) : f a â‰  x",
    "args": "{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : antitone f) (n : â„¤) {x : Î±} (h1 : f (n + 1) < x) (h2 : x < f n) (a : â„¤)",
    "doc_string": " If `f` is an antitone function from `â„¤` to a preorder and `x` lies between `f (n + 1)` and `f n`, then `x` doesn't lie in the range of `f`.",
    "type": "f a â‰  x"
  },
  {
    "name": "subgroup.inv_mem",
    "statement": "theorem subgroup.inv_mem {G : Type u_1} [group G] (H : subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) {x : G} : x âˆˆ H â†’ xâ»Â¹ âˆˆ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G) {x : G}",
    "doc_string": "A subgroup is closed under inverse.",
    "type": "x âˆˆ H â†’ xâ»Â¹ âˆˆ H"
  },
  {
    "name": "real.sq_cos_pi_div_six",
    "statement": "theorem real.sq_cos_pi_div_six  : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "theorem": " : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the cosine of `Ï€ / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "type": "real.cos (real.pi / 6) ^ 2 = 3 / 4"
  },
  {
    "name": "function.injective2.left",
    "statement": "theorem function.injective2.left {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)",
    "theorem": "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b)",
    "args": "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²)",
    "doc_string": "A binary injective function is injective when only the left argument varies.",
    "type": "function.injective (Î» (a : Î±), f a b)"
  },
  {
    "name": "function.is_periodic_pt_zero",
    "statement": "theorem function.is_periodic_pt_zero {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x",
    "theorem": "{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x",
    "args": "{Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±)",
    "doc_string": "Any point is a periodic point of period `0`.",
    "type": "function.is_periodic_pt f 0 x"
  },
  {
    "name": "function.injective.exists_ne",
    "statement": "theorem function.injective.exists_ne {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²)",
    "doc_string": " An injective function from a nontrivial type has an argument at which it does not take a given value.",
    "type": "âˆƒ (x : Î±), f x â‰  y"
  },
  {
    "name": "multiples.is_add_submonoid",
    "statement": "theorem multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "theorem": "{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "args": "{M : Type u_1} [add_monoid M] (x : M)",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` `M` is an `add_submonoid` of `M`.",
    "type": "is_add_submonoid (multiples x)"
  },
  {
    "name": "is_open_map.to_quotient_map",
    "statement": "theorem is_open_map.to_quotient_map {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f)",
    "doc_string": "A continuous surjective open map is a quotient map.",
    "type": "quotient_map f"
  },
  {
    "name": "cardinal.ord_card_unbounded'",
    "statement": "theorem cardinal.ord_card_unbounded'  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}",
    "theorem": " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}",
    "args": "",
    "doc_string": "Infinite ordinals that are cardinals are unbounded.",
    "type": "set.unbounded has_lt.lt {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length'",
    "statement": "theorem nat.of_digits_lt_base_pow_length' {b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "theorem": "{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "args": "{b : â„•} {l : list â„•} (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b + 2)",
    "doc_string": "an n-digit number in base b + 2 is less than (b + 2)^n",
    "type": "nat.of_digits (b + 2) l < (b + 2) ^ l.length"
  },
  {
    "name": "nat.odd_mod_four_iff",
    "statement": "theorem nat.odd_mod_four_iff {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3",
    "theorem": "{n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3",
    "args": "{n : â„•}",
    "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
    "type": "n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3"
  },
  {
    "name": "add_subsemigroup.subset_closure",
    "statement": "theorem add_subsemigroup.subset_closure {M : Type u_1} [has_add M] {s : set M} : s âŠ† â†‘(add_subsemigroup.closure s)",
    "theorem": "{M : Type u_1} [has_add M] {s : set M} : s âŠ† â†‘(add_subsemigroup.closure s)",
    "args": "{M : Type u_1} [has_add M] {s : set M}",
    "doc_string": "The `add_subsemigroup` generated by a set includes the set.",
    "type": "s âŠ† â†‘(add_subsemigroup.closure s)"
  },
  {
    "name": "is_monoid_hom.inv",
    "statement": "theorem is_monoid_hom.inv {Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f) : is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [mul_one_class Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_monoid_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "type": "is_monoid_hom (Î» (a : Î±), (f a)â»Â¹)"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_product",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_product f]",
    "doc_string": "In a preadditive category, if the product over `f : J â†’ C` exists,    then the biproduct over `f` exists.",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "right.one_lt_inv_iff",
    "statement": "theorem right.one_lt_inv_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a : Î±}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "1 < aâ»Â¹ â†” a < 1"
  },
  {
    "name": "dvd_add_self_left",
    "statement": "theorem dvd_add_self_left {Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b",
    "theorem": "{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ a + b â†” a âˆ£ b",
    "args": "{Î± : Type u} [ring Î±] {a b : Î±}",
    "doc_string": "An element a divides the sum a + b if and only if a divides b.",
    "type": "a âˆ£ a + b â†” a âˆ£ b"
  },
  {
    "name": "erased.out_proof",
    "statement": "theorem erased.out_proof {p : Prop} (a : erased p) : p",
    "theorem": "{p : Prop} (a : erased p) : p",
    "args": "{p : Prop} (a : erased p)",
    "doc_string": "Extracts the erased value, if it is a proof.",
    "type": "p"
  },
  {
    "name": "division_def",
    "statement": "theorem division_def {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": "**Alias** of div_eq_mul_inv`.",
    "type": "a / b = a * bâ»Â¹"
  },
  {
    "name": "int.nat_abs_pow_two",
    "statement": "theorem int.nat_abs_pow_two (x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2",
    "theorem": "(x : â„¤) : â†‘(x.nat_abs) ^ 2 = x ^ 2",
    "args": "(x : â„¤)",
    "doc_string": "**Alias** of int.nat_abs_sq`.",
    "type": "â†‘(x.nat_abs) ^ 2 = x ^ 2"
  },
  {
    "name": "real.sin_pi_div_six",
    "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2",
    "theorem": " : real.sin (real.pi / 6) = 1 / 2",
    "args": "",
    "doc_string": "The sine of `Ï€ / 6` is `1 / 2`.",
    "type": "real.sin (real.pi / 6) = 1 / 2"
  },
  {
    "name": "function.maps_to_fixed_pts_comp",
    "statement": "theorem function.maps_to_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))",
    "theorem": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))",
    "args": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±)",
    "doc_string": "Any map `f` sends fixed points of `g âˆ˜ f` to fixed points of `f âˆ˜ g`.",
    "type": "set.maps_to f (function.fixed_points (g âˆ˜ f)) (function.fixed_points (f âˆ˜ g))"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts_of_finite_biproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts_of_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C]",
    "doc_string": "A category with finite biproducts has binary biproducts.  This is not an instance as typically in concrete categories there will be an alternative construction with nicer definitional properties.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "add_lt_of_lt_neg_add",
    "statement": "theorem add_lt_of_lt_neg_add {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < -a + c â†’ a + b < c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`.",
    "type": "b < -a + c â†’ a + b < c"
  },
  {
    "name": "le_refl",
    "statement": "theorem le_refl {Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a",
    "theorem": "{Î± : Type u} [preorder Î±] (a : Î±) : a â‰¤ a",
    "args": "{Î± : Type u} [preorder Î±] (a : Î±)",
    "doc_string": "The relation `â‰¤` on a preorder is reflexive.",
    "type": "a â‰¤ a"
  },
  {
    "name": "real.tendsto_exp_neg_at_top_nhds_0",
    "statement": "theorem real.tendsto_exp_neg_at_top_nhds_0  : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)",
    "theorem": " : filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)",
    "args": "",
    "doc_string": " The real exponential function tends to `0` at `-âˆž` or, equivalently, `exp(-x)` tends to `0` at `+âˆž`",
    "type": "filter.tendsto (Î» (x : â„), real.exp (-x)) filter.at_top (nhds 0)"
  },
  {
    "name": "eq.ge",
    "statement": "theorem eq.ge {Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x",
    "theorem": "{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y) : y â‰¤ x",
    "args": "{Î± : Type u} [preorder Î±] {x y : Î±} (h : x = y)",
    "doc_string": " If `x = y` then `y â‰¤ x`. Note: this lemma uses `y â‰¤ x` instead of `x â‰¥ y`, because `le` is used almost exclusively in mathlib.",
    "type": "y â‰¤ x"
  },
  {
    "name": "eq.le",
    "statement": "theorem eq.le {Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} : a = b â†’ a â‰¤ b",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±}",
    "doc_string": "**Alias** of le_of_eq`.",
    "type": "a = b â†’ a â‰¤ b"
  },
  {
    "name": "pythagorean_triple.mul",
    "statement": "theorem pythagorean_triple.mul {x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)",
    "theorem": "{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z)",
    "args": "{x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤)",
    "doc_string": " A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`.",
    "type": "pythagorean_triple (k * x) (k * y) (k * z)"
  },
  {
    "name": "is_max.succ_eq",
    "statement": "theorem is_max.succ_eq {Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a",
    "theorem": "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±} : is_max a â†’ order.succ a = a",
    "args": "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a : Î±}",
    "doc_string": "**Alias** of the reverse direction of order.succ_eq_iff_is_max`.",
    "type": "is_max a â†’ order.succ a = a"
  },
  {
    "name": "category_theory.abelian.pseudoelement.pseudo_zero_iff",
    "statement": "theorem category_theory.abelian.pseudoelement.pseudo_zero_iff {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P)",
    "doc_string": "The pseudoelement induced by an arrow is zero precisely when that arrow is zero",
    "type": "â†‘a = 0 â†” a.hom = 0"
  },
  {
    "name": "and_or_distrib_left",
    "statement": "theorem and_or_distrib_left {a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c",
    "theorem": "{a b c : Prop} : a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c",
    "args": "{a b c : Prop}",
    "doc_string": "`âˆ§` distributes over `âˆ¨` (on the left).",
    "type": "a âˆ§ (b âˆ¨ c) â†” a âˆ§ b âˆ¨ a âˆ§ c"
  },
  {
    "name": "set.antitone_bforall",
    "statement": "theorem set.antitone_bforall {Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)",
    "theorem": "{Î± : Type u_1} {P : Î± â†’ Prop} : antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)",
    "args": "{Î± : Type u_1} {P : Î± â†’ Prop}",
    "doc_string": "Quantifying over a set is antitone in the set",
    "type": "antitone (Î» (s : set Î±), âˆ€ (x : Î±), x âˆˆ s â†’ P x)"
  },
  {
    "name": "has_lt.lt.trans'",
    "statement": "theorem has_lt.lt.trans' {Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : b < c â†’ a < b â†’ a < c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of lt_trans'`.",
    "type": "b < c â†’ a < b â†’ a < c"
  },
  {
    "name": "submonoid.closure_eq",
    "statement": "theorem submonoid.closure_eq {M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure â†‘S = S",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) : submonoid.closure â†‘S = S",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M)",
    "doc_string": "Closure of a submonoid `S` equals `S`.",
    "type": "submonoid.closure â†‘S = S"
  },
  {
    "name": "le_trans",
    "statement": "theorem le_trans {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "The relation `â‰¤` on a preorder is transitive.",
    "type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c"
  },
  {
    "name": "add_nonpos",
    "statement": "theorem add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0)",
    "doc_string": "**Alias** of `left.add_nonpos`.",
    "type": "a + b â‰¤ 0"
  },
  {
    "name": "has_lt.lt.asymm",
    "statement": "theorem has_lt.lt.asymm {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "type": "Â¬b < a"
  },
  {
    "name": "add_commute.is_of_fin_order_add",
    "statement": "theorem add_commute.is_of_fin_order_add {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Commuting elements of finite additive order are closed under addition.",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "add_subsemigroup.ext",
    "statement": "theorem add_subsemigroup.ext {M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T",
    "theorem": "{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T",
    "args": "{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T)",
    "doc_string": "Two `add_subsemigroup`s are equal if they have the same elements.",
    "type": "S = T"
  },
  {
    "name": "has_le.le.lt_of_ne",
    "statement": "theorem has_le.le.lt_of_ne {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b",
    "theorem": "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a â‰  b â†’ a < b",
    "args": "{Î± : Type u} [partial_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of lt_of_le_of_ne`.",
    "type": "a â‰¤ b â†’ a â‰  b â†’ a < b"
  },
  {
    "name": "right.add_pos_of_nonneg_of_pos",
    "statement": "theorem right.add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "le_add_of_sub_left_le",
    "statement": "theorem le_add_of_sub_left_le {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c",
    "theorem": "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a - b â‰¤ c â†’ a â‰¤ b + c",
    "args": "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of sub_le_iff_le_add'`.",
    "type": "a - b â‰¤ c â†’ a â‰¤ b + c"
  },
  {
    "name": "not_bdd_above_iff",
    "statement": "theorem not_bdd_above_iff {Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y",
    "theorem": "{Î± : Type u_1} [linear_order Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y",
    "args": "{Î± : Type u_1} [linear_order Î±] {s : set Î±}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y âˆˆ s` that is greater than `x`. A version for preorders is called `not_bdd_above_iff'`.",
    "type": "Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), x < y"
  },
  {
    "name": "matrix.inv_eq_right_inv",
    "statement": "theorem matrix.inv_eq_right_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1) : Aâ»Â¹ = B",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : A.mul B = 1)",
    "doc_string": "If matrix A is right invertible, then its inverse equals its right inverse.",
    "type": "Aâ»Â¹ = B"
  },
  {
    "name": "Compactum_to_CompHaus.ess_surj",
    "statement": "theorem Compactum_to_CompHaus.ess_surj  : category_theory.ess_surj Compactum_to_CompHaus",
    "theorem": " : category_theory.ess_surj Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is essentially surjective.",
    "type": "category_theory.ess_surj Compactum_to_CompHaus"
  },
  {
    "name": "add_subgroup.add_mem",
    "statement": "theorem add_subgroup.add_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G}",
    "doc_string": "An `add_subgroup` is closed under addition.",
    "type": "x âˆˆ H â†’ y âˆˆ H â†’ x + y âˆˆ H"
  },
  {
    "name": "con.coe_one",
    "statement": "theorem con.coe_one {M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1",
    "theorem": "{M : Type u_1} [mul_one_class M] {c : con M} : â†‘1 = 1",
    "args": "{M : Type u_1} [mul_one_class M] {c : con M}",
    "doc_string": "The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the    monoid's 1.",
    "type": "â†‘1 = 1"
  },
  {
    "name": "is_regular.subsingleton",
    "statement": "theorem is_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0)",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "type": "subsingleton R"
  },
  {
    "name": "inv_lt_one'",
    "statement": "theorem inv_lt_one' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "aâ»Â¹ < 1 â†” 1 < a"
  },
  {
    "name": "multiset.nat.antidiagonal_zero",
    "statement": "theorem multiset.nat.antidiagonal_zero  : multiset.nat.antidiagonal 0 = {(0, 0)}",
    "theorem": " : multiset.nat.antidiagonal 0 = {(0, 0)}",
    "args": "",
    "doc_string": "The antidiagonal of `0` is the list `[(0, 0)]`",
    "type": "multiset.nat.antidiagonal 0 = {(0, 0)}"
  },
  {
    "name": "well_founded.cut_expand",
    "statement": "theorem well_founded.cut_expand {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (hr : well_founded r)",
    "doc_string": "`cut_expand r` is well-founded when `r` is.",
    "type": "well_founded (relation.cut_expand r)"
  },
  {
    "name": "is_group_hom.injective_iff",
    "statement": "theorem is_group_hom.injective_iff {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1",
    "theorem": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1",
    "args": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
    "type": "function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1"
  },
  {
    "name": "int.abs_le_self_pow_two",
    "statement": "theorem int.abs_le_self_pow_two (a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2",
    "theorem": "(a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2",
    "args": "(a : â„¤)",
    "doc_string": "**Alias** of int.abs_le_self_sq`.",
    "type": "â†‘(a.nat_abs) â‰¤ a ^ 2"
  },
  {
    "name": "list.length_pos_of_one_lt_prod",
    "statement": "theorem list.length_pos_of_one_lt_prod {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod)",
    "doc_string": "A list with product greater than one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "is_mul_hom.to_is_monoid_hom",
    "statement": "theorem is_mul_hom.to_is_monoid_hom {Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f",
    "theorem": "{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f",
    "args": "{Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f)",
    "doc_string": "A map to a group preserving multiplication is a monoid homomorphism.",
    "type": "is_monoid_hom f"
  },
  {
    "name": "neg_add_lt_of_lt_add",
    "statement": "theorem neg_add_lt_of_lt_add {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a < b + c â†’ -b + a < c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`.",
    "type": "a < b + c â†’ -b + a < c"
  },
  {
    "name": "topological_space.dense_range_dense_seq",
    "statement": "theorem topological_space.dense_range_dense_seq (Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)",
    "theorem": "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : dense_range (topological_space.dense_seq Î±)",
    "args": "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±]",
    "doc_string": "The sequence `dense_seq Î±` has dense range.",
    "type": "dense_range (topological_space.dense_seq Î±)"
  },
  {
    "name": "list.length_pos_of_prod_ne_one",
    "statement": "theorem list.length_pos_of_prod_ne_one {M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod â‰  1)",
    "doc_string": "A list with product not one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "finset.ne_of_mem_slice",
    "statement": "theorem finset.ne_of_mem_slice {Î± : Type u_1} {ð’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚",
    "theorem": "{Î± : Type u_1} {ð’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚) : râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚",
    "args": "{Î± : Type u_1} {ð’œ : finset (finset Î±)} {Aâ‚ Aâ‚‚ : finset Î±} {râ‚ râ‚‚ : â„•} (hâ‚ : Aâ‚ âˆˆ ð’œ.slice râ‚) (hâ‚‚ : Aâ‚‚ âˆˆ ð’œ.slice râ‚‚)",
    "doc_string": "Elements in distinct slices must be distinct.",
    "type": "râ‚ â‰  râ‚‚ â†’ Aâ‚ â‰  Aâ‚‚"
  },
  {
    "name": "subgroup.closure_eq",
    "statement": "theorem subgroup.closure_eq {G : Type u_1} [group G] (K : subgroup G) : subgroup.closure â†‘K = K",
    "theorem": "{G : Type u_1} [group G] (K : subgroup G) : subgroup.closure â†‘K = K",
    "args": "{G : Type u_1} [group G] (K : subgroup G)",
    "doc_string": "Closure of a subgroup `K` equals `K`.",
    "type": "subgroup.closure â†‘K = K"
  },
  {
    "name": "nnreal.summable_of_le",
    "statement": "theorem nnreal.summable_of_le {Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g",
    "theorem": "{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b) : summable f â†’ summable g",
    "args": "{Î² : Type u_2} {f g : Î² â†’ nnreal} (hgf : âˆ€ (b : Î²), g b â‰¤ f b)",
    "doc_string": "Comparison test of convergence of `â„â‰¥0`-valued series.",
    "type": "summable f â†’ summable g"
  },
  {
    "name": "function.injective.inj_on",
    "statement": "theorem function.injective.inj_on {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s",
    "theorem": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±) : set.inj_on f s",
    "args": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} (h : function.injective f) (s : set Î±)",
    "doc_string": "**Alias** of set.inj_on_of_injective`.",
    "type": "set.inj_on f s"
  },
  {
    "name": "matrix.det_transpose",
    "statement": "theorem matrix.det_transpose {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "theorem": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "args": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R)",
    "doc_string": "Transposing a matrix preserves the determinant.",
    "type": "M.transpose.det = M.det"
  },
  {
    "name": "setoid.eqv_gen_mono",
    "statement": "theorem setoid.eqv_gen_mono {Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s",
    "theorem": "{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y) : eqv_gen.setoid r â‰¤ eqv_gen.setoid s",
    "args": "{Î± : Type u_1} {r s : Î± â†’ Î± â†’ Prop} (h : âˆ€ (x y : Î±), r x y â†’ s x y)",
    "doc_string": "Equivalence closure of binary relations is monotone.",
    "type": "eqv_gen.setoid r â‰¤ eqv_gen.setoid s"
  },
  {
    "name": "is_topological_fiber_bundle_fst",
    "statement": "theorem is_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The first projection in a product is a topological fiber bundle.",
    "type": "is_topological_fiber_bundle F prod.fst"
  },
  {
    "name": "module.nontrivial",
    "statement": "theorem module.nontrivial (R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M]",
    "doc_string": "A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring.",
    "type": "nontrivial R"
  },
  {
    "name": "subsemigroup.closure_le",
    "statement": "theorem subsemigroup.closure_le {M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S",
    "theorem": "{M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M} : subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S",
    "args": "{M : Type u_1} [has_mul M] {s : set M} {S : subsemigroup M}",
    "doc_string": "A subsemigroup `S` includes `closure s` if and only if it includes `s`.",
    "type": "subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S"
  },
  {
    "name": "free_group.red.step.length",
    "statement": "theorem free_group.red.step.length {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length",
    "theorem": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} : free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length",
    "args": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)}",
    "doc_string": " Predicate asserting that word `wâ‚` can be reduced to `wâ‚‚` in one step, i.e. there are words `wâ‚ƒ wâ‚„` and letter `x` such that `wâ‚ = wâ‚ƒxxâ»Â¹wâ‚„` and `wâ‚‚ = wâ‚ƒwâ‚„`",
    "type": "free_group.red.step Lâ‚ Lâ‚‚ â†’ Lâ‚‚.length + 2 = Lâ‚.length"
  },
  {
    "name": "mul_is_left_regular_iff",
    "statement": "theorem mul_is_left_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) â†” is_left_regular b",
    "args": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a)",
    "doc_string": "  An element is left-regular if and only if multiplying it on the left by a left-regular element is left-regular.",
    "type": "is_left_regular (a * b) â†” is_left_regular b"
  },
  {
    "name": "nat.gcd_eq_gcd_ab",
    "statement": "theorem nat.gcd_eq_gcd_ab (x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y",
    "theorem": "(x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y",
    "args": "(x y : â„•)",
    "doc_string": " **BÃ©zout's lemma**: given `x y : â„•`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.",
    "type": "â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y"
  },
  {
    "name": "function.surjective.comp_left",
    "statement": "theorem function.surjective.comp_left {Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)",
    "theorem": "{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g) : function.surjective (function.comp g)",
    "args": "{Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.surjective g)",
    "doc_string": "Composition by an surjective function on the left is itself surjective.",
    "type": "function.surjective (function.comp g)"
  },
  {
    "name": "is_left_regular.of_mul",
    "statement": "theorem is_left_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b))",
    "doc_string": "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular element, then `b` is left-regular.",
    "type": "is_left_regular b"
  },
  {
    "name": "nat.image_Ico_mod",
    "statement": "theorem nat.image_Ico_mod (n a : â„•) : finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a",
    "theorem": "(n a : â„•) : finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a",
    "args": "(n a : â„•)",
    "doc_string": " Note that while this lemma cannot be easily generalized to a type class, it holds for â„¤ as well. See `int.image_Ico_mod` for the â„¤ version.",
    "type": "finset.image (Î» (_x : â„•), _x % a) (finset.Ico n (n + a)) = finset.range a"
  },
  {
    "name": "inv_lt_one_iff_one_lt",
    "statement": "theorem inv_lt_one_iff_one_lt {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "aâ»Â¹ < 1 â†” 1 < a"
  },
  {
    "name": "right.add_pos_of_pos_of_nonneg",
    "statement": "theorem right.add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "left.one_lt_inv_iff",
    "statement": "theorem left.one_lt_inv_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "1 < aâ»Â¹ â†” a < 1"
  },
  {
    "name": "le_rfl",
    "statement": "theorem le_rfl {Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a",
    "theorem": "{Î± : Type u} [preorder Î±] {a : Î±} : a â‰¤ a",
    "args": "{Î± : Type u} [preorder Î±] {a : Î±}",
    "doc_string": "A version of `le_refl` where the argument is implicit",
    "type": "a â‰¤ a"
  },
  {
    "name": "add_subgroup.closure_eq",
    "statement": "theorem add_subgroup.closure_eq {G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure â†‘K = K",
    "theorem": "{G : Type u_1} [add_group G] (K : add_subgroup G) : add_subgroup.closure â†‘K = K",
    "args": "{G : Type u_1} [add_group G] (K : add_subgroup G)",
    "doc_string": "Additive closure of an additive subgroup `K` equals `K`",
    "type": "add_subgroup.closure â†‘K = K"
  },
  {
    "name": "sub_left_le_of_le_add",
    "statement": "theorem sub_left_le_of_le_add {Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c",
    "theorem": "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a â‰¤ b + c â†’ a - b â‰¤ c",
    "args": "{Î± : Type u} [add_comm_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of sub_le_iff_le_add'`.",
    "type": "a â‰¤ b + c â†’ a - b â‰¤ c"
  },
  {
    "name": "not_is_right_regular_zero",
    "statement": "theorem not_is_right_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_right_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : Â¬is_right_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not right-regular -- with typeclasses.",
    "type": "Â¬is_right_regular 0"
  },
  {
    "name": "is_group_hom.map_inv",
    "statement": "theorem is_group_hom.map_inv {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹",
    "theorem": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±) : f aâ»Â¹ = (f a)â»Â¹",
    "args": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) (a : Î±)",
    "doc_string": "A group homomorphism sends inverses to inverses.",
    "type": "f aâ»Â¹ = (f a)â»Â¹"
  },
  {
    "name": "ordinal.fp_unbounded",
    "statement": "theorem ordinal.fp_unbounded {f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "theorem": "{f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "args": "{f : ordinal â†’ ordinal} (H : ordinal.is_normal f)",
    "doc_string": " The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points.",
    "type": "set.unbounded has_lt.lt (function.fixed_points f)"
  },
  {
    "name": "chart_at_self_eq",
    "statement": "theorem chart_at_self_eq {H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {x : H}",
    "doc_string": "In the model space, chart_at is always the identity",
    "type": "charted_space.chart_at H x = local_homeomorph.refl H"
  },
  {
    "name": "is_add_left_regular_of_add_eq_zero",
    "statement": "theorem is_add_left_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0)",
    "doc_string": "An element admitting a left additive opposite is add-left-regular.",
    "type": "is_add_left_regular a"
  },
  {
    "name": "is_least.bdd_below",
    "statement": "theorem is_least.bdd_below {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s",
    "theorem": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a) : bdd_below s",
    "args": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_least s a)",
    "doc_string": "If `s` has a least element, then it is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "sub_eq_zero_of_eq",
    "statement": "theorem sub_eq_zero_of_eq {G : Type u_2} [add_group G] {a b : G} : a = b â†’ a - b = 0",
    "theorem": "{G : Type u_2} [add_group G] {a b : G} : a = b â†’ a - b = 0",
    "args": "{G : Type u_2} [add_group G] {a b : G}",
    "doc_string": "**Alias** of the reverse direction of sub_eq_zero`.",
    "type": "a = b â†’ a - b = 0"
  },
  {
    "name": "has_le.le.trans_lt'",
    "statement": "theorem has_le.le.trans_lt' {Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a < b â†’ a < c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of lt_of_le_of_lt'`.",
    "type": "b â‰¤ c â†’ a < b â†’ a < c"
  },
  {
    "name": "has_binary_products_of_terminal_and_pullbacks",
    "statement": "theorem has_binary_products_of_terminal_and_pullbacks (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "Any category with pullbacks and terminal object has binary products.",
    "type": "category_theory.limits.has_binary_products C"
  },
  {
    "name": "bdd_above.inter_of_left",
    "statement": "theorem bdd_above.inter_of_left {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t)",
    "theorem": "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t)",
    "args": "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s)",
    "doc_string": "If `s` is bounded, then so is `s âˆ© t`",
    "type": "bdd_above (s âˆ© t)"
  },
  {
    "name": "nhds_le_uniformity",
    "statement": "theorem nhds_le_uniformity {Î± : Type u_1} [uniform_space Î±] (x : Î±) : nhds (x, x) â‰¤ uniformity Î±",
    "theorem": "{Î± : Type u_1} [uniform_space Î±] (x : Î±) : nhds (x, x) â‰¤ uniformity Î±",
    "args": "{Î± : Type u_1} [uniform_space Î±] (x : Î±)",
    "doc_string": "Entourages are neighborhoods of the diagonal.",
    "type": "nhds (x, x) â‰¤ uniformity Î±"
  },
  {
    "name": "padic_val_int.one",
    "statement": "theorem padic_val_int.one {p : â„•} : padic_val_int p 1 = 0",
    "theorem": "{p : â„•} : padic_val_int p 1 = 0",
    "args": "{p : â„•}",
    "doc_string": "`padic_val_int p 1` is 0 for any `p`.",
    "type": "padic_val_int p 1 = 0"
  },
  {
    "name": "polynomial.cyclotomic_two",
    "statement": "theorem polynomial.cyclotomic_two (R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1",
    "theorem": "(R : Type u_1) [ring R] : polynomial.cyclotomic 2 R = polynomial.X + 1",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "The second cyclotomic polyomial is `X + 1`.",
    "type": "polynomial.cyclotomic 2 R = polynomial.X + 1"
  },
  {
    "name": "is_min.pred_eq",
    "statement": "theorem is_min.pred_eq {Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a",
    "theorem": "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±} : is_min a â†’ order.pred a = a",
    "args": "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a : Î±}",
    "doc_string": "**Alias** of the reverse direction of order.pred_eq_iff_is_min`.",
    "type": "is_min a â†’ order.pred a = a"
  },
  {
    "name": "free_group.reduce.sound",
    "statement": "theorem free_group.reduce.sound {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚",
    "theorem": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚",
    "args": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚)",
    "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.",
    "type": "free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚"
  },
  {
    "name": "add_subgroup.is_open_of_zero_mem_interior",
    "statement": "theorem add_subgroup.is_open_of_zero_mem_interior {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H",
    "theorem": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H) : is_open â†‘H",
    "args": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 âˆˆ interior â†‘H)",
    "doc_string": "If a subgroup of an additive topological group has `0` in its interior, then it is open.",
    "type": "is_open â†‘H"
  },
  {
    "name": "star_div",
    "statement": "theorem star_div {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "theorem": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "args": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R)",
    "doc_string": "When multiplication is commutative, `star` preserves division.",
    "type": "has_star.star (x / y) = has_star.star x / has_star.star y"
  },
  {
    "name": "is_smul_regular.zero",
    "statement": "theorem is_smul_regular.zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M]",
    "doc_string": "The element `0` is `M`-regular when `M` is trivial.",
    "type": "is_smul_regular M 0"
  },
  {
    "name": "is_trivial_topological_fiber_bundle_snd",
    "statement": "theorem is_trivial_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a trivial topological fiber bundle.",
    "type": "is_trivial_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "powers.one_mem",
    "statement": "theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "1 is in the set of natural number powers of an element of a monoid.",
    "type": "1 âˆˆ powers x"
  },
  {
    "name": "has_le.le.trans'",
    "statement": "theorem has_le.le.trans' {Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of le_trans'`.",
    "type": "b â‰¤ c â†’ a â‰¤ b â†’ a â‰¤ c"
  },
  {
    "name": "W_type.cardinal_mk_le_of_le",
    "statement": "theorem W_type.cardinal_mk_le_of_le {Î± : Type u} {Î² : Î± â†’ Type u} {Îº : cardinal} (hÎº : cardinal.sum (Î» (a : Î±), Îº ^ cardinal.mk (Î² a)) â‰¤ Îº) : cardinal.mk (W_type Î²) â‰¤ Îº",
    "theorem": "{Î± : Type u} {Î² : Î± â†’ Type u} {Îº : cardinal} (hÎº : cardinal.sum (Î» (a : Î±), Îº ^ cardinal.mk (Î² a)) â‰¤ Îº) : cardinal.mk (W_type Î²) â‰¤ Îº",
    "args": "{Î± : Type u} {Î² : Î± â†’ Type u} {Îº : cardinal} (hÎº : cardinal.sum (Î» (a : Î±), Îº ^ cardinal.mk (Î² a)) â‰¤ Îº)",
    "doc_string": "`#(W_type Î²)` is the least cardinal `Îº` such that `sum (Î» a : Î±, Îº ^ #(Î² a)) â‰¤ Îº`",
    "type": "cardinal.mk (W_type Î²) â‰¤ Îº"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_initial_object",
    "statement": "theorem category_theory.limits.has_zero_object_of_has_initial_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C]",
    "doc_string": "If there are zero morphisms, any initial object is a zero object.",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "nat.exists_infinite_primes",
    "statement": "theorem nat.exists_infinite_primes (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p",
    "theorem": "(n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p",
    "args": "(n : â„•)",
    "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`.",
    "type": "âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p"
  },
  {
    "name": "add_commute.refl",
    "statement": "theorem add_commute.refl {S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "theorem": "{S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "args": "{S : Type u_1} [has_add S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "type": "add_commute a a"
  },
  {
    "name": "range.is_submonoid",
    "statement": "theorem range.is_submonoid {M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "args": "{M : Type u_1} [monoid M] {Î³ : Type u_2} [monoid Î³] {f : M â†’ Î³} (hf : is_monoid_hom f)",
    "doc_string": "The image of a monoid hom is a submonoid of the codomain.",
    "type": "is_submonoid (set.range f)"
  },
  {
    "name": "add_le_of_le_neg_add",
    "statement": "theorem add_le_of_le_neg_add {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : b â‰¤ -a + c â†’ a + b â‰¤ c",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of le_inv_mul_iff_mul_le`.",
    "type": "b â‰¤ -a + c â†’ a + b â‰¤ c"
  },
  {
    "name": "is_smul_regular.not_zero",
    "statement": "theorem is_smul_regular.not_zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : Â¬is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M]",
    "doc_string": "The `0` element is not `M`-regular, on a non-trivial module.",
    "type": "Â¬is_smul_regular M 0"
  },
  {
    "name": "has_subset.subset.antisymm",
    "statement": "theorem has_subset.subset.antisymm {Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : a = b",
    "theorem": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : a = b",
    "args": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a)",
    "doc_string": "**Alias** of subset_antisymm`.",
    "type": "a = b"
  },
  {
    "name": "category_theory.zigzag_is_connected",
    "statement": "theorem category_theory.zigzag_is_connected {J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J",
    "theorem": "{J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚) : category_theory.is_connected J",
    "args": "{J : Type uâ‚} [category_theory.category J] [nonempty J] (h : âˆ€ (jâ‚ jâ‚‚ : J), category_theory.zigzag jâ‚ jâ‚‚)",
    "doc_string": "If any two objects in an nonempty category are related by `zigzag`, the category is connected.",
    "type": "category_theory.is_connected J"
  },
  {
    "name": "int.le_induction_down",
    "statement": "theorem int.le_induction_down {P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n",
    "theorem": "{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤) : n â‰¤ m â†’ P n",
    "args": "{P : â„¤ â†’ Prop} {m : â„¤} (h0 : P m) (h1 : âˆ€ (n : â„¤), n â‰¤ m â†’ P n â†’ P (n - 1)) (n : â„¤)",
    "doc_string": "See `int.induction_on'` for an induction in both directions.",
    "type": "n â‰¤ m â†’ P n"
  },
  {
    "name": "is_add_group_hom.mk'",
    "statement": "theorem is_add_group_hom.mk' {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y) : is_add_group_hom f",
    "theorem": "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y) : is_add_group_hom f",
    "args": "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : âˆ€ (x y : Î±), f (x + y) = f x + f y)",
    "doc_string": "Construct `is_add_group_hom` from its only hypothesis.",
    "type": "is_add_group_hom f"
  },
  {
    "name": "is_unit.is_smul_regular",
    "statement": "theorem is_unit.is_smul_regular {R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "theorem": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "args": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a)",
    "doc_string": "A unit is `M`-regular.",
    "type": "is_smul_regular M a"
  },
  {
    "name": "setoid.ker_lift_injective",
    "statement": "theorem setoid.ker_lift_injective {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²)",
    "doc_string": "Given a map f from Î± to Î², the natural map from the quotient of Î± by the kernel of f is    injective.",
    "type": "function.injective (quotient.lift f _)"
  },
  {
    "name": "tendsto_diag_uniformity",
    "statement": "theorem tendsto_diag_uniformity {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²) : filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] (f : Î² â†’ Î±) (l : filter Î²)",
    "doc_string": "Relation `Î» f g, tendsto (Î» x, (f x, g x)) l (ð“¤ Î±)` is reflexive.",
    "type": "filter.tendsto (Î» (x : Î²), (f x, f x)) l (uniformity Î±)"
  },
  {
    "name": "finset.shadow_empty",
    "statement": "theorem finset.shadow_empty {Î± : Type u_1} [decidable_eq Î±] : âˆ….shadow = âˆ…",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] : âˆ….shadow = âˆ…",
    "args": "{Î± : Type u_1} [decidable_eq Î±]",
    "doc_string": "The shadow of the empty set is empty.",
    "type": "âˆ….shadow = âˆ…"
  },
  {
    "name": "list.length_pos_of_prod_lt_one",
    "statement": "theorem list.length_pos_of_prod_lt_one {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1)",
    "doc_string": "A list with product less than one must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "is_GÎ´.union",
    "statement": "theorem is_GÎ´.union {Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)",
    "theorem": "{Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t)",
    "args": "{Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t)",
    "doc_string": "The union of two GÎ´ sets is a GÎ´ set.",
    "type": "is_GÎ´ (s âˆª t)"
  },
  {
    "name": "real.not_summable_one_div_nat_cast",
    "statement": "theorem real.not_summable_one_div_nat_cast  : Â¬summable (Î» (n : â„•), 1 / â†‘n)",
    "theorem": " : Â¬summable (Î» (n : â„•), 1 / â†‘n)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "type": "Â¬summable (Î» (n : â„•), 1 / â†‘n)"
  },
  {
    "name": "le_neg_of_le_neg",
    "statement": "theorem le_neg_of_le_neg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ -b â†’ b â‰¤ -a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of le_inv'`.",
    "type": "a â‰¤ -b â†’ b â‰¤ -a"
  },
  {
    "name": "has_le.le.eq_or_gt",
    "statement": "theorem has_le.le.eq_or_gt {Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b",
    "theorem": "{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b) : b = a âˆ¨ a < b",
    "args": "{Î± : Type u} [partial_order Î±] {a b : Î±} (h : a â‰¤ b)",
    "doc_string": "**Alias** of eq_or_gt_of_le`.",
    "type": "b = a âˆ¨ a < b"
  },
  {
    "name": "nat.set_induction",
    "statement": "theorem nat.set_induction {S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S",
    "theorem": "{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•) : n âˆˆ S",
    "args": "{S : set â„•} (hb : 0 âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) (n : â„•)",
    "doc_string": "A subset of `â„•` containing zero and closed under `nat.succ` contains all of `â„•`.",
    "type": "n âˆˆ S"
  },
  {
    "name": "le_of_neg_le_neg",
    "statement": "theorem le_of_neg_le_neg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ -b â†’ b â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of neg_le_neg_iff`.",
    "type": "-a â‰¤ -b â†’ b â‰¤ a"
  },
  {
    "name": "topological_space.opens.coe_mk",
    "statement": "theorem topological_space.opens.coe_mk {Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U",
    "theorem": "{Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U} : â†‘âŸ¨U, hUâŸ© = U",
    "args": "{Î± : Type u_1} [topological_space Î±] {U : set Î±} {hU : is_open U}",
    "doc_string": "the coercion `opens Î± â†’ set Î±` applied to a pair is the same as taking the first component",
    "type": "â†‘âŸ¨U, hUâŸ© = U"
  },
  {
    "name": "fin.coe_val_eq_self",
    "statement": "theorem fin.coe_val_eq_self {n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a",
    "theorem": "{n : â„•} (a : fin (n + 1)) : â†‘(a.val) = a",
    "args": "{n : â„•} (a : fin (n + 1))",
    "doc_string": " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results in the same value.",
    "type": "â†‘(a.val) = a"
  },
  {
    "name": "topological_fiber_bundle_core.is_open_map_proj",
    "statement": "theorem topological_fiber_bundle_core.is_open_map_proj {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj",
    "theorem": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_open_map Z.proj",
    "args": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F)",
    "doc_string": "The projection on the base of a topological bundle created from core is an open map",
    "type": "is_open_map Z.proj"
  },
  {
    "name": "is_of_fin_order.inv",
    "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order xâ»Â¹",
    "theorem": "{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order xâ»Â¹",
    "args": "{G : Type u} [group G] {x : G} (hx : is_of_fin_order x)",
    "doc_string": "Inverses of elements of finite order have finite order.",
    "type": "is_of_fin_order xâ»Â¹"
  },
  {
    "name": "lt_or_lt_iff_ne",
    "statement": "theorem lt_or_lt_iff_ne {Î± : Type u} [linear_order Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y",
    "theorem": "{Î± : Type u} [linear_order Î±] {x y : Î±} : x < y âˆ¨ y < x â†” x â‰  y",
    "args": "{Î± : Type u} [linear_order Î±] {x y : Î±}",
    "doc_string": "A version of `ne_iff_lt_or_gt` with LHS and RHS reversed.",
    "type": "x < y âˆ¨ y < x â†” x â‰  y"
  },
  {
    "name": "nat.sum_four_squares",
    "statement": "theorem nat.sum_four_squares (n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
    "theorem": "(n : â„•) : âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
    "args": "(n : â„•)",
    "doc_string": "**Four squares theorem**",
    "type": "âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"
  },
  {
    "name": "compact_space.uniform_continuous_of_continuous",
    "statement": "theorem compact_space.uniform_continuous_of_continuous {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f) : uniform_continuous f",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [compact_space Î±] [separated_space Î±] {f : Î± â†’ Î²} (h : continuous f)",
    "doc_string": " Heine-Cantor: a continuous function on a compact separated uniform space is uniformly continuous.",
    "type": "uniform_continuous f"
  },
  {
    "name": "function.injective.tendsto_cofinite",
    "statement": "theorem function.injective.tendsto_cofinite {Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite",
    "theorem": "{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite",
    "args": "{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f)",
    "doc_string": " For an injective function `f`, inverse images of finite sets are finite. See also `filter.comap_cofinite_le` and `function.injective.comap_cofinite_eq`.",
    "type": "filter.tendsto f filter.cofinite filter.cofinite"
  },
  {
    "name": "function.commute.inv_on_fixed_pts_comp",
    "statement": "theorem function.commute.inv_on_fixed_pts_comp {Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))",
    "theorem": "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))",
    "args": "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then they are inverse of each other on the set of fixed points of `f âˆ˜ g`. This is a particular case of `function.inv_on_fixed_pts_comp`.",
    "type": "set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))"
  },
  {
    "name": "is_topological_fiber_bundle.continuous_proj",
    "statement": "theorem is_topological_fiber_bundle.continuous_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj)",
    "doc_string": "The projection from a topological fiber bundle to its base is continuous.",
    "type": "continuous proj"
  },
  {
    "name": "has_binary_coproducts_of_initial_and_pushouts",
    "statement": "theorem has_binary_coproducts_of_initial_and_pushouts (C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C]",
    "doc_string": "Any category with pushouts and initial object has binary coproducts.",
    "type": "category_theory.limits.has_binary_coproducts C"
  },
  {
    "name": "modular_group.bottom_row_coprime",
    "statement": "theorem modular_group.bottom_row_coprime {R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (â†‘g 1 0) (â†‘g 1 1)",
    "theorem": "{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (â†‘g 1 0) (â†‘g 1 1)",
    "args": "{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R)",
    "doc_string": "The two numbers `c`, `d` in the \"bottom_row\" of `g=[[*,*],[c,d]]` in `SL(2, â„¤)` are coprime.",
    "type": "is_coprime (â†‘g 1 0) (â†‘g 1 1)"
  },
  {
    "name": "int.exists_strict_anti",
    "statement": "theorem int.exists_strict_anti (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_anti f",
    "theorem": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_anti f",
    "args": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±]",
    "doc_string": " If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly antitone function `f : â„¤ â†’ Î±`.",
    "type": "âˆƒ (f : â„¤ â†’ Î±), strict_anti f"
  },
  {
    "name": "subsemiring.coe_closure_eq",
    "statement": "theorem subsemiring.coe_closure_eq {R : Type u} [non_assoc_semiring R] (s : set R) : â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : set R) : â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))",
    "args": "{R : Type u} [non_assoc_semiring R] (s : set R)",
    "doc_string": " The elements of the subsemiring closure of `M` are exactly the elements of the additive closure of a multiplicative submonoid `M`.",
    "type": "â†‘(subsemiring.closure s) = â†‘(add_submonoid.closure â†‘(submonoid.closure s))"
  },
  {
    "name": "nat.digits_lt_base",
    "statement": "theorem nat.digits_lt_base {b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m) : d < b",
    "theorem": "{b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m) : d < b",
    "args": "{b m d : â„•} (hb : 2 â‰¤ b) (hd : d âˆˆ b.digits m)",
    "doc_string": "The digits in the base b expansion of n are all less than b, if b â‰¥ 2",
    "type": "d < b"
  },
  {
    "name": "category_theory.limits.has_equalizers_of_pullbacks_and_binary_products",
    "statement": "theorem category_theory.limits.has_equalizers_of_pullbacks_and_binary_products {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "Any category with pullbacks and binary products, has equalizers.",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "order.succ_lt_succ",
    "statement": "theorem order.succ_lt_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a < b â†’ order.succ a < order.succ b",
    "theorem": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a < b â†’ order.succ a < order.succ b",
    "args": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±]",
    "doc_string": "**Alias** of the reverse direction of order.succ_lt_succ_iff`.",
    "type": "a < b â†’ order.succ a < order.succ b"
  },
  {
    "name": "left.one_lt_mul",
    "statement": "theorem left.one_lt_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "real.summable_nat_pow_inv",
    "statement": "theorem real.summable_nat_pow_inv {p : â„•} : summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p",
    "theorem": "{p : â„•} : summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p",
    "args": "{p : â„•}",
    "doc_string": " Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges if and only if `1 < p`.",
    "type": "summable (Î» (n : â„•), (â†‘n ^ p)â»Â¹) â†” 1 < p"
  },
  {
    "name": "comp_add_left",
    "statement": "theorem comp_add_left {Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)",
    "theorem": "{Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)",
    "args": "{Î± : Type u_1} [add_semigroup Î±] (x y : Î±)",
    "doc_string": "Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`.",
    "type": "has_add.add x âˆ˜ has_add.add y = has_add.add (x + y)"
  },
  {
    "name": "nat.set_induction_bounded",
    "statement": "theorem nat.set_induction_bounded {b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S",
    "theorem": "{b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n) : n âˆˆ S",
    "args": "{b : â„•} {S : set â„•} (hb : b âˆˆ S) (h_ind : âˆ€ (k : â„•), k âˆˆ S â†’ k + 1 âˆˆ S) {n : â„•} (hbn : b â‰¤ n)",
    "doc_string": "A subset of `â„•` containing `b : â„•` and closed under `nat.succ` contains every `n â‰¥ b`.",
    "type": "n âˆˆ S"
  },
  {
    "name": "szemeredi_regularity.step_bound_pos",
    "statement": "theorem szemeredi_regularity.step_bound_pos {n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n",
    "theorem": "{n : â„•} : 0 < n â†’ 0 < szemeredi_regularity.step_bound n",
    "args": "{n : â„•}",
    "doc_string": "**Alias** of the reverse direction of szemeredi_regularity.step_bound_pos_iff`.",
    "type": "0 < n â†’ 0 < szemeredi_regularity.step_bound n"
  },
  {
    "name": "multiples.self_mem",
    "statement": "theorem multiples.self_mem {M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : x âˆˆ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "An element of an `add_monoid` is in the set of that element's natural number multiples.",
    "type": "x âˆˆ multiples x"
  },
  {
    "name": "complex.tendsto_exp_comap_re_at_top",
    "statement": "theorem complex.tendsto_exp_comap_re_at_top  : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "theorem": " : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "args": "",
    "doc_string": "`complex.abs (complex.exp z) â†’ âˆž` as `complex.re z â†’ âˆž`. TODO: use `bornology.cobounded`.",
    "type": "filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)"
  },
  {
    "name": "rel_embedding.coe_fn_injective",
    "statement": "theorem rel_embedding.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}",
    "doc_string": "The map `coe_fn : (r â†ªr s) â†’ (Î± â†’ Î²)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts",
    "statement": "theorem category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with finite coproducts and coequalizers has all finite colimits.  See <https://stacks.math.columbia.edu/tag/002Q>.",
    "type": "category_theory.limits.has_finite_colimits C"
  },
  {
    "name": "add_order_of_pos_iff",
    "statement": "theorem add_order_of_pos_iff {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x",
    "theorem": "{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x",
    "args": "{G : Type u} {x : G} [add_monoid G]",
    "doc_string": "A group element has finite additive order iff its order is positive.",
    "type": "0 < add_order_of x â†” is_of_fin_add_order x"
  },
  {
    "name": "has_sum_zero",
    "statement": "theorem has_sum_zero {Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±] : has_sum (Î» (b : Î²), 0) 0",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [add_comm_monoid Î±] [topological_space Î±]",
    "doc_string": "Constant zero function has sum `0`",
    "type": "has_sum (Î» (b : Î²), 0) 0"
  },
  {
    "name": "turing.list_blank.exists_cons",
    "statement": "theorem turing.list_blank.exists_cons {Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'",
    "theorem": "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'",
    "args": "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "type": "âˆƒ (a : Î“) (l' : turing.list_blank Î“), l = turing.list_blank.cons a l'"
  },
  {
    "name": "reflexive.ne_imp_iff",
    "statement": "theorem reflexive.ne_imp_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} : x â‰  y â†’ r x y â†” r x y",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±}",
    "doc_string": " If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, then it holds whether or not `x â‰  y`.",
    "type": "x â‰  y â†’ r x y â†” r x y"
  },
  {
    "name": "upper_central_series_is_ascending_central_series",
    "statement": "theorem upper_central_series_is_ascending_central_series (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "theorem": "(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The upper central series of a group is an ascending central series.",
    "type": "is_ascending_central_series (upper_central_series G)"
  },
  {
    "name": "nat.prime.mod_two_eq_one_iff_ne_two",
    "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2",
    "theorem": "{p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2",
    "args": "{p : â„•} [fact (nat.prime p)]",
    "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`.",
    "type": "p % 2 = 1 â†” p â‰  2"
  },
  {
    "name": "list.map_comp_map",
    "statement": "theorem list.map_comp_map {Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)",
    "theorem": "{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²) : list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)",
    "args": "{Î± : Type u} {Î² : Type v} {Î³ : Type w} (g : Î² â†’ Î³) (f : Î± â†’ Î²)",
    "doc_string": "Composing a `list.map` with another `list.map` is equal to a single `list.map` of composed functions.",
    "type": "list.map g âˆ˜ list.map f = list.map (g âˆ˜ f)"
  },
  {
    "name": "not_is_right_regular_zero_iff",
    "statement": "theorem not_is_right_regular_zero_iff {R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : Â¬is_right_regular 0 â†” nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not right-regular.",
    "type": "Â¬is_right_regular 0 â†” nontrivial R"
  },
  {
    "name": "finset.eq_empty_of_is_empty",
    "statement": "theorem finset.eq_empty_of_is_empty {Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…",
    "theorem": "{Î± : Type u_1} [is_empty Î±] (s : finset Î±) : s = âˆ…",
    "args": "{Î± : Type u_1} [is_empty Î±] (s : finset Î±)",
    "doc_string": "A `finset` for an empty type is empty.",
    "type": "s = âˆ…"
  },
  {
    "name": "is_lub.bdd_above",
    "statement": "theorem is_lub.bdd_above {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s",
    "theorem": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a) : bdd_above s",
    "args": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_lub s a)",
    "doc_string": "If `s` has a least upper bound, then it is bounded above.",
    "type": "bdd_above s"
  },
  {
    "name": "function.injective2.left'",
    "statement": "theorem function.injective2.left' {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f",
    "theorem": "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²] : function.injective f",
    "args": "{Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) [nonempty Î²]",
    "doc_string": "As a map from the left argument to a unary function, `f` is injective.",
    "type": "function.injective f"
  },
  {
    "name": "is_compact_interval",
    "statement": "theorem is_compact_interval {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)",
    "theorem": "{Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b)",
    "args": "{Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±}",
    "doc_string": "An unordered closed interval is compact.",
    "type": "is_compact (set.interval a b)"
  },
  {
    "name": "ordinal.principal_add_iff_zero_or_omega_opow",
    "statement": "theorem ordinal.principal_add_iff_zero_or_omega_opow {o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for additive principal ordinals.",
    "type": "ordinal.principal has_add.add o â†” o = 0 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ a"
  },
  {
    "name": "inv_lt_of_inv_lt'",
    "statement": "theorem inv_lt_of_inv_lt' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : aâ»Â¹ < b â†’ bâ»Â¹ < a",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of inv_lt'`.",
    "type": "aâ»Â¹ < b â†’ bâ»Â¹ < a"
  },
  {
    "name": "pow_two",
    "statement": "theorem pow_two {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "Note that most of the lemmas about powers of two refer to it as `sq`.",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "subsemigroup.closure_eq",
    "statement": "theorem subsemigroup.closure_eq {M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure â†‘S = S",
    "theorem": "{M : Type u_1} [has_mul M] (S : subsemigroup M) : subsemigroup.closure â†‘S = S",
    "args": "{M : Type u_1} [has_mul M] (S : subsemigroup M)",
    "doc_string": "Closure of a subsemigroup `S` equals `S`.",
    "type": "subsemigroup.closure â†‘S = S"
  },
  {
    "name": "not_is_unit_prime_of_dvd_card",
    "statement": "theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R)",
    "doc_string": " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`.",
    "type": "Â¬is_unit â†‘p"
  },
  {
    "name": "neg_nonpos",
    "statement": "theorem neg_nonpos {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†” 0 â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "type": "-a â‰¤ 0 â†” 0 â‰¤ a"
  },
  {
    "name": "nat.eq_pow_of_factorization_eq_single",
    "statement": "theorem nat.eq_pow_of_factorization_eq_single {n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "theorem": "{n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "args": "{n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k)",
    "doc_string": "If the factorization of `n` contains just one number `p` then `n` is a power of `p`",
    "type": "n = p ^ k"
  },
  {
    "name": "finset.Icc_eq_empty",
    "statement": "theorem finset.Icc_eq_empty {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…",
    "theorem": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…",
    "args": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of finset.Icc_eq_empty_iff`.",
    "type": "Â¬a â‰¤ b â†’ finset.Icc a b = âˆ…"
  },
  {
    "name": "nat.lt_wf",
    "statement": "theorem nat.lt_wf  : well_founded nat.lt",
    "theorem": " : well_founded nat.lt",
    "args": "",
    "doc_string": "less-than is well-founded",
    "type": "well_founded nat.lt"
  },
  {
    "name": "list.length_pos_of_sum_ne_zero",
    "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum â‰  0)",
    "doc_string": "A list with sum not zero must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "one_lt_mul'",
    "statement": "theorem one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "eq.subset",
    "statement": "theorem eq.subset {Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t",
    "theorem": "{Î± : Type u_1} {s t : set Î±} : s = t â†’ s âŠ† t",
    "args": "{Î± : Type u_1} {s t : set Î±}",
    "doc_string": "Duplicate of `eq.subset'`, which currently has elaboration problems.",
    "type": "s = t â†’ s âŠ† t"
  },
  {
    "name": "multiset.sub_zero",
    "statement": "theorem multiset.sub_zero {Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±) : s - 0 = s",
    "args": "{Î± : Type u_1} [decidable_eq Î±] (s : multiset Î±)",
    "doc_string": "This is a special case of `tsub_zero`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset Î±)`.",
    "type": "s - 0 = s"
  },
  {
    "name": "matrix.nonsing_inv_eq_ring_inverse",
    "statement": "theorem matrix.nonsing_inv_eq_ring_inverse {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : Aâ»Â¹ = ring.inverse A",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±)",
    "doc_string": "The nonsingular inverse is the same as the general `ring.inverse`.",
    "type": "Aâ»Â¹ = ring.inverse A"
  },
  {
    "name": "ring.inverse_non_unit",
    "statement": "theorem ring.inverse_non_unit {Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0",
    "theorem": "{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x) : ring.inverse x = 0",
    "args": "{Mâ‚€ : Type u_1} [monoid_with_zero Mâ‚€] (x : Mâ‚€) (h : Â¬is_unit x)",
    "doc_string": "By definition, if `x` is not invertible then `inverse x = 0`.",
    "type": "ring.inverse x = 0"
  },
  {
    "name": "subsingleton.convex_independent",
    "statement": "theorem subsingleton.convex_independent {ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ð•œ p",
    "theorem": "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E) : convex_independent ð•œ p",
    "args": "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] [subsingleton Î¹] (p : Î¹ â†’ E)",
    "doc_string": "A family with at most one point is convex independent.",
    "type": "convex_independent ð•œ p"
  },
  {
    "name": "is_square_of_exists_sq",
    "statement": "theorem is_square_of_exists_sq {Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m",
    "theorem": "{Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m",
    "args": "{Î± : Type u_2} [monoid Î±] (m : Î±)",
    "doc_string": "**Alias** of the reverse direction of is_square_iff_exists_sq`.",
    "type": "(âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_coproduct",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J â†’ C) [category_theory.limits.has_coproduct f]",
    "doc_string": "In a preadditive category, if the coproduct over `f : J â†’ C` exists,    then the biproduct over `f` exists.",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "inv_gold_conj",
    "statement": "theorem inv_gold_conj  : golden_conjâ»Â¹ = -golden_ratio",
    "theorem": " : golden_conjâ»Â¹ = -golden_ratio",
    "args": "",
    "doc_string": "The opposite of the golden ratio is the inverse of its conjugate.",
    "type": "golden_conjâ»Â¹ = -golden_ratio"
  },
  {
    "name": "nat.exists_strict_anti'",
    "statement": "theorem nat.exists_strict_anti' {Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a",
    "theorem": "{Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a",
    "args": "{Î± : Type u} [preorder Î±] [no_min_order Î±] (a : Î±)",
    "doc_string": " If `Î±` is a preorder with no maximal elements, then there exists a strictly antitone function `â„• â†’ Î±` with any prescribed value of `f 0`.",
    "type": "âˆƒ (f : â„• â†’ Î±), strict_anti f âˆ§ f 0 = a"
  },
  {
    "name": "neg_pos",
    "statement": "theorem neg_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†” a < 0",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "type": "0 < -a â†” a < 0"
  },
  {
    "name": "category_theory.is_subterminal.mono_is_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_is_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "theorem": "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "args": "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`.",
    "type": "category_theory.mono (hT.from A)"
  },
  {
    "name": "submonoid.list_prod_mem",
    "statement": "theorem submonoid.list_prod_mem {M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s",
    "theorem": "{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.prod âˆˆ s",
    "args": "{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s)",
    "doc_string": "Product of a list of elements in a submonoid is in the submonoid.",
    "type": "l.prod âˆˆ s"
  },
  {
    "name": "closed_under_restriction_iff_id_le",
    "statement": "theorem closed_under_restriction_iff_id_le {H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G â†” id_restr_groupoid â‰¤ G",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) : closed_under_restriction G â†” id_restr_groupoid â‰¤ G",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H)",
    "doc_string": " A groupoid is closed under restriction if and only if it contains the trivial restriction-closed groupoid.",
    "type": "closed_under_restriction G â†” id_restr_groupoid â‰¤ G"
  },
  {
    "name": "is_add_right_regular.of_add",
    "statement": "theorem is_add_right_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a))",
    "doc_string": "If an element `b` becomes add-right-regular after adding to it on the right a add-right-regular element, then `b` is add-right-regular.",
    "type": "is_add_right_regular b"
  },
  {
    "name": "topological_fiber_bundle_core.continuous_total_space_mk",
    "statement": "theorem topological_fiber_bundle_core.continuous_total_space_mk {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)",
    "theorem": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b)",
    "args": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B)",
    "doc_string": "The inclusion of a fiber into the total space is a continuous map.",
    "type": "continuous (bundle.total_space_mk b)"
  },
  {
    "name": "int.exists_strict_mono",
    "statement": "theorem int.exists_strict_mono (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f",
    "theorem": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f",
    "args": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±]",
    "doc_string": " If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : â„¤ â†’ Î±`.",
    "type": "âˆƒ (f : â„¤ â†’ Î±), strict_mono f"
  },
  {
    "name": "nonempty.map",
    "statement": "theorem nonempty.map {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²",
    "theorem": "{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) : nonempty Î± â†’ nonempty Î²",
    "args": "{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²)",
    "doc_string": "Given `f : Î± â†’ Î²`, if `Î±` is nonempty then `Î²` is also nonempty.  `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`.",
    "type": "nonempty Î± â†’ nonempty Î²"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length",
    "statement": "theorem nat.of_digits_lt_base_pow_length {b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length",
    "theorem": "{b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b) : nat.of_digits b l < b ^ l.length",
    "args": "{b : â„•} {l : list â„•} (hb : 2 â‰¤ b) (hl : âˆ€ (x : â„•), x âˆˆ l â†’ x < b)",
    "doc_string": "an n-digit number in base b is less than b^n if b â‰¥ 2",
    "type": "nat.of_digits b l < b ^ l.length"
  },
  {
    "name": "add_semiconj_by.conj_mk",
    "statement": "theorem add_semiconj_by.conj_mk {G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "theorem": "{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "args": "{G : Type u} [add_group G] (a x : G)",
    "doc_string": "`a` semiconjugates `x` to `a + x + -a`.",
    "type": "add_semiconj_by a x (a + x + -a)"
  },
  {
    "name": "rel_iso.coe_fn_injective",
    "statement": "theorem rel_iso.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}",
    "doc_string": " The map `coe_fn : (r â‰ƒr s) â†’ (Î± â†’ Î²)` is injective. Lean fails to parse `function.injective (Î» e : r â‰ƒr s, (e : Î± â†’ Î²))`, so we use a trick to say the same.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "nat_ordinal.induction",
    "statement": "theorem nat_ordinal.induction {p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j) : p i",
    "theorem": "{p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j) : p i",
    "args": "{p : nat_ordinal â†’ Prop} (i : nat_ordinal) (h : âˆ€ (j : nat_ordinal), (âˆ€ (k : nat_ordinal), k < j â†’ p k) â†’ p j)",
    "doc_string": "`ordinal.induction` but for `nat_ordinal`.",
    "type": "p i"
  },
  {
    "name": "comp_mul_right",
    "statement": "theorem comp_mul_right {Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)",
    "theorem": "{Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)",
    "args": "{Î± : Type u_1} [semigroup Î±] (x y : Î±)",
    "doc_string": "Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`.",
    "type": "((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x)"
  },
  {
    "name": "nat.partrec.code.evaln_prim",
    "statement": "theorem nat.partrec.code.evaln_prim  : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "theorem": " : primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "args": "",
    "doc_string": "The `nat.partrec.code.evaln` function is primitive recursive.",
    "type": "primrec (Î» (a : (â„• Ã— nat.partrec.code) Ã— â„•), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)"
  },
  {
    "name": "matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix",
    "statement": "theorem matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : â†‘â†‘â†‘g = â†‘g",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R)",
    "doc_string": " Coercing a `special_linear_group` via `GL_pos` and `GL` is the same as coercing striaght to a matrix.",
    "type": "â†‘â†‘â†‘g = â†‘g"
  },
  {
    "name": "right.add_pos'",
    "statement": "theorem right.add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "list.pairwise.pw_filter",
    "statement": "theorem list.pairwise.pw_filter {Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l",
    "theorem": "{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±} : list.pairwise R l â†’ list.pw_filter R l = l",
    "args": "{Î± : Type u_1} {R : Î± â†’ Î± â†’ Prop} [decidable_rel R] {l : list Î±}",
    "doc_string": "**Alias** of the reverse direction of list.pw_filter_eq_self`.",
    "type": "list.pairwise R l â†’ list.pw_filter R l = l"
  },
  {
    "name": "list.comp_map",
    "statement": "theorem list.comp_map {Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±) : list.map (h âˆ˜ g) l = list.map h (list.map g l)",
    "theorem": "{Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±) : list.map (h âˆ˜ g) l = list.map h (list.map g l)",
    "args": "{Î± : Type u} {Î² : Type v} {Î³ : Type w} (h : Î² â†’ Î³) (g : Î± â†’ Î²) (l : list Î±)",
    "doc_string": "A single `list.map` of a composition of functions is equal to composing a `list.map` with another `list.map`, fully applied. This is the reverse direction of `list.map_map`.",
    "type": "list.map (h âˆ˜ g) l = list.map h (list.map g l)"
  },
  {
    "name": "category_theory.exact_inl_snd",
    "statement": "theorem category_theory.exact_inl_snd {ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "theorem": "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "args": "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ)",
    "doc_string": "The sequence `A âŸ¶ A âŠž B âŸ¶ B` is exact.",
    "type": "category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd"
  },
  {
    "name": "finset.up_shadow_monotone",
    "statement": "theorem finset.up_shadow_monotone {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : monotone finset.up_shadow",
    "args": "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±]",
    "doc_string": "The upper shadow is monotone.",
    "type": "monotone finset.up_shadow"
  },
  {
    "name": "zero_dvd_iff",
    "statement": "theorem zero_dvd_iff {Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0",
    "theorem": "{Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±} : 0 âˆ£ a â†” a = 0",
    "args": "{Î± : Type u_1} [semigroup_with_zero Î±] {a : Î±}",
    "doc_string": "Given an element `a` of a commutative semigroup with zero, there exists another element whose    product with zero equals `a` iff `a` equals zero.",
    "type": "0 âˆ£ a â†” a = 0"
  },
  {
    "name": "lt_add_of_neg_add_lt_left",
    "statement": "theorem lt_add_of_neg_add_lt_left {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of lt_mul_of_inv_mul_lt`.",
    "type": "-b + a < c â†’ a < b + c"
  },
  {
    "name": "has_sbtw.sbtw.not_btw",
    "statement": "theorem has_sbtw.sbtw.not_btw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_btw.btw c b a",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of not_btw_of_sbtw`.",
    "type": "Â¬has_btw.btw c b a"
  },
  {
    "name": "ordered_add_comm_group.le_of_add_le_add_left",
    "statement": "theorem ordered_add_comm_group.le_of_add_le_add_left {Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c",
    "theorem": "{Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c) : b â‰¤ c",
    "args": "{Î± : Type u_1} [has_add Î±] [has_le Î±] [contravariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} (bc : a + b â‰¤ a + c)",
    "doc_string": "**Alias** of le_of_mul_le_mul_left'`.",
    "type": "b â‰¤ c"
  },
  {
    "name": "free_group.reduce.self",
    "statement": "theorem free_group.reduce.self {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "theorem": "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "args": "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±]",
    "doc_string": " A word and its maximal reduction correspond to the same element of the free group.",
    "type": "free_group.mk (free_group.reduce L) = free_group.mk L"
  },
  {
    "name": "padic_val_nat.one",
    "statement": "theorem padic_val_nat.one {p : â„•} : padic_val_nat p 1 = 0",
    "theorem": "{p : â„•} : padic_val_nat p 1 = 0",
    "args": "{p : â„•}",
    "doc_string": "`padic_val_nat p 1` is 0 for any `p`.",
    "type": "padic_val_nat p 1 = 0"
  },
  {
    "name": "subtype.prop",
    "statement": "theorem subtype.prop {Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x",
    "theorem": "{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p) : p â†‘x",
    "args": "{Î± : Sort u_1} {p : Î± â†’ Prop} (x : subtype p)",
    "doc_string": "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`  instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`.",
    "type": "p â†‘x"
  },
  {
    "name": "continuous_map.continuous_restrict",
    "statement": "theorem continuous_map.continuous_restrict {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±)",
    "doc_string": " For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a function from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies.",
    "type": "continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F)"
  },
  {
    "name": "matrix.transpose_apply",
    "statement": "theorem matrix.transpose_apply {m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j",
    "theorem": "{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n) : M.transpose j i = M i j",
    "args": "{m : Type u_2} {n : Type u_3} {Î± : Type v} (M : matrix m n Î±) (i : m) (j : n)",
    "doc_string": "Tell `simp` what the entries are in a transposed matrix.  Compare with `mul_apply`, `diagonal_apply_eq`, etc.",
    "type": "M.transpose j i = M i j"
  },
  {
    "name": "topological_add_group.continuous_conj",
    "statement": "theorem topological_add_group.continuous_conj {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (Î» (h : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G)",
    "doc_string": "Conjugation by a fixed element is continuous when `add` is continuous.",
    "type": "continuous (Î» (h : G), g + h + -g)"
  },
  {
    "name": "finprod_mem_one",
    "statement": "theorem finprod_mem_one {Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1",
    "theorem": "{Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±) : finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1",
    "args": "{Î± : Type u_1} {M : Type u_5} [comm_monoid M] (s : set Î±)",
    "doc_string": "The product of the constant function `1` over any set equals `1`.",
    "type": "finprod (Î» (i : Î±), finprod (Î» (H : i âˆˆ s), 1)) = 1"
  },
  {
    "name": "multiples.zero_mem",
    "statement": "theorem multiples.zero_mem {M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : 0 âˆˆ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "0 is in the set of natural number multiples of an element of an `add_monoid`.",
    "type": "0 âˆˆ multiples x"
  },
  {
    "name": "comp_mul_left",
    "statement": "theorem comp_mul_left {Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)",
    "theorem": "{Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)",
    "args": "{Î± : Type u_1} [semigroup Î±] (x y : Î±)",
    "doc_string": "Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`.",
    "type": "has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y)"
  },
  {
    "name": "div_div_self",
    "statement": "theorem div_div_self {Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a",
    "theorem": "{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€) : a / (a / a) = a",
    "args": "{Gâ‚€ : Type u_2} [group_with_zero Gâ‚€] (a : Gâ‚€)",
    "doc_string": " Dividing `a` by the result of dividing `a` by itself results in `a` (whether or not `a` is zero).",
    "type": "a / (a / a) = a"
  },
  {
    "name": "part.ext",
    "statement": "theorem part.ext {Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p",
    "theorem": "{Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p) : o = p",
    "args": "{Î± : Type u_1} {o p : part Î±} (H : âˆ€ (a : Î±), a âˆˆ o â†” a âˆˆ p)",
    "doc_string": "`part` extensionality",
    "type": "o = p"
  },
  {
    "name": "rel_hom.coe_fn_injective",
    "statement": "theorem rel_hom.coe_fn_injective {Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop} : function.injective coe_fn",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {r : Î± â†’ Î± â†’ Prop} {s : Î² â†’ Î² â†’ Prop}",
    "doc_string": "The map `coe_fn : (r â†’r s) â†’ (Î± â†’ Î²)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "is_add_hom.id",
    "statement": "theorem is_add_hom.id {Î± : Type u} [has_add Î±] : is_add_hom id",
    "theorem": "{Î± : Type u} [has_add Î±] : is_add_hom id",
    "args": "{Î± : Type u} [has_add Î±]",
    "doc_string": "The identity map preserves addition",
    "type": "is_add_hom id"
  },
  {
    "name": "char_prime_of_ne_zero",
    "statement": "theorem char_prime_of_ne_zero (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p",
    "args": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0)",
    "doc_string": "A helper lemma: the characteristic is prime if it is non-zero.",
    "type": "nat.prime p"
  },
  {
    "name": "has_dvd.dvd.trans",
    "statement": "theorem has_dvd.dvd.trans {Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c",
    "theorem": "{Î± : Type u_1} [semigroup Î±] {a b c : Î±} : a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c",
    "args": "{Î± : Type u_1} [semigroup Î±] {a b c : Î±}",
    "doc_string": "**Alias** of dvd_trans`.",
    "type": "a âˆ£ b â†’ b âˆ£ c â†’ a âˆ£ c"
  },
  {
    "name": "list.sorted_insertion_sort",
    "statement": "theorem list.sorted_insertion_sort {Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)",
    "theorem": "{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±) : list.sorted r (list.insertion_sort r l)",
    "args": "{Î± : Type uu} (r : Î± â†’ Î± â†’ Prop) [decidable_rel r] [is_total Î± r] [is_trans Î± r] (l : list Î±)",
    "doc_string": "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`.",
    "type": "list.sorted r (list.insertion_sort r l)"
  },
  {
    "name": "function.inv_on_fixed_pts_comp",
    "statement": "theorem function.inv_on_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))",
    "theorem": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))",
    "args": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±)",
    "doc_string": " Any two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±` are inverse of each other on the sets of fixed points of `f âˆ˜ g` and `g âˆ˜ f`, respectively.",
    "type": "set.inv_on f g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))"
  },
  {
    "name": "int.dvd_sub_of_mod_eq",
    "statement": "theorem int.dvd_sub_of_mod_eq {a b c : â„¤} (h : a % b = c) : b âˆ£ a - c",
    "theorem": "{a b c : â„¤} (h : a % b = c) : b âˆ£ a - c",
    "args": "{a b c : â„¤} (h : a % b = c)",
    "doc_string": "If `a % b = c` then `b` divides `a - c`.",
    "type": "b âˆ£ a - c"
  },
  {
    "name": "composition.sigma_eq_iff_blocks_eq",
    "statement": "theorem composition.sigma_eq_iff_blocks_eq {c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks",
    "theorem": "{c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks",
    "args": "{c c' : Î£ (n : â„•), composition n}",
    "doc_string": " Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks.",
    "type": "c = c' â†” c.snd.blocks = c'.snd.blocks"
  },
  {
    "name": "has_dvd.dvd.nat_cast",
    "statement": "theorem has_dvd.dvd.nat_cast {Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n",
    "theorem": "{Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n) : â†‘m âˆ£ â†‘n",
    "args": "{Î± : Type u_1} [semiring Î±] {m n : â„•} (h : m âˆ£ n)",
    "doc_string": "**Alias** of nat.coe_nat_dvd`.",
    "type": "â†‘m âˆ£ â†‘n"
  },
  {
    "name": "add_submonoid.add_mem",
    "statement": "theorem add_submonoid.add_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M}",
    "doc_string": "An `add_submonoid` is closed under addition.",
    "type": "x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S"
  },
  {
    "name": "is_of_fin_add_order.neg",
    "statement": "theorem is_of_fin_add_order.neg {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "theorem": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "args": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x)",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "type": "is_of_fin_add_order (-x)"
  },
  {
    "name": "submonoid.multiset_prod_mem",
    "statement": "theorem submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.prod âˆˆ S",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S)",
    "doc_string": "Product of a multiset of elements in a submonoid of a `comm_monoid` is in the submonoid.",
    "type": "m.prod âˆˆ S"
  },
  {
    "name": "is_unit_iff_not_dvd_char",
    "statement": "theorem is_unit_iff_not_dvd_char (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R",
    "theorem": "(R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R",
    "args": "(R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)]",
    "doc_string": " A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic.",
    "type": "is_unit â†‘p â†” Â¬p âˆ£ ring_char R"
  },
  {
    "name": "dense.of_closure",
    "statement": "theorem dense.of_closure {Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s",
    "theorem": "{Î± : Type u} [topological_space Î±] {s : set Î±} : dense (closure s) â†’ dense s",
    "args": "{Î± : Type u} [topological_space Î±] {s : set Î±}",
    "doc_string": "**Alias** of the forward direction of dense_closure`.",
    "type": "dense (closure s) â†’ dense s"
  },
  {
    "name": "is_locally_constant.desc",
    "statement": "theorem is_locally_constant.desc {X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f",
    "theorem": "{X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g) : is_locally_constant f",
    "args": "{X : Type u_1} [topological_space X] {Î± : Type u_2} {Î² : Type u_3} (f : X â†’ Î±) (g : Î± â†’ Î²) (h : is_locally_constant (g âˆ˜ f)) (inj : function.injective g)",
    "doc_string": " If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`.",
    "type": "is_locally_constant f"
  },
  {
    "name": "int.dvd_of_dvd_mul_right_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_right_of_gcd_one {a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c",
    "theorem": "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1) : a âˆ£ c",
    "args": "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd b = 1)",
    "doc_string": " Euclid's lemma: if `a âˆ£ b * c` and `gcd a b = 1` then `a âˆ£ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors`",
    "type": "a âˆ£ c"
  },
  {
    "name": "real.sq_sin_pi_div_three",
    "statement": "theorem real.sq_sin_pi_div_three  : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "theorem": " : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the sine of `Ï€ / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "type": "real.sin (real.pi / 3) ^ 2 = 3 / 4"
  },
  {
    "name": "quaternion_group.quaternion_group_one_is_cyclic",
    "statement": "theorem quaternion_group.quaternion_group_one_is_cyclic  : is_cyclic (quaternion_group 1)",
    "theorem": " : is_cyclic (quaternion_group 1)",
    "args": "",
    "doc_string": "In the special case `n = 1`, `quaternion 1` is a cyclic group (of order `4`).",
    "type": "is_cyclic (quaternion_group 1)"
  },
  {
    "name": "commute.mul_left",
    "statement": "theorem commute.mul_left {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c)",
    "doc_string": "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
    "type": "commute (a * b) c"
  },
  {
    "name": "left.add_pos_of_pos_of_nonneg",
    "statement": "theorem left.add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "real.cos_pi_div_six",
    "statement": "theorem real.cos_pi_div_six  : real.cos (real.pi / 6) = real.sqrt 3 / 2",
    "theorem": " : real.cos (real.pi / 6) = real.sqrt 3 / 2",
    "args": "",
    "doc_string": "The cosine of `Ï€ / 6` is `âˆš3 / 2`.",
    "type": "real.cos (real.pi / 6) = real.sqrt 3 / 2"
  },
  {
    "name": "surjective_quot_mk",
    "statement": "theorem surjective_quot_mk {Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)",
    "theorem": "{Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop) : function.surjective (quot.mk r)",
    "args": "{Î± : Sort u_1} (r : Î± â†’ Î± â†’ Prop)",
    "doc_string": "`quot.mk r` is a surjective function.",
    "type": "function.surjective (quot.mk r)"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_left",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)",
    "theorem": "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y)",
    "args": "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³)",
    "doc_string": "Left multiplication in a ring is an additive monoid morphism.",
    "type": "is_add_monoid_hom (Î» (y : Î³), x * y)"
  },
  {
    "name": "add_neg_of_nonpos_of_neg",
    "statement": "theorem add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "is_clopen.frontier_eq",
    "statement": "theorem is_clopen.frontier_eq {Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…",
    "theorem": "{Î± : Type u} [topological_space Î±] {s : set Î±} : is_clopen s â†’ frontier s = âˆ…",
    "args": "{Î± : Type u} [topological_space Î±] {s : set Î±}",
    "doc_string": "**Alias** of the forward direction of is_clopen_iff_frontier_eq_empty`.",
    "type": "is_clopen s â†’ frontier s = âˆ…"
  },
  {
    "name": "lie_algebra.is_engelian_of_is_noetherian",
    "statement": "theorem lie_algebra.is_engelian_of_is_noetherian {R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "theorem": "{R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "args": "{R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L]",
    "doc_string": " *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`.",
    "type": "lie_algebra.is_engelian R L"
  },
  {
    "name": "matrix.det_fin_one",
    "statement": "theorem matrix.det_fin_one {R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "theorem": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "args": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R)",
    "doc_string": "Determinant of 1x1 matrix",
    "type": "A.det = A 0 0"
  },
  {
    "name": "exists_open_nhds_zero_add_subset",
    "statement": "theorem exists_open_nhds_zero_add_subset {M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U âˆˆ nhds 0) : âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U",
    "theorem": "{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U âˆˆ nhds 0) : âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U",
    "args": "{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] {U : set M} (hU : U âˆˆ nhds 0)",
    "doc_string": "Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`   such that `V + V âŠ† U`.",
    "type": "âˆƒ (V : set M), is_open V âˆ§ 0 âˆˆ V âˆ§ V + V âŠ† U"
  },
  {
    "name": "real.sinh_strict_mono",
    "statement": "theorem real.sinh_strict_mono  : strict_mono real.sinh",
    "theorem": " : strict_mono real.sinh",
    "args": "",
    "doc_string": "`sinh` is strictly monotone.",
    "type": "strict_mono real.sinh"
  },
  {
    "name": "free_group.reduce.red",
    "statement": "theorem free_group.reduce.red {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)",
    "theorem": "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.red L (free_group.reduce L)",
    "args": "{Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±]",
    "doc_string": " The first theorem that characterises the function `reduce`: a word reduces to its maximal reduction.",
    "type": "free_group.red L (free_group.reduce L)"
  },
  {
    "name": "fin.coe_coe_eq_self",
    "statement": "theorem fin.coe_coe_eq_self {n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a",
    "theorem": "{n : â„•} (a : fin (n + 1)) : â†‘â†‘a = a",
    "args": "{n : â„•} (a : fin (n + 1))",
    "doc_string": " Converting a `fin (n + 1)` to `â„•` and back results in the same value.",
    "type": "â†‘â†‘a = a"
  },
  {
    "name": "reflexive.rel_of_ne_imp",
    "statement": "theorem reflexive.rel_of_ne_imp {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y) : r x y",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : reflexive r) {x y : Î±} (hr : x â‰  y â†’ r x y)",
    "doc_string": " To show a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, it suffices to show it holds when `x â‰  y`.",
    "type": "r x y"
  },
  {
    "name": "smul_zero'",
    "statement": "theorem smul_zero' {R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r â€¢ 0 = 0",
    "theorem": "{R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R) : r â€¢ 0 = 0",
    "args": "{R : Type u_1} (M : Type u_3) [has_zero R] [has_zero M] [smul_with_zero R M] (r : R)",
    "doc_string": "Note that this lemma has different typeclass assumptions to `smul_zero`.",
    "type": "r â€¢ 0 = 0"
  },
  {
    "name": "subgroup.div_mem",
    "statement": "theorem subgroup.div_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x / y âˆˆ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H)",
    "doc_string": "A subgroup is closed under division.",
    "type": "x / y âˆˆ H"
  },
  {
    "name": "gold_irrational",
    "statement": "theorem gold_irrational  : irrational golden_ratio",
    "theorem": " : irrational golden_ratio",
    "args": "",
    "doc_string": "The golden ratio is irrational.",
    "type": "irrational golden_ratio"
  },
  {
    "name": "eq.trans_lt",
    "statement": "theorem eq.trans_lt {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c) : a < c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a = b) (hbc : b < c)",
    "doc_string": "**Alias** of lt_of_eq_of_lt`.",
    "type": "a < c"
  },
  {
    "name": "list.length_le_sum_of_one_le",
    "statement": "theorem list.length_le_sum_of_one_le (L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum",
    "theorem": "(L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i) : L.length â‰¤ L.sum",
    "args": "(L : list â„•) (h : âˆ€ (i : â„•), i âˆˆ L â†’ 1 â‰¤ i)",
    "doc_string": " If all elements in a list are bounded below by `1`, then the length of the list is bounded by the sum of the elements.",
    "type": "L.length â‰¤ L.sum"
  },
  {
    "name": "le_inv_of_le_inv",
    "statement": "theorem le_inv_of_le_inv {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of le_inv'`.",
    "type": "a â‰¤ bâ»Â¹ â†’ b â‰¤ aâ»Â¹"
  },
  {
    "name": "is_add_group_hom.neg",
    "statement": "theorem is_add_group_hom.neg {Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_group_hom (Î» (a : Î±), -f a)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [add_group Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f)",
    "doc_string": "The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative.",
    "type": "is_add_group_hom (Î» (a : Î±), -f a)"
  },
  {
    "name": "left.one_le_mul",
    "statement": "theorem left.one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_le_mul`.",
    "type": "1 â‰¤ a * b"
  },
  {
    "name": "has_btw.btw.not_sbtw",
    "statement": "theorem has_btw.btw.not_sbtw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : Â¬has_sbtw.sbtw c b a",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of not_sbtw_of_btw`.",
    "type": "Â¬has_sbtw.sbtw c b a"
  },
  {
    "name": "left.add_pos'",
    "statement": "theorem left.add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C]",
    "doc_string": "Finite wide pushouts are finite colimits, so if `C` has all finite colimits, it also has finite wide pushouts",
    "type": "category_theory.limits.has_finite_wide_pushouts C"
  },
  {
    "name": "add_subsemigroup.add_mem",
    "statement": "theorem add_subsemigroup.add_mem {M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S",
    "theorem": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S",
    "args": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M}",
    "doc_string": "An `add_subsemigroup` is closed under addition.",
    "type": "x âˆˆ S â†’ y âˆˆ S â†’ x + y âˆˆ S"
  },
  {
    "name": "int.le_self_pow_two",
    "statement": "theorem int.le_self_pow_two (b : â„¤) : b â‰¤ b ^ 2",
    "theorem": "(b : â„¤) : b â‰¤ b ^ 2",
    "args": "(b : â„¤)",
    "doc_string": "**Alias** of int.le_self_sq`.",
    "type": "b â‰¤ b ^ 2"
  },
  {
    "name": "category_theory.limits.initial_mono_class_of_disjoint_coproducts",
    "statement": "theorem category_theory.limits.initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C]",
    "doc_string": " If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in general that `C` has strict initial objects, for instance consider the category of types and partial functions.",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "category_theory.preadditive.has_coequalizers_of_has_cokernels",
    "statement": "theorem category_theory.preadditive.has_coequalizers_of_has_cokernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C]",
    "doc_string": "If a preadditive category has all cokernels, then it also has all coequalizers.",
    "type": "category_theory.limits.has_coequalizers C"
  },
  {
    "name": "order_top.bdd_above",
    "statement": "theorem order_top.bdd_above {Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s",
    "theorem": "{Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s",
    "args": "{Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³)",
    "doc_string": "When there is a global maximum, every set is bounded above.",
    "type": "bdd_above s"
  },
  {
    "name": "one_le_mul",
    "statement": "theorem one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b)",
    "doc_string": "**Alias** of left.one_le_mul`.",
    "type": "1 â‰¤ a * b"
  },
  {
    "name": "subgroup.ext",
    "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K",
    "theorem": "{G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K",
    "args": "{G : Type u_1} [group G] {H K : subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K)",
    "doc_string": "Two subgroups are equal if they have the same elements.",
    "type": "H = K"
  },
  {
    "name": "has_lt.lt.ne",
    "statement": "theorem has_lt.lt.ne {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : a â‰  b",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b)",
    "doc_string": "**Alias** of ne_of_lt`.",
    "type": "a â‰  b"
  },
  {
    "name": "cardinal.bdd_above_range",
    "statement": "theorem cardinal.bdd_above_range {Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)",
    "theorem": "{Î¹ : Type u} (f : Î¹ â†’ cardinal) : bdd_above (set.range f)",
    "args": "{Î¹ : Type u} (f : Î¹ â†’ cardinal)",
    "doc_string": "The range of an indexed cardinal function, whose outputs live in a higher universe than the    inputs, is always bounded above.",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "add_semiconj_by.eq",
    "statement": "theorem add_semiconj_by.eq {S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "theorem": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "args": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y)",
    "doc_string": "Equality behind `add_semiconj_by a x y`; useful for rewriting.",
    "type": "a + x = y + a"
  },
  {
    "name": "real.real_sqrt_le_nat_sqrt_succ",
    "statement": "theorem real.real_sqrt_le_nat_sqrt_succ {a : â„•} : real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1",
    "theorem": "{a : â„•} : real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1",
    "args": "{a : â„•}",
    "doc_string": "The real square root is at most the natural square root plus one",
    "type": "real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1"
  },
  {
    "name": "is_open_map_quotient_mk_mul",
    "statement": "theorem is_open_map_quotient_mk_mul {Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk",
    "theorem": "{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T] : is_open_map quotient.mk",
    "args": "{Î“ : Type u_4} [group Î“] {T : Type u_5} [topological_space T] [mul_action Î“ T] [has_continuous_const_smul Î“ T]",
    "doc_string": "The quotient map by a group action is open.",
    "type": "is_open_map quotient.mk"
  },
  {
    "name": "pythagorean_triple.mul_iff",
    "statement": "theorem pythagorean_triple.mul_iff {x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z",
    "theorem": "{x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z",
    "args": "{x y z : â„¤} (k : â„¤) (hk : k â‰  0)",
    "doc_string": " `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple.",
    "type": "pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z"
  },
  {
    "name": "fin.coe_val_of_lt",
    "statement": "theorem fin.coe_val_of_lt {n a : â„•} (h : a < n + 1) : â†‘a.val = a",
    "theorem": "{n a : â„•} (h : a < n + 1) : â†‘a.val = a",
    "args": "{n a : â„•} (h : a < n + 1)",
    "doc_string": " Converting an in-range number to `fin (n + 1)` produces a result whose value is the original number.",
    "type": "â†‘a.val = a"
  },
  {
    "name": "cardinal.ord_aleph_eq_enum_card",
    "statement": "theorem cardinal.ord_aleph_eq_enum_card  : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}",
    "theorem": " : cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}",
    "args": "",
    "doc_string": "`ord âˆ˜ aleph` enumerates the infinite ordinals that are cardinals.",
    "type": "cardinal.ord âˆ˜ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b âˆ§ ordinal.omega â‰¤ b}"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_coproducts",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C]",
    "doc_string": "A preadditive category with finite coproducts has finite biproducts.",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "nnreal.tendsto_tsum_compl_at_top_zero",
    "statement": "theorem nnreal.tendsto_tsum_compl_at_top_zero {Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)",
    "theorem": "{Î± : Type u_1} (f : Î± â†’ nnreal) : filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)",
    "args": "{Î± : Type u_1} (f : Î± â†’ nnreal)",
    "doc_string": " The sum over the complement of a finset tends to `0` when the finset grows to cover the whole space. This does not need a summability assumption, as otherwise all sums are zero.",
    "type": "filter.tendsto (Î» (s : finset Î±), âˆ‘' (b : {x // x âˆ‰ s}), f â†‘b) filter.at_top (nhds 0)"
  },
  {
    "name": "zmod.int_cast_zmod_cast",
    "statement": "theorem zmod.int_cast_zmod_cast {n : â„•} (a : zmod n) : â†‘â†‘a = a",
    "theorem": "{n : â„•} (a : zmod n) : â†‘â†‘a = a",
    "args": "{n : â„•} (a : zmod n)",
    "doc_string": " So-named because the outer coercion is `int.cast` into `zmod`. For `int.cast` into an arbitrary ring, see `zmod.int_cast_cast`.",
    "type": "â†‘â†‘a = a"
  },
  {
    "name": "is_regular.ne_zero",
    "statement": "theorem is_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a â‰  0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a)",
    "doc_string": "A regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "type": "a â‰  0"
  },
  {
    "name": "topological_add_group.continuous_conj'",
    "statement": "theorem topological_add_group.continuous_conj' {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (Î» (g : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G)",
    "doc_string": "Conjugation acting on fixed element of the additive group is continuous when both   `add` and `neg` are continuous.",
    "type": "continuous (Î» (g : G), g + h + -g)"
  },
  {
    "name": "is_open_map_fst",
    "statement": "theorem is_open_map_fst {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst",
    "theorem": "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst",
    "args": "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²]",
    "doc_string": "The first projection in a product of topological spaces sends open sets to open sets.",
    "type": "is_open_map prod.fst"
  },
  {
    "name": "category_theory.preadditive.has_equalizers_of_has_kernels",
    "statement": "theorem category_theory.preadditive.has_equalizers_of_has_kernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C]",
    "doc_string": "If a preadditive category has all kernels, then it also has all equalizers.",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "is_regular_of_cancel_monoid",
    "statement": "theorem is_regular_of_cancel_monoid {R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "theorem": "{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "args": "{R : Type u_1} [cancel_monoid R] (g : R)",
    "doc_string": "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist.",
    "type": "is_regular g"
  },
  {
    "name": "is_add_monoid_hom.neg",
    "statement": "theorem is_add_monoid_hom.neg {Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f) : is_add_monoid_hom (Î» (a : Î±), -f a)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [add_zero_class Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_monoid_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "type": "is_add_monoid_hom (Î» (a : Î±), -f a)"
  },
  {
    "name": "dense_inducing.separable_space",
    "statement": "theorem dense_inducing.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±] : topological_space.separable_space Î²",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {i : Î± â†’ Î²} (di : dense_inducing i) [topological_space.separable_space Î±]",
    "doc_string": "If the domain of a `dense_inducing` map is a separable space, then so is the codomain.",
    "type": "topological_space.separable_space Î²"
  },
  {
    "name": "funext",
    "statement": "theorem funext {Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚",
    "theorem": "{Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x) : fâ‚ = fâ‚‚",
    "args": "{Î± : Sort u} {Î² : Î± â†’ Sort v} {fâ‚ fâ‚‚ : Î  (x : Î±), Î² x} (h : âˆ€ (x : Î±), fâ‚ x = fâ‚‚ x)",
    "doc_string": "Function extensionality, proven using quotients.",
    "type": "fâ‚ = fâ‚‚"
  },
  {
    "name": "zmod.legendre_sym_eq_pow",
    "statement": "theorem zmod.legendre_sym_eq_pow (p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)",
    "theorem": "(p : â„•) (a : â„¤) [hp : fact (nat.prime p)] : â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)",
    "args": "(p : â„•) (a : â„¤) [hp : fact (nat.prime p)]",
    "doc_string": "We have the congruence `legendre_sym p a â‰¡ a ^ (p / 2) mod p`.",
    "type": "â†‘(zmod.legendre_sym p a) = â†‘a ^ (p / 2)"
  },
  {
    "name": "right.one_lt_mul_of_lt_of_le",
    "statement": "theorem right.one_lt_mul_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "neg_le_self",
    "statement": "theorem neg_le_self {Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a) : -a â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} (h : 0 â‰¤ a)",
    "doc_string": "**Alias** of left.neg_le_self`.",
    "type": "-a â‰¤ a"
  },
  {
    "name": "padic_val_nat.zero",
    "statement": "theorem padic_val_nat.zero {p : â„•} : padic_val_nat p 0 = 0",
    "theorem": "{p : â„•} : padic_val_nat p 0 = 0",
    "args": "{p : â„•}",
    "doc_string": "`padic_val_nat p 0` is 0 for any `p`.",
    "type": "padic_val_nat p 0 = 0"
  },
  {
    "name": "subgroup.subset_closure",
    "statement": "theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k âŠ† â†‘(subgroup.closure k)",
    "theorem": "{G : Type u_1} [group G] {k : set G} : k âŠ† â†‘(subgroup.closure k)",
    "args": "{G : Type u_1} [group G] {k : set G}",
    "doc_string": "The subgroup generated by a set includes the set.",
    "type": "k âŠ† â†‘(subgroup.closure k)"
  },
  {
    "name": "category_theory.exact_inr_fst",
    "statement": "theorem category_theory.exact_inr_fst {ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "theorem": "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "args": "{ð’œ : Type u_1} [category_theory.category ð’œ] [category_theory.preadditive ð’œ] [category_theory.limits.has_kernels ð’œ] [category_theory.limits.has_images ð’œ] [category_theory.limits.has_binary_biproducts ð’œ] (A B : ð’œ)",
    "doc_string": "The sequence `B âŸ¶ A âŠž B âŸ¶ A` is exact.",
    "type": "category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst"
  },
  {
    "name": "eq.subset'",
    "statement": "theorem eq.subset' {Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ a âŠ† b",
    "theorem": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ a âŠ† b",
    "args": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset]",
    "doc_string": "**Alias** of subset_of_eq`.",
    "type": "a = b â†’ a âŠ† b"
  },
  {
    "name": "module.subsingleton",
    "statement": "theorem module.subsingleton (R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M]",
    "doc_string": " A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this as an instance because Lean has no way to guess `R`.",
    "type": "subsingleton M"
  },
  {
    "name": "has_lt.lt.not_lt",
    "statement": "theorem has_lt.lt.not_lt {Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b) : Â¬b < a",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "type": "Â¬b < a"
  },
  {
    "name": "polynomial.cyclotomic_ne_zero",
    "statement": "theorem polynomial.cyclotomic_ne_zero (n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0",
    "theorem": "(n : â„•) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R â‰  0",
    "args": "(n : â„•) (R : Type u_1) [ring R] [nontrivial R]",
    "doc_string": "`cyclotomic n R` is different from `0`.",
    "type": "polynomial.cyclotomic n R â‰  0"
  },
  {
    "name": "neg_neg_iff_pos",
    "statement": "theorem neg_neg_iff_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "-a < 0 â†” 0 < a"
  },
  {
    "name": "is_add_left_regular.of_add",
    "statement": "theorem is_add_left_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b))",
    "doc_string": "If an element `b` becomes add-left-regular after adding to it on the left a add-left-regular element, then `b` is add-left-regular.",
    "type": "is_add_left_regular b"
  },
  {
    "name": "nat.exists_strict_anti",
    "statement": "theorem nat.exists_strict_anti (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f",
    "theorem": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_anti f",
    "args": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±]",
    "doc_string": " If `Î±` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `â„• â†’ Î±`.",
    "type": "âˆƒ (f : â„• â†’ Î±), strict_anti f"
  },
  {
    "name": "free_group.red.church_rosser",
    "statement": "theorem free_group.red.church_rosser {Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ",
    "theorem": "{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)} : free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ",
    "args": "{Î± : Type u} {Lâ‚ Lâ‚‚ Lâ‚ƒ : list (Î± Ã— bool)}",
    "doc_string": " **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4` respectively. This is also known as Newman's diamond lemma.",
    "type": "free_group.red Lâ‚ Lâ‚‚ â†’ free_group.red Lâ‚ Lâ‚ƒ â†’ relation.join free_group.red Lâ‚‚ Lâ‚ƒ"
  },
  {
    "name": "is_left_regular.mul",
    "statement": "theorem is_left_regular.mul {R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b)",
    "doc_string": "In a semigroup, the product of left-regular elements is left-regular.",
    "type": "is_left_regular (a * b)"
  },
  {
    "name": "affine_subspace.top_coe",
    "statement": "theorem affine_subspace.top_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : â†‘âŠ¤ = set.univ",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": "`âŠ¤`, coerced to a set, is the whole set of points.",
    "type": "â†‘âŠ¤ = set.univ"
  },
  {
    "name": "is_left_regular_of_left_cancel_semigroup",
    "statement": "theorem is_left_regular_of_left_cancel_semigroup {R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "theorem": "{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "args": "{R : Type u_1} [left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a left cancel semigroup are left regular.",
    "type": "is_left_regular g"
  },
  {
    "name": "is_topological_fiber_bundle.is_open_map_proj",
    "statement": "theorem is_topological_fiber_bundle.is_open_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] (h : is_topological_fiber_bundle F proj)",
    "doc_string": "The projection from a topological fiber bundle to its base is an open map.",
    "type": "is_open_map proj"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_products",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C]",
    "doc_string": "In a preadditive category, if all binary products exist, then all binary biproducts exist.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "add_neg'",
    "statement": "theorem add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "charted_space_self_atlas",
    "statement": "theorem charted_space_self_atlas {H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H}",
    "doc_string": " In the trivial charted_space structure of a space modelled over itself through the identity, the atlas members are just the identity",
    "type": "e âˆˆ charted_space.atlas H H â†” e = local_homeomorph.refl H"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C]",
    "doc_string": "Finite wide pullbacks are finite limits, so if `C` has all finite limits, it also has finite wide pullbacks",
    "type": "category_theory.limits.has_finite_wide_pullbacks C"
  },
  {
    "name": "finset.nat.mem_antidiagonal",
    "statement": "theorem finset.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n",
    "theorem": "{n : â„•} {x : â„• Ã— â„•} : x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n",
    "args": "{n : â„•} {x : â„• Ã— â„•}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "type": "x âˆˆ finset.nat.antidiagonal n â†” x.fst + x.snd = n"
  },
  {
    "name": "is_regular_iff_subsingleton",
    "statement": "theorem is_regular_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_regular 0 â†” subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "type": "is_regular 0 â†” subsingleton R"
  },
  {
    "name": "category_theory.limits.has_finite_products_of_has_products",
    "statement": "theorem category_theory.limits.has_finite_products_of_has_products (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C]",
    "doc_string": "If a category has all products then in particular it has finite products.",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "dense_range.separable_space",
    "statement": "theorem dense_range.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f) : topological_space.separable_space Î²",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space.separable_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (h : dense_range f) (h' : continuous f)",
    "doc_string": " If `Î±` is a separable space and `f : Î± â†’ Î²` is a continuous map with dense range, then `Î²` is a separable space as well. E.g., the completion of a separable uniform space is separable.",
    "type": "topological_space.separable_space Î²"
  },
  {
    "name": "topological_add_group.continuous_conj_sum",
    "statement": "theorem topological_add_group.continuous_conj_sum {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G]",
    "doc_string": "Conjugation is jointly continuous on `G Ã— G` when both `mul` and `inv` are continuous.",
    "type": "continuous (Î» (g : G Ã— G), g.fst + g.snd + -g.fst)"
  },
  {
    "name": "apply_ite",
    "statement": "theorem apply_ite {Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±) : f (ite P a b) = ite P (f a) (f b)",
    "theorem": "{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±) : f (ite P a b) = ite P (f a) (f b)",
    "args": "{Î± : Sort u_1} {Î² : Sort u_2} (f : Î± â†’ Î²) (P : Prop) [decidable P] (a b : Î±)",
    "doc_string": "A function applied to a `ite` is a `ite` of that function applied to each of the branches.",
    "type": "f (ite P a b) = ite P (f a) (f b)"
  },
  {
    "name": "padic_norm.padic_norm_p",
    "statement": "theorem padic_norm.padic_norm_p {p : â„•} (hp : 1 < p) : padic_norm p â†‘p = 1 / â†‘p",
    "theorem": "{p : â„•} (hp : 1 < p) : padic_norm p â†‘p = 1 / â†‘p",
    "args": "{p : â„•} (hp : 1 < p)",
    "doc_string": "The p-adic norm of `p` is `1/p` if `p > 1`.  See also `padic_norm.padic_norm_p_of_prime` for a version that assumes `p` is prime.",
    "type": "padic_norm p â†‘p = 1 / â†‘p"
  },
  {
    "name": "add_commute.symm",
    "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "theorem": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "args": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "type": "add_commute b a"
  },
  {
    "name": "dense_range_pure",
    "statement": "theorem dense_range_pure {Î± : Type u} : dense_range has_pure.pure",
    "theorem": "{Î± : Type u} : dense_range has_pure.pure",
    "args": "{Î± : Type u}",
    "doc_string": "The range of `pure : Î± â†’ ultrafilter Î±` is dense in `ultrafilter Î±`.",
    "type": "dense_range has_pure.pure"
  },
  {
    "name": "nat.sum_two_pow_lt",
    "statement": "theorem nat.sum_two_pow_lt {k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (has_pow.pow 2) < 2 ^ k",
    "theorem": "{k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k) : A.sum (has_pow.pow 2) < 2 ^ k",
    "args": "{k : â„•} {A : finset â„•} (hâ‚ : âˆ€ {x : â„•}, x âˆˆ A â†’ x < k)",
    "doc_string": "If everything in `A` is less than `k`, we can bound the sum of powers.",
    "type": "A.sum (has_pow.pow 2) < 2 ^ k"
  },
  {
    "name": "has_sbtw.sbtw.not_sbtw",
    "statement": "theorem has_sbtw.sbtw.not_sbtw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : Â¬has_sbtw.sbtw c b a",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_asymm`.",
    "type": "Â¬has_sbtw.sbtw c b a"
  },
  {
    "name": "nat.factorization_eq_zero_iff",
    "statement": "theorem nat.factorization_eq_zero_iff (n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1",
    "theorem": "(n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1",
    "args": "(n : â„•)",
    "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
    "type": "n.factorization = 0 â†” n = 0 âˆ¨ n = 1"
  },
  {
    "name": "order.succ_ne_succ",
    "statement": "theorem order.succ_ne_succ {Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b",
    "theorem": "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : a â‰  b â†’ order.succ a â‰  order.succ b",
    "args": "{Î± : Type u_1} [partial_order Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±]",
    "doc_string": "**Alias** of the reverse direction of order.succ_ne_succ_iff`.",
    "type": "a â‰  b â†’ order.succ a â‰  order.succ b"
  },
  {
    "name": "tsub_tsub_le",
    "statement": "theorem tsub_tsub_le {Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a",
    "theorem": "{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : b - (b - a) â‰¤ a",
    "args": "{Î± : Type u_1} [preorder Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±}",
    "doc_string": "See `tsub_tsub_cancel_of_le` for the equality.",
    "type": "b - (b - a) â‰¤ a"
  },
  {
    "name": "sigma.subtype_ext",
    "statement": "theorem sigma.subtype_ext {Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£ (a : Î±), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of sigma types over an indexed subtype.",
    "type": "xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚"
  },
  {
    "name": "bornology.is_bounded.bounded_space_subtype",
    "statement": "theorem bornology.is_bounded.bounded_space_subtype {Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)",
    "theorem": "{Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop} : bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)",
    "args": "{Î± : Type u_1} [bornology Î±] {p : Î± â†’ Prop}",
    "doc_string": "**Alias** of the reverse direction of bounded_space_subtype_iff`.",
    "type": "bornology.is_bounded {x : Î± | p x} â†’ bounded_space (subtype p)"
  },
  {
    "name": "zero_ne_one_or_forall_eq_0",
    "statement": "theorem zero_ne_one_or_forall_eq_0 {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€]",
    "doc_string": "In a monoid with zero, either zero and one are nonequal, or zero is the only element.",
    "type": "0 â‰  1 âˆ¨ âˆ€ (a : Mâ‚€), a = 0"
  },
  {
    "name": "dense_embedding.separable_space",
    "statement": "theorem dense_embedding.separable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±] : topological_space.separable_space Î²",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {e : Î± â†’ Î²} (de : dense_embedding e) [topological_space.separable_space Î±]",
    "doc_string": "If the domain of a `dense_embedding` is a separable space, then so is its codomain.",
    "type": "topological_space.separable_space Î²"
  },
  {
    "name": "nat.cast_desc_factorial_two",
    "statement": "theorem nat.cast_desc_factorial_two (S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)",
    "theorem": "(S : Type u_1) [ring S] (a : â„•) : â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)",
    "args": "(S : Type u_1) [ring S] (a : â„•)",
    "doc_string": " Convenience lemma. The `a - 1` is not using truncated substraction, as opposed to the definition of `nat.desc_factorial` as a natural.",
    "type": "â†‘(a.desc_factorial 2) = â†‘a * (â†‘a - 1)"
  },
  {
    "name": "has_sbtw.sbtw.trans_right",
    "statement": "theorem has_sbtw.sbtw.trans_right {Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c d : Î±} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d)",
    "doc_string": "**Alias** of sbtw_trans_right`.",
    "type": "has_sbtw.sbtw a b d"
  },
  {
    "name": "function.is_periodic_id",
    "statement": "theorem function.is_periodic_id {Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x",
    "theorem": "{Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x",
    "args": "{Î± : Type u_1} (n : â„•) (x : Î±)",
    "doc_string": "For the identity map, all points are periodic.",
    "type": "function.is_periodic_pt id n x"
  },
  {
    "name": "right.add_neg",
    "statement": "theorem right.add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "add_submonoid.multiset_sum_mem",
    "statement": "theorem add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S) : m.sum âˆˆ S",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ S)",
    "doc_string": "Sum of a multiset of elements in an `add_submonoid` of an `add_comm_monoid` is in the `add_submonoid`.",
    "type": "m.sum âˆˆ S"
  },
  {
    "name": "gold_conj_irrational",
    "statement": "theorem gold_conj_irrational  : irrational golden_conj",
    "theorem": " : irrational golden_conj",
    "args": "",
    "doc_string": "The conjugate of the golden ratio is irrational.",
    "type": "irrational golden_conj"
  },
  {
    "name": "finsupp.lt_wf",
    "statement": "theorem finsupp.lt_wf (Î¹ : Type u_3) : well_founded has_lt.lt",
    "theorem": "(Î¹ : Type u_3) : well_founded has_lt.lt",
    "args": "(Î¹ : Type u_3)",
    "doc_string": "The order on `Î¹ â†’â‚€ â„•` is well-founded.",
    "type": "well_founded has_lt.lt"
  },
  {
    "name": "antisymm_rel.eq",
    "statement": "theorem antisymm_rel.eq {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±} : antisymm_rel r a b â†’ a = b",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] [is_antisymm Î± r] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of antisymm_rel_iff_eq`.",
    "type": "antisymm_rel r a b â†’ a = b"
  },
  {
    "name": "fin.coe_fin_le",
    "statement": "theorem fin.coe_fin_le {n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b",
    "theorem": "{n : â„•} {a b : fin n} : â†‘a â‰¤ â†‘b â†” a â‰¤ b",
    "args": "{n : â„•} {a b : fin n}",
    "doc_string": "`a â‰¤ b` as natural numbers if and only if `a â‰¤ b` in `fin n`.",
    "type": "â†‘a â‰¤ â†‘b â†” a â‰¤ b"
  },
  {
    "name": "pred_lt_pred",
    "statement": "theorem pred_lt_pred {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b",
    "theorem": "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a < b â†’ order.pred a < order.pred b",
    "args": "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±]",
    "doc_string": "**Alias** of the reverse direction of order.pred_lt_pred_iff`.",
    "type": "a < b â†’ order.pred a < order.pred b"
  },
  {
    "name": "is_of_fin_order_zero",
    "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "args": "{G : Type u} [add_monoid G]",
    "doc_string": "0 is of finite order in any additive monoid.",
    "type": "is_of_fin_add_order 0"
  },
  {
    "name": "is_add_left_regular.add",
    "statement": "theorem is_add_left_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-left-regular elements is add-left.regular.",
    "type": "is_add_left_regular (a + b)"
  },
  {
    "name": "ordinal.induction",
    "statement": "theorem ordinal.induction {p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i",
    "theorem": "{p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j) : p i",
    "args": "{p : ordinal â†’ Prop} (i : ordinal) (h : âˆ€ (j : ordinal), (âˆ€ (k : ordinal), k < j â†’ p k) â†’ p j)",
    "doc_string": " Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`.",
    "type": "p i"
  },
  {
    "name": "real.sinh_injective",
    "statement": "theorem real.sinh_injective  : function.injective real.sinh",
    "theorem": " : function.injective real.sinh",
    "args": "",
    "doc_string": "`sinh` is injective, `âˆ€ a b, sinh a = sinh b â†’ a = b`.",
    "type": "function.injective real.sinh"
  },
  {
    "name": "right.neg_pos_iff",
    "statement": "theorem right.neg_pos_iff {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : 0 < -a â†” a < 0",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "0 < -a â†” a < 0"
  },
  {
    "name": "surjective_quotient_mk",
    "statement": "theorem surjective_quotient_mk (Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk",
    "theorem": "(Î± : Sort u_1) [s : setoid Î±] : function.surjective quotient.mk",
    "args": "(Î± : Sort u_1) [s : setoid Î±]",
    "doc_string": "`quotient.mk` is a surjective function.",
    "type": "function.surjective quotient.mk"
  },
  {
    "name": "commute.refl",
    "statement": "theorem commute.refl {S : Type u_1} [has_mul S] (a : S) : commute a a",
    "theorem": "{S : Type u_1} [has_mul S] (a : S) : commute a a",
    "args": "{S : Type u_1} [has_mul S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "type": "commute a a"
  },
  {
    "name": "right.neg_neg_iff",
    "statement": "theorem right.neg_neg_iff {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a : Î±}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "-a < 0 â†” 0 < a"
  },
  {
    "name": "add_neg_of_neg_of_nonpos",
    "statement": "theorem add_neg_of_neg_of_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0)",
    "doc_string": "**Alias** of `left.add_neg_of_neg_of_nonpos`.",
    "type": "a + b < 0"
  },
  {
    "name": "one_lt_mul''",
    "statement": "theorem one_lt_mul'' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "one_lt_mul_of_lt_of_le'",
    "statement": "theorem one_lt_mul_of_lt_of_le' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "left.add_neg",
    "statement": "theorem left.add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "is_add_left_regular_of_left_cancel_add_semigroup",
    "statement": "theorem is_add_left_regular_of_left_cancel_add_semigroup {R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "theorem": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "args": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add left cancel semigroup are add-left-regular.",
    "type": "is_add_left_regular g"
  },
  {
    "name": "set.interval_subset_interval_union_interval",
    "statement": "theorem set.interval_subset_interval_union_interval {Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c",
    "theorem": "{Î± : Type u} [linear_order Î±] {a b c : Î±} : set.interval a c âŠ† set.interval a b âˆª set.interval b c",
    "args": "{Î± : Type u} [linear_order Î±] {a b c : Î±}",
    "doc_string": "A sort of triangle inequality.",
    "type": "set.interval a c âŠ† set.interval a b âˆª set.interval b c"
  },
  {
    "name": "add_neg",
    "statement": "theorem add_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "neg_of_neg_pos",
    "statement": "theorem neg_of_neg_pos {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : 0 < -a â†’ a < 0",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "type": "0 < -a â†’ a < 0"
  },
  {
    "name": "is_topological_fiber_bundle_snd",
    "statement": "theorem is_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a topological fiber bundle.",
    "type": "is_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "tendsto_rpow_div",
    "statement": "theorem tendsto_rpow_div  : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)",
    "theorem": " : filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)",
    "args": "",
    "doc_string": "The function `x ^ (1 / x)` tends to `1` at `+âˆž`.",
    "type": "filter.tendsto (Î» (x : â„), x ^ (1 / x)) filter.at_top (nhds 1)"
  },
  {
    "name": "category_theory.has_finite_products_of_has_binary_and_terminal",
    "statement": "theorem category_theory.has_finite_products_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C]",
    "doc_string": "If `C` has a terminal object and binary products, then it has finite products.",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "has_le.le.lt_of_not_le",
    "statement": "theorem has_le.le.lt_of_not_le {Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} : a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±}",
    "doc_string": "**Alias** of lt_of_le_not_le`.",
    "type": "a â‰¤ b â†’ Â¬b â‰¤ a â†’ a < b"
  },
  {
    "name": "filter.tendsto_at_bot_at_bot_of_monotone'",
    "statement": "theorem filter.tendsto_at_bot_at_bot_of_monotone' {Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "theorem": "{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "args": "{Î¹ : Type u_1} {Î± : Type u_3} [preorder Î¹] [linear_order Î±] {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (set.range u))",
    "doc_string": " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded below, then `tendsto u at_bot at_bot`.",
    "type": "filter.tendsto u filter.at_bot filter.at_bot"
  },
  {
    "name": "has_btw.btw.cyclic_right",
    "statement": "theorem has_btw.btw.cyclic_right {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of btw_cyclic_right`.",
    "type": "has_btw.btw c a b"
  },
  {
    "name": "lt_of_tsub_lt_tsub_right",
    "statement": "theorem lt_of_tsub_lt_tsub_right {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b",
    "theorem": "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c) : a < b",
    "args": "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] (h : a - c < b - c)",
    "doc_string": "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order.",
    "type": "a < b"
  },
  {
    "name": "real.tendsto_log_at_top",
    "statement": "theorem real.tendsto_log_at_top  : filter.tendsto real.log filter.at_top filter.at_top",
    "theorem": " : filter.tendsto real.log filter.at_top filter.at_top",
    "args": "",
    "doc_string": "The real logarithm function tends to `+âˆž` at `+âˆž`.",
    "type": "filter.tendsto real.log filter.at_top filter.at_top"
  },
  {
    "name": "finset.not_mem_map_subtype_of_not_property",
    "statement": "theorem finset.not_mem_map_subtype_of_not_property {Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s",
    "theorem": "{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a) : a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s",
    "args": "{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : Â¬p a)",
    "doc_string": " If a `finset` of a subtype is converted to the main type with `embedding.subtype`, the result does not contain any value that does not satisfy the property of the subtype.",
    "type": "a âˆ‰ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s"
  },
  {
    "name": "padic_val_nat.div",
    "statement": "theorem padic_val_nat.div {p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "theorem": "{p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "args": "{p : â„•} [p_prime : fact (nat.prime p)] {b : â„•} (dvd : p âˆ£ b)",
    "doc_string": "Dividing out by a prime factor reduces the padic_val_nat by 1.",
    "type": "padic_val_nat p (b / p) = padic_val_nat p b - 1"
  },
  {
    "name": "function.antiperiodic.periodic",
    "statement": "theorem function.antiperiodic.periodic {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c)",
    "doc_string": "If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`.",
    "type": "function.periodic f (2 * c)"
  },
  {
    "name": "option.subsingleton_iff_is_empty",
    "statement": "theorem option.subsingleton_iff_is_empty {Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±",
    "theorem": "{Î± : Type u_1} : subsingleton (option Î±) â†” is_empty Î±",
    "args": "{Î± : Type u_1}",
    "doc_string": "`option Î±` is a `subsingleton` if and only if `Î±` is empty.",
    "type": "subsingleton (option Î±) â†” is_empty Î±"
  },
  {
    "name": "cardinal.sum_lt_prod",
    "statement": "theorem cardinal.sum_lt_prod {Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g",
    "theorem": "{Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i) : cardinal.sum f < cardinal.prod g",
    "args": "{Î¹ : Type u_1} (f g : Î¹ â†’ cardinal) (H : âˆ€ (i : Î¹), f i < g i)",
    "doc_string": "**KÃ¶nig's theorem**",
    "type": "cardinal.sum f < cardinal.prod g"
  },
  {
    "name": "add_pos'",
    "statement": "theorem add_pos' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos'`.",
    "type": "0 < a + b"
  },
  {
    "name": "rack.assoc_iff_id",
    "statement": "theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z",
    "theorem": "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z",
    "args": "{R : Type u_1} [rack R] {x y z : R}",
    "doc_string": "Associative racks are uninteresting.",
    "type": "shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z â†” shelf.act x z = z"
  },
  {
    "name": "not_not",
    "statement": "theorem not_not {a : Prop} : Â¬Â¬a â†” a",
    "theorem": "{a : Prop} : Â¬Â¬a â†” a",
    "args": "{a : Prop}",
    "doc_string": " The Double Negation Theorem: `Â¬ Â¬ P` is equivalent to `P`. The left-to-right direction, double negation elimination (DNE), is classically true but not constructively.",
    "type": "Â¬Â¬a â†” a"
  },
  {
    "name": "topological_space.exists_dense_seq",
    "statement": "theorem topological_space.exists_dense_seq (Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u",
    "theorem": "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±] : âˆƒ (u : â„• â†’ Î±), dense_range u",
    "args": "(Î± : Type u) [t : topological_space Î±] [topological_space.separable_space Î±] [nonempty Î±]",
    "doc_string": " A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the conclusion of this lemma, you might want to use `topological_space.dense_seq` and `topological_space.dense_range_dense_seq`.  If `Î±` might be empty, then `exists_countable_dense` is the main way to use separability of `Î±`.",
    "type": "âˆƒ (u : â„• â†’ Î±), dense_range u"
  },
  {
    "name": "is_of_fin_order_inv_iff",
    "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x",
    "theorem": "{G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x",
    "args": "{G : Type u} [group G] {x : G}",
    "doc_string": "Inverses of elements of finite order have finite order.",
    "type": "is_of_fin_order xâ»Â¹ â†” is_of_fin_order x"
  },
  {
    "name": "finsupp.single_injective",
    "statement": "theorem finsupp.single_injective {Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)",
    "theorem": "{Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±) : function.injective (finsupp.single a)",
    "args": "{Î± : Type u_1} {M : Type u_5} [has_zero M] (a : Î±)",
    "doc_string": " `finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see `finsupp.single_left_injective`",
    "type": "function.injective (finsupp.single a)"
  },
  {
    "name": "not_bdd_above_iff'",
    "statement": "theorem not_bdd_above_iff' {Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x",
    "theorem": "{Î± : Type u} [preorder Î±] {s : set Î±} : Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x",
    "args": "{Î± : Type u} [preorder Î±] {s : set Î±}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y âˆˆ s` such that `x` is not greater than or equal to `y`. This version only assumes `preorder` structure and uses `Â¬(y â‰¤ x)`. A version for linear orders is called `not_bdd_above_iff`.",
    "type": "Â¬bdd_above s â†” âˆ€ (x : Î±), âˆƒ (y : Î±) (H : y âˆˆ s), Â¬y â‰¤ x"
  },
  {
    "name": "pythagorean_triple_comm",
    "statement": "theorem pythagorean_triple_comm {x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z",
    "theorem": "{x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z",
    "args": "{x y z : â„¤}",
    "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.",
    "type": "pythagorean_triple x y z â†” pythagorean_triple y x z"
  },
  {
    "name": "nat.le_induction",
    "statement": "theorem nat.le_induction {P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n",
    "theorem": "{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•) : m â‰¤ n â†’ P n",
    "args": "{P : â„• â†’ Prop} {m : â„•} (h0 : P m) (h1 : âˆ€ (n : â„•), m â‰¤ n â†’ P n â†’ P (n + 1)) (n : â„•)",
    "doc_string": "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`.",
    "type": "m â‰¤ n â†’ P n"
  },
  {
    "name": "is_of_fin_order_neg_iff",
    "statement": "theorem is_of_fin_order_neg_iff {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x",
    "theorem": "{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x",
    "args": "{G : Type u} [add_group G] {x : G}",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "type": "is_of_fin_add_order (-x) â†” is_of_fin_add_order x"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_target_tendsto_at_top",
    "statement": "theorem formal_multilinear_series.comp_partial_sum_target_tendsto_at_top  : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "theorem": " : filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "args": "",
    "doc_string": " The auxiliary set corresponding to the composition of partial sums asymptotically contains all possible compositions.",
    "type": "filter.tendsto (Î» (N : â„•), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top"
  },
  {
    "name": "fin.coe_fin_lt",
    "statement": "theorem fin.coe_fin_lt {n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b",
    "theorem": "{n : â„•} {a b : fin n} : â†‘a < â†‘b â†” a < b",
    "args": "{n : â„•} {a b : fin n}",
    "doc_string": "`a < b` as natural numbers if and only if `a < b` in `fin n`.",
    "type": "â†‘a < â†‘b â†” a < b"
  },
  {
    "name": "subgroup.closure_le",
    "statement": "theorem subgroup.closure_le {G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k â‰¤ K â†” k âŠ† â†‘K",
    "theorem": "{G : Type u_1} [group G] (K : subgroup G) {k : set G} : subgroup.closure k â‰¤ K â†” k âŠ† â†‘K",
    "args": "{G : Type u_1} [group G] (K : subgroup G) {k : set G}",
    "doc_string": "A subgroup `K` includes `closure k` if and only if it includes `k`.",
    "type": "subgroup.closure k â‰¤ K â†” k âŠ† â†‘K"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_right",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)",
    "theorem": "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x)",
    "args": "{Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³)",
    "doc_string": "Right multiplication in a ring is an additive monoid morphism.",
    "type": "is_add_monoid_hom (Î» (y : Î³), y * x)"
  },
  {
    "name": "has_le.le.lt_or_eq",
    "statement": "theorem has_le.le.lt_or_eq {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b",
    "theorem": "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ a < b âˆ¨ a = b",
    "args": "{Î± : Type u} [partial_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of lt_or_eq_of_le`.",
    "type": "a â‰¤ b â†’ a < b âˆ¨ a = b"
  },
  {
    "name": "continuous_map.continuous_eval_const'",
    "statement": "theorem continuous_map.continuous_eval_const' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±) : continuous (Î» (f : C(Î±, Î²)), â‡‘f a)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] (a : Î±)",
    "doc_string": "See also `continuous_map.continuous_eval_const`",
    "type": "continuous (Î» (f : C(Î±, Î²)), â‡‘f a)"
  },
  {
    "name": "order.lt_of_pred_lt_pred",
    "statement": "theorem order.lt_of_pred_lt_pred {Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b",
    "theorem": "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : order.pred a < order.pred b â†’ a < b",
    "args": "{Î± : Type u_1} [preorder Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±]",
    "doc_string": "**Alias** of the forward direction of order.pred_lt_pred_iff`.",
    "type": "order.pred a < order.pred b â†’ a < b"
  },
  {
    "name": "vadd_comm_class.symm",
    "statement": "theorem vadd_comm_class.symm (M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±",
    "theorem": "(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±] : vadd_comm_class N M Î±",
    "args": "(M : Type u_1) (N : Type u_2) (Î± : Type u_3) [has_vadd M Î±] [has_vadd N Î±] [vadd_comm_class M N Î±]",
    "doc_string": " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance because this would cause a loop in the instance search graph.",
    "type": "vadd_comm_class N M Î±"
  },
  {
    "name": "finset.property_of_mem_map_subtype",
    "statement": "theorem finset.property_of_mem_map_subtype {Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s) : p a",
    "theorem": "{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s) : p a",
    "args": "{Î± : Type u_1} {p : Î± â†’ Prop} (s : finset {x // p x}) {a : Î±} (h : a âˆˆ finset.map (function.embedding.subtype (Î» (x : Î±), p x)) s)",
    "doc_string": " If a `finset` of a subtype is converted to the main type with `embedding.subtype`, all elements of the result have the property of the subtype.",
    "type": "p a"
  },
  {
    "name": "subsemigroup.ext",
    "statement": "theorem subsemigroup.ext {M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T",
    "theorem": "{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T) : S = T",
    "args": "{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : âˆ€ (x : M), x âˆˆ S â†” x âˆˆ T)",
    "doc_string": "Two subsemigroups are equal if they have the same elements.",
    "type": "S = T"
  },
  {
    "name": "padic_val_rat.of_int_multiplicity",
    "statement": "theorem padic_val_rat.of_int_multiplicity {p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0) : padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)",
    "theorem": "{p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0) : padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)",
    "args": "{p : â„•} (z : â„¤) (hp : p â‰  1) (hz : z â‰  0)",
    "doc_string": "The p-adic value of an integer `z â‰  0` is the multiplicity of `p` in `z`.",
    "type": "padic_val_rat p â†‘z = â†‘((multiplicity â†‘p z).get _)"
  },
  {
    "name": "dense.inter_of_open_left",
    "statement": "theorem dense.inter_of_open_left {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)",
    "theorem": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t)",
    "args": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s)",
    "doc_string": "The intersection of an open dense set with a dense set is a dense set.",
    "type": "dense (s âˆ© t)"
  },
  {
    "name": "add_semiconj_by.zero_right",
    "statement": "theorem add_semiconj_by.zero_right {M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "theorem": "{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "args": "{M : Type u} [add_zero_class M] (a : M)",
    "doc_string": "Any element additively semiconjugates `0` to `0`.",
    "type": "add_semiconj_by a 0 0"
  },
  {
    "name": "right.add_nonneg",
    "statement": "theorem right.add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonneg`.",
    "type": "0 â‰¤ a + b"
  },
  {
    "name": "submonoid.one_mem",
    "statement": "theorem submonoid.one_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 âˆˆ S",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 âˆˆ S",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M)",
    "doc_string": "A submonoid contains the monoid's 1.",
    "type": "1 âˆˆ S"
  },
  {
    "name": "tactic.ring2.correctness",
    "statement": "theorem tactic.ring2.correctness {Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚",
    "theorem": "{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚) : tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚",
    "args": "{Î± : Type u_1} [comm_semiring Î±] (t : tree Î±) (râ‚ râ‚‚ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr râ‚ = tactic.ring2.horner_expr.of_csexpr râ‚‚)",
    "doc_string": " The main proof-by-reflection theorem. Given reflected csring expressions `râ‚` and `râ‚‚` plus a storage `t` of atoms, if both expressions go to the same Horner normal form, then the original non-reflected expressions are equal. `H` follows from kernel reduction and is therefore `rfl`.",
    "type": "tactic.ring2.csring_expr.eval t râ‚ = tactic.ring2.csring_expr.eval t râ‚‚"
  },
  {
    "name": "ring.two_ne_zero",
    "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0",
    "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0",
    "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2)",
    "doc_string": "We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`.",
    "type": "2 â‰  0"
  },
  {
    "name": "list.of_fn_zero",
    "statement": "theorem list.of_fn_zero {Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil",
    "theorem": "{Î± : Type u} (f : fin 0 â†’ Î±) : list.of_fn f = list.nil",
    "args": "{Î± : Type u} (f : fin 0 â†’ Î±)",
    "doc_string": "`of_fn` on an empty domain is the empty list.",
    "type": "list.of_fn f = list.nil"
  },
  {
    "name": "add_subgroup.ext",
    "statement": "theorem add_subgroup.ext {G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K",
    "theorem": "{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K) : H = K",
    "args": "{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : âˆ€ (x : G), x âˆˆ H â†” x âˆˆ K)",
    "doc_string": "Two `add_subgroup`s are equal if they have the same elements.",
    "type": "H = K"
  },
  {
    "name": "real.not_summable_nat_cast_inv",
    "statement": "theorem real.not_summable_nat_cast_inv  : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)",
    "theorem": " : Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "type": "Â¬summable (Î» (n : â„•), (â†‘n)â»Â¹)"
  },
  {
    "name": "category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers",
    "statement": "theorem category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "theorem": "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "args": "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "If a category has all binary coproducts and all coequalizers, then it also has all pushouts.    As usual, this is not an instance, since there may be a more direct way to construct    pushouts.",
    "type": "category_theory.limits.has_pushouts C"
  },
  {
    "name": "is_group_hom.inv",
    "statement": "theorem is_group_hom.inv {Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f)",
    "doc_string": "The inverse of a group homomorphism is a group homomorphism if the target is commutative.",
    "type": "is_group_hom (Î» (a : Î±), (f a)â»Â¹)"
  },
  {
    "name": "list.prod_pos",
    "statement": "theorem list.prod_pos {R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod",
    "theorem": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a) : 0 < l.prod",
    "args": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : âˆ€ (a : R), a âˆˆ l â†’ 0 < a)",
    "doc_string": " The product of a list of positive natural numbers is positive, and likewise for any nontrivial ordered semiring.",
    "type": "0 < l.prod"
  },
  {
    "name": "subgroup.is_open_of_one_mem_interior",
    "statement": "theorem subgroup.is_open_of_one_mem_interior {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H",
    "args": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H)",
    "doc_string": "If a subgroup of a topological group has `1` in its interior, then it is open.",
    "type": "is_open â†‘H"
  },
  {
    "name": "function.not_surjective_Type",
    "statement": "theorem function.not_surjective_Type {Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f",
    "theorem": "{Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f",
    "args": "{Î± : Type u} (f : Î± â†’ Type (max u v))",
    "doc_string": "There is no surjection from `Î± : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean.",
    "type": "Â¬function.surjective f"
  },
  {
    "name": "is_mul_hom.inv",
    "statement": "theorem is_mul_hom.inv {Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_mul_hom (Î» (a : Î±), (f a)â»Â¹)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [has_mul Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "type": "is_mul_hom (Î» (a : Î±), (f a)â»Â¹)"
  },
  {
    "name": "powers.is_submonoid",
    "statement": "theorem powers.is_submonoid {M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "theorem": "{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "args": "{M : Type u_1} [monoid M] (x : M)",
    "doc_string": "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`.",
    "type": "is_submonoid (powers x)"
  },
  {
    "name": "add_semiconj_by.zero_left",
    "statement": "theorem add_semiconj_by.zero_left {M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "theorem": "{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "args": "{M : Type u} [add_zero_class M] (x : M)",
    "doc_string": "Zero additively semiconjugates any element to itself.",
    "type": "add_semiconj_by 0 x x"
  },
  {
    "name": "bdd_below.inter_of_right",
    "statement": "theorem bdd_below.inter_of_right {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)",
    "theorem": "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t) : bdd_below (s âˆ© t)",
    "args": "{Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below t)",
    "doc_string": "If `t` is bounded, then so is `s âˆ© t`",
    "type": "bdd_below (s âˆ© t)"
  },
  {
    "name": "category_theory.is_subterminal.mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "theorem": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "args": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`.",
    "type": "category_theory.mono (category_theory.limits.terminal.from A)"
  },
  {
    "name": "nat.count_eq_card_fintype",
    "statement": "theorem nat.count_eq_card_fintype (p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : nat.count p n = fintype.card {k // k < n âˆ§ p k}",
    "theorem": "(p : â„• â†’ Prop) [decidable_pred p] (n : â„•) : nat.count p n = fintype.card {k // k < n âˆ§ p k}",
    "args": "(p : â„• â†’ Prop) [decidable_pred p] (n : â„•)",
    "doc_string": "`count p n` can be expressed as the cardinality of `{k // k < n âˆ§ p k}`.",
    "type": "nat.count p n = fintype.card {k // k < n âˆ§ p k}"
  },
  {
    "name": "range.is_add_submonoid",
    "statement": "theorem range.is_add_submonoid {M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "args": "{M : Type u_1} [add_monoid M] {Î³ : Type u_2} [add_monoid Î³] {f : M â†’ Î³} (hf : is_add_monoid_hom f)",
    "doc_string": "The image of an `add_monoid` hom is an `add_submonoid` of the codomain.",
    "type": "is_add_submonoid (set.range f)"
  },
  {
    "name": "nat.dvd_left_injective",
    "statement": "theorem nat.dvd_left_injective  : function.injective has_dvd.dvd",
    "theorem": " : function.injective has_dvd.dvd",
    "args": "",
    "doc_string": "`dvd` is injective in the left argument",
    "type": "function.injective has_dvd.dvd"
  },
  {
    "name": "seq_closure_subset_closure",
    "statement": "theorem seq_closure_subset_closure {X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : seq_closure s âŠ† closure s",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " The sequential closure of a set is contained in the closure of that set. The converse is not true.",
    "type": "seq_closure s âŠ† closure s"
  },
  {
    "name": "dense_range.quotient",
    "statement": "theorem dense_range.quotient {Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)",
    "theorem": "{Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f) : dense_range (quotient.mk âˆ˜ f)",
    "args": "{Î± : Type u} {Î² : Type v} [setoid Î±] [topological_space Î±] {f : Î² â†’ Î±} (hf : dense_range f)",
    "doc_string": "The composition of `quotient.mk` and a function with dense range has dense range.",
    "type": "dense_range (quotient.mk âˆ˜ f)"
  },
  {
    "name": "add_pos_of_nonneg_of_pos",
    "statement": "theorem add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "max_chain_spec",
    "statement": "theorem max_chain_spec {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r)",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop}",
    "doc_string": " **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `Î±`. Note that we do not require `Î±` to be partially ordered by `r`.",
    "type": "is_max_chain r (max_chain r)"
  },
  {
    "name": "padic_val_rat.of_nat",
    "statement": "theorem padic_val_rat.of_nat {p n : â„•} : padic_val_rat p â†‘n = â†‘(padic_val_nat p n)",
    "theorem": "{p n : â„•} : padic_val_rat p â†‘n = â†‘(padic_val_nat p n)",
    "args": "{p n : â„•}",
    "doc_string": "The p-adic value of an integer `z â‰  0` is its p-adic_value as a rational",
    "type": "padic_val_rat p â†‘n = â†‘(padic_val_nat p n)"
  },
  {
    "name": "order.pfilter.ext",
    "statement": "theorem order.pfilter.ext {P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t",
    "theorem": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t) : s = t",
    "args": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : â†‘s = â†‘t)",
    "doc_string": "Two filters are equal when their underlying sets are equal.",
    "type": "s = t"
  },
  {
    "name": "left.add_nonneg",
    "statement": "theorem left.add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonneg`.",
    "type": "0 â‰¤ a + b"
  },
  {
    "name": "multiset.nat.mem_antidiagonal",
    "statement": "theorem multiset.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n",
    "theorem": "{n : â„•} {x : â„• Ã— â„•} : x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n",
    "args": "{n : â„•} {x : â„• Ã— â„•}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "type": "x âˆˆ multiset.nat.antidiagonal n â†” x.fst + x.snd = n"
  },
  {
    "name": "ordinal.bdd_above_range",
    "statement": "theorem ordinal.bdd_above_range {Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)",
    "theorem": "{Î¹ : Type u} (f : Î¹ â†’ ordinal) : bdd_above (set.range f)",
    "args": "{Î¹ : Type u} (f : Î¹ â†’ ordinal)",
    "doc_string": "The range of any family of ordinals is bounded above. See also `lsub_not_mem_range`.",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "extend_partial_order",
    "statement": "theorem extend_partial_order {Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s",
    "theorem": "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r] : âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s",
    "args": "{Î± : Type u} (r : Î± â†’ Î± â†’ Prop) [is_partial_order Î± r]",
    "doc_string": "Any partial order can be extended to a linear order.",
    "type": "âˆƒ (s : Î± â†’ Î± â†’ Prop) (_x : is_linear_order Î± s), r â‰¤ s"
  },
  {
    "name": "commute.mul_right",
    "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product.",
    "type": "commute a (b * c)"
  },
  {
    "name": "finsum_mem_empty",
    "statement": "theorem finsum_mem_empty {Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0",
    "theorem": "{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} : finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0",
    "args": "{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M}",
    "doc_string": "The sum of any function over an empty set is `0`.",
    "type": "finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ âˆ…), f i)) = 0"
  },
  {
    "name": "pythagorean_triple.zero",
    "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0",
    "theorem": " : pythagorean_triple 0 0 0",
    "args": "",
    "doc_string": "The zeroth Pythagorean triple is all zeros.",
    "type": "pythagorean_triple 0 0 0"
  },
  {
    "name": "is_coprime.ne_zero",
    "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0",
    "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1)) : p â‰  0",
    "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 â†’ R} (h : is_coprime (p 0) (p 1))",
    "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p â‰  0`.",
    "type": "p â‰  0"
  },
  {
    "name": "is_simple_group_of_prime_card",
    "statement": "theorem is_simple_group_of_prime_card {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±",
    "theorem": "{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î±",
    "args": "{Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p)",
    "doc_string": "A finite group of prime order is simple.",
    "type": "is_simple_group Î±"
  },
  {
    "name": "bool.apply_apply_apply",
    "statement": "theorem bool.apply_apply_apply (f : bool â†’ bool) (x : bool) : f (f (f x)) = f x",
    "theorem": "(f : bool â†’ bool) (x : bool) : f (f (f x)) = f x",
    "args": "(f : bool â†’ bool) (x : bool)",
    "doc_string": "**Kaminski's Equation**",
    "type": "f (f (f x)) = f x"
  },
  {
    "name": "has_le.le.antisymm'",
    "statement": "theorem has_le.le.antisymm' {Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a",
    "theorem": "{Î± : Type u} [partial_order Î±] {a b : Î±} : a â‰¤ b â†’ b â‰¤ a â†’ b = a",
    "args": "{Î± : Type u} [partial_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of ge_antisymm`.",
    "type": "a â‰¤ b â†’ b â‰¤ a â†’ b = a"
  },
  {
    "name": "one_lt_mul_of_le_of_lt'",
    "statement": "theorem one_lt_mul_of_le_of_lt' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "inv_le_one'",
    "statement": "theorem inv_le_one' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "type": "aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a"
  },
  {
    "name": "is_right_regular.of_mul",
    "statement": "theorem is_right_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a))",
    "doc_string": "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular element, then `b` is right-regular.",
    "type": "is_right_regular b"
  },
  {
    "name": "nat.pow_le_iff_le_log",
    "statement": "theorem nat.pow_le_iff_le_log {b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y",
    "theorem": "{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y) : b ^ x â‰¤ y â†” x â‰¤ nat.log b y",
    "args": "{b : â„•} (hb : 1 < b) {x y : â„•} (hy : 0 < y)",
    "doc_string": "`pow b` and `log b` (almost) form a Galois connection.",
    "type": "b ^ x â‰¤ y â†” x â‰¤ nat.log b y"
  },
  {
    "name": "le_implies_le_of_le_of_le",
    "statement": "theorem le_implies_le_of_le_of_le {Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d",
    "theorem": "{Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d) : a â‰¤ b â†’ c â‰¤ d",
    "args": "{Î± : Type u} {a b c d : Î±} [preorder Î±] (hca : c â‰¤ a) (hbd : b â‰¤ d)",
    "doc_string": "monotonicity of `â‰¤` with respect to `â†’`",
    "type": "a â‰¤ b â†’ c â‰¤ d"
  },
  {
    "name": "filter.comap_cocompact_le",
    "statement": "theorem filter.comap_cocompact_le {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±",
    "theorem": "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±",
    "args": "{Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f)",
    "doc_string": " The comap of the cocompact filter on `Î²` by a continuous function `f : Î± â†’ Î²` is less than or equal to the cocompact filter on `Î±`. This is a reformulation of the fact that images of compact sets are compact.",
    "type": "filter.comap f (filter.cocompact Î²) â‰¤ filter.cocompact Î±"
  },
  {
    "name": "has_btw.btw.sbtw_of_not_btw",
    "statement": "theorem has_btw.btw.sbtw_of_not_btw {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (habc : has_btw.btw a b c) (hcba : Â¬has_btw.btw c b a)",
    "doc_string": "**Alias** of sbtw_of_btw_not_btw`.",
    "type": "has_sbtw.sbtw a b c"
  },
  {
    "name": "finset.subtype_map_of_mem",
    "statement": "theorem finset.subtype_map_of_mem {Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s",
    "theorem": "{Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s",
    "args": "{Î± : Type u_1} {s : finset Î±} {p : Î± â†’ Prop} [decidable_pred p] (h : âˆ€ (x : Î±), x âˆˆ s â†’ p x)",
    "doc_string": " If all elements of a `finset` satisfy the predicate `p`, `s.subtype p` converts back to `s` with `embedding.subtype`.",
    "type": "finset.map (function.embedding.subtype p) (finset.subtype p s) = s"
  },
  {
    "name": "odd.exists_bit1",
    "statement": "theorem odd.exists_bit1 {Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)",
    "theorem": "{Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b)",
    "args": "{Î± : Type u_2} [semiring Î±] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of odd_iff_exists_bit1`.",
    "type": "odd a â†’ (âˆƒ (b : Î±), a = bit1 b)"
  },
  {
    "name": "padic_val_nat.mul",
    "statement": "theorem padic_val_nat.mul (p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "theorem": "(p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "args": "(p : â„•) [p_prime : fact (nat.prime p)] {q r : â„•} (hq : q â‰  0) (hr : r â‰  0)",
    "doc_string": "A rewrite lemma for `padic_val_nat p (q * r)` with conditions `q â‰  0`, `r â‰  0`.",
    "type": "padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r"
  },
  {
    "name": "add_subgroup.neg_mem",
    "statement": "theorem add_subgroup.neg_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x âˆˆ H â†’ -x âˆˆ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G}",
    "doc_string": "An `add_subgroup` is closed under inverse.",
    "type": "x âˆˆ H â†’ -x âˆˆ H"
  },
  {
    "name": "category_theory.limits.initial_mono_class.of_initial",
    "statement": "theorem category_theory.limits.initial_mono_class.of_initial {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "args": "{C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] (h : âˆ€ (X : C), category_theory.mono (category_theory.limits.initial.to X))",
    "doc_string": " To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism.",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "structure_groupoid.id_mem_maximal_atlas",
    "statement": "theorem structure_groupoid.id_mem_maximal_atlas {H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H)",
    "doc_string": "In the model space, the identity is in any maximal atlas.",
    "type": "local_homeomorph.refl H âˆˆ structure_groupoid.maximal_atlas H G"
  },
  {
    "name": "function.is_fixed_pt.is_periodic_pt",
    "statement": "theorem function.is_fixed_pt.is_periodic_pt {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x",
    "theorem": "{Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x",
    "args": "{Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•)",
    "doc_string": "A fixed point of `f` is a periodic point of `f` of any prescribed period.",
    "type": "function.is_periodic_pt f n x"
  },
  {
    "name": "left.inv_lt_one_iff",
    "statement": "theorem left.inv_lt_one_iff {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : aâ»Â¹ < 1 â†” 1 < a",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "aâ»Â¹ < 1 â†” 1 < a"
  },
  {
    "name": "subtype.range_coe_subtype",
    "statement": "theorem subtype.range_coe_subtype {Î± : Type u_1} {p : Î± â†’ Prop} : set.range coe = {x : Î± | p x}",
    "theorem": "{Î± : Type u_1} {p : Î± â†’ Prop} : set.range coe = {x : Î± | p x}",
    "args": "{Î± : Type u_1} {p : Î± â†’ Prop}",
    "doc_string": "We make this the simp lemma instead of `range_coe`. The reason is that if we write  for `s : set Î±` the function `coe : s â†’ Î±`, then the inferred implicit arguments of `coe` are  `coe Î± (Î» x, x âˆˆ s)`.",
    "type": "set.range coe = {x : Î± | p x}"
  },
  {
    "name": "is_add_regular_add_and_add_iff",
    "statement": "theorem is_add_regular_add_and_add_iff {R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R]",
    "doc_string": "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a` are add-regular.",
    "type": "is_add_regular (a + b) âˆ§ is_add_regular (b + a) â†” is_add_regular a âˆ§ is_add_regular b"
  },
  {
    "name": "lt_add_of_neg_add_lt",
    "statement": "theorem lt_add_of_neg_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : -b + a < c â†’ a < b + c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`.",
    "type": "-b + a < c â†’ a < b + c"
  },
  {
    "name": "pow_two_sub_pow_two",
    "statement": "theorem pow_two_sub_pow_two {R : Type uâ‚} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "theorem": "{R : Type uâ‚} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "args": "{R : Type uâ‚} [comm_ring R] (a b : R)",
    "doc_string": "**Alias** of sq_sub_sq`.",
    "type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)"
  },
  {
    "name": "has_le.le.eq_of_not_gt",
    "statement": "theorem has_le.le.eq_of_not_gt {Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a",
    "theorem": "{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b) : b = a",
    "args": "{Î± : Type u} [partial_order Î±] {a b : Î±} (hab : a â‰¤ b) (hba : Â¬a < b)",
    "doc_string": "**Alias** of eq_of_ge_of_not_gt`.",
    "type": "b = a"
  },
  {
    "name": "add_subgroup.multiset_sum_mem",
    "statement": "theorem add_subgroup.multiset_sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K",
    "theorem": "{G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G) : (âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K",
    "args": "{G : Type u_1} [add_comm_group G] (K : add_subgroup G) (g : multiset G)",
    "doc_string": "Sum of a multiset of elements in an `add_subgroup` of an `add_comm_group` is in the `add_subgroup`.",
    "type": "(âˆ€ (a : G), a âˆˆ g â†’ a âˆˆ K) â†’ g.sum âˆˆ K"
  },
  {
    "name": "real.tendsto_exp_div_pow_at_top",
    "statement": "theorem real.tendsto_exp_div_pow_at_top (n : â„•) : filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top",
    "theorem": "(n : â„•) : filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top",
    "args": "(n : â„•)",
    "doc_string": "The function `exp(x)/x^n` tends to `+âˆž` at `+âˆž`, for any natural number `n`",
    "type": "filter.tendsto (Î» (x : â„), real.exp x / x ^ n) filter.at_top filter.at_top"
  },
  {
    "name": "con.ext'",
    "statement": "theorem con.ext' {M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d",
    "theorem": "{M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r) : c = d",
    "args": "{M : Type u_1} [has_mul M] {c d : con M} (H : setoid.r = setoid.r)",
    "doc_string": "The map sending a congruence relation to its underlying binary relation is injective.",
    "type": "c = d"
  },
  {
    "name": "pow_two_nonneg",
    "statement": "theorem pow_two_nonneg {R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2",
    "theorem": "{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 â‰¤ a ^ 2",
    "args": "{R : Type u_4} [linear_ordered_ring R] (a : R)",
    "doc_string": "**Alias** of sq_nonneg`.",
    "type": "0 â‰¤ a ^ 2"
  },
  {
    "name": "composition.sigma_composition_eq_iff",
    "statement": "theorem composition.sigma_composition_eq_iff {n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks",
    "theorem": "{n : â„•} (i j : Î£ (a : composition n), composition a.length) : i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks",
    "args": "{n : â„•} (i j : Î£ (a : composition n), composition a.length)",
    "doc_string": " Rewriting equality in the dependent type `Î£ (a : composition n), composition a.length)` in non-dependent terms with lists, requiring that the blocks coincide.",
    "type": "i = j â†” i.fst.blocks = j.fst.blocks âˆ§ i.snd.blocks = j.snd.blocks"
  },
  {
    "name": "lower_central_series_is_descending_central_series",
    "statement": "theorem lower_central_series_is_descending_central_series {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "theorem": "{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The lower central series of a group is a descending central series.",
    "type": "is_descending_central_series (lower_central_series G)"
  },
  {
    "name": "is_compact.diff",
    "statement": "theorem is_compact.diff {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)",
    "theorem": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_open t) : is_compact (s  t)",
    "args": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_open t)",
    "doc_string": "The set difference of a compact set and an open set is a compact set.",
    "type": "is_compact (s  t)"
  },
  {
    "name": "sbtw_cyclic",
    "statement": "theorem sbtw_cyclic {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±}",
    "doc_string": " The order of the `â†”` has been chosen so that `rw sbtw_cyclic` cycles to the right while `rw â†sbtw_cyclic` cycles to the left (thus following the prepended arrow).",
    "type": "has_sbtw.sbtw a b c â†” has_sbtw.sbtw c a b"
  },
  {
    "name": "polynomial.cyclotomic_injective",
    "statement": "theorem polynomial.cyclotomic_injective {R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)",
    "theorem": "{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (Î» (n : â„•), polynomial.cyclotomic n R)",
    "args": "{R : Type u_1} [comm_ring R] [char_zero R]",
    "doc_string": "Over a ring `R` of characteristic zero, `Î» n, cyclotomic n R` is injective.",
    "type": "function.injective (Î» (n : â„•), polynomial.cyclotomic n R)"
  },
  {
    "name": "finset.up_shadow_empty",
    "statement": "theorem finset.up_shadow_empty {Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±] : âˆ….up_shadow = âˆ…",
    "args": "{Î± : Type u_1} [decidable_eq Î±] [fintype Î±]",
    "doc_string": "The upper shadow of the empty set is empty.",
    "type": "âˆ….up_shadow = âˆ…"
  },
  {
    "name": "padic_val_int.zero",
    "statement": "theorem padic_val_int.zero {p : â„•} : padic_val_int p 0 = 0",
    "theorem": "{p : â„•} : padic_val_int p 0 = 0",
    "args": "{p : â„•}",
    "doc_string": "`padic_val_int p 0` is 0 for any `p`.",
    "type": "padic_val_int p 0 = 0"
  },
  {
    "name": "add_con.coe_zero",
    "statement": "theorem add_con.coe_zero {M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0",
    "theorem": "{M : Type u_1} [add_zero_class M] {c : add_con M} : â†‘0 = 0",
    "args": "{M : Type u_1} [add_zero_class M] {c : add_con M}",
    "doc_string": "The 0 of the quotient of an `add_monoid` by an additive congruence relation is the equivalence class of the `add_monoid`'s 0.",
    "type": "â†‘0 = 0"
  },
  {
    "name": "int.dvd_of_dvd_mul_left_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_left_of_gcd_one {a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b",
    "theorem": "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1) : a âˆ£ b",
    "args": "{a b c : â„¤} (habc : a âˆ£ b * c) (hab : a.gcd c = 1)",
    "doc_string": " Euclid's lemma: if `a âˆ£ b * c` and `gcd a c = 1` then `a âˆ£ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors`",
    "type": "a âˆ£ b"
  },
  {
    "name": "eq_zero_of_zero_eq_one",
    "statement": "theorem eq_zero_of_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€) : a = 0",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] (h : 0 = 1) (a : Mâ‚€)",
    "doc_string": "In a monoid with zero, if zero equals one, then zero is the only element.",
    "type": "a = 0"
  },
  {
    "name": "continuous.snd'",
    "statement": "theorem continuous.snd' {Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)",
    "theorem": "{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f) : continuous (Î» (x : Î± Ã— Î²), f x.snd)",
    "args": "{Î± : Type u} {Î² : Type v} {Î³ : Type u_1} [topological_space Î±] [topological_space Î²] [topological_space Î³] {f : Î² â†’ Î³} (hf : continuous f)",
    "doc_string": "Precomposing `f` with `prod.snd` is continuous",
    "type": "continuous (Î» (x : Î± Ã— Î²), f x.snd)"
  },
  {
    "name": "Compactum_to_CompHaus.faithful",
    "statement": "theorem Compactum_to_CompHaus.faithful  : category_theory.faithful Compactum_to_CompHaus",
    "theorem": " : category_theory.faithful Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is faithful.",
    "type": "category_theory.faithful Compactum_to_CompHaus"
  },
  {
    "name": "and_or_distrib_right",
    "statement": "theorem and_or_distrib_right {a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
    "theorem": "{a b c : Prop} : a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)",
    "args": "{a b c : Prop}",
    "doc_string": "`âˆ¨` distributes over `âˆ§` (on the right).",
    "type": "a âˆ§ b âˆ¨ c â†” (a âˆ¨ c) âˆ§ (b âˆ¨ c)"
  },
  {
    "name": "powers.self_mem",
    "statement": "theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "An element of a monoid is in the set of that element's natural number powers.",
    "type": "x âˆˆ powers x"
  },
  {
    "name": "matrix.det_fin_zero",
    "statement": "theorem matrix.det_fin_zero {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "theorem": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "args": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R}",
    "doc_string": "Determinant of 0x0 matrix",
    "type": "A.det = 1"
  },
  {
    "name": "add_units.is_add_unit_add_add_units",
    "statement": "theorem add_units.is_add_unit_add_add_units {M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a",
    "theorem": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + â†‘u) â†” is_add_unit a",
    "args": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M)",
    "doc_string": "Addition of a `u : add_units M` on the right doesn't affect `is_add_unit`.",
    "type": "is_add_unit (a + â†‘u) â†” is_add_unit a"
  },
  {
    "name": "cardinal.cantor",
    "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a",
    "theorem": "(a : cardinal) : a < 2 ^ a",
    "args": "(a : cardinal)",
    "doc_string": "**Cantor's theorem**",
    "type": "a < 2 ^ a"
  },
  {
    "name": "div_eq_mul_inv",
    "statement": "theorem div_eq_mul_inv {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * bâ»Â¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": " Dividing by an element is the same as multiplying by its inverse.  This is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better.",
    "type": "a / b = a * bâ»Â¹"
  },
  {
    "name": "le_sub_right_of_add_le",
    "statement": "theorem le_sub_right_of_add_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ a â‰¤ c - b",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of le_sub_iff_add_le`.",
    "type": "a + b â‰¤ c â†’ a â‰¤ c - b"
  },
  {
    "name": "is_mul_hom.id",
    "statement": "theorem is_mul_hom.id {Î± : Type u} [has_mul Î±] : is_mul_hom id",
    "theorem": "{Î± : Type u} [has_mul Î±] : is_mul_hom id",
    "args": "{Î± : Type u} [has_mul Î±]",
    "doc_string": "The identity map preserves multiplication.",
    "type": "is_mul_hom id"
  },
  {
    "name": "function.surjective.dense_range",
    "statement": "theorem function.surjective.dense_range {Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f",
    "theorem": "{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f) : dense_range f",
    "args": "{Î² : Type u_2} [topological_space Î²] {Îº : Type u_5} {f : Îº â†’ Î²} (hf : function.surjective f)",
    "doc_string": "A surjective map has dense range.",
    "type": "dense_range f"
  },
  {
    "name": "add_nonneg",
    "statement": "theorem add_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b) : 0 â‰¤ a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 â‰¤ b)",
    "doc_string": "**Alias** of `left.add_nonneg`.",
    "type": "0 â‰¤ a + b"
  },
  {
    "name": "colex.singleton_lt_iff_lt",
    "statement": "theorem colex.singleton_lt_iff_lt {Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s",
    "theorem": "{Î± : Type u_1} [linear_order Î±] {r s : Î±} : {r}.to_colex < {s}.to_colex â†” r < s",
    "args": "{Î± : Type u_1} [linear_order Î±] {r s : Î±}",
    "doc_string": "Colex is an extension of the base ordering on Î±.",
    "type": "{r}.to_colex < {s}.to_colex â†” r < s"
  },
  {
    "name": "dihedral_group.card",
    "statement": "theorem dihedral_group.card {n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n",
    "theorem": "{n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n",
    "args": "{n : â„•} [fact (0 < n)]",
    "doc_string": "If `0 < n`, then `dihedral_group n` has `2n` elements.",
    "type": "fintype.card (dihedral_group n) = 2 * n"
  },
  {
    "name": "exists_compact_superset",
    "statement": "theorem exists_compact_superset {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'",
    "theorem": "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'",
    "args": "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K)",
    "doc_string": "In a locally compact space, every compact set is contained in the interior of a compact set.",
    "type": "âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K'"
  },
  {
    "name": "category_theory.limits.limits_from_equalizers_and_products",
    "statement": "theorem category_theory.limits.limits_from_equalizers_and_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "Any category with products and equalizers has all limits.  See <https://stacks.math.columbia.edu/tag/002N>.",
    "type": "category_theory.limits.has_limits C"
  },
  {
    "name": "category_theory.limits.has_binary_products_of_has_limit_pair",
    "statement": "theorem category_theory.limits.has_binary_products_of_has_limit_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C",
    "theorem": "(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C",
    "args": "(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)]",
    "doc_string": "If `C` has all limits of diagrams `pair X Y`, then it has all binary products",
    "type": "category_theory.limits.has_binary_products C"
  },
  {
    "name": "topological_space.subset_trans",
    "statement": "theorem topological_space.subset_trans {X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t âŠ† s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space",
    "theorem": "{X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t âŠ† s) : subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space",
    "args": "{X : Type u_1} [tX : topological_space X] {s t : set X} (ts : t âŠ† s)",
    "doc_string": " Let `X` be a topological space and let `s, t âŠ† X` be two subsets.  If there is an inclusion `t âŠ† s`, then the topological space structure on `t` induced by `X` is the same as the one obtained by the induced topological space structure on `s`.",
    "type": "subtype.topological_space = topological_space.induced (set.inclusion ts) subtype.topological_space"
  },
  {
    "name": "finset.filter_false_of_mem",
    "statement": "theorem finset.filter_false_of_mem {Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : finset.filter p s = âˆ…",
    "theorem": "{Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x) : finset.filter p s = âˆ…",
    "args": "{Î± : Type u_1} {p : Î± â†’ Prop} [decidable_pred p] {s : finset Î±} (h : âˆ€ (x : Î±), x âˆˆ s â†’ Â¬p x)",
    "doc_string": "If all elements of a `finset` fail to satisfy the predicate `p`, `s.filter p` is `âˆ…`.",
    "type": "finset.filter p s = âˆ…"
  },
  {
    "name": "nat.eq_zero_of_dvd_of_lt",
    "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0",
    "theorem": "{a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0",
    "args": "{a b : â„•} (w : a âˆ£ b) (h : b < a)",
    "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero.",
    "type": "b = 0"
  },
  {
    "name": "add_commute.eq",
    "statement": "theorem add_commute.eq {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a",
    "theorem": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a",
    "args": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b)",
    "doc_string": "Equality behind `add_commute a b`; useful for rewriting.",
    "type": "a + b = b + a"
  },
  {
    "name": "has_sbtw.sbtw.cyclic_left",
    "statement": "theorem has_sbtw.sbtw.cyclic_left {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_cyclic_left`.",
    "type": "has_sbtw.sbtw b c a"
  },
  {
    "name": "neg_lt_of_neg_lt",
    "statement": "theorem neg_lt_of_neg_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < b â†’ -b < a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : -a < b â†’ -b < a",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of inv_lt'`.",
    "type": "-a < b â†’ -b < a"
  },
  {
    "name": "subsingleton_iff_zero_eq_one",
    "statement": "theorem subsingleton_iff_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†” subsingleton Mâ‚€",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†” subsingleton Mâ‚€",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€]",
    "doc_string": " In a monoid with zero, zero equals one if and only if all elements of that semiring are equal.",
    "type": "0 = 1 â†” subsingleton Mâ‚€"
  },
  {
    "name": "finset.mem_shadow_iff_exists_mem_card_add_one",
    "statement": "theorem finset.mem_shadow_iff_exists_mem_card_add_one {Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±} : s âˆˆ ð’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1",
    "args": "{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {s : finset Î±}",
    "doc_string": "`s âˆˆ âˆ‚ ð’œ` iff `s` is exactly one element less than something from `ð’œ`",
    "type": "s âˆˆ ð’œ.shadow â†” âˆƒ (t : finset Î±) (H : t âˆˆ ð’œ), s âŠ† t âˆ§ t.card = s.card + 1"
  },
  {
    "name": "function.is_fixed_pt.to_left_inverse",
    "statement": "theorem function.is_fixed_pt.to_left_inverse {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x",
    "theorem": "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x",
    "args": "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f)",
    "doc_string": " If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed point of `g`.",
    "type": "function.is_fixed_pt g x"
  },
  {
    "name": "subtype.forall'",
    "statement": "theorem subtype.forall' {Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _",
    "theorem": "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _",
    "args": "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop}",
    "doc_string": "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`  when using `subtype.forall` from right to left.",
    "type": "(âˆ€ (x : Î±) (h : p x), q x h) â†” âˆ€ (x : {a // p a}), q â†‘x _"
  },
  {
    "name": "is_of_fin_order_one",
    "statement": "theorem is_of_fin_order_one {G : Type u} [monoid G] : is_of_fin_order 1",
    "theorem": "{G : Type u} [monoid G] : is_of_fin_order 1",
    "args": "{G : Type u} [monoid G]",
    "doc_string": "1 is of finite order in any monoid.",
    "type": "is_of_fin_order 1"
  },
  {
    "name": "matrix.inv_eq_left_inv",
    "statement": "theorem matrix.inv_eq_left_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1) : Aâ»Â¹ = B",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {A B : matrix n n Î±} (h : B.mul A = 1)",
    "doc_string": "If matrix A is left invertible, then its inverse equals its left inverse.",
    "type": "Aâ»Â¹ = B"
  },
  {
    "name": "zero_mul_eq_const",
    "statement": "theorem zero_mul_eq_const {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] : has_mul.mul 0 = function.const Mâ‚€ 0",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€]",
    "doc_string": "To match `one_mul_eq_id`.",
    "type": "has_mul.mul 0 = function.const Mâ‚€ 0"
  },
  {
    "name": "one_pos",
    "statement": "theorem one_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1",
    "theorem": "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 1",
    "args": "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±]",
    "doc_string": "**Alias** of zero_lt_one`.",
    "type": "0 < 1"
  },
  {
    "name": "submonoid.subset_closure",
    "statement": "theorem submonoid.subset_closure {M : Type u_1} [mul_one_class M] {s : set M} : s âŠ† â†‘(submonoid.closure s)",
    "theorem": "{M : Type u_1} [mul_one_class M] {s : set M} : s âŠ† â†‘(submonoid.closure s)",
    "args": "{M : Type u_1} [mul_one_class M] {s : set M}",
    "doc_string": "The submonoid generated by a set includes the set.",
    "type": "s âŠ† â†‘(submonoid.closure s)"
  },
  {
    "name": "add_subsemigroup.closure_le",
    "statement": "theorem add_subsemigroup.closure_le {M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S",
    "theorem": "{M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M} : add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S",
    "args": "{M : Type u_1} [has_add M] {s : set M} {S : add_subsemigroup M}",
    "doc_string": "An additive subsemigroup `S` includes `closure s` if and only if it includes `s`",
    "type": "add_subsemigroup.closure s â‰¤ S â†” s âŠ† â†‘S"
  },
  {
    "name": "finset.nat.antidiagonal_zero",
    "statement": "theorem finset.nat.antidiagonal_zero  : finset.nat.antidiagonal 0 = {(0, 0)}",
    "theorem": " : finset.nat.antidiagonal 0 = {(0, 0)}",
    "args": "",
    "doc_string": "The antidiagonal of `0` is the list `[(0, 0)]`",
    "type": "finset.nat.antidiagonal 0 = {(0, 0)}"
  },
  {
    "name": "free_group.red.nil_iff",
    "statement": "theorem free_group.red.nil_iff {Î± : Type u} {L : list (Î± Ã— bool)} : free_group.red list.nil L â†” L = list.nil",
    "theorem": "{Î± : Type u} {L : list (Î± Ã— bool)} : free_group.red list.nil L â†” L = list.nil",
    "args": "{Î± : Type u} {L : list (Î± Ã— bool)}",
    "doc_string": "The empty word `[]` only reduces to itself.",
    "type": "free_group.red list.nil L â†” L = list.nil"
  },
  {
    "name": "one_le_inv'",
    "statement": "theorem one_le_inv' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "type": "1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"
  },
  {
    "name": "neg_lt_zero",
    "statement": "theorem neg_lt_zero {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†” 0 < a",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "type": "-a < 0 â†” 0 < a"
  },
  {
    "name": "mul_action.to_perm_injective",
    "statement": "theorem mul_action.to_perm_injective {Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm",
    "theorem": "{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²] : function.injective mul_action.to_perm",
    "args": "{Î± : Type u} {Î² : Type v} [group Î±] [mul_action Î± Î²] [has_faithful_smul Î± Î²]",
    "doc_string": "`mul_action.to_perm` is injective on faithful actions.",
    "type": "function.injective mul_action.to_perm"
  },
  {
    "name": "filter.tendsto.le_comap",
    "statement": "theorem filter.tendsto.le_comap {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚",
    "theorem": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²} : filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚",
    "args": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {lâ‚ : filter Î±} {lâ‚‚ : filter Î²}",
    "doc_string": "**Alias** of the forward direction of filter.tendsto_iff_comap`.",
    "type": "filter.tendsto f lâ‚ lâ‚‚ â†’ lâ‚ â‰¤ filter.comap f lâ‚‚"
  },
  {
    "name": "subgroup.list_prod_mem",
    "statement": "theorem subgroup.list_prod_mem {G : Type u_1} [group G] (K : subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K",
    "theorem": "{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K",
    "args": "{G : Type u_1} [group G] (K : subgroup G) {l : list G}",
    "doc_string": "Product of a list of elements in a subgroup is in the subgroup.",
    "type": "(âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.prod âˆˆ K"
  },
  {
    "name": "real.nat_sqrt_le_real_sqrt",
    "statement": "theorem real.nat_sqrt_le_real_sqrt {a : â„•} : â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a",
    "theorem": "{a : â„•} : â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a",
    "args": "{a : â„•}",
    "doc_string": "The natural square root is at most the real square root",
    "type": "â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a"
  },
  {
    "name": "nat.dvd_right_iff_eq",
    "statement": "theorem nat.dvd_right_iff_eq {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n",
    "theorem": "{m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n",
    "args": "{m n : â„•}",
    "doc_string": "Two natural numbers are equal if and only if the have the same multiples.",
    "type": "(âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n"
  },
  {
    "name": "eq.superset",
    "statement": "theorem eq.superset {Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ b âŠ† a",
    "theorem": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset] : a = b â†’ b âŠ† a",
    "args": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_refl Î± has_subset.subset]",
    "doc_string": "**Alias** of superset_of_eq`.",
    "type": "a = b â†’ b âŠ† a"
  },
  {
    "name": "is_group_hom.id",
    "statement": "theorem is_group_hom.id {Î± : Type u} [group Î±] : is_group_hom id",
    "theorem": "{Î± : Type u} [group Î±] : is_group_hom id",
    "args": "{Î± : Type u} [group Î±]",
    "doc_string": "The identity is a group homomorphism.",
    "type": "is_group_hom id"
  },
  {
    "name": "function.injective.pairwise_ne",
    "statement": "theorem function.injective.pairwise_ne {Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)",
    "theorem": "{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±} : function.injective f â†’ pairwise (ne on f)",
    "args": "{Î± : Type u_1} {Î¹ : Type u_2} {f : Î¹ â†’ Î±}",
    "doc_string": "**Alias** of the forward direction of function.injective_iff_pairwise_ne`.",
    "type": "function.injective f â†’ pairwise (ne on f)"
  },
  {
    "name": "sym.map_id'",
    "statement": "theorem sym.map_id' {Î± : Type u_1} {n : â„•} (s : sym Î± n) : sym.map (Î» (x : Î±), x) s = s",
    "theorem": "{Î± : Type u_1} {n : â„•} (s : sym Î± n) : sym.map (Î» (x : Î±), x) s = s",
    "args": "{Î± : Type u_1} {n : â„•} (s : sym Î± n)",
    "doc_string": "Note: `sym.map_id` is not simp-normal, as simp ends up unfolding `id` with `sym.map_congr`",
    "type": "sym.map (Î» (x : Î±), x) s = s"
  },
  {
    "name": "eq.trans_ge",
    "statement": "theorem eq.trans_ge {Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : b = c â†’ a â‰¤ b â†’ a â‰¤ c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of le_of_eq_of_le'`.",
    "type": "b = c â†’ a â‰¤ b â†’ a â‰¤ c"
  },
  {
    "name": "matrix.is_unit_diagonal",
    "statement": "theorem matrix.is_unit_diagonal {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±}",
    "doc_string": "When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`.",
    "type": "is_unit (matrix.diagonal v) â†” is_unit v"
  },
  {
    "name": "ordered_add_comm_group.lt_of_add_lt_add_left",
    "statement": "theorem ordered_add_comm_group.lt_of_add_lt_add_left {Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c",
    "theorem": "{Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c) : b < c",
    "args": "{Î± : Type u_1} [has_add Î±] [has_lt Î±] [contravariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} (bc : a + b < a + c)",
    "doc_string": "**Alias** of lt_of_mul_lt_mul_left'`.",
    "type": "b < c"
  },
  {
    "name": "dvd_add_self_right",
    "statement": "theorem dvd_add_self_right {Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b",
    "theorem": "{Î± : Type u} [ring Î±] {a b : Î±} : a âˆ£ b + a â†” a âˆ£ b",
    "args": "{Î± : Type u} [ring Î±] {a b : Î±}",
    "doc_string": "An element a divides the sum b + a if and only if a divides b.",
    "type": "a âˆ£ b + a â†” a âˆ£ b"
  },
  {
    "name": "dense.inter_of_open_right",
    "statement": "theorem dense.inter_of_open_right {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)",
    "theorem": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t)",
    "args": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t)",
    "doc_string": "The intersection of a dense set with an open dense set is a dense set.",
    "type": "dense (s âˆ© t)"
  },
  {
    "name": "left.add_nonpos",
    "statement": "theorem left.add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonpos`.",
    "type": "a + b â‰¤ 0"
  },
  {
    "name": "submonoid.closure_le",
    "statement": "theorem submonoid.closure_le {M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s â‰¤ S â†” s âŠ† â†‘S",
    "theorem": "{M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M} : submonoid.closure s â‰¤ S â†” s âŠ† â†‘S",
    "args": "{M : Type u_1} [mul_one_class M] {s : set M} {S : submonoid M}",
    "doc_string": "A submonoid `S` includes `closure s` if and only if it includes `s`.",
    "type": "submonoid.closure s â‰¤ S â†” s âŠ† â†‘S"
  },
  {
    "name": "function.cantor_surjective",
    "statement": "theorem function.cantor_surjective {Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f",
    "theorem": "{Î± : Type u_1} (f : Î± â†’ set Î±) : Â¬function.surjective f",
    "args": "{Î± : Type u_1} (f : Î± â†’ set Î±)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no surjective functions from `Î±` to `set Î±`.",
    "type": "Â¬function.surjective f"
  },
  {
    "name": "is_open.is_GÎ´",
    "statement": "theorem is_open.is_GÎ´ {Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s",
    "theorem": "{Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s",
    "args": "{Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s)",
    "doc_string": "An open set is a GÎ´ set.",
    "type": "is_GÎ´ s"
  },
  {
    "name": "list.exists_of_mem_map",
    "statement": "theorem list.exists_of_mem_map {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)",
    "theorem": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±} : b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)",
    "args": "{Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {b : Î²} {l : list Î±}",
    "doc_string": "**Alias** of the forward direction of list.mem_map`.",
    "type": "b âˆˆ list.map f l â†’ (âˆƒ (a : Î±), a âˆˆ l âˆ§ f a = b)"
  },
  {
    "name": "is_add_right_regular.add",
    "statement": "theorem is_add_right_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-right-regular elements is add-right-regular.",
    "type": "is_add_right_regular (a + b)"
  },
  {
    "name": "filter.tendsto.germ_tendsto",
    "statement": "theorem filter.tendsto.germ_tendsto {Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²} : filter.tendsto f l lb â†’ â†‘f.tendsto lb",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {l : filter Î±} {f : Î± â†’ Î²} {lb : filter Î²}",
    "doc_string": "**Alias** of the reverse direction of filter.germ.coe_tendsto`.",
    "type": "filter.tendsto f l lb â†’ â†‘f.tendsto lb"
  },
  {
    "name": "add_tsub_le_right",
    "statement": "theorem add_tsub_le_right {Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a",
    "theorem": "{Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±} : a + b - b â‰¤ a",
    "args": "{Î± : Type u_1} [preorder Î±] [has_add Î±] [has_sub Î±] [has_ordered_sub Î±] {a b : Î±}",
    "doc_string": "See `add_tsub_cancel_right` for the equality if `contravariant_class Î± Î± (+) (â‰¤)`.",
    "type": "a + b - b â‰¤ a"
  },
  {
    "name": "exists_prime_order_of_dvd_card",
    "statement": "theorem exists_prime_order_of_dvd_card {G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p",
    "theorem": "{G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G) : âˆƒ (x : G), order_of x = p",
    "args": "{G : Type u_1} [group G] [fintype G] (p : â„•) [hp : fact (nat.prime p)] (hdvd : p âˆ£ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem.",
    "type": "âˆƒ (x : G), order_of x = p"
  },
  {
    "name": "lt_sub_right_of_add_lt",
    "statement": "theorem lt_sub_right_of_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±} : a + b < c â†’ a < c - b",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt`.",
    "type": "a + b < c â†’ a < c - b"
  },
  {
    "name": "ordinal.eq_enum_ord",
    "statement": "theorem ordinal.eq_enum_ord {S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S",
    "theorem": "{S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S",
    "args": "{S : set ordinal} (f : ordinal â†’ ordinal) (hS : set.unbounded has_lt.lt S)",
    "doc_string": "A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`.",
    "type": "strict_mono f âˆ§ set.range f = S â†” f = ordinal.enum_ord S"
  },
  {
    "name": "is_regular_mul_and_mul_iff",
    "statement": "theorem is_regular_mul_and_mul_iff {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R]",
    "doc_string": "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular.",
    "type": "is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b"
  },
  {
    "name": "padic_norm.padic_norm_of_prime_of_ne",
    "statement": "theorem padic_norm.padic_norm_of_prime_of_ne {p q : â„•} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p â‰  q) : padic_norm p â†‘q = 1",
    "theorem": "{p q : â„•} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p â‰  q) : padic_norm p â†‘q = 1",
    "args": "{p q : â„•} [p_prime : fact (nat.prime p)] [q_prime : fact (nat.prime q)] (neq : p â‰  q)",
    "doc_string": "The p-adic norm of `q` is `1` if `q` is prime and not equal to `p`.",
    "type": "padic_norm p â†‘q = 1"
  },
  {
    "name": "finset.min'_lt_max'_of_card",
    "statement": "theorem finset.min'_lt_max'_of_card {Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _",
    "theorem": "{Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card) : s.min' _ < s.max' _",
    "args": "{Î± : Type u_1} [linear_order Î±] (s : finset Î±) (hâ‚‚ : 1 < s.card)",
    "doc_string": "If there's more than 1 element, the min' is less than the max'. An alternate version of `min'_lt_max'` which is sometimes more convenient.",
    "type": "s.min' _ < s.max' _"
  },
  {
    "name": "is_totally_disconnected_of_clopen_set",
    "statement": "theorem is_totally_disconnected_of_clopen_set {X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ",
    "theorem": "{X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ",
    "args": "{X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U))",
    "doc_string": "Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there  is some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected.",
    "type": "is_totally_disconnected set.univ"
  },
  {
    "name": "right.one_lt_mul_of_le_of_lt",
    "statement": "theorem right.one_lt_mul_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "decidable.em",
    "statement": "theorem decidable.em (p : Prop) [decidable p] : p âˆ¨ Â¬p",
    "theorem": "(p : Prop) [decidable p] : p âˆ¨ Â¬p",
    "args": "(p : Prop) [decidable p]",
    "doc_string": "Law of Excluded Middle.",
    "type": "p âˆ¨ Â¬p"
  },
  {
    "name": "add_submonoid.list_sum_mem",
    "statement": "theorem add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s",
    "theorem": "{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) : l.sum âˆˆ s",
    "args": "{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s)",
    "doc_string": "Sum of a list of elements in an `add_submonoid` is in the `add_submonoid`.",
    "type": "l.sum âˆˆ s"
  },
  {
    "name": "subgroup.one_mem",
    "statement": "theorem subgroup.one_mem {G : Type u_1} [group G] (H : subgroup G) : 1 âˆˆ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : 1 âˆˆ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "A subgroup contains the group's 1.",
    "type": "1 âˆˆ H"
  },
  {
    "name": "right.add_neg'",
    "statement": "theorem right.add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "finset.card_le_one_of_subsingleton",
    "statement": "theorem finset.card_le_one_of_subsingleton {Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1",
    "theorem": "{Î± : Type u_1} [subsingleton Î±] (s : finset Î±) : s.card â‰¤ 1",
    "args": "{Î± : Type u_1} [subsingleton Î±] (s : finset Î±)",
    "doc_string": "A `finset` of a subsingleton type has cardinality at most one.",
    "type": "s.card â‰¤ 1"
  },
  {
    "name": "is_add_right_regular_of_add_eq_zero",
    "statement": "theorem is_add_right_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0)",
    "doc_string": "An element admitting a right additive opposite is add-right-regular.",
    "type": "is_add_right_regular a"
  },
  {
    "name": "empty_wf",
    "statement": "theorem empty_wf {Î± : Sort u} : well_founded empty_relation",
    "theorem": "{Î± : Sort u} : well_founded empty_relation",
    "args": "{Î± : Sort u}",
    "doc_string": "Empty relation is well-founded",
    "type": "well_founded empty_relation"
  },
  {
    "name": "pnat.xgcd_type.step_v",
    "statement": "theorem pnat.xgcd_type.step_v (u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap",
    "theorem": "(u : pnat.xgcd_type) (hr : u.r â‰  0) : u.step.v = u.v.swap",
    "args": "(u : pnat.xgcd_type) (hr : u.r â‰  0)",
    "doc_string": "The reduction step does not change the product vector.",
    "type": "u.step.v = u.v.swap"
  },
  {
    "name": "subset_span_points",
    "statement": "theorem subset_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s âŠ† span_points k s",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": "A set is contained in its `span_points`.",
    "type": "s âŠ† span_points k s"
  },
  {
    "name": "order.lt_of_succ_lt_succ",
    "statement": "theorem order.lt_of_succ_lt_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b",
    "theorem": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a < order.succ b â†’ a < b",
    "args": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±]",
    "doc_string": "**Alias** of the forward direction of order.succ_lt_succ_iff`.",
    "type": "order.succ a < order.succ b â†’ a < b"
  },
  {
    "name": "turing.list_blank.cons_head_tail",
    "statement": "theorem turing.list_blank.cons_head_tail {Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l",
    "theorem": "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“) : turing.list_blank.cons l.head l.tail = l",
    "args": "{Î“ : Type u_1} [inhabited Î“] (l : turing.list_blank Î“)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "type": "turing.list_blank.cons l.head l.tail = l"
  },
  {
    "name": "ordinal.opow_le_iff_le_log",
    "statement": "theorem ordinal.opow_le_iff_le_log {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x",
    "theorem": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x",
    "args": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x)",
    "doc_string": "`opow b` and `log b` (almost) form a Galois connection.",
    "type": "b ^ c â‰¤ x â†” c â‰¤ ordinal.log b x"
  },
  {
    "name": "fin_injective",
    "statement": "theorem fin_injective  : function.injective fin",
    "theorem": " : function.injective fin",
    "args": "",
    "doc_string": " `fin` as a map from `â„•` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible.",
    "type": "function.injective fin"
  },
  {
    "name": "submodule.torsion_by_set_eq_torsion_by_span",
    "statement": "theorem submodule.torsion_by_set_eq_torsion_by_span {R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)",
    "args": "{R : Type u_1} {M : Type u_2} [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R)",
    "doc_string": "Torsion by a set is torsion by the ideal generated by it.",
    "type": "submodule.torsion_by_set R M s = submodule.torsion_by_set R M â†‘(ideal.span s)"
  },
  {
    "name": "con.mk'_ker",
    "statement": "theorem con.mk'_ker {M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "args": "{M : Type u_1} [mul_one_class M] (c : con M)",
    "doc_string": "The kernel of the natural homomorphism from a monoid to its quotient by a congruence    relation `c` equals `c`.",
    "type": "con.ker c.mk' = c"
  },
  {
    "name": "list.nat.mem_antidiagonal",
    "statement": "theorem list.nat.mem_antidiagonal {n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n",
    "theorem": "{n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n",
    "args": "{n : â„•} {x : â„• Ã— â„•}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "type": "x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n"
  },
  {
    "name": "matrix.fin.circulant_ite",
    "statement": "theorem matrix.fin.circulant_ite (Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1",
    "theorem": "(Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•) : matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1",
    "args": "(Î± : Type u_1) [has_zero Î±] [has_one Î±] (n : â„•)",
    "doc_string": " Note we use `â†‘i = 0` instead of `i = 0` as `fin 0` has no `0`. This means that we cannot state this with `pi.single` as we did with `matrix.circulant_single`.",
    "type": "matrix.circulant (Î» (i : fin n), ite (â†‘i = 0) 1 0) = 1"
  },
  {
    "name": "sq",
    "statement": "theorem sq {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "**Alias** of pow_two`.",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "exists_compact_mem_nhds",
    "statement": "theorem exists_compact_mem_nhds {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±) : âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x",
    "theorem": "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±) : âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x",
    "args": "{Î± : Type u} [topological_space Î±] [locally_compact_space Î±] (x : Î±)",
    "doc_string": "In a locally compact space every point has a compact neighborhood.",
    "type": "âˆƒ (K : set Î±), is_compact K âˆ§ K âˆˆ nhds x"
  },
  {
    "name": "left.one_lt_mul_of_lt_of_le",
    "statement": "theorem left.one_lt_mul_of_lt_of_le {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 â‰¤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`.",
    "type": "1 < a * b"
  },
  {
    "name": "list.Ico.trichotomy",
    "statement": "theorem list.Ico.trichotomy (n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b",
    "theorem": "(n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b",
    "args": "(n a b : â„•)",
    "doc_string": "For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n â‰¥ b 3. n âˆˆ Ico a b",
    "type": "n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b"
  },
  {
    "name": "category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C}",
    "doc_string": "Given all finite wide pullbacks in `C`, construct finite products in `C/B`.",
    "type": "category_theory.limits.has_finite_products (category_theory.over B)"
  },
  {
    "name": "is_monoid_hom.id",
    "statement": "theorem is_monoid_hom.id {Î± : Type u} [mul_one_class Î±] : is_monoid_hom id",
    "theorem": "{Î± : Type u} [mul_one_class Î±] : is_monoid_hom id",
    "args": "{Î± : Type u} [mul_one_class Î±]",
    "doc_string": "The identity map is a monoid homomorphism.",
    "type": "is_monoid_hom id"
  },
  {
    "name": "padic_norm.padic_norm_p_of_prime",
    "statement": "theorem padic_norm.padic_norm_p_of_prime (p : â„•) [fact (nat.prime p)] : padic_norm p â†‘p = 1 / â†‘p",
    "theorem": "(p : â„•) [fact (nat.prime p)] : padic_norm p â†‘p = 1 / â†‘p",
    "args": "(p : â„•) [fact (nat.prime p)]",
    "doc_string": "The p-adic norm of `p` is `1/p` if `p` is prime.  See also `padic_norm.padic_norm_p` for a version that assumes `1 < p`.",
    "type": "padic_norm p â†‘p = 1 / â†‘p"
  },
  {
    "name": "nat.prime.sq_add_sq",
    "statement": "theorem nat.prime.sq_add_sq {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p",
    "theorem": "{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p",
    "args": "{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1)",
    "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
    "type": "âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p"
  },
  {
    "name": "commute.symm",
    "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "theorem": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "args": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "type": "commute b a"
  },
  {
    "name": "pos_of_neg_neg",
    "statement": "theorem pos_of_neg_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±} : -a < 0 â†’ 0 < a",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of left.inv_lt_one_iff`.",
    "type": "-a < 0 â†’ 0 < a"
  },
  {
    "name": "category_theory.limits.colimits_from_coequalizers_and_coproducts",
    "statement": "theorem category_theory.limits.colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with coproducts and coequalizers has all colimits.  See <https://stacks.math.columbia.edu/tag/002P>.",
    "type": "category_theory.limits.has_colimits C"
  },
  {
    "name": "one_le_of_inv_le_one",
    "statement": "theorem one_le_of_inv_le_one {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "type": "aâ»Â¹ â‰¤ 1 â†’ 1 â‰¤ a"
  },
  {
    "name": "list.eq_iff_join_eq",
    "statement": "theorem list.eq_iff_join_eq {Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'",
    "theorem": "{Î± : Type u_1} (L L' : list (list Î±)) : L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'",
    "args": "{Î± : Type u_1} (L L' : list (list Î±))",
    "doc_string": " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the sublists.",
    "type": "L = L' â†” L.join = L'.join âˆ§ list.map list.length L = list.map list.length L'"
  },
  {
    "name": "setoid.eqv_gen_of_setoid",
    "statement": "theorem setoid.eqv_gen_of_setoid {Î± : Type u_1} (r : setoid Î±) : eqv_gen.setoid setoid.r = r",
    "theorem": "{Î± : Type u_1} (r : setoid Î±) : eqv_gen.setoid setoid.r = r",
    "args": "{Î± : Type u_1} (r : setoid Î±)",
    "doc_string": "The equivalence closure of an equivalence relation r is r.",
    "type": "eqv_gen.setoid setoid.r = r"
  },
  {
    "name": "add_commute.add_right",
    "statement": "theorem add_commute.add_right {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "theorem": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "args": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their sum.",
    "type": "add_commute a (b + c)"
  },
  {
    "name": "real.sinh_surjective",
    "statement": "theorem real.sinh_surjective  : function.surjective real.sinh",
    "theorem": " : function.surjective real.sinh",
    "args": "",
    "doc_string": "`sinh` is surjective, `âˆ€ b, âˆƒ a, sinh a = b`. In this case, we use `a = arsinh b`.",
    "type": "function.surjective real.sinh"
  },
  {
    "name": "mem_residual",
    "statement": "theorem mem_residual {Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t",
    "theorem": "{Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±} : s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t",
    "args": "{Î± : Type u_1} [topological_space Î±] [baire_space Î±] {s : set Î±}",
    "doc_string": "A set is residual (comeagre) if and only if it includes a dense `GÎ´` set.",
    "type": "s âˆˆ residual Î± â†” âˆƒ (t : set Î±) (H : t âŠ† s), is_GÎ´ t âˆ§ dense t"
  },
  {
    "name": "le_nhds_iff",
    "statement": "theorem le_nhds_iff {Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f",
    "theorem": "{Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±} : f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f",
    "args": "{Î± : Type u} [topological_space Î±] {f : filter Î±} {a : Î±}",
    "doc_string": "A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`.",
    "type": "f â‰¤ nhds a â†” âˆ€ (s : set Î±), a âˆˆ s â†’ is_open s â†’ s âˆˆ f"
  },
  {
    "name": "add_con.ext'_iff",
    "statement": "theorem add_con.ext'_iff {M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r â†” c = d",
    "theorem": "{M : Type u_1} [has_add M] {c d : add_con M} : setoid.r = setoid.r â†” c = d",
    "args": "{M : Type u_1} [has_add M] {c d : add_con M}",
    "doc_string": "Two additive congruence relations are equal iff their underlying binary relations are equal.",
    "type": "setoid.r = setoid.r â†” c = d"
  },
  {
    "name": "sub_nonpos_of_le",
    "statement": "theorem sub_nonpos_of_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : a â‰¤ b â†’ a - b â‰¤ 0",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of sub_nonpos`.",
    "type": "a â‰¤ b â†’ a - b â‰¤ 0"
  },
  {
    "name": "is_add_unit.is_add_regular",
    "statement": "theorem is_add_unit.is_add_regular {R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "theorem": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "args": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a)",
    "doc_string": "An additive unit in an additive monoid is add-regular.",
    "type": "is_add_regular a"
  },
  {
    "name": "add_submonoid.closure_le",
    "statement": "theorem add_submonoid.closure_le {M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S",
    "theorem": "{M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M} : add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S",
    "args": "{M : Type u_1} [add_zero_class M] {s : set M} {S : add_submonoid M}",
    "doc_string": "An additive submonoid `S` includes `closure s` if and only if it includes `s`",
    "type": "add_submonoid.closure s â‰¤ S â†” s âŠ† â†‘S"
  },
  {
    "name": "matrix.cons_val_one",
    "statement": "theorem matrix.cons_val_one {Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "theorem": "{Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "args": "{Î± : Type u} {m : â„•} (x : Î±) (u : fin m.succ â†’ Î±)",
    "doc_string": "`![a, b, ...] 1` is equal to `b`.   The simplifier needs a special lemma for length `â‰¥ 2`, in addition to  `cons_val_succ`, because `1 : fin 1 = 0 : fin 1`.",
    "type": "matrix.vec_cons x u 1 = matrix.vec_head u"
  },
  {
    "name": "function.injective.nontrivial",
    "statement": "theorem function.injective.nontrivial {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) : nontrivial Î²",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f)",
    "doc_string": "Pushforward a `nontrivial` instance along an injective function.",
    "type": "nontrivial Î²"
  },
  {
    "name": "nat.choose_le_middle",
    "statement": "theorem nat.choose_le_middle (r n : â„•) : n.choose r â‰¤ n.choose (n / 2)",
    "theorem": "(r n : â„•) : n.choose r â‰¤ n.choose (n / 2)",
    "args": "(r n : â„•)",
    "doc_string": "`choose n r` is maximised when `r` is `n/2`.",
    "type": "n.choose r â‰¤ n.choose (n / 2)"
  },
  {
    "name": "is_add_monoid_hom.id",
    "statement": "theorem is_add_monoid_hom.id {Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id",
    "theorem": "{Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id",
    "args": "{Î± : Type u} [add_zero_class Î±]",
    "doc_string": "The identity map is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom id"
  },
  {
    "name": "function.injective.nat_tendsto_at_top",
    "statement": "theorem function.injective.nat_tendsto_at_top {f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "theorem": "{f : â„• â†’ â„•} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "args": "{f : â„• â†’ â„•} (hf : function.injective f)",
    "doc_string": "An injective sequence `f : â„• â†’ â„•` tends to infinity at infinity.",
    "type": "filter.tendsto f filter.at_top filter.at_top"
  },
  {
    "name": "vector.singleton_tail",
    "statement": "theorem vector.singleton_tail {Î± : Type u_1} (v : vector Î± 1) : v.tail = vector.nil",
    "theorem": "{Î± : Type u_1} (v : vector Î± 1) : v.tail = vector.nil",
    "args": "{Î± : Type u_1} (v : vector Î± 1)",
    "doc_string": "The `tail` of a vector made up of one element is `nil`.",
    "type": "v.tail = vector.nil"
  },
  {
    "name": "finset.exists_intermediate_set",
    "statement": "theorem finset.exists_intermediate_set {Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card",
    "theorem": "{Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A) : âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card",
    "args": "{Î± : Type u_1} {A B : finset Î±} (i : â„•) (hâ‚ : i + B.card â‰¤ A.card) (hâ‚‚ : B âŠ† A)",
    "doc_string": " Given a set `A` and a set `B` inside it, we can shrink `A` to any appropriate size, and keep `B` inside it.",
    "type": "âˆƒ (C : finset Î±), B âŠ† C âˆ§ C âŠ† A âˆ§ C.card = i + B.card"
  },
  {
    "name": "is_add_regular_zero",
    "statement": "theorem is_add_regular_zero {R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "theorem": "{R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "args": "{R : Type u_1} [add_zero_class R]",
    "doc_string": "If adding `0` on either side is the identity, `0` is regular.",
    "type": "is_add_regular 0"
  },
  {
    "name": "not_is_regular_zero",
    "statement": "theorem not_is_regular_zero {R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nontrivial R] : Â¬is_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not regular -- with typeclasses.",
    "type": "Â¬is_regular 0"
  },
  {
    "name": "left.add_pos_of_nonneg_of_pos",
    "statement": "theorem left.add_pos_of_nonneg_of_pos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : 0 â‰¤ a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`.",
    "type": "0 < a + b"
  },
  {
    "name": "implies.trans",
    "statement": "theorem implies.trans {p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r",
    "theorem": "{p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r) : implies p r",
    "args": "{p q r : Prop} (hâ‚ : implies p q) (hâ‚‚ : implies q r)",
    "doc_string": "Implication `â†’` is transitive. If `P â†’ Q` and `Q â†’ R` then `P â†’ R`.",
    "type": "implies p r"
  },
  {
    "name": "has_le.le.lt_or_eq_dec",
    "statement": "theorem has_le.le.lt_or_eq_dec {Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b",
    "theorem": "{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b) : a < b âˆ¨ a = b",
    "args": "{Î± : Type u} [partial_order Î±] [decidable_rel has_le.le] {a b : Î±} (hab : a â‰¤ b)",
    "doc_string": "**Alias** of decidable.lt_or_eq_of_le`.",
    "type": "a < b âˆ¨ a = b"
  },
  {
    "name": "lt_of_sub_neg",
    "statement": "theorem lt_of_sub_neg {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a - b < 0 â†’ a < b",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of sub_neg`.",
    "type": "a - b < 0 â†’ a < b"
  },
  {
    "name": "has_le.le.trans_eq",
    "statement": "theorem has_le.le.trans_eq {Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c) : a â‰¤ c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±} (hab : a â‰¤ b) (hbc : b = c)",
    "doc_string": "**Alias** of le_of_le_of_eq`.",
    "type": "a â‰¤ c"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct.of_has_binary_coproduct",
    "statement": "theorem category_theory.limits.has_binary_biproduct.of_has_binary_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y]",
    "doc_string": "In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists.",
    "type": "category_theory.limits.has_binary_biproduct X Y"
  },
  {
    "name": "category_theory.limits.has_binary_coproducts_of_has_colimit_pair",
    "statement": "theorem category_theory.limits.has_binary_coproducts_of_has_colimit_pair (C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [âˆ€ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)]",
    "doc_string": "If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts",
    "type": "category_theory.limits.has_binary_coproducts C"
  },
  {
    "name": "finset.nat.antidiagonal_congr",
    "statement": "theorem finset.nat.antidiagonal_congr {n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n) : p = q â†” p.fst = q.fst",
    "theorem": "{n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n) : p = q â†” p.fst = q.fst",
    "args": "{n : â„•} {p q : â„• Ã— â„•} (hp : p âˆˆ finset.nat.antidiagonal n) (hq : q âˆˆ finset.nat.antidiagonal n)",
    "doc_string": "A point in the antidiagonal is determined by its first co-ordinate.",
    "type": "p = q â†” p.fst = q.fst"
  },
  {
    "name": "quaternion_group.order_of_xa",
    "statement": "theorem quaternion_group.order_of_xa {n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "theorem": "{n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "args": "{n : â„•} [hpos : fact (0 < n)] (i : zmod (2 * n))",
    "doc_string": "If `0 < n`, then `xa i` has order 4.",
    "type": "order_of (quaternion_group.xa i) = 4"
  },
  {
    "name": "is_add_regular_add_iff",
    "statement": "theorem is_add_regular_add_iff {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_comm_semigroup R]",
    "doc_string": "A sum is add-regular if and only if the summands are.",
    "type": "is_add_regular (a + b) â†” is_add_regular a âˆ§ is_add_regular b"
  },
  {
    "name": "left.one_lt_mul_of_le_of_lt",
    "statement": "theorem left.one_lt_mul_of_le_of_lt {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`.",
    "type": "1 < a * b"
  },
  {
    "name": "function.is_fixed_pt.left_of_comp",
    "statement": "theorem function.is_fixed_pt.left_of_comp {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "theorem": "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "args": "{Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x)",
    "doc_string": "If `x` is a fixed point of `f âˆ˜ g` and `g`, then it is a fixed point of `f`.",
    "type": "function.is_fixed_pt f x"
  },
  {
    "name": "free_group.reduce.eq_of_red",
    "statement": "theorem free_group.reduce.eq_of_red {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚",
    "theorem": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚",
    "args": "{Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.red Lâ‚ Lâ‚‚)",
    "doc_string": " If a word reduces to another word, then they have a common maximal reduction.",
    "type": "free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚"
  },
  {
    "name": "lt_inv_of_lt_inv",
    "statement": "theorem lt_inv_of_lt_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} : a < bâ»Â¹ â†’ b < aâ»Â¹",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of lt_inv'`.",
    "type": "a < bâ»Â¹ â†’ b < aâ»Â¹"
  },
  {
    "name": "nat.dvd_left_iff_eq",
    "statement": "theorem nat.dvd_left_iff_eq {m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n",
    "theorem": "{m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n",
    "args": "{m n : â„•}",
    "doc_string": "Two natural numbers are equal if and only if the have the same divisors.",
    "type": "(âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n"
  },
  {
    "name": "vector.reverse_nth_zero",
    "statement": "theorem vector.reverse_nth_zero {n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last",
    "theorem": "{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)} : v.reverse.head = v.last",
    "args": "{n : â„•} {Î± : Type u_1} {v : vector Î± (n + 1)}",
    "doc_string": "The `last` element of a vector is the `head` of the `reverse` vector.",
    "type": "v.reverse.head = v.last"
  },
  {
    "name": "has_le.le.trans",
    "statement": "theorem has_le.le.trans {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of le_trans`.",
    "type": "a â‰¤ b â†’ b â‰¤ c â†’ a â‰¤ c"
  },
  {
    "name": "is_add_group_hom.id",
    "statement": "theorem is_add_group_hom.id {Î± : Type u} [add_group Î±] : is_add_group_hom id",
    "theorem": "{Î± : Type u} [add_group Î±] : is_add_group_hom id",
    "args": "{Î± : Type u} [add_group Î±]",
    "doc_string": "The identity is an additive group homomorphism.",
    "type": "is_add_group_hom id"
  },
  {
    "name": "is_submonoid.multiset_prod_mem",
    "statement": "theorem is_submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s",
    "theorem": "{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s",
    "args": "{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M)",
    "doc_string": " The product of a multiset of elements of a submonoid of a `comm_monoid` is an element of the submonoid.",
    "type": "(âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.prod âˆˆ s"
  },
  {
    "name": "ordered_semiring.to_char_zero",
    "statement": "theorem ordered_semiring.to_char_zero {R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "theorem": "{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "args": "{R : Type u_1} [ordered_semiring R] [nontrivial R]",
    "doc_string": " Note this is not an instance as `char_zero` implies `nontrivial`, and this would risk forming a loop.",
    "type": "char_zero R"
  },
  {
    "name": "dense_inducing_pure",
    "statement": "theorem dense_inducing_pure {Î± : Type u} : dense_inducing has_pure.pure",
    "theorem": "{Î± : Type u} : dense_inducing has_pure.pure",
    "args": "{Î± : Type u}",
    "doc_string": "`pure : Î± â†’ ultrafilter Î±` defines a dense inducing of `Î±` in `ultrafilter Î±`.",
    "type": "dense_inducing has_pure.pure"
  },
  {
    "name": "exp_neg_inv_glue.f_aux_zero_eq",
    "statement": "theorem exp_neg_inv_glue.f_aux_zero_eq  : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "theorem": " : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "args": "",
    "doc_string": "The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition.",
    "type": "exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue"
  },
  {
    "name": "set.sized.union",
    "statement": "theorem set.sized.union {Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)",
    "theorem": "{Î± : Type u_1} {A B : set (finset Î±)} {r : â„•} : set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)",
    "args": "{Î± : Type u_1} {A B : set (finset Î±)} {r : â„•}",
    "doc_string": "**Alias** of the reverse direction of set.sized_union`.",
    "type": "set.sized r A âˆ§ set.sized r B â†’ set.sized r (A âˆª B)"
  },
  {
    "name": "dihedral_group.order_of_sr",
    "statement": "theorem dihedral_group.order_of_sr {n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "theorem": "{n : â„•} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "args": "{n : â„•} (i : zmod n)",
    "doc_string": "If `0 < n`, then `sr i` has order 2.",
    "type": "order_of (dihedral_group.sr i) = 2"
  },
  {
    "name": "equiv.coe_fn_injective",
    "statement": "theorem equiv.coe_fn_injective {Î± : Sort u} {Î² : Sort v} : function.injective coe_fn",
    "theorem": "{Î± : Sort u} {Î² : Sort v} : function.injective coe_fn",
    "args": "{Î± : Sort u} {Î² : Sort v}",
    "doc_string": "The map `coe_fn : (r â‰ƒ s) â†’ (r â†’ s)` is injective.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "order.le_of_succ_le_succ",
    "statement": "theorem order.le_of_succ_le_succ {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b",
    "theorem": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±] : order.succ a â‰¤ order.succ b â†’ a â‰¤ b",
    "args": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a b : Î±} [no_max_order Î±]",
    "doc_string": "**Alias** of the forward direction of order.succ_le_succ_iff`.",
    "type": "order.succ a â‰¤ order.succ b â†’ a â‰¤ b"
  },
  {
    "name": "nat.dvd_add_self_right",
    "statement": "theorem nat.dvd_add_self_right {m n : â„•} : m âˆ£ n + m â†” m âˆ£ n",
    "theorem": "{m n : â„•} : m âˆ£ n + m â†” m âˆ£ n",
    "args": "{m n : â„•}",
    "doc_string": "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.",
    "type": "m âˆ£ n + m â†” m âˆ£ n"
  },
  {
    "name": "le_of_sub_nonneg",
    "statement": "theorem le_of_sub_nonneg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : 0 â‰¤ a - b â†’ b â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of sub_nonneg`.",
    "type": "0 â‰¤ a - b â†’ b â‰¤ a"
  },
  {
    "name": "count_succ_eq_succ_count",
    "statement": "theorem count_succ_eq_succ_count {p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1",
    "theorem": "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : p n â†’ nat.count p (n + 1) = nat.count p n + 1",
    "args": "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_succ_count_iff`.",
    "type": "p n â†’ nat.count p (n + 1) = nat.count p n + 1"
  },
  {
    "name": "nat.sub_succ'",
    "statement": "theorem nat.sub_succ' (a b : â„•) : a - b.succ = a - b - 1",
    "theorem": "(a b : â„•) : a - b.succ = a - b - 1",
    "args": "(a b : â„•)",
    "doc_string": "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`.",
    "type": "a - b.succ = a - b - 1"
  },
  {
    "name": "zmod.nat_cast_zmod_val",
    "statement": "theorem zmod.nat_cast_zmod_val {n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a",
    "theorem": "{n : â„•} [fact (0 < n)] (a : zmod n) : â†‘(a.val) = a",
    "args": "{n : â„•} [fact (0 < n)] (a : zmod n)",
    "doc_string": " So-named because the coercion is `nat.cast` into `zmod`. For `nat.cast` into an arbitrary ring, see `zmod.nat_cast_val`.",
    "type": "â†‘(a.val) = a"
  },
  {
    "name": "list.prod_eq_zero_iff",
    "statement": "theorem list.prod_eq_zero_iff {Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L",
    "theorem": "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€} : L.prod = 0 â†” 0 âˆˆ L",
    "args": "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] [nontrivial Mâ‚€] [no_zero_divisors Mâ‚€] {L : list Mâ‚€}",
    "doc_string": " Product of elements of a list `L` equals zero if and only if `0 âˆˆ L`. See also `list.prod_eq_zero` for an implication that needs weaker typeclass assumptions.",
    "type": "L.prod = 0 â†” 0 âˆˆ L"
  },
  {
    "name": "right.one_lt_mul'",
    "statement": "theorem right.one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "is_right_regular_of_right_cancel_semigroup",
    "statement": "theorem is_right_regular_of_right_cancel_semigroup {R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "theorem": "{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "args": "{R : Type u_1} [right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a right cancel semigroup are right regular.",
    "type": "is_right_regular g"
  },
  {
    "name": "le_nhds_of_cauchy_adhp",
    "statement": "theorem le_nhds_of_cauchy_adhp {Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x",
    "theorem": "{Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f) : f â‰¤ nhds x",
    "args": "{Î± : Type u} [uniform_space Î±] {f : filter Î±} {x : Î±} (hf : cauchy f) (adhs : cluster_pt x f)",
    "doc_string": " If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point for `f`.",
    "type": "f â‰¤ nhds x"
  },
  {
    "name": "real.summable_one_div_nat_pow",
    "statement": "theorem real.summable_one_div_nat_pow {p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p",
    "theorem": "{p : â„•} : summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p",
    "args": "{p : â„•}",
    "doc_string": " Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, 1 / n ^ p` converges if and only if `1 < p`.",
    "type": "summable (Î» (n : â„•), 1 / â†‘n ^ p) â†” 1 < p"
  },
  {
    "name": "no_min_order.infinite",
    "statement": "theorem no_min_order.infinite {Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±",
    "theorem": "{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±] : infinite Î±",
    "args": "{Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_min_order Î±]",
    "doc_string": " A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite Î± â†’ nontrivial Î± â†’ nonempty Î±`.",
    "type": "infinite Î±"
  },
  {
    "name": "filter.at_top_le_cofinite",
    "statement": "theorem filter.at_top_le_cofinite {Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite",
    "theorem": "{Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite",
    "args": "{Î± : Type u_2} [preorder Î±] [no_max_order Î±]",
    "doc_string": "If `Î±` is a preorder with no maximal element, then `at_top â‰¤ cofinite`.",
    "type": "filter.at_top â‰¤ filter.cofinite"
  },
  {
    "name": "nat.upto.wf",
    "statement": "theorem nat.upto.wf {p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)",
    "theorem": "{p : â„• â†’ Prop} : (âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)",
    "args": "{p : â„• â†’ Prop}",
    "doc_string": " The \"greater than\" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`.",
    "type": "(âˆƒ (x : â„•), p x) â†’ well_founded (nat.upto.gt p)"
  },
  {
    "name": "list.drop_append_eq_append_drop",
    "statement": "theorem list.drop_append_eq_append_drop {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚",
    "theorem": "{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚",
    "args": "{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•}",
    "doc_string": " Dropping the elements up to `n` in `lâ‚ ++ lâ‚‚` is the same as dropping the elements up to `n` in `lâ‚`, dropping the elements up to `n - lâ‚.length` in `lâ‚‚`, and appending them.",
    "type": "list.drop n (lâ‚ ++ lâ‚‚) = list.drop n lâ‚ ++ list.drop (n - lâ‚.length) lâ‚‚"
  },
  {
    "name": "add_subgroup.zero_mem",
    "statement": "theorem add_subgroup.zero_mem {G : Type u_1} [add_group G] (H : add_subgroup G) : 0 âˆˆ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 âˆˆ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G)",
    "doc_string": "An `add_subgroup` contains the group's 0.",
    "type": "0 âˆˆ H"
  },
  {
    "name": "finset.exists_smaller_set",
    "statement": "theorem finset.exists_smaller_set {Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i",
    "theorem": "{Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card) : âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i",
    "args": "{Î± : Type u_1} (A : finset Î±) (i : â„•) (hâ‚ : i â‰¤ A.card)",
    "doc_string": "We can shrink `A` to any smaller size.",
    "type": "âˆƒ (B : finset Î±), B âŠ† A âˆ§ B.card = i"
  },
  {
    "name": "dense_range_stone_cech_unit",
    "statement": "theorem dense_range_stone_cech_unit {Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit",
    "theorem": "{Î± : Type u} [topological_space Î±] : dense_range stone_cech_unit",
    "args": "{Î± : Type u} [topological_space Î±]",
    "doc_string": "The image of stone_cech_unit is dense. (But stone_cech_unit need  not be an embedding, for example if Î± is not Hausdorff.)",
    "type": "dense_range stone_cech_unit"
  },
  {
    "name": "category_theory.is_connected_zigzag",
    "statement": "theorem category_theory.is_connected_zigzag {J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚",
    "theorem": "{J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J) : category_theory.zigzag jâ‚ jâ‚‚",
    "args": "{J : Type uâ‚} [category_theory.category J] [category_theory.is_connected J] (jâ‚ jâ‚‚ : J)",
    "doc_string": "In a connected category, any two objects are related by `zigzag`.",
    "type": "category_theory.zigzag jâ‚ jâ‚‚"
  },
  {
    "name": "right.one_le_inv_iff",
    "statement": "theorem right.one_le_inv_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a : Î±}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "type": "1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"
  },
  {
    "name": "matrix.mul_nonsing_inv",
    "statement": "theorem matrix.mul_nonsing_inv {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det) : A.mul Aâ»Â¹ = 1",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) (h : is_unit A.det)",
    "doc_string": "The `nonsing_inv` of `A` is a right inverse.",
    "type": "A.mul Aâ»Â¹ = 1"
  },
  {
    "name": "is_glb.bdd_below",
    "statement": "theorem is_glb.bdd_below {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s",
    "theorem": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a) : bdd_below s",
    "args": "{Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_glb s a)",
    "doc_string": "If `s` has a greatest lower bound, then it is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "padic_norm.one",
    "statement": "theorem padic_norm.one (p : â„•) : padic_norm p 1 = 1",
    "theorem": "(p : â„•) : padic_norm p 1 = 1",
    "args": "(p : â„•)",
    "doc_string": "The p-adic norm of 1 is 1.",
    "type": "padic_norm p 1 = 1"
  },
  {
    "name": "sub_eq_add_neg",
    "statement": "theorem sub_eq_add_neg {G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "theorem": "{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "args": "{G : Type u_1} [sub_neg_monoid G] (a b : G)",
    "doc_string": "Subtracting an element is the same as adding by its negative.  This is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better.",
    "type": "a - b = a + -b"
  },
  {
    "name": "psigma.subtype_ext",
    "statement": "theorem psigma.subtype_ext {Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚",
    "theorem": "{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)} : xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚",
    "args": "{Î± : Sort u_1} {Î² : Sort u_2} {p : Î± â†’ Î² â†’ Prop} {xâ‚€ xâ‚ : Î£' (a : Î±), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of psigma types over an indexed subtype.",
    "type": "xâ‚€.fst = xâ‚.fst â†’ â†‘(xâ‚€.snd) = â†‘(xâ‚.snd) â†’ xâ‚€ = xâ‚"
  },
  {
    "name": "category_theory.over.construct_products.over_binary_product_of_pullback",
    "statement": "theorem category_theory.over.construct_products.over_binary_product_of_pullback {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C}",
    "doc_string": "Given a pullback in `C`, construct a binary product in `C/B`.",
    "type": "category_theory.limits.has_binary_products (category_theory.over B)"
  },
  {
    "name": "group_topology.continuous_inv'",
    "statement": "theorem group_topology.continuous_inv' {Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv",
    "theorem": "{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous has_inv.inv",
    "args": "{Î± : Type u} [group Î±] (g : group_topology Î±)",
    "doc_string": "A version of the global `continuous_inv` suitable for dot notation.",
    "type": "continuous has_inv.inv"
  },
  {
    "name": "add_pos_of_pos_of_nonneg",
    "statement": "theorem add_pos_of_pos_of_nonneg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b) : 0 < a + b",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : 0 < a) (hb : 0 â‰¤ b)",
    "doc_string": "**Alias** of `left.add_pos_of_pos_of_nonneg`.",
    "type": "0 < a + b"
  },
  {
    "name": "nat.eq_prime_pow_of_dvd_least_prime_pow",
    "statement": "theorem nat.eq_prime_pow_of_dvd_least_prime_pow {a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)",
    "theorem": "{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1)",
    "args": "{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1))",
    "doc_string": "If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`.",
    "type": "a = p ^ (k + 1)"
  },
  {
    "name": "zero_ne_one",
    "statement": "theorem zero_ne_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€] : 0 â‰  1",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] [nontrivial Mâ‚€]",
    "doc_string": "In a nontrivial monoid with zero, zero and one are different.",
    "type": "0 â‰  1"
  },
  {
    "name": "finset.subtype_map",
    "statement": "theorem finset.subtype_map {Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "theorem": "{Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "args": "{Î± : Type u_1} {s : finset Î±} (p : Î± â†’ Prop) [decidable_pred p]",
    "doc_string": " `s.subtype p` converts back to `s.filter p` with `embedding.subtype`.",
    "type": "finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s"
  },
  {
    "name": "nat.le_pow_iff_clog_le",
    "statement": "theorem nat.le_pow_iff_clog_le {b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y",
    "theorem": "{b : â„•} (hb : 1 < b) {x y : â„•} : x â‰¤ b ^ y â†” nat.clog b x â‰¤ y",
    "args": "{b : â„•} (hb : 1 < b) {x y : â„•}",
    "doc_string": "`clog b` and `pow b` form a Galois connection.",
    "type": "x â‰¤ b ^ y â†” nat.clog b x â‰¤ y"
  },
  {
    "name": "uniform_inducing.uniform_embedding",
    "statement": "theorem uniform_inducing.uniform_embedding {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f)",
    "doc_string": " If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`.",
    "type": "uniform_embedding f"
  },
  {
    "name": "nat.exists_strict_mono",
    "statement": "theorem nat.exists_strict_mono (Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f",
    "theorem": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f",
    "args": "(Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±]",
    "doc_string": " If `Î±` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `â„• â†’ Î±`.",
    "type": "âˆƒ (f : â„• â†’ Î±), strict_mono f"
  },
  {
    "name": "is_square.inv",
    "statement": "theorem is_square.inv {Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹",
    "theorem": "{Î± : Type u_2} [division_monoid Î±] {a : Î±} : is_square a â†’ is_square aâ»Â¹",
    "args": "{Î± : Type u_2} [division_monoid Î±] {a : Î±}",
    "doc_string": "**Alias** of the reverse direction of is_square_inv`.",
    "type": "is_square a â†’ is_square aâ»Â¹"
  },
  {
    "name": "finset.sized_slice",
    "statement": "theorem finset.sized_slice {Î± : Type u_1} {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘(ð’œ.slice r)",
    "theorem": "{Î± : Type u_1} {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘(ð’œ.slice r)",
    "args": "{Î± : Type u_1} {ð’œ : finset (finset Î±)} {r : â„•}",
    "doc_string": "Everything in the `r`-th slice of `ð’œ` has size `r`.",
    "type": "set.sized r â†‘(ð’œ.slice r)"
  },
  {
    "name": "polynomial.cyclotomic_one",
    "statement": "theorem polynomial.cyclotomic_one (R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1",
    "theorem": "(R : Type u_1) [ring R] : polynomial.cyclotomic 1 R = polynomial.X - 1",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "The first cyclotomic polyomial is `X - 1`.",
    "type": "polynomial.cyclotomic 1 R = polynomial.X - 1"
  },
  {
    "name": "padic_norm.zero",
    "statement": "theorem padic_norm.zero (p : â„•) : padic_norm p 0 = 0",
    "theorem": "(p : â„•) : padic_norm p 0 = 0",
    "args": "(p : â„•)",
    "doc_string": "The p-adic norm of 0 is 0.",
    "type": "padic_norm p 0 = 0"
  },
  {
    "name": "has_sbtw.sbtw.cyclic_right",
    "statement": "theorem has_sbtw.sbtw.cyclic_right {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_cyclic_right`.",
    "type": "has_sbtw.sbtw c a b"
  },
  {
    "name": "is_right_regular_iff",
    "statement": "theorem is_right_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)",
    "theorem": "{R : Type u_1} [has_mul R] {a : R} : is_right_regular a â†” is_smul_regular R (mul_opposite.op a)",
    "args": "{R : Type u_1} [has_mul R] {a : R}",
    "doc_string": "Right-regular multiplication on `R` is equivalent to `Ráµáµ’áµ–`-regularity of `R` itself.",
    "type": "is_right_regular a â†” is_smul_regular R (mul_opposite.op a)"
  },
  {
    "name": "order_of_pos",
    "statement": "theorem order_of_pos {G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "theorem": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "args": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `order_of_pos' but with one fewer explicit assumption since this is  automatic in case of a finite cancellative monoid.",
    "type": "0 < order_of x"
  },
  {
    "name": "int.exists_least_of_bdd",
    "statement": "theorem int.exists_least_of_bdd {P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z",
    "theorem": "{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z",
    "args": "{P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ b â‰¤ z) (Hinh : âˆƒ (z : â„¤), P z)",
    "doc_string": " If `P : â„¤ â†’ Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty, then this set has the least element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.least_of_bdd` for a constructive counterpart.",
    "type": "âˆƒ (lb : â„¤), P lb âˆ§ âˆ€ (z : â„¤), P z â†’ lb â‰¤ z"
  },
  {
    "name": "left.one_lt_mul'",
    "statement": "theorem left.one_lt_mul' {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul'`.",
    "type": "1 < a * b"
  },
  {
    "name": "fintype.exists_ne_map_eq_of_infinite",
    "statement": "theorem fintype.exists_ne_map_eq_of_infinite {Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²) : âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [infinite Î±] [fintype Î²] (f : Î± â†’ Î²)",
    "doc_string": "The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are infinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the same pigeonhole.  See also: `fintype.exists_ne_map_eq_of_card_lt`, `fintype.exists_infinite_fiber`.",
    "type": "âˆƒ (x y : Î±), x â‰  y âˆ§ f x = f y"
  },
  {
    "name": "finsupp.coe_fn_injective",
    "statement": "theorem finsupp.coe_fn_injective {Î± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn",
    "theorem": "{Î± : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn",
    "args": "{Î± : Type u_1} {M : Type u_5} [has_zero M]",
    "doc_string": "Deprecated. Use `fun_like.coe_injective` instead.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "has_subset.subset.trans",
    "statement": "theorem has_subset.subset.trans {Î± : Type u} [has_subset Î±] [is_trans Î± has_subset.subset] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",
    "theorem": "{Î± : Type u} [has_subset Î±] [is_trans Î± has_subset.subset] {a b c : Î±} : a âŠ† b â†’ b âŠ† c â†’ a âŠ† c",
    "args": "{Î± : Type u} [has_subset Î±] [is_trans Î± has_subset.subset] {a b c : Î±}",
    "doc_string": "**Alias** of subset_trans`.",
    "type": "a âŠ† b â†’ b âŠ† c â†’ a âŠ† c"
  },
  {
    "name": "fin.strict_mono_unique",
    "statement": "theorem fin.strict_mono_unique {n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g",
    "theorem": "{n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g",
    "args": "{n : â„•} {Î± : Type u_1} [preorder Î±] {f g : fin n â†’ Î±} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g)",
    "doc_string": " Two strictly monotone functions from `fin n` are equal provided that their ranges are equal.",
    "type": "f = g"
  },
  {
    "name": "is_square_of_char_two'",
    "statement": "theorem is_square_of_char_two' {R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a",
    "theorem": "{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a",
    "args": "{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R)",
    "doc_string": " If `ring_char R = 2`, where `R` is a finite reduced commutative ring, then every `a : R` is a square.",
    "type": "is_square a"
  },
  {
    "name": "real.tendsto_sum_range_one_div_nat_succ_at_top",
    "statement": "theorem real.tendsto_sum_range_one_div_nat_succ_at_top  : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top",
    "theorem": " : filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top",
    "args": "",
    "doc_string": "**Divergence of the Harmonic Series**",
    "type": "filter.tendsto (Î» (n : â„•), (finset.range n).sum (Î» (i : â„•), 1 / (â†‘i + 1))) filter.at_top filter.at_top"
  },
  {
    "name": "topological_fiber_bundle_core.is_topological_fiber_bundle",
    "statement": "theorem topological_fiber_bundle_core.is_topological_fiber_bundle {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_topological_fiber_bundle F Z.proj",
    "theorem": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) : is_topological_fiber_bundle F Z.proj",
    "args": "{Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F)",
    "doc_string": "A topological fiber bundle constructed from core is indeed a topological fiber bundle.",
    "type": "is_topological_fiber_bundle F Z.proj"
  },
  {
    "name": "charted_space.locally_compact",
    "statement": "theorem charted_space.locally_compact (H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M",
    "theorem": "(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M",
    "args": "(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H]",
    "doc_string": " If a topological space admits an atlas with locally compact charts, then the space itself is locally compact.",
    "type": "locally_compact_space M"
  },
  {
    "name": "not_or_distrib",
    "statement": "theorem not_or_distrib {a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b",
    "theorem": "{a b : Prop} : Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b",
    "args": "{a b : Prop}",
    "doc_string": " One of de Morgan's laws: the negation of a disjunction is logically equivalent to the conjunction of the negations.",
    "type": "Â¬(a âˆ¨ b) â†” Â¬a âˆ§ Â¬b"
  },
  {
    "name": "set.sized.shadow",
    "statement": "theorem set.sized.shadow {Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : set.sized (r - 1) â†‘(ð’œ.shadow)",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ) : set.sized (r - 1) â†‘(ð’œ.shadow)",
    "args": "{Î± : Type u_1} [decidable_eq Î±] {ð’œ : finset (finset Î±)} {r : â„•} (hð’œ : set.sized r â†‘ð’œ)",
    "doc_string": "The shadow of a family of `r`-sets is a family of `r - 1`-sets.",
    "type": "set.sized (r - 1) â†‘(ð’œ.shadow)"
  },
  {
    "name": "is_add_submonoid.list_sum_mem",
    "statement": "theorem is_add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s",
    "theorem": "{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s",
    "args": "{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M}",
    "doc_string": "The sum of a list of elements of an `add_submonoid` is an element of the `add_submonoid`.",
    "type": "(âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.sum âˆˆ s"
  },
  {
    "name": "is_left_regular.ne_zero",
    "statement": "theorem is_left_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a â‰  0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a â‰  0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a)",
    "doc_string": "A left-regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "type": "a â‰  0"
  },
  {
    "name": "subsingleton_or_nontrivial",
    "statement": "theorem subsingleton_or_nontrivial (Î± : Type u_1) : subsingleton Î± âˆ¨ nontrivial Î±",
    "theorem": "(Î± : Type u_1) : subsingleton Î± âˆ¨ nontrivial Î±",
    "args": "(Î± : Type u_1)",
    "doc_string": "A type is either a subsingleton or nontrivial.",
    "type": "subsingleton Î± âˆ¨ nontrivial Î±"
  },
  {
    "name": "function.injective.cod_restrict",
    "statement": "theorem function.injective.cod_restrict {Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)",
    "theorem": "{Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t) : function.injective f â†’ function.injective (set.cod_restrict f t h)",
    "args": "{Î± : Type u} {Î² : Type v} {t : set Î²} {f : Î± â†’ Î²} (h : âˆ€ (x : Î±), f x âˆˆ t)",
    "doc_string": "**Alias** of the reverse direction of set.injective_cod_restrict`.",
    "type": "function.injective f â†’ function.injective (set.cod_restrict f t h)"
  },
  {
    "name": "is_smul_regular.one",
    "statement": "theorem is_smul_regular.one {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "theorem": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "args": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M]",
    "doc_string": "One is `M`-regular always.",
    "type": "is_smul_regular M 1"
  },
  {
    "name": "reflexive_ne_imp_iff",
    "statement": "theorem reflexive_ne_imp_iff {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±} : x â‰  y â†’ r x y â†” r x y",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} [is_refl Î± r] {x y : Î±}",
    "doc_string": " If a reflexive relation `r : Î± â†’ Î± â†’ Prop` holds over `x y : Î±`, then it holds whether or not `x â‰  y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl Î± r]`.",
    "type": "x â‰  y â†’ r x y â†” r x y"
  },
  {
    "name": "div_eq_one_of_eq",
    "statement": "theorem div_eq_one_of_eq {G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1",
    "theorem": "{G : Type u_2} [group G] {a b : G} : a = b â†’ a / b = 1",
    "args": "{G : Type u_2} [group G] {a b : G}",
    "doc_string": "**Alias** of the reverse direction of div_eq_one`.",
    "type": "a = b â†’ a / b = 1"
  },
  {
    "name": "has_le.le.trans_lt",
    "statement": "theorem has_le.le.trans_lt {Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c",
    "theorem": "{Î± : Type u} [preorder Î±] {a b c : Î±} : a â‰¤ b â†’ b < c â†’ a < c",
    "args": "{Î± : Type u} [preorder Î±] {a b c : Î±}",
    "doc_string": "**Alias** of lt_of_le_of_lt`.",
    "type": "a â‰¤ b â†’ b < c â†’ a < c"
  },
  {
    "name": "lt_add_of_sub_left_lt",
    "statement": "theorem lt_add_of_sub_left_lt {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c",
    "theorem": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a - b < c â†’ a < b + c",
    "args": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add'`.",
    "type": "a - b < c â†’ a < b + c"
  },
  {
    "name": "dfinsupp.coe_fn_injective",
    "statement": "theorem dfinsupp.coe_fn_injective {Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn",
    "theorem": "{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)] : function.injective coe_fn",
    "args": "{Î¹ : Type u} {Î² : Î¹ â†’ Type v} [Î  (i : Î¹), has_zero (Î² i)]",
    "doc_string": "Deprecated. Use `fun_like.coe_injective` instead.",
    "type": "function.injective coe_fn"
  },
  {
    "name": "list.prod_eq_zero",
    "statement": "theorem list.prod_eq_zero {Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0",
    "theorem": "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L) : L.prod = 0",
    "args": "{Mâ‚€ : Type u_6} [monoid_with_zero Mâ‚€] {L : list Mâ‚€} (h : 0 âˆˆ L)",
    "doc_string": " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial monoid with zero with no divisors, then this implication becomes an `iff`, see `list.prod_eq_zero_iff`.",
    "type": "L.prod = 0"
  },
  {
    "name": "function.bij_on_fixed_pts_comp",
    "statement": "theorem function.bij_on_fixed_pts_comp {Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))",
    "theorem": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))",
    "args": "{Î± : Type u} {Î² : Type v} (f : Î± â†’ Î²) (g : Î² â†’ Î±)",
    "doc_string": " Given two maps `f : Î± â†’ Î²` and `g : Î² â†’ Î±`, `g` is a bijective map between the fixed points of `f âˆ˜ g` and the fixed points of `g âˆ˜ f`. The inverse map is `f`, see `inv_on_fixed_pts_comp`.",
    "type": "set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (g âˆ˜ f))"
  },
  {
    "name": "fin_succ_equiv'_zero",
    "statement": "theorem fin_succ_equiv'_zero {n : â„•} : fin_succ_equiv' 0 = fin_succ_equiv n",
    "theorem": "{n : â„•} : fin_succ_equiv' 0 = fin_succ_equiv n",
    "args": "{n : â„•}",
    "doc_string": "The equiv version of `fin.pred_above_zero`.",
    "type": "fin_succ_equiv' 0 = fin_succ_equiv n"
  },
  {
    "name": "free_group.of_injective",
    "statement": "theorem free_group.of_injective {Î± : Type u} : function.injective free_group.of",
    "theorem": "{Î± : Type u} : function.injective free_group.of",
    "args": "{Î± : Type u}",
    "doc_string": "The canonical injection from the type to the free group is an injection.",
    "type": "function.injective free_group.of"
  },
  {
    "name": "padic_norm.padic_norm_p_lt_one",
    "statement": "theorem padic_norm.padic_norm_p_lt_one {p : â„•} (hp : 1 < p) : padic_norm p â†‘p < 1",
    "theorem": "{p : â„•} (hp : 1 < p) : padic_norm p â†‘p < 1",
    "args": "{p : â„•} (hp : 1 < p)",
    "doc_string": "The p-adic norm of `p` is less than 1 if `1 < p`.  See also `padic_norm.padic_norm_p_lt_one_of_prime` for a version assuming `prime p`.",
    "type": "padic_norm p â†‘p < 1"
  },
  {
    "name": "is_chain.exists_max_chain",
    "statement": "theorem is_chain.exists_max_chain {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c)",
    "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.",
    "type": "âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_products",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C]",
    "doc_string": "A preadditive category with finite products has finite biproducts.",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "ordinal.principal_mul_iff_le_two_or_omega_opow_opow",
    "statement": "theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for multiplicative principal ordinals.",
    "type": "ordinal.principal has_mul.mul o â†” o â‰¤ 2 âˆ¨ âˆƒ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a"
  },
  {
    "name": "function.semiconj.maps_to_fixed_pts",
    "statement": "theorem function.semiconj.maps_to_fixed_pts {Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)",
    "theorem": "{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)",
    "args": "{Î± : Type u} {Î² : Type v} {fa : Î± â†’ Î±} {fb : Î² â†’ Î²} {g : Î± â†’ Î²} (h : function.semiconj g fa fb)",
    "doc_string": " If `g` semiconjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points of `fb`.",
    "type": "set.maps_to g (function.fixed_points fa) (function.fixed_points fb)"
  },
  {
    "name": "right.one_le_mul",
    "statement": "theorem right.one_le_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b) : 1 â‰¤ a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} (ha : 1 â‰¤ a) (hb : 1 â‰¤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_le_mul`.",
    "type": "1 â‰¤ a * b"
  },
  {
    "name": "inv_le_of_inv_le'",
    "statement": "theorem inv_le_of_inv_le' {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±} : aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] [covariant_class Î± Î± (function.swap has_mul.mul) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of inv_le'`.",
    "type": "aâ»Â¹ â‰¤ b â†’ bâ»Â¹ â‰¤ a"
  },
  {
    "name": "vector.map_id",
    "statement": "theorem vector.map_id {Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v",
    "theorem": "{Î± : Type u_1} {n : â„•} (v : vector Î± n) : vector.map id v = v",
    "args": "{Î± : Type u_1} {n : â„•} (v : vector Î± n)",
    "doc_string": "Mapping under `id` does not change a vector.",
    "type": "vector.map id v = v"
  },
  {
    "name": "is_submonoid.list_prod_mem",
    "statement": "theorem is_submonoid.list_prod_mem {M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M}",
    "doc_string": "The product of a list of elements of a submonoid is an element of the submonoid.",
    "type": "(âˆ€ (x : M), x âˆˆ l â†’ x âˆˆ s) â†’ l.prod âˆˆ s"
  },
  {
    "name": "is_group_hom.map_one",
    "statement": "theorem is_group_hom.map_one {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1",
    "theorem": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1",
    "args": "{Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism sends 1 to 1.",
    "type": "f 1 = 1"
  },
  {
    "name": "nonneg_of_neg_nonpos",
    "statement": "theorem nonneg_of_neg_nonpos {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : -a â‰¤ 0 â†’ 0 â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "type": "-a â‰¤ 0 â†’ 0 â‰¤ a"
  },
  {
    "name": "add_subgroup.list_sum_mem",
    "statement": "theorem add_subgroup.list_sum_mem {G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K",
    "theorem": "{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K",
    "args": "{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G}",
    "doc_string": "Sum of a list of elements in an `add_subgroup` is in the `add_subgroup`.",
    "type": "(âˆ€ (x : G), x âˆˆ l â†’ x âˆˆ K) â†’ l.sum âˆˆ K"
  },
  {
    "name": "category_theory.essentially_small_iff",
    "statement": "theorem category_theory.essentially_small_iff (C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is essentially small if and only if the underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small, and it is locally small.",
    "type": "category_theory.essentially_small C â†” small (category_theory.skeleton C) âˆ§ category_theory.locally_small C"
  },
  {
    "name": "lt_neg_add_of_add_lt",
    "statement": "theorem lt_neg_add_of_add_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < -a + c",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`.",
    "type": "a + b < c â†’ b < -a + c"
  },
  {
    "name": "btw_cyclic",
    "statement": "theorem btw_cyclic {Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b",
    "theorem": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±} : has_btw.btw a b c â†” has_btw.btw c a b",
    "args": "{Î± : Type u_1} [circular_preorder Î±] {a b c : Î±}",
    "doc_string": " The order of the `â†”` has been chosen so that `rw btw_cyclic` cycles to the right while `rw â†btw_cyclic` cycles to the left (thus following the prepended arrow).",
    "type": "has_btw.btw a b c â†” has_btw.btw c a b"
  },
  {
    "name": "dihedral_group.order_of_r_one",
    "statement": "theorem dihedral_group.order_of_r_one {n : â„•} : order_of (dihedral_group.r 1) = n",
    "theorem": "{n : â„•} : order_of (dihedral_group.r 1) = n",
    "args": "{n : â„•}",
    "doc_string": "If `0 < n`, then `r 1` has order `n`.",
    "type": "order_of (dihedral_group.r 1) = n"
  },
  {
    "name": "function.surjective.nontrivial",
    "statement": "theorem function.surjective.nontrivial {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f) : nontrivial Î±",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [nontrivial Î²] {f : Î± â†’ Î²} (hf : function.surjective f)",
    "doc_string": "Pullback a `nontrivial` instance along a surjective function.",
    "type": "nontrivial Î±"
  },
  {
    "name": "dense.closure",
    "statement": "theorem dense.closure {Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)",
    "theorem": "{Î± : Type u} [topological_space Î±] {s : set Î±} : dense s â†’ dense (closure s)",
    "args": "{Î± : Type u} [topological_space Î±] {s : set Î±}",
    "doc_string": "**Alias** of the reverse direction of dense_closure`.",
    "type": "dense s â†’ dense (closure s)"
  },
  {
    "name": "finset.card_powerset",
    "statement": "theorem finset.card_powerset {Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card",
    "theorem": "{Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card",
    "args": "{Î± : Type u_1} (s : finset Î±)",
    "doc_string": "**Number of Subsets of a Set**",
    "type": "s.powerset.card = 2 ^ s.card"
  },
  {
    "name": "is_unit.dvd",
    "statement": "theorem is_unit.dvd {Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a",
    "theorem": "{Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a",
    "args": "{Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u)",
    "doc_string": "Units of a monoid divide any element of the monoid.",
    "type": "u âˆ£ a"
  },
  {
    "name": "is_square_zero",
    "statement": "theorem is_square_zero (M : Type u_1) [monoid_with_zero M] : is_square 0",
    "theorem": "(M : Type u_1) [monoid_with_zero M] : is_square 0",
    "args": "(M : Type u_1) [monoid_with_zero M]",
    "doc_string": "`0` is always a square (in a monoid with zero).",
    "type": "is_square 0"
  },
  {
    "name": "category_theory.is_subterminal_of_mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "args": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)]",
    "doc_string": "If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`.",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "real.cos_pi_div_three",
    "statement": "theorem real.cos_pi_div_three  : real.cos (real.pi / 3) = 1 / 2",
    "theorem": " : real.cos (real.pi / 3) = 1 / 2",
    "args": "",
    "doc_string": "The cosine of `Ï€ / 3` is `1 / 2`.",
    "type": "real.cos (real.pi / 3) = 1 / 2"
  },
  {
    "name": "nat.pow_two_sub_pow_two",
    "statement": "theorem nat.pow_two_sub_pow_two (a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "theorem": "(a b : â„•) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "args": "(a b : â„•)",
    "doc_string": "**Alias** of nat.sq_sub_sq`.",
    "type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)"
  },
  {
    "name": "function.injective.comap_cofinite_eq",
    "statement": "theorem function.injective.comap_cofinite_eq {Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite",
    "theorem": "{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f) : filter.comap f filter.cofinite = filter.cofinite",
    "args": "{Î± : Type u_2} {Î² : Type u_3} {f : Î± â†’ Î²} (hf : function.injective f)",
    "doc_string": " The pullback of the `filter.cofinite` under an injective function is equal to `filter.cofinite`. See also `filter.comap_cofinite_le` and `function.injective.tendsto_cofinite`.",
    "type": "filter.comap f filter.cofinite = filter.cofinite"
  },
  {
    "name": "add_submonoid.closure_eq",
    "statement": "theorem add_submonoid.closure_eq {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure â†‘S = S",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : add_submonoid.closure â†‘S = S",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M)",
    "doc_string": "Additive closure of an additive submonoid `S` equals `S`",
    "type": "add_submonoid.closure â†‘S = S"
  },
  {
    "name": "category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers",
    "statement": "theorem category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "theorem": "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "args": "(C : Type u) [ð’ž : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "If a category has all binary products and all equalizers, then it also has all pullbacks.    As usual, this is not an instance, since there may be a more direct way to construct    pullbacks.",
    "type": "category_theory.limits.has_pullbacks C"
  },
  {
    "name": "category_theory.limits.has_limits_of_size_shrink",
    "statement": "theorem category_theory.limits.has_limits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C]",
    "doc_string": "`has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C` from some other `has_limits_of_size C`.",
    "type": "category_theory.limits.has_limits_of_size C"
  },
  {
    "name": "lt_tsub_iff_right",
    "statement": "theorem lt_tsub_iff_right {Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b",
    "theorem": "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±] : a < b - c â†” a + c < b",
    "args": "{Î± : Type u_1} {a b c : Î±} [linear_order Î±] [add_comm_semigroup Î±] [has_sub Î±] [has_ordered_sub Î±]",
    "doc_string": "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order.",
    "type": "a < b - c â†” a + c < b"
  },
  {
    "name": "has_lt.lt.le",
    "statement": "theorem has_lt.lt.le {Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b",
    "theorem": "{Î± : Type u} [preorder Î±] {a b : Î±} : a < b â†’ a â‰¤ b",
    "args": "{Î± : Type u} [preorder Î±] {a b : Î±}",
    "doc_string": "**Alias** of le_of_lt`.",
    "type": "a < b â†’ a â‰¤ b"
  },
  {
    "name": "is_add_regular_of_cancel_add_monoid",
    "statement": "theorem is_add_regular_of_cancel_add_monoid {R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "theorem": "{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "args": "{R : Type u_1} [add_cancel_monoid R] (g : R)",
    "doc_string": "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist.",
    "type": "is_add_regular g"
  },
  {
    "name": "zsmul_right_injective",
    "statement": "theorem zsmul_right_injective {Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)",
    "theorem": "{Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0) : function.injective (Î» (_x : Î±), n â€¢ _x)",
    "args": "{Î± : Type u_1} [linear_ordered_add_comm_group Î±] {n : â„¤} (hn : n â‰  0)",
    "doc_string": "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that here because importing that definition would create import cycles.",
    "type": "function.injective (Î» (_x : Î±), n â€¢ _x)"
  },
  {
    "name": "right.add_neg_of_nonpos_of_neg",
    "statement": "theorem right.add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "inv_of_one_lt_inv",
    "statement": "theorem inv_of_one_lt_inv {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†’ a < 1",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "type": "1 < aâ»Â¹ â†’ a < 1"
  },
  {
    "name": "directed_on.directed_coe",
    "statement": "theorem directed_on.directed_coe {Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe",
    "theorem": "{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} : directed_on r s â†’ directed r coe",
    "args": "{Î± : Type u} {r : Î± â†’ Î± â†’ Prop} {s : set Î±}",
    "doc_string": "**Alias** of the forward direction of directed_on_iff_directed`.",
    "type": "directed_on r s â†’ directed r coe"
  },
  {
    "name": "is_right_regular_zero_iff_subsingleton",
    "statement": "theorem is_right_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_right_regular 0 â†” subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is right-regular if and only if `R` is trivial.",
    "type": "is_right_regular 0 â†” subsingleton R"
  },
  {
    "name": "left.add_neg'",
    "statement": "theorem left.add_neg' {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg'`.",
    "type": "a + b < 0"
  },
  {
    "name": "right.one_lt_mul",
    "statement": "theorem right.one_lt_mul {Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{Î± : Type u_1} [mul_one_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_mul.mul) has_lt.lt] {a b : Î±} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul`.",
    "type": "1 < a * b"
  },
  {
    "name": "left.add_neg_of_neg_of_nonpos",
    "statement": "theorem left.add_neg_of_neg_of_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b : Î±} (ha : a < 0) (hb : b â‰¤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`.",
    "type": "a + b < 0"
  },
  {
    "name": "category_theory.is_subterminal_of_is_iso_diag",
    "statement": "theorem category_theory.is_subterminal_of_is_iso_diag {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "args": "{C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)]",
    "doc_string": "If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`.",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "category_theory.is_subterminal.is_iso_diag",
    "statement": "theorem category_theory.is_subterminal.is_iso_diag {C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "theorem": "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "args": "{C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A]",
    "doc_string": "If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`.",
    "type": "category_theory.is_iso (category_theory.limits.diag A)"
  },
  {
    "name": "one_lt_inv'",
    "statement": "theorem one_lt_inv' {Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "theorem": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±} : 1 < aâ»Â¹ â†” a < 1",
    "args": "{Î± : Type u} [group Î±] [has_lt Î±] [covariant_class Î± Î± has_mul.mul has_lt.lt] {a : Î±}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "type": "1 < aâ»Â¹ â†” a < 1"
  },
  {
    "name": "irrational_sqrt_two",
    "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)",
    "theorem": " : irrational (real.sqrt 2)",
    "args": "",
    "doc_string": "**Irrationality of the Square Root of 2**",
    "type": "irrational (real.sqrt 2)"
  },
  {
    "name": "filter.Coprod_cofinite",
    "statement": "theorem filter.Coprod_cofinite {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] : filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite",
    "theorem": "{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹] : filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite",
    "args": "{Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [fintype Î¹]",
    "doc_string": "Finite product of finite sets is finite",
    "type": "filter.Coprod (Î» (i : Î¹), filter.cofinite) = filter.cofinite"
  },
  {
    "name": "continuous_map.compact_open_eq_compact_convergence",
    "statement": "theorem continuous_map.compact_open_eq_compact_convergence {Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] : continuous_map.compact_open = continuous_map.compact_convergence_topology",
    "theorem": "{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²] : continuous_map.compact_open = continuous_map.compact_convergence_topology",
    "args": "{Î± : Type uâ‚} {Î² : Type uâ‚‚} [topological_space Î±] [uniform_space Î²]",
    "doc_string": "The compact-open topology is equal to the compact-convergence topology.",
    "type": "continuous_map.compact_open = continuous_map.compact_convergence_topology"
  },
  {
    "name": "monotone.ne_of_lt_of_lt_int",
    "statement": "theorem monotone.ne_of_lt_of_lt_int {Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x",
    "theorem": "{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤) : f a â‰  x",
    "args": "{Î± : Type u} [preorder Î±] {f : â„¤ â†’ Î±} (hf : monotone f) (n : â„¤) {x : Î±} (h1 : f n < x) (h2 : x < f (n + 1)) (a : â„¤)",
    "doc_string": "If `f` is a monotone function from `â„¤` to a preorder and `x` lies between `f n` and  `f (n + 1)`, then `x` doesn't lie in the range of `f`.",
    "type": "f a â‰  x"
  },
  {
    "name": "convex_independent.injective",
    "statement": "theorem convex_independent.injective {ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p) : function.injective p",
    "theorem": "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p) : function.injective p",
    "args": "{ð•œ : Type u_1} {E : Type u_2} {Î¹ : Type u_3} [ordered_semiring ð•œ] [add_comm_group E] [module ð•œ E] {p : Î¹ â†’ E} (hc : convex_independent ð•œ p)",
    "doc_string": "A convex independent family is injective.",
    "type": "function.injective p"
  },
  {
    "name": "function.commute.right_bij_on_fixed_pts_comp",
    "statement": "theorem function.commute.right_bij_on_fixed_pts_comp {Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))",
    "theorem": "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g) : set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))",
    "args": "{Î± : Type u} {f g : Î± â†’ Î±} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f âˆ˜ g`. This is a particular case of `function.bij_on_fixed_pts_comp`.",
    "type": "set.bij_on g (function.fixed_points (f âˆ˜ g)) (function.fixed_points (f âˆ˜ g))"
  },
  {
    "name": "three_pos",
    "statement": "theorem three_pos {Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3",
    "theorem": "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±] : 0 < 3",
    "args": "{Î± : Type u} [ordered_semiring Î±] [nontrivial Î±]",
    "doc_string": "**Alias** of zero_lt_three`.",
    "type": "0 < 3"
  },
  {
    "name": "finset.max'_singleton",
    "statement": "theorem finset.max'_singleton {Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a",
    "theorem": "{Î± : Type u_1} [linear_order Î±] (a : Î±) : {a}.max' _ = a",
    "args": "{Î± : Type u_1} [linear_order Î±] (a : Î±)",
    "doc_string": "`{a}.max' _` is `a`.",
    "type": "{a}.max' _ = a"
  },
  {
    "name": "add_is_add_left_regular_iff",
    "statement": "theorem add_is_add_left_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) â†” is_add_left_regular b",
    "args": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a)",
    "doc_string": "An element is add-left-regular if and only if adding to it on the left a add-left-regular element is add-left-regular.",
    "type": "is_add_left_regular (a + b) â†” is_add_left_regular b"
  },
  {
    "name": "continuous_map.continuous_uncurry",
    "statement": "theorem continuous_map.continuous_uncurry {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry",
    "args": "{Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²]",
    "doc_string": "The uncurrying process is a continuous map between function spaces.",
    "type": "continuous continuous_map.uncurry"
  },
  {
    "name": "multiples.add_mem",
    "statement": "theorem multiples.add_mem {M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x y z : M} : y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x y z : M}",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` is closed under addition.",
    "type": "y âˆˆ multiples x â†’ z âˆˆ multiples x â†’ y + z âˆˆ multiples x"
  },
  {
    "name": "left.one_le_inv_iff",
    "statement": "theorem left.one_le_inv_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : 1 â‰¤ aâ»Â¹ â†” a â‰¤ 1",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "1 â‰¤ aâ»Â¹ â†” a â‰¤ 1"
  },
  {
    "name": "nat.squarefree_mul",
    "statement": "theorem nat.squarefree_mul {m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n",
    "theorem": "{m n : â„•} (hmn : m.coprime n) : squarefree (m * n) â†” squarefree m âˆ§ squarefree n",
    "args": "{m n : â„•} (hmn : m.coprime n)",
    "doc_string": " `squarefree` is multiplicative. Note that the â†’ direction does not require `hmn` and generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and `squarefree.of_mul_right` above for auxiliary lemmas.",
    "type": "squarefree (m * n) â†” squarefree m âˆ§ squarefree n"
  },
  {
    "name": "category_theory.limits.has_finite_coproducts_of_has_coproducts",
    "statement": "theorem category_theory.limits.has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C]",
    "doc_string": "If a category has all coproducts then in particular it has finite coproducts.",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "complete_space_of_is_complete_univ",
    "statement": "theorem complete_space_of_is_complete_univ {Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±",
    "theorem": "{Î± : Type u} [uniform_space Î±] (h : is_complete set.univ) : complete_space Î±",
    "args": "{Î± : Type u} [uniform_space Î±] (h : is_complete set.univ)",
    "doc_string": "If `univ` is complete, the space is a complete space",
    "type": "complete_space Î±"
  },
  {
    "name": "multiset.Ico_eq_zero",
    "statement": "theorem multiset.Ico_eq_zero {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0",
    "theorem": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ multiset.Ico a b = 0",
    "args": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of multiset.Ico_eq_zero_iff`.",
    "type": "Â¬a < b â†’ multiset.Ico a b = 0"
  },
  {
    "name": "padic_val_rat.finite_int_prime_iff",
    "statement": "theorem padic_val_rat.finite_int_prime_iff {p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0",
    "theorem": "{p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤} : multiplicity.finite â†‘p a â†” a â‰  0",
    "args": "{p : â„•} [p_prime : fact (nat.prime p)] {a : â„¤}",
    "doc_string": "The multiplicity of `p : â„•` in `a : â„¤` is finite exactly when `a â‰  0`.",
    "type": "multiplicity.finite â†‘p a â†” a â‰  0"
  },
  {
    "name": "matrix.is_unit_iff_is_unit_det",
    "statement": "theorem matrix.is_unit_iff_is_unit_det {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det",
    "theorem": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det",
    "args": "{n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±)",
    "doc_string": "When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`.",
    "type": "is_unit A â†” is_unit A.det"
  },
  {
    "name": "function.cantor_injective",
    "statement": "theorem function.cantor_injective {Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f",
    "theorem": "{Î± : Type u_1} (f : set Î± â†’ Î±) : Â¬function.injective f",
    "args": "{Î± : Type u_1} (f : set Î± â†’ Î±)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no injective functions from `set Î±` to `Î±`.",
    "type": "Â¬function.injective f"
  },
  {
    "name": "order.lt_succ_of_not_is_max",
    "statement": "theorem order.lt_succ_of_not_is_max {Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a",
    "theorem": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±} : Â¬is_max a â†’ a < order.succ a",
    "args": "{Î± : Type u_1} [preorder Î±] [succ_order Î±] {a : Î±}",
    "doc_string": "**Alias** of the reverse direction of order.lt_succ_iff_not_is_max`.",
    "type": "Â¬is_max a â†’ a < order.succ a"
  },
  {
    "name": "add_order_of_pos",
    "statement": "theorem add_order_of_pos {G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "theorem": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "args": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is   automatic in case of a finite cancellative additive monoid.",
    "type": "0 < add_order_of x"
  },
  {
    "name": "right.add_nonpos",
    "statement": "theorem right.add_nonpos {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0) : a + b â‰¤ 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} (ha : a â‰¤ 0) (hb : b â‰¤ 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonpos`.",
    "type": "a + b â‰¤ 0"
  },
  {
    "name": "subsemigroup.subset_closure",
    "statement": "theorem subsemigroup.subset_closure {M : Type u_1} [has_mul M] {s : set M} : s âŠ† â†‘(subsemigroup.closure s)",
    "theorem": "{M : Type u_1} [has_mul M] {s : set M} : s âŠ† â†‘(subsemigroup.closure s)",
    "args": "{M : Type u_1} [has_mul M] {s : set M}",
    "doc_string": "The subsemigroup generated by a set includes the set.",
    "type": "s âŠ† â†‘(subsemigroup.closure s)"
  },
  {
    "name": "padic_val_rat.zero",
    "statement": "theorem padic_val_rat.zero (m : â„•) : padic_val_rat m 0 = 0",
    "theorem": "(m : â„•) : padic_val_rat m 0 = 0",
    "args": "(m : â„•)",
    "doc_string": "`padic_val_rat p 0` is 0 for any `p`.",
    "type": "padic_val_rat m 0 = 0"
  },
  {
    "name": "add_con.coe_add",
    "statement": "theorem add_con.coe_add {M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y",
    "theorem": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : â†‘(x + y) = â†‘x + â†‘y",
    "args": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M)",
    "doc_string": "The coercion to the quotient of an additive congruence relation commutes with addition (by definition).",
    "type": "â†‘(x + y) = â†‘x + â†‘y"
  },
  {
    "name": "subtype.exists'",
    "statement": "theorem subtype.exists' {Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _",
    "theorem": "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop} : (âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _",
    "args": "{Î± : Sort u_1} {p : Î± â†’ Prop} {q : Î  (x : Î±), p x â†’ Prop}",
    "doc_string": "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`  when using `subtype.exists` from right to left.",
    "type": "(âˆƒ (x : Î±) (h : p x), q x h) â†” âˆƒ (x : {a // p a}), q â†‘x _"
  },
  {
    "name": "is_preconnected.subset_closure",
    "statement": "theorem is_preconnected.subset_closure {Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t",
    "theorem": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s) : is_preconnected t",
    "args": "{Î± : Type u} [topological_space Î±] {s t : set Î±} (H : is_preconnected s) (Kst : s âŠ† t) (Ktcs : t âŠ† closure s)",
    "doc_string": " Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well.",
    "type": "is_preconnected t"
  },
  {
    "name": "is_add_group_hom.to_is_add_monoid_hom",
    "statement": "theorem is_add_group_hom.to_is_add_monoid_hom {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "theorem": "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "args": "{Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism is an additive monoid homomorphism.",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "real.coe_fib_eq'",
    "statement": "theorem real.coe_fib_eq'  : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "theorem": " : (Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "args": "",
    "doc_string": "Binet's formula as a function equality.",
    "type": "(Î» (n : â„•), â†‘(nat.fib n)) = Î» (n : â„•), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5"
  },
  {
    "name": "inducing.is_open_map",
    "statement": "theorem inducing.is_open_map {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hi : inducing f) (ho : is_open (set.range f))",
    "doc_string": "An inducing map with an open range is an open map.",
    "type": "is_open_map f"
  },
  {
    "name": "nat.fib_add_two_strict_mono",
    "statement": "theorem nat.fib_add_two_strict_mono  : strict_mono (Î» (n : â„•), nat.fib (n + 2))",
    "theorem": " : strict_mono (Î» (n : â„•), nat.fib (n + 2))",
    "args": "",
    "doc_string": "`fib (n + 2)` is strictly monotone.",
    "type": "strict_mono (Î» (n : â„•), nat.fib (n + 2))"
  },
  {
    "name": "finset.mem_powerset_len",
    "statement": "theorem finset.mem_powerset_len {Î± : Type u_1} {n : â„•} {s t : finset Î±} : s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n",
    "theorem": "{Î± : Type u_1} {n : â„•} {s t : finset Î±} : s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n",
    "args": "{Î± : Type u_1} {n : â„•} {s t : finset Î±}",
    "doc_string": "**Formula for the Number of Combinations**",
    "type": "s âˆˆ finset.powerset_len n t â†” s âŠ† t âˆ§ s.card = n"
  },
  {
    "name": "add_subgroup.sub_mem",
    "statement": "theorem add_subgroup.sub_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H) : x - y âˆˆ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x âˆˆ H) (hy : y âˆˆ H)",
    "doc_string": "An `add_subgroup` is closed under subtraction.",
    "type": "x - y âˆˆ H"
  },
  {
    "name": "order_bot.bdd_below",
    "statement": "theorem order_bot.bdd_below {Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s",
    "theorem": "{Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³) : bdd_below s",
    "args": "{Î³ : Type w} [preorder Î³] [order_bot Î³] (s : set Î³)",
    "doc_string": "When there is a global minimum, every set is bounded below.",
    "type": "bdd_below s"
  },
  {
    "name": "subsingleton_of_zero_eq_one",
    "statement": "theorem subsingleton_of_zero_eq_one {Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€",
    "theorem": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€] : 0 = 1 â†’ subsingleton Mâ‚€",
    "args": "{Mâ‚€ : Type u_1} [mul_zero_one_class Mâ‚€]",
    "doc_string": "**Alias** of the forward direction of subsingleton_iff_zero_eq_one`.",
    "type": "0 = 1 â†’ subsingleton Mâ‚€"
  },
  {
    "name": "nat.even_pow",
    "statement": "theorem nat.even_pow {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0",
    "theorem": "{m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0",
    "args": "{m n : â„•}",
    "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
    "type": "even (m ^ n) â†” even m âˆ§ n â‰  0"
  },
  {
    "name": "left.inv_le_one_iff",
    "statement": "theorem left.inv_le_one_iff {Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
    "theorem": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±} : aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a",
    "args": "{Î± : Type u} [group Î±] [has_le Î±] [covariant_class Î± Î± has_mul.mul has_le.le] {a : Î±}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "type": "aâ»Â¹ â‰¤ 1 â†” 1 â‰¤ a"
  },
  {
    "name": "left.add_neg_of_nonpos_of_neg",
    "statement": "theorem left.add_neg_of_nonpos_of_neg {Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0) : a + b < 0",
    "args": "{Î± : Type u_1} [add_zero_class Î±] [preorder Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b : Î±} (ha : a â‰¤ 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`.",
    "type": "a + b < 0"
  },
  {
    "name": "matrix.det_unique",
    "statement": "theorem matrix.det_unique {R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "theorem": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "args": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R)",
    "doc_string": " If `n` has only one element, the determinant of an `n` by `n` matrix is just that element. Although `unique` implies `decidable_eq` and `fintype`, the instances might not be syntactically equal. Thus, we need to fill in the args explicitly.",
    "type": "A.det = A inhabited.default inhabited.default"
  },
  {
    "name": "ascending_central_series_le_upper",
    "statement": "theorem ascending_central_series_le_upper {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n",
    "theorem": "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n",
    "args": "{G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•)",
    "doc_string": "Any ascending central series for a group is bounded above by the upper central series.",
    "type": "H n â‰¤ upper_central_series G n"
  },
  {
    "name": "category_theory.abelian.pseudo_equal_trans",
    "statement": "theorem category_theory.abelian.pseudo_equal_trans {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C}",
    "doc_string": "Pseudoequality is transitive: Just take the pullback. The pullback morphisms will    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms.",
    "type": "transitive (category_theory.abelian.pseudo_equal P)"
  },
  {
    "name": "con.con_gen_mono",
    "statement": "theorem con.con_gen_mono {M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s",
    "theorem": "{M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s",
    "args": "{M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y)",
    "doc_string": "Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`.",
    "type": "con_gen r â‰¤ con_gen s"
  },
  {
    "name": "multiset.sub_le_iff_le_add",
    "statement": "theorem multiset.sub_le_iff_le_add {Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t",
    "theorem": "{Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±} : s - t â‰¤ u â†” s â‰¤ u + t",
    "args": "{Î± : Type u_1} [decidable_eq Î±] {s t u : multiset Î±}",
    "doc_string": "This is a special case of `tsub_le_iff_right`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset Î±)`.",
    "type": "s - t â‰¤ u â†” s â‰¤ u + t"
  },
  {
    "name": "continuous_map.continuous_coe'",
    "statement": "theorem continuous_map.continuous_coe' {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±] : continuous coe_fn",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] [locally_compact_space Î±]",
    "doc_string": "See also `continuous_map.continuous_coe`",
    "type": "continuous coe_fn"
  },
  {
    "name": "has_dvd.dvd.mul_left",
    "statement": "theorem has_dvd.dvd.mul_left {Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b",
    "theorem": "{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ c * b",
    "args": "{Î± : Type u_1} [comm_semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_right`.",
    "type": "a âˆ£ c * b"
  },
  {
    "name": "count_succ_eq_count",
    "statement": "theorem count_succ_eq_count {p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n",
    "theorem": "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•} : Â¬p n â†’ nat.count p (n + 1) = nat.count p n",
    "args": "{p : â„• â†’ Prop} [decidable_pred p] {n : â„•}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_count_iff`.",
    "type": "Â¬p n â†’ nat.count p (n + 1) = nat.count p n"
  },
  {
    "name": "neg.is_add_group_hom",
    "statement": "theorem neg.is_add_group_hom {Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg",
    "theorem": "{Î± : Type u} [add_comm_group Î±] : is_add_group_hom has_neg.neg",
    "args": "{Î± : Type u} [add_comm_group Î±]",
    "doc_string": "Negation is an `add_group` homomorphism if the `add_group` is commutative.",
    "type": "is_add_group_hom has_neg.neg"
  },
  {
    "name": "has_dvd.dvd.mul_right",
    "statement": "theorem has_dvd.dvd.mul_right {Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c",
    "theorem": "{Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±) : a âˆ£ b * c",
    "args": "{Î± : Type u_1} [semigroup Î±] {a b : Î±} (h : a âˆ£ b) (c : Î±)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_left`.",
    "type": "a âˆ£ b * c"
  },
  {
    "name": "polynomial.of_finsupp_inj",
    "statement": "theorem polynomial.of_finsupp_inj {R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b",
    "theorem": "{R : Type u} [semiring R] {a b : add_monoid_algebra R â„•} : {to_finsupp := a} = {to_finsupp := b} â†” a = b",
    "args": "{R : Type u} [semiring R] {a b : add_monoid_algebra R â„•}",
    "doc_string": "A more convenient spelling of `polynomial.of_finsupp.inj_eq` in terms of `iff`.",
    "type": "{to_finsupp := a} = {to_finsupp := b} â†” a = b"
  },
  {
    "name": "is_add_submonoid.multiset_sum_mem",
    "statement": "theorem is_add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s",
    "theorem": "{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s",
    "args": "{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M)",
    "doc_string": "The sum of a multiset of elements of an `add_submonoid` of an `add_comm_monoid` is an element of the `add_submonoid`.",
    "type": "(âˆ€ (a : M), a âˆˆ m â†’ a âˆˆ s) â†’ m.sum âˆˆ s"
  },
  {
    "name": "padic_val_rat.self",
    "statement": "theorem padic_val_rat.self {p : â„•} (hp : 1 < p) : padic_val_rat p â†‘p = 1",
    "theorem": "{p : â„•} (hp : 1 < p) : padic_val_rat p â†‘p = 1",
    "args": "{p : â„•} (hp : 1 < p)",
    "doc_string": "For `p â‰  0, p â‰  1, `padic_val_rat p p` is 1.",
    "type": "padic_val_rat p â†‘p = 1"
  },
  {
    "name": "list.take_append_eq_append_take",
    "statement": "theorem list.take_append_eq_append_take {Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚",
    "theorem": "{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•} : list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚",
    "args": "{Î± : Type u} {lâ‚ lâ‚‚ : list Î±} {n : â„•}",
    "doc_string": " Taking the first `n` elements in `lâ‚ ++ lâ‚‚` is the same as appending the first `n` elements of `lâ‚` to the first `n - lâ‚.length` elements of `lâ‚‚`.",
    "type": "list.take n (lâ‚ ++ lâ‚‚) = list.take n lâ‚ ++ list.take (n - lâ‚.length) lâ‚‚"
  },
  {
    "name": "nat.factorization_inj",
    "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : â„• | x â‰  0}",
    "theorem": " : set.inj_on nat.factorization {x : â„• | x â‰  0}",
    "args": "",
    "doc_string": "Every nonzero natural number has a unique prime factorization",
    "type": "set.inj_on nat.factorization {x : â„• | x â‰  0}"
  },
  {
    "name": "list.sorted.insertion_sort_eq",
    "statement": "theorem list.sorted.insertion_sort_eq {Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l",
    "theorem": "{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l) : list.insertion_sort r l = l",
    "args": "{Î± : Type uu} {r : Î± â†’ Î± â†’ Prop} [decidable_rel r] {l : list Î±} (h : list.sorted r l)",
    "doc_string": " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change it.",
    "type": "list.insertion_sort r l = l"
  },
  {
    "name": "has_subset.subset.antisymm'",
    "statement": "theorem has_subset.subset.antisymm' {Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : b = a",
    "theorem": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a) : b = a",
    "args": "{Î± : Type u} [has_subset Î±] {a b : Î±} [is_antisymm Î± has_subset.subset] (h : a âŠ† b) (h' : b âŠ† a)",
    "doc_string": "**Alias** of superset_antisymm`.",
    "type": "b = a"
  },
  {
    "name": "nat.pow_dvd_pow_iff_le_right",
    "statement": "theorem nat.pow_dvd_pow_iff_le_right {x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l",
    "theorem": "{x k l : â„•} (w : 1 < x) : x ^ k âˆ£ x ^ l â†” k â‰¤ l",
    "args": "{x k l : â„•} (w : 1 < x)",
    "doc_string": "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`.",
    "type": "x ^ k âˆ£ x ^ l â†” k â‰¤ l"
  },
  {
    "name": "fintype.univ_of_is_empty",
    "statement": "theorem fintype.univ_of_is_empty {Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…",
    "theorem": "{Î± : Type u_1} [is_empty Î±] : finset.univ = âˆ…",
    "args": "{Î± : Type u_1} [is_empty Î±]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `finset.univ_eq_empty`.",
    "type": "finset.univ = âˆ…"
  },
  {
    "name": "is_topological_fiber_bundle.surjective_proj",
    "statement": "theorem is_topological_fiber_bundle.surjective_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map.",
    "type": "function.surjective proj"
  },
  {
    "name": "add_con.mk'_ker",
    "statement": "theorem add_con.mk'_ker {M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "args": "{M : Type u_1} [add_zero_class M] (c : add_con M)",
    "doc_string": "The kernel of the natural homomorphism from an `add_monoid` to its quotient by an additive congruence relation `c` equals `c`.",
    "type": "add_con.ker c.mk' = c"
  },
  {
    "name": "is_topological_fiber_bundle.quotient_map_proj",
    "statement": "theorem is_topological_fiber_bundle.quotient_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z â†’ B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a quotient map.",
    "type": "quotient_map proj"
  },
  {
    "name": "group_topology.continuous_mul'",
    "statement": "theorem group_topology.continuous_mul' {Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)",
    "theorem": "{Î± : Type u} [group Î±] (g : group_topology Î±) : continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)",
    "args": "{Î± : Type u} [group Î±] (g : group_topology Î±)",
    "doc_string": "A version of the global `continuous_mul` suitable for dot notation.",
    "type": "continuous (Î» (p : Î± Ã— Î±), p.fst * p.snd)"
  },
  {
    "name": "is_regular.and_of_mul_of_mul",
    "statement": "theorem is_regular.and_of_mul_of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a âˆ§ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a))",
    "doc_string": "The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `âˆ§`.",
    "type": "is_regular a âˆ§ is_regular b"
  },
  {
    "name": "sub_neg_of_lt",
    "statement": "theorem sub_neg_of_lt {Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±} : a < b â†’ a - b < 0",
    "args": "{Î± : Type u} [add_group Î±] [has_lt Î±] [covariant_class Î± Î± (function.swap has_add.add) has_lt.lt] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of sub_neg`.",
    "type": "a < b â†’ a - b < 0"
  },
  {
    "name": "cardinal.mk_quaternion",
    "statement": "theorem cardinal.mk_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "theorem": "(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "args": "(R : Type u_1) [has_one R] [has_neg R]",
    "doc_string": "The cardinality of the quaternions, as a type.",
    "type": "cardinal.mk (quaternion R) = cardinal.mk R ^ 4"
  },
  {
    "name": "mt",
    "statement": "theorem mt {a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a",
    "theorem": "{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b) : Â¬a",
    "args": "{a b : Prop} (hâ‚ : a â†’ b) (hâ‚‚ : Â¬b)",
    "doc_string": "Modus tollens. If an implication is true, then so is its contrapositive.",
    "type": "Â¬a"
  },
  {
    "name": "semiconj_by.one_right",
    "statement": "theorem semiconj_by.one_right {M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "theorem": "{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "args": "{M : Type u} [mul_one_class M] (a : M)",
    "doc_string": "Any element semiconjugates `1` to `1`.",
    "type": "semiconj_by a 1 1"
  },
  {
    "name": "le_neg_add_of_add_le",
    "statement": "theorem le_neg_add_of_add_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±} : a + b â‰¤ c â†’ b â‰¤ -a + c",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`.",
    "type": "a + b â‰¤ c â†’ b â‰¤ -a + c"
  },
  {
    "name": "is_totally_separated.is_totally_disconnected",
    "statement": "theorem is_totally_separated.is_totally_disconnected {Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s) : is_totally_disconnected s",
    "theorem": "{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s) : is_totally_disconnected s",
    "args": "{Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_totally_separated s)",
    "doc_string": "**Alias** of is_totally_disconnected_of_is_totally_separated`.",
    "type": "is_totally_disconnected s"
  },
  {
    "name": "lucas_lehmer.mersenne_coe_X",
    "statement": "theorem lucas_lehmer.mersenne_coe_X (p : â„•) : â†‘(mersenne p) = 0",
    "theorem": "(p : â„•) : â†‘(mersenne p) = 0",
    "args": "(p : â„•)",
    "doc_string": "`q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`.",
    "type": "â†‘(mersenne p) = 0"
  },
  {
    "name": "filter.tendsto_pow_at_top",
    "statement": "theorem filter.tendsto_pow_at_top {Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top",
    "theorem": "{Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n) : filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top",
    "args": "{Î± : Type u_3} [ordered_semiring Î±] {n : â„•} (hn : 1 â‰¤ n)",
    "doc_string": " The monomial function `x^n` tends to `+âˆž` at `+âˆž` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.",
    "type": "filter.tendsto (Î» (x : Î±), x ^ n) filter.at_top filter.at_top"
  },
  {
    "name": "list.length_pos_of_sum_pos",
    "statement": "theorem list.length_pos_of_sum_pos {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum)",
    "doc_string": "A list with positive sum must have positive length.",
    "type": "0 < L.length"
  },
  {
    "name": "padic_val_rat.of_int",
    "statement": "theorem padic_val_rat.of_int {p : â„•} {z : â„¤} : padic_val_rat p â†‘z = â†‘(padic_val_int p z)",
    "theorem": "{p : â„•} {z : â„¤} : padic_val_rat p â†‘z = â†‘(padic_val_int p z)",
    "args": "{p : â„•} {z : â„¤}",
    "doc_string": "The p-adic value of an integer `z â‰  0` is its p-adic_value as a rational",
    "type": "padic_val_rat p â†‘z = â†‘(padic_val_int p z)"
  },
  {
    "name": "category_theory.over.construct_products.over_products_of_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_products_of_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C}",
    "doc_string": "Given all wide pullbacks in `C`, construct products in `C/B`.",
    "type": "category_theory.limits.has_products (category_theory.over B)"
  },
  {
    "name": "is_of_fin_add_order.add",
    "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Elements of finite additive order are closed under addition.",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "has_lt.lt.not_is_min",
    "statement": "theorem has_lt.lt.not_is_min {Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a",
    "theorem": "{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a) : Â¬is_min a",
    "args": "{Î± : Type u_1} [preorder Î±] {a b : Î±} (h : b < a)",
    "doc_string": "**Alias** of not_is_min_of_lt`.",
    "type": "Â¬is_min a"
  },
  {
    "name": "sub_nonneg_of_le",
    "statement": "theorem sub_nonneg_of_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : b â‰¤ a â†’ 0 â‰¤ a - b",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of sub_nonneg`.",
    "type": "b â‰¤ a â†’ 0 â‰¤ a - b"
  },
  {
    "name": "multiset.Icc_eq_zero",
    "statement": "theorem multiset.Icc_eq_zero {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0",
    "theorem": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a â‰¤ b â†’ multiset.Icc a b = 0",
    "args": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of multiset.Icc_eq_zero_iff`.",
    "type": "Â¬a â‰¤ b â†’ multiset.Icc a b = 0"
  },
  {
    "name": "pnat.factor_multiset_of_prime",
    "statement": "theorem pnat.factor_multiset_of_prime (p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p",
    "theorem": "(p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p",
    "args": "(p : nat.primes)",
    "doc_string": "Factoring a prime gives the corresponding one-element multiset.",
    "type": "â†‘p.factor_multiset = prime_multiset.of_prime p"
  },
  {
    "name": "add_lt_of_lt_sub_left",
    "statement": "theorem add_lt_of_lt_sub_left {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c",
    "theorem": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : b < c - a â†’ a + b < c",
    "args": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the forward direction of lt_sub_iff_add_lt'`.",
    "type": "b < c - a â†’ a + b < c"
  },
  {
    "name": "set.sized.subset_powerset_len_univ",
    "statement": "theorem set.sized.subset_powerset_len_univ {Î± : Type u_1} [fintype Î±] {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘ð’œ â†’ ð’œ âŠ† finset.powerset_len r finset.univ",
    "theorem": "{Î± : Type u_1} [fintype Î±] {ð’œ : finset (finset Î±)} {r : â„•} : set.sized r â†‘ð’œ â†’ ð’œ âŠ† finset.powerset_len r finset.univ",
    "args": "{Î± : Type u_1} [fintype Î±] {ð’œ : finset (finset Î±)} {r : â„•}",
    "doc_string": "**Alias** of the reverse direction of finset.subset_powerset_len_univ_iff`.",
    "type": "set.sized r â†‘ð’œ â†’ ð’œ âŠ† finset.powerset_len r finset.univ"
  },
  {
    "name": "not_is_left_regular_zero_iff",
    "statement": "theorem not_is_left_regular_zero_iff {R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : Â¬is_left_regular 0 â†” nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not left-regular.",
    "type": "Â¬is_left_regular 0 â†” nontrivial R"
  },
  {
    "name": "dite_not",
    "statement": "theorem dite_not {Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x",
    "theorem": "{Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±) : dite (Â¬P) x y = dite P (Î» (h : P), y _) x",
    "args": "{Î± : Sort u_1} (P : Prop) [decidable P] (x : Â¬P â†’ Î±) (y : Â¬Â¬P â†’ Î±)",
    "doc_string": "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches.",
    "type": "dite (Â¬P) x y = dite P (Î» (h : P), y _) x"
  },
  {
    "name": "ite_not",
    "statement": "theorem ite_not {Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a",
    "theorem": "{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±) : ite (Â¬P) a b = ite P b a",
    "args": "{Î± : Sort u_1} (P : Prop) [decidable P] (a b : Î±)",
    "doc_string": "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches.",
    "type": "ite (Â¬P) a b = ite P b a"
  },
  {
    "name": "is_chain.symm",
    "statement": "theorem is_chain.symm {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s",
    "theorem": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s) : is_chain (flip r) s",
    "args": "{Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {s : set Î±} (h : is_chain r s)",
    "doc_string": "This can be used to turn `is_chain (â‰¥)` into `is_chain (â‰¤)` and vice-versa.",
    "type": "is_chain (flip r) s"
  },
  {
    "name": "affine_subspace.coe_injective",
    "statement": "theorem affine_subspace.coe_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "theorem": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "args": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "Two affine subspaces are equal if they have the same points.",
    "type": "function.injective coe"
  },
  {
    "name": "dihedral_group.order_of_r",
    "statement": "theorem dihedral_group.order_of_r {n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "theorem": "{n : â„•} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "args": "{n : â„•} [fact (0 < n)] (i : zmod n)",
    "doc_string": "If `0 < n`, then `i : zmod n` has order `n / gcd n i`.",
    "type": "order_of (dihedral_group.r i) = n / n.gcd i.val"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_coproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C]",
    "doc_string": "In a preadditive category, if all binary coproducts exist, then all binary biproducts exist.",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "prime_dvd_char_iff_dvd_card",
    "statement": "theorem prime_dvd_char_iff_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)]",
    "doc_string": " The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality.",
    "type": "p âˆ£ ring_char R â†” p âˆ£ fintype.card R"
  },
  {
    "name": "neg_nonneg",
    "statement": "theorem neg_nonneg {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±} : 0 â‰¤ -a â†” a â‰¤ 0",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] {a : Î±}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "type": "0 â‰¤ -a â†” a â‰¤ 0"
  },
  {
    "name": "is_add_hom.neg",
    "statement": "theorem is_add_hom.neg {Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)",
    "theorem": "{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f) : is_add_hom (Î» (a : Î±), -f a)",
    "args": "{Î± : Type u_1} {Î² : Type u_2} [has_add Î±] [add_comm_group Î²] {f : Î± â†’ Î²} (hf : is_add_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "type": "is_add_hom (Î» (a : Î±), -f a)"
  },
  {
    "name": "order.pred_ne_pred",
    "statement": "theorem order.pred_ne_pred {Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b",
    "theorem": "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±] : a â‰  b â†’ order.pred a â‰  order.pred b",
    "args": "{Î± : Type u_1} [partial_order Î±] [pred_order Î±] {a b : Î±} [no_min_order Î±]",
    "doc_string": "**Alias** of the reverse direction of order.pred_ne_pred_iff`.",
    "type": "a â‰  b â†’ order.pred a â‰  order.pred b"
  },
  {
    "name": "right_iff_left_not_left_of",
    "statement": "theorem right_iff_left_not_left_of {Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a",
    "theorem": "{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±} : s a b â†” r a b âˆ§ Â¬r b a",
    "args": "{Î± : Type u} (r s : Î± â†’ Î± â†’ Prop) [is_nonstrict_strict_order Î± r s] {a b : Î±}",
    "doc_string": "A version of `right_iff_left_not_left` with explicit `r` and `s`.",
    "type": "s a b â†” r a b âˆ§ Â¬r b a"
  },
  {
    "name": "lt_sub_left_of_add_lt",
    "statement": "theorem lt_sub_left_of_add_lt {Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a",
    "theorem": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±} : a + b < c â†’ b < c - a",
    "args": "{Î± : Type u} [add_comm_group Î±] [has_lt Î±] [covariant_class Î± Î± has_add.add has_lt.lt] {a b c : Î±}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt'`.",
    "type": "a + b < c â†’ b < c - a"
  },
  {
    "name": "one_add_mul_le_pow'",
    "statement": "theorem one_add_mul_le_pow' {R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n",
    "theorem": "{R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•) : 1 + â†‘n * a â‰¤ (1 + a) ^ n",
    "args": "{R : Type uâ‚} [ordered_semiring R] {a : R} (Hsq : 0 â‰¤ a * a) (Hsq' : 0 â‰¤ (1 + a) * (1 + a)) (H : 0 â‰¤ 2 + a) (n : â„•)",
    "doc_string": " Bernoulli's inequality. This version works for semirings but requires additional hypotheses `0 â‰¤ a * a` and `0 â‰¤ (1 + a) * (1 + a)`.",
    "type": "1 + â†‘n * a â‰¤ (1 + a) ^ n"
  },
  {
    "name": "neg_le_of_neg_le",
    "statement": "theorem neg_le_of_neg_le {Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a",
    "theorem": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±} : -a â‰¤ b â†’ -b â‰¤ a",
    "args": "{Î± : Type u} [add_group Î±] [has_le Î±] [covariant_class Î± Î± has_add.add has_le.le] [covariant_class Î± Î± (function.swap has_add.add) has_le.le] {a b : Î±}",
    "doc_string": "**Alias** of the forward direction of inv_le'`.",
    "type": "-a â‰¤ b â†’ -b â‰¤ a"
  },
  {
    "name": "category_theory.indecomposable_of_simple",
    "statement": "theorem category_theory.indecomposable_of_simple {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X]",
    "doc_string": "Any simple object in a preadditive category is indecomposable.",
    "type": "category_theory.indecomposable X"
  },
  {
    "name": "is_add_right_regular_of_right_cancel_add_semigroup",
    "statement": "theorem is_add_right_regular_of_right_cancel_add_semigroup {R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "theorem": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "args": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add right cancel semigroup are add-right-regular",
    "type": "is_add_right_regular g"
  },
  {
    "name": "add_subgroup.closure_le",
    "statement": "theorem add_subgroup.closure_le {G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K",
    "theorem": "{G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G} : add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K",
    "args": "{G : Type u_1} [add_group G] (K : add_subgroup G) {k : set G}",
    "doc_string": "An additive subgroup `K` includes `closure k` if and only if it includes `k`",
    "type": "add_subgroup.closure k â‰¤ K â†” k âŠ† â†‘K"
  },
  {
    "name": "finset.Ico_eq_empty",
    "statement": "theorem finset.Ico_eq_empty {Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…",
    "theorem": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±} : Â¬a < b â†’ finset.Ico a b = âˆ…",
    "args": "{Î± : Type u_1} [preorder Î±] [locally_finite_order Î±] {a b : Î±}",
    "doc_string": "**Alias** of the reverse direction of finset.Ico_eq_empty_iff`.",
    "type": "Â¬a < b â†’ finset.Ico a b = âˆ…"
  }
]