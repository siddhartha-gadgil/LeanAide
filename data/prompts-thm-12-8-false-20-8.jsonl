{"text": "If every proper closed set of a topological space is compact, then the space itself is compact.", "fullPrompt": "/-- A closed subset of a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t) :=\n\n/-- In a `t2_space`, every compact set is closed. -/\ntheorem {Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U) :=\n\n/--  A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`. -/\ntheorem {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact Î±) (filter.cocompact Î²) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- A compact set is bounded above -/\ntheorem {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_above s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H â†” totally_separated_space H :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b) :=\n\n/-- If X is is_compact then prâ‚‚ : X Ã— Y â†’ Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- If every proper closed set of a topological space is compact, then the space itself is compact. -/\ntheorem "}
{"text": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "fullPrompt": "/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2 :=\n\n/-- When `p âˆ¤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`. -/\ntheorem (p : â„•) [fact (nat.prime p)] {a : â„¤} (ha0 : â†‘a â‰  0) : zmod.legendre_sym p a = 1 â†” is_square â†‘a :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/-- A prime natural number is prime in `â„¤[i]` if and only if it is `3` mod `4` -/\ntheorem (p : â„•) [hp : fact (nat.prime p)] : prime â†‘p â†” p % 4 = 3 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p âˆ¤ a`. -/\ntheorem (p : â„•) [fact (nat.prime p)] (a : â„¤) (ha : â†‘a â‰  0) : zmod.legendre_sym p (a ^ 2) = 1 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem (p : â„•) [fact (nat.prime p)] {a : zmod p} (ha : a â‰  0) : is_square a â†” a ^ (p / 2) = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1 :=\n\n/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem (p : â„•) [fact (nat.prime p)] (hp : p â‰  2) (a : â„¤) : â†‘({x : zmod p | x ^ 2 = â†‘a}.to_finset.card) = zmod.legendre_sym p a + 1 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem "}
{"text": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "fullPrompt": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/--  `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple. -/\ntheorem {x y z : â„¤} (k : â„¤) (hk : k â‰  0) : pythagorean_triple (k * x) (k * y) (k * z) â†” pythagorean_triple x y z :=\n\n/-- Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`. -/\ntheorem {Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : has_add.add x âˆ˜ has_add.add y = has_add.add (x + y) :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n â‰¥ b 3. n âˆˆ Ico a b -/\ntheorem (n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b :=\n\n/-- Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`. -/\ntheorem {Î± : Type u_1} [semigroup Î±] (x y : Î±) : has_mul.mul x âˆ˜ has_mul.mul y = has_mul.mul (x * y) :=\n\n/-- Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`. -/\ntheorem {Î± : Type u_1} [add_semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x + x) âˆ˜ Î» (_x : Î±), _x + y) = Î» (_x : Î±), _x + (y + x) :=\n\n/-- Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`. -/\ntheorem {Î± : Type u_1} [semigroup Î±] (x y : Î±) : ((Î» (_x : Î±), _x * x) âˆ˜ Î» (_x : Î±), _x * y) = Î» (_x : Î±), _x * (y * x) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem "}
{"text": "A ring with all elements idempotent is commutative.", "fullPrompt": "/-- The identity map is a ring homomorphism. -/\ntheorem {Î± : Type u} [ring Î±] : is_ring_hom id :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a :=\n\n/-- Compressing an element is idempotent. -/\ntheorem {Î± : Type u_1} [generalized_boolean_algebra Î±] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : Î±) : uv.compress u v (uv.compress u v a) = uv.compress u v a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x) :=\n\n/-- The identity map is an additive monoid homomorphism. -/\ntheorem {Î± : Type u} [add_zero_class Î±] : is_add_monoid_hom id :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0 :=\n\n/-- Ring homomorphisms preserve additive inverses. -/\ntheorem {Î± : Type u} {Î² : Type v} [ring Î±] [ring Î²] {f : Î± â†’ Î²} {x : Î±} (hf : is_ring_hom f) : f (-x) = -f x :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem "}
{"text": "There are infinitely many pairs of primes that differ exactly by `2`.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : â„• | x â‰  0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : Â¬bdd_above {p : â„• | nat.prime p} :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : â„•} : is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : â„•) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- The Legendre symbol of `p` and `a` is zero iff `p âˆ£ a`. -/\ntheorem (p : â„•) [fact (nat.prime p)] (a : â„¤) : zmod.legendre_sym p a = 0 â†” â†‘a = 0 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem "}
{"text": "Every finite division ring is a field.", "fullPrompt": "/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R :=\n\n/-- A field extension is integral if it is finite. -/\ntheorem (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {Î± : Type u_1} [fintype Î±] [field Î±] : is_prime_pow (fintype.card Î±) :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0 :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : Â¬is_field (polynomial R) :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Î“â‚€ : Type u_3} [linear_ordered_comm_monoid_with_zero Î“â‚€] [nontrivial Î“â‚€] {K : Type u_1} [division_ring K] (v : valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0 :=\n\n/--  In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type u_1} {s : set Î¹} [is_noetherian K V] (b : basis â†¥s K V) : s.finite :=\n\n/--  Over a characteristic-zero division ring, the centroids of two faces of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : â„•} (s : affine.simplex k P n) {fsâ‚ fsâ‚‚ : finset (fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : finset.centroid k finset.univ (s.face hâ‚).points = finset.centroid k finset.univ (s.face hâ‚‚).points â†” fsâ‚ = fsâ‚‚ :=\n\n/--  The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `â„µâ‚€`. -/\ntheorem (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : module.rank K V < cardinal.aleph_0 :=\n\n/--  Over a characteristic-zero division ring, the centroids given by two subsets of the points of a simplex are equal if and only if those faces are given by the same subset of points. -/\ntheorem {k : Type u_1} {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] [char_zero k] {n : â„•} (s : affine.simplex k P n) {fsâ‚ fsâ‚‚ : finset (fin (n + 1))} {mâ‚ mâ‚‚ : â„•} (hâ‚ : fsâ‚.card = mâ‚ + 1) (hâ‚‚ : fsâ‚‚.card = mâ‚‚ + 1) : finset.centroid k fsâ‚ s.points = finset.centroid k fsâ‚‚ s.points â†” fsâ‚ = fsâ‚‚ :=\n\n/-- Every finite division ring is a field. -/\ntheorem "}
{"text": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "fullPrompt": "/--  **The SchrÃ¶der-Bernstein Theorem**: Given injections `Î± â†’ Î²` and `Î² â†’ Î±`, we can get a bijection `Î± â†’ Î²`. -/\ntheorem {Î± : Type u} {Î² : Type v} {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : function.injective f) (hg : function.injective g) : âˆƒ (h : Î± â†’ Î²), function.bijective h :=\n\n/-- A binary injective function is injective when only the right argument varies. -/\ntheorem {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (a : Î±) : function.injective (f a) :=\n\n/-- A binary injective function is injective when only the left argument varies. -/\ntheorem {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {f : Î± â†’ Î² â†’ Î³} (hf : function.injective2 f) (b : Î²) : function.injective (Î» (a : Î±), f a b) :=\n\n/-- `option.map f` is injective if `f` is injective. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} (Hf : function.injective f) : function.injective (option.map f) :=\n\n/--  `fin` as a map from `â„•` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible. -/\ntheorem  : function.injective fin :=\n\n/--  An injective function from a nontrivial type has an argument at which it does not take a given value. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [nontrivial Î±] {f : Î± â†’ Î²} (hf : function.injective f) (y : Î²) : âˆƒ (x : Î±), f x â‰  y :=\n\n/-- Composition by an bijective function on the left is itself bijective. -/\ntheorem {Î± : Sort u} {Î² : Sort v} {Î³ : Sort w} {g : Î² â†’ Î³} (hg : function.bijective g) : function.bijective (function.comp g) :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem {Î± : Sort u_1} {Î² : Sort u_2} {Î³ : Sort u_3} {g : Î² â†’ Î³} (hg : function.injective g) : function.injective (function.comp g) :=\n\n/--  If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well. -/\ntheorem {Î± : Sort u} {Î² : Sort v} {f : Î± â†’ Î²} (hf : function.injective f) [subsingleton Î²] : subsingleton Î± :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {Î± : Type u} : function.injective free_group.of :=\n\n/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/\ntheorem {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined âŸ¨x, _âŸ© âŸ¨y, _âŸ© :=\n\n/-- There is no surjection from `Î± : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean. -/\ntheorem {Î± : Type u} (f : Î± â†’ Type (max u v)) : Â¬function.surjective f :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem "}
{"text": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "fullPrompt": "/--  This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods. -/\ntheorem {X : Type u_1} [topological_space X] : discrete_topology X â†” nhds = has_pure.pure :=\n\n/-- Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`. -/\ntheorem {M : Type u_1} [has_mul M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : con_gen r â‰¤ con_gen s :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there  is some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ :=\n\n/-- Given binary relations `r, s` with `r` contained in `s`, the smallest additive congruence relation containing `s` contains the smallest additive congruence relation containing `r`. -/\ntheorem {M : Type u_1} [has_add M] {r s : M â†’ M â†’ Prop} (h : âˆ€ (x y : M), r x y â†’ s x y) : add_con_gen r â‰¤ add_con_gen s :=\n\n/-- If `s.nth n = some aâ‚™` for some value `aâ‚™`, then there is also some value `aâ‚˜` such that `s.nth = some aâ‚˜` for `m â‰¤ n`. -/\ntheorem {Î± : Type u} (s : seq Î±) {aâ‚™ : Î±} {n m : â„•} (m_le_n : m â‰¤ n) (s_nth_eq_some : s.nth n = option.some aâ‚™) : âˆƒ (aâ‚˜ : Î±), s.nth m = option.some aâ‚˜ :=\n\n/-- If a category has all coproducts then in particular it has finite coproducts. -/\ntheorem (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem {Î± : Type u} [topological_space Î±] {S : set (set Î±)} (K : directed_on has_subset.subset S) (H : âˆ€ (s : set Î±), s âˆˆ S â†’ is_preconnected s) : is_preconnected (â‹ƒâ‚€S) :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x} :=\n\n/-- Given a map `f : N â†’ M` and an equivalence relation `r` on `Î²`, the equivalence relation    induced on `Î±` by `f` equals the kernel of `r`'s quotient map composed with `f`. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {r : setoid Î²} : setoid.comap f r = setoid.ker (quotient.mk âˆ˜ f) :=\n\n/-- Two elements are related by an additive congruence relation `c` iff they are represented by the same element of the quotient by `c`. -/\ntheorem {M : Type u_1} [has_add M] (c : add_con M) {a b : M} : â†‘a = â†‘b â†” â‡‘c a b :=\n\n/--  The neighbourhoods {Î³ | Î³ < Î³â‚€} of 0 form a directed set indexed by the invertible elements Î³â‚€. -/\ntheorem (Î“â‚€ : Type u_1) [linear_ordered_comm_group_with_zero Î“â‚€] : directed ge (Î» (Î³â‚€ : Î“â‚€Ë£), filter.principal {Î³ : Î“â‚€ | Î³ < â†‘Î³â‚€}) :=\n\n/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C :=\n\n/-- The pseudoelement induced by an arrow is zero precisely when that arrow is zero -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : â†‘a = 0 â†” a.hom = 0 :=\n\n/--  The Monge plane associated with vertices `iâ‚` and `iâ‚‚` equals that associated with `iâ‚‚` and `iâ‚`. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} (s : affine.simplex â„ P (n + 2)) (iâ‚ iâ‚‚ : fin (n + 3)) : s.monge_plane iâ‚ iâ‚‚ = s.monge_plane iâ‚‚ iâ‚ :=\n\n/--  Suppose all distances from `pâ‚` and `pâ‚‚` to the points of a simplex are equal, and that `pâ‚` and `pâ‚‚` lie in the affine span of `p` with the vertices of that simplex.  Then `pâ‚` and `pâ‚‚` are equal or reflections of each other in the affine span of the vertices of the simplex. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {n : â„•} {s : affine.simplex â„ P n} {p pâ‚ pâ‚‚ : P} {r : â„} (hpâ‚ : pâ‚ âˆˆ affine_span â„ (has_insert.insert p (set.range s.points))) (hpâ‚‚ : pâ‚‚ âˆˆ affine_span â„ (has_insert.insert p (set.range s.points))) (hâ‚ : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) pâ‚ = r) (hâ‚‚ : âˆ€ (i : fin (n + 1)), has_dist.dist (s.points i) pâ‚‚ = r) : pâ‚ = pâ‚‚ âˆ¨ pâ‚ = â‡‘(euclidean_geometry.reflection (affine_span â„ (set.range s.points))) pâ‚‚ :=\n\n/--  Suppose we are given a triangle `tâ‚`, and replace one of its vertices by its orthocenter, yielding triangle `tâ‚‚` (with vertices not necessarily listed in the same order).  Then an altitude of `tâ‚‚` from a vertex that was not replaced is the corresponding side of `tâ‚`. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {tâ‚ tâ‚‚ : affine.triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : affine.simplex.altitude tâ‚‚ jâ‚‚ = affine_span â„ {tâ‚.points iâ‚, tâ‚.points iâ‚‚} :=\n\n/--  Suppose we are given a triangle `tâ‚`, and replace one of its vertices by its orthocenter, yielding triangle `tâ‚‚` (with vertices not necessarily listed in the same order).  Then the orthocenter of `tâ‚‚` is the vertex of `tâ‚` that was replaced. -/\ntheorem {V : Type u_1} {P : Type u_2} [inner_product_space â„ V] [metric_space P] [normed_add_torsor V P] {tâ‚ tâ‚‚ : affine.triangle â„ P} {iâ‚ iâ‚‚ iâ‚ƒ jâ‚ jâ‚‚ jâ‚ƒ : fin 3} (hiâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hiâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hiâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) (hjâ‚â‚‚ : jâ‚ â‰  jâ‚‚) (hjâ‚â‚ƒ : jâ‚ â‰  jâ‚ƒ) (hjâ‚‚â‚ƒ : jâ‚‚ â‰  jâ‚ƒ) (hâ‚ : tâ‚‚.points jâ‚ = tâ‚.orthocenter) (hâ‚‚ : tâ‚‚.points jâ‚‚ = tâ‚.points iâ‚‚) (hâ‚ƒ : tâ‚‚.points jâ‚ƒ = tâ‚.points iâ‚ƒ) : tâ‚‚.orthocenter = tâ‚.points iâ‚ :=\n\n/-- In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : â„•) (h : âˆ€ (v : V), G.degree v â‰¤ k) : G.max_degree â‰¤ k :=\n\n/-- In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum degree. Note the assumption that the graph is nonempty is necessary as long as `G.min_degree` is defined to be a natural. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] (k : â„•) (h : âˆ€ (v : V), k â‰¤ G.degree v) : k â‰¤ G.min_degree :=\n\n/--  The **closed graph theorem** : a linear map between two Banach spaces whose graph is closed is continuous. -/\ntheorem {ð•œ : Type u_1} [nondiscrete_normed_field ð•œ] {E : Type u_2} [normed_group E] [normed_space ð•œ E] {F : Type u_3} [normed_group F] [normed_space ð•œ F] [complete_space F] [complete_space E] (g : E â†’â‚—[ð•œ] F) (hg : is_closed â†‘(g.graph)) : continuous â‡‘g :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (v : V) : G.min_degree â‰¤ G.degree v :=\n\n/-- When `t` is supported on `s`, `f âˆˆ s.dfinsupp t` precisely means that `f` is pointwise in `t`. -/\ntheorem {Î¹ : Type u_1} {Î± : Î¹ â†’ Type u_2} [decidable_eq Î¹] [Î  (i : Î¹), has_zero (Î± i)] {s : finset Î¹} {f : Î â‚€ (i : Î¹), Î± i} [Î  (i : Î¹), decidable_eq (Î± i)] {t : Î â‚€ (i : Î¹), finset (Î± i)} (ht : t.support âŠ† s) : f âˆˆ s.dfinsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i :=\n\n/-- When `t` is supported on `s`, `f âˆˆ s.finsupp t` precisely means that `f` is pointwise in `t`. -/\ntheorem {Î¹ : Type u_1} {Î± : Type u_2} [has_zero Î±] {s : finset Î¹} {f : Î¹ â†’â‚€ Î±} {t : Î¹ â†’â‚€ finset Î±} (ht : t.support âŠ† s) : f âˆˆ s.finsupp â‡‘t â†” âˆ€ (i : Î¹), â‡‘f i âˆˆ â‡‘t i :=\n\n/--  A linear operator on a complex inner product space is self-adjoint precisely when `âŸªT v, vâŸ«_â„‚` is real for all v. -/\ntheorem {V : Type u_4} [inner_product_space â„‚ V] (T : V â†’â‚—[â„‚] V) : inner_product_space.is_self_adjoint T â†” âˆ€ (v : V), â‡‘(star_ring_end â„‚) (has_inner.inner (â‡‘T v) v) = has_inner.inner (â‡‘T v) v :=\n\n/--  For positive values, the derivative of the `n`-th auxiliary function `f_aux n` (given in this statement in unfolded form) is the `n+1`-th auxiliary function, since the polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/\ntheorem (n : â„•) (x : â„) (hx : x â‰  0) : has_deriv_at (Î» (x : â„), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-xâ»Â¹) / x ^ (2 * n)) (polynomial.eval x (exp_neg_inv_glue.P_aux (n + 1)) * real.exp (-xâ»Â¹) / x ^ (2 * (n + 1))) x :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem "}
{"text": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- **Alias** of the forward direction of odd_iff_exists_bit1`. -/\ntheorem {Î± : Type u_2} [semiring Î±] {a : Î±} : odd a â†’ (âˆƒ (b : Î±), a = bit1 b) :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : â„•} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/--  Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks. -/\ntheorem {c c' : Î£ (n : â„•), composition n} : c = c' â†” c.snd.blocks = c'.snd.blocks :=\n\n/-- Two holors are equal if all their slices are equal. -/\ntheorem {Î± : Type} {d : â„•} {ds : list â„•} (x y : holor Î± (d :: ds)) (h : x.slice = y.slice) : x = y :=\n\n/-- The cardinality of the antidiagonal of `n` is `n+1`. -/\ntheorem (n : â„•) : â‡‘multiset.card (multiset.nat.antidiagonal n) = n + 1 :=\n\n/-- **Number of Subsets of a Set** -/\ntheorem {Î± : Type u_1} (s : finset Î±) : s.powerset.card = 2 ^ s.card :=\n\n/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = Â±1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : a ^ (fintype.card F / 2) = 1 âˆ¨ a ^ (fintype.card F / 2) = -1 :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem {a b c : â„¤} (h : a % b = c) : b âˆ£ a - c :=\n\n/-- Congruence relations are symmetric. -/\ntheorem {M : Type u_1} [has_mul M] (c : con M) {x y : M} : â‡‘c x y â†’ â‡‘c y x :=\n\n/-- **Alias** of the forward direction of even_iff_exists_bit0`. -/\ntheorem {Î± : Type u_2} [has_add Î±] {a : Î±} : even a â†’ (âˆƒ (b : Î±), a = bit0 b) :=\n\n/--  To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q 1 â†’ Prop} (hÎ¹ : âˆ€ (v : M), P (â‡‘(clifford_algebra.Î¹ Q) v) _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1} {hy : y âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q 1) : P x hx :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem "}
{"text": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "fullPrompt": "/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} {c : set Î±} (hc : is_chain r c) : âˆƒ (M : set Î±), is_max_chain r M âˆ§ c âŠ† M :=\n\n/-- If `Î±` is a preorder with no maximal element, then `at_top â‰¤ cofinite`. -/\ntheorem {Î± : Type u_2} [preorder Î±] [no_max_order Î±] : filter.at_top â‰¤ filter.cofinite :=\n\n/--  **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `Î±`. Note that we do not require `Î±` to be partially ordered by `r`. -/\ntheorem {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} : is_max_chain r (max_chain r) :=\n\n/-- When there is a global maximum, every set is bounded above. -/\ntheorem {Î³ : Type w} [preorder Î³] [order_top Î³] (s : set Î³) : bdd_above s :=\n\n/-- If `s` has a greatest element, then it is bounded above. -/\ntheorem {Î± : Type u} [preorder Î±] {s : set Î±} {a : Î±} (h : is_greatest s a) : bdd_above s :=\n\n/--  If `P : â„¤ â†’ Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart. -/\ntheorem {P : â„¤ â†’ Prop} (Hbdd : âˆƒ (b : â„¤), âˆ€ (z : â„¤), P z â†’ z â‰¤ b) (Hinh : âˆƒ (z : â„¤), P z) : âˆƒ (ub : â„¤), P ub âˆ§ âˆ€ (z : â„¤), P z â†’ z â‰¤ ub :=\n\n/--  If `Î±` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `â„• â†’ Î±`. -/\ntheorem (Î± : Type u) [preorder Î±] [nonempty Î±] [no_max_order Î±] : âˆƒ (f : â„• â†’ Î±), strict_mono f :=\n\n/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem {Î± : Type u} [pseudo_emetric_space Î±] {x y : Î±} {s : set Î±} (h : y âˆˆ s) : emetric.inf_edist x s â‰¤ has_edist.edist x y :=\n\n/--  If `Î±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : â„¤ â†’ Î±`. -/\ntheorem (Î± : Type u) [preorder Î±] [nonempty Î±] [no_min_order Î±] [no_max_order Î±] : âˆƒ (f : â„¤ â†’ Î±), strict_mono f :=\n\n/--  If `Î±` is a preorder with no maximal elements, then there exists a strictly monotone function `â„• â†’ Î±` with any prescribed value of `f 0`. -/\ntheorem {Î± : Type u} [preorder Î±] [no_max_order Î±] (a : Î±) : âˆƒ (f : â„• â†’ Î±), strict_mono f âˆ§ f 0 = a :=\n\n/-- The supremum of a singleton is the element of the singleton -/\ntheorem {Î± : Type u_1} [conditionally_complete_lattice Î±] (a : Î±) : has_Sup.Sup {a} = a :=\n\n/-- **Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`. -/\ntheorem (Î± : Type u_1) [complete_lattice Î±] : complete_lattice.is_sup_closed_compact Î± â†’ complete_lattice.is_Sup_finite_compact Î± :=\n\n/--  A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite Î± â†’ nontrivial Î± â†’ nonempty Î±`. -/\ntheorem {Î± : Type u_1} [preorder Î±] [nonempty Î±] [no_max_order Î±] : infinite Î± :=\n\n/--  A compact element `k` has the property that any `b < k` lies below a \"maximal element below `k`\", which is to say `[âŠ¥, k]` is coatomic. -/\ntheorem {Î± : Type u_1} [complete_lattice Î±] {k : Î±} (h : complete_lattice.is_compact_element k) : is_coatomic â†¥(set.Iic k) :=\n\n/--  **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element. -/\ntheorem {Î± : Type u_1} {r : Î± â†’ Î± â†’ Prop} (h : âˆ€ (c : set Î±), is_chain r c â†’ (âˆƒ (ub : Î±), âˆ€ (a : Î±), a âˆˆ c â†’ r a ub)) (trans : âˆ€ {a b c : Î±}, r a b â†’ r b c â†’ r a c) : âˆƒ (m : Î±), âˆ€ (a : Î±), r m a â†’ r a m :=\n\n/--  If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`, then `a âŠ” b` is the least upper bound of `s âˆª t`. -/\ntheorem {Î³ : Type w} [semilattice_sup Î³] {a b : Î³} {s t : set Î³} (hs : is_lub s a) (ht : is_lub t b) : is_lub (s âˆª t) (a âŠ” b) :=\n\n/-- Introduction rule to prove that b is the supremum of s: it suffices to check that 1) b is an upper bound 2) every other upper bound b' satisfies b â‰¤ b'. -/\ntheorem {Î± : Type u_1} [conditionally_complete_lattice Î±] {s : set Î±} {b : Î±} (hs : s.nonempty) (h_is_ub : âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ b) (h_b_le_ub : âˆ€ (ub : Î±), (âˆ€ (a : Î±), a âˆˆ s â†’ a â‰¤ ub) â†’ b â‰¤ ub) : has_Sup.Sup s = b :=\n\n/--  If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any set `t`, `s âŠ† t âŠ† p`. -/\ntheorem {Î± : Type u} [preorder Î±] {a : Î±} {s t p : set Î±} (hs : is_lub s a) (hp : is_lub p a) (hst : s âŠ† t) (htp : t âŠ† p) : is_lub t a :=\n\n/-- A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. -/\ntheorem {p n k : â„•} : â‡‘((n.choose k).factorization) p â‰¤ nat.log p n :=\n\n/--  When the domain is non-empty, we do not need the `0 â‰¤ C` condition in the formula for âˆ¥fâˆ¥ as an `Inf`. -/\ntheorem {Î± : Type u} {Î² : Type v} [topological_space Î±] [semi_normed_group Î²] (f : bounded_continuous_function Î± Î²) [h : nonempty Î±] : âˆ¥fâˆ¥ = has_Inf.Inf {C : â„ | âˆ€ (x : Î±), âˆ¥â‡‘f xâˆ¥ â‰¤ C} :=\n\n/-- Cardinality of a non-empty `Icc` of finsets. -/\ntheorem {Î± : Type u_1} [decidable_eq Î±] {s t : finset Î±} (h : s âŠ† t) : (finset.Icc s t).card = 2 ^ (t.card - s.card) :=\n\n/--  The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top. -/\ntheorem {Î² : Type u_1} [conditionally_complete_lattice Î²] {s : set (with_top Î²)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s) :=\n\n/-- A non-empty set is countable iff there exists a surjection from the natural numbers onto the subtype induced by the set. -/\ntheorem {Î± : Type u} {s : set Î±} (hs : s.nonempty) : s.countable â†” âˆƒ (f : â„• â†’ â†¥s), function.surjective f :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem "}
{"text": "A group whose automorphism group is cyclic is Abelian.", "fullPrompt": "/-- A finite group of prime order is cyclic. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î± :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î± :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [group Î±] [comm_group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_group_hom (Î» (a : Î±), (f a)â»Â¹) :=\n\n/-- A map to a group preserving multiplication is a monoid homomorphism. -/\ntheorem {Î± : Type u} {Î² : Type v} [mul_one_class Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_mul_hom f) : is_monoid_hom f :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem {Î± : Type u} [comm_group Î±] : is_group_hom has_inv.inv :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x :=\n\n/-- The identity is an additive group homomorphism. -/\ntheorem {Î± : Type u} [add_group Î±] : is_add_group_hom id :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L :=\n\n/--  Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a simple algebra. -/\ntheorem {R : Type u} {L : Type v} {L' : Type wâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] (f : L â†’â‚—â…Râ† L') {Iâ‚ Iâ‚‚ : lie_ideal R L} : lie_ideal.map f â…Iâ‚,Iâ‚‚â† â‰¤ â…lie_ideal.map f Iâ‚,lie_ideal.map f Iâ‚‚â† :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem {G : Type u_1} [comm_group G] : group.nilpotency_class G â‰¤ 1 :=\n\n/--  If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g` and `g'` is an order right adjoint of `g` (i.e. `g' y = Sup {x | f x â‰¤ y}`), then `fb` is semiconjugate to `fa` by `g'`.  This is a version of Proposition 2.1 from [Ã‰tienne Ghys, Groupes d'homeomorphismes du cercle et cohomologie bornee][ghys87:groupes]. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [partial_order Î±] [preorder Î²] {fa : Î± â‰ƒo Î±} {fb : Î² â†ªo Î²} {g : Î± â†’ Î²} (h : function.semiconj g â‡‘fa â‡‘fb) {g' : Î² â†’ Î±} (hg' : is_order_right_adjoint g g') : function.semiconj g' â‡‘fb â‡‘fa :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem "}
{"text": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] : uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f :=\n\n/--  If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_dist x s) :=\n\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {Î± : Type u} {Î² : Type v} {Î³ : Type w} [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³] {G : Î² â†’ Î³} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Î  i, E i` is uniformly continuous. -/\ntheorem {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] [fact (1 â‰¤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {K : nnreal} {f : Î± â†’ Î²} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem "}
{"text": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "fullPrompt": "/-- The new distance is uniformly continuous. -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] : uniform_continuous (Î» (p : uniform_space.completion Î± Ã— uniform_space.completion Î±), has_dist.dist p.fst p.snd) :=\n\n/-- The minimal distance to a set is uniformly continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_dist x s) :=\n\n/-- The minimal distance to a set (as `â„â‰¥0`) is uniformly continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : uniform_continuous (Î» (x : Î±), metric.inf_nndist x s) :=\n\n/-- The indexed supremum of a function is bounded above by a uniform bound -/\ntheorem {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), f x â‰¤ c) : supr f â‰¤ c :=\n\n/-- The indexed minimum of a function is bounded below by a uniform lower bound -/\ntheorem {Î± : Type u_1} {Î¹ : Sort u_3} [conditionally_complete_lattice Î±] [nonempty Î¹] {f : Î¹ â†’ Î±} {c : Î±} (H : âˆ€ (x : Î¹), c â‰¤ f x) : c â‰¤ infi f :=\n\n/--  If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {f : Î± â†’ Î²} (hf : uniform_inducing f) : uniform_embedding f :=\n\n/-- In a sequential space, continuity and sequential continuity coincide. -/\ntheorem {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X â†’ Y} [sequential_space X] : continuous f â†” seq_continuous f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] {f : Î± â†’ Î²} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f :=\n\n/--  If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain. -/\ntheorem {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X â†’ Y} (h : lipschitz_with K f) : dimH (set.range f) â‰¤ dimH set.univ :=\n\n/-- The inclusion of a fiber into the total space is a continuous map. -/\ntheorem {Î¹ : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core Î¹ B F) (b : B) : continuous (bundle.total_space_mk b) :=\n\n/-- The minimal distance to a set is continuous in point -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] (s : set Î±) : continuous (Î» (x : Î±), metric.inf_dist x s) :=\n\n/-- The uncurrying process is a continuous map between function spaces. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î±] [topological_space Î²] [topological_space Î³] [locally_compact_space Î±] [locally_compact_space Î²] : continuous continuous_map.uncurry :=\n\n/-- Composing on the left by a uniformly continuous function preserves  uniform convergence on a set -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s : set Î±} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly_on F f p s) (hg : uniform_continuous g) : tendsto_uniformly_on (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p s :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î¹ : Type u_4} [uniform_space Î²] {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {p : filter Î¹} [uniform_space Î³] {g : Î² â†’ Î³} (h : tendsto_uniformly F f p) (hg : uniform_continuous g) : tendsto_uniformly (Î» (i : Î¹), g âˆ˜ F i) (g âˆ˜ f) p :=\n\n/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous -/\ntheorem {Î± : Type u} {Î² : Type v} {Î³ : Type w} [topological_space Î±] [pseudo_metric_space Î²] [pseudo_metric_space Î³] {G : Î² â†’ Î³} {C : nnreal} (H : lipschitz_with C G) : uniform_continuous (bounded_continuous_function.comp G H) :=\n\n/-- The coercion from `lp E p` to `Î  i, E i` is uniformly continuous. -/\ntheorem {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] [fact (1 â‰¤ p)] : uniform_continuous coe :=\n\n/--  Heine-Cantor: a continuous function on a compact set of a separated uniform space is uniformly continuous. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] [separated_space Î±] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/--  Heine-Cantor: a continuous function on a compact separated set of a uniform space is uniformly continuous. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [uniform_space Î±] [uniform_space Î²] {s : set Î±} {f : Î± â†’ Î²} (hs : is_compact s) (hs' : is_separated s) (hf : continuous_on f s) : uniform_continuous_on f s :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} (hf : holder_with C r f) (h0 : 0 < r) : uniform_continuous f :=\n\n/-- A HÃ¶lder continuous function is uniformly continuous -/\ntheorem {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C r : nnreal} {f : X â†’ Y} {s : set X} (hf : holder_on_with C r f s) (h0 : 0 < r) : uniform_continuous_on f s :=\n\n/-- A Lipschitz function is uniformly continuous -/\ntheorem {Î± : Type u} {Î² : Type v} [pseudo_emetric_space Î±] [pseudo_emetric_space Î²] {K : nnreal} {f : Î± â†’ Î²} (hf : lipschitz_with K f) : uniform_continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem "}
{"text": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "fullPrompt": "/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H â†” totally_separated_space H :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {Î± : Type u} [topological_space Î±] [t2_space Î±] (h : topological_space.is_topological_basis {s : set Î± | is_clopen s}) : totally_separated_space Î± :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y âˆˆ X`, there  is some clopen set `U` such that `x âˆˆ U` and `y âˆ‰ U`. Then `X` is totally disconnected. -/\ntheorem {X : Type u_1} [topological_space X] (hX : âˆ€ {x y : X}, x â‰  y â†’ (âˆƒ (U : set X) (h_clopen : is_clopen U), x âˆˆ U âˆ§ y âˆ‰ U)) : is_totally_disconnected set.univ :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- A product is regular if and only if the factors are. -/\ntheorem {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) â†” is_regular a âˆ§ is_regular b :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s} :=\n\n/--   Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular. -/\ntheorem {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) âˆ§ is_regular (b * a) â†” is_regular a âˆ§ is_regular b :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s âŠ† t) : group.normal_closure s âŠ† t :=\n\n/-- A space is totally disconnected iff its connected components are singletons. -/\ntheorem {Î± : Type u} [topological_space Î±] : totally_disconnected_space Î± â†” âˆ€ (x : Î±), connected_component x = {x} :=\n\n/--  For any subset `s` of `Î±`, the restriction of continuous functions to `s` is continuous as a function from `C(Î±, Î²)` to `C(s, Î²)` with their respective compact-open topologies. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [topological_space Î²] (s : set Î±) : continuous (Î» (F : C(Î±, Î²)), continuous_map.restrict s F) :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a â‰¤ b` are two real numbers, then there exists a continuous function `f : X â†’ â„` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a â‰¤ f x â‰¤ b` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : â„} (hle : a â‰¤ b) : âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f (function.const X a) s âˆ§ set.eq_on â‡‘f (function.const X b) t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc a b :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X â†’ â„` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 â‰¤ f x â‰¤ 1` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : C(X, â„)), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1 :=\n\n/--  Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X â†’ â„` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 â‰¤ f x â‰¤ 1` for all `x`. -/\ntheorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : âˆƒ (f : bounded_continuous_function X â„), set.eq_on â‡‘f 0 s âˆ§ set.eq_on â‡‘f 1 t âˆ§ âˆ€ (x : X), â‡‘f x âˆˆ set.Icc 0 1 :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem "}
{"text": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "fullPrompt": "/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem {Î± : Type u_1} {f : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (n : â„•) : function.is_periodic_pt f n x :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem {Î± : Type u_1} (f : Î± â†’ Î±) (x : Î±) : function.is_periodic_pt f 0 x :=\n\n/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {c : Î±} [semiring Î±] [add_group Î²] (h : function.antiperiodic f c) : function.periodic f (2 * c) :=\n\n/--  An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true. -/\ntheorem (n a : â„•) (p : â„• â†’ Prop) [decidable_pred p] (pp : function.periodic p a) : â‡‘multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem {Î± : Type u_1} (n : â„•) (x : Î±) : function.is_periodic_pt id n x :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {Î± : Type u_1} [linear_ordered_ring Î±] [archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- A function `f` on `fin (n + 1)` is monotone if and only if `f i â‰¤ f (i + 1)` for all `i`. -/\ntheorem {n : â„•} {Î± : Type u_1} [preorder Î±] {f : fin (n + 1) â†’ Î±} : monotone f â†” âˆ€ (i : fin n), f (â‡‘fin.cast_succ i) â‰¤ f i.succ :=\n\n/--  The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points. -/\ntheorem {f : ordinal â†’ ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f) :=\n\n/-- Every point is a fixed point of `id`. -/\ntheorem {Î± : Type u} (x : Î±) : function.is_fixed_pt id x :=\n\n/-- If `x` is a fixed point of `f âˆ˜ g` and `g`, then it is a fixed point of `f`. -/\ntheorem {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hfg : function.is_fixed_pt (f âˆ˜ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : â„•` with `y ^ n < x`. -/\ntheorem {Î± : Type u_1} [linear_ordered_field Î±] [archimedean Î±] {x y : Î±} (hx : 0 < x) (hy : y < 1) : âˆƒ (n : â„•), y ^ n < x :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f âˆ˜ g`. -/\ntheorem {Î± : Type u} {f g : Î± â†’ Î±} {x : Î±} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f âˆ˜ g) x :=\n\n/--  If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`. -/\ntheorem {Î± : Type u_1} {f : Î± â†’ Î±} {x y : Î±} {m n : â„•} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem "}
{"text": "A terminal object in a category is unique up to unique isomorphism.", "fullPrompt": "/-- If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`. -/\ntheorem {C : Type uâ‚} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A :=\n\n/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C :=\n\n/-- If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`. -/\ntheorem {C : Type uâ‚} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A) :=\n\n/-- If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`. -/\ntheorem {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A) :=\n\n/-- If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`. -/\ntheorem {C : Type uâ‚} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A :=\n\n/-- Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.) -/\ntheorem {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B) :=\n\n/-- Any category with pullbacks and terminal object has binary products. -/\ntheorem (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C :=\n\n/-- Any simple object in a preadditive category is indecomposable. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X :=\n\n/-- If a preadditive category has all kernels, then it also has all equalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C :=\n\n/-- If a preadditive category has all cokernels, then it also has all coequalizers. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C :=\n\n/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C :=\n\n/-- In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y :=\n\n/--  If `c` is a limiting binary product cone, and we have a terminal object, then we have `is_pullback c.fst c.snd 0 0` (where each `0` is the unique morphism to the terminal object). -/\ntheorem {C : Type uâ‚} [category_theory.category C] {X Y Z : C} {c : category_theory.limits.binary_fan X Y} (h : category_theory.limits.is_limit c) (t : category_theory.limits.is_terminal Z) : category_theory.is_pullback c.fst c.snd (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.left})) (t.from ((category_theory.limits.pair X Y).obj {as := category_theory.limits.walking_pair.right})) :=\n\n/--  To show a category is a `initial_mono_class` it suffices to show the unique morphism from the initial object to a terminal object is a monomorphism. -/\ntheorem {C : Type uâ‚} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.mono (category_theory.limits.initial.to (âŠ¤_ C))) : category_theory.limits.initial_mono_class C :=\n\n/-- If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object also. Note this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C` has limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape `J`. -/\ntheorem {C : Type uâ‚} [category_theory.category C] {D : Type uâ‚‚} [category_theory.category D] (G : C â¥¤ D) [category_theory.limits.has_terminal C] [category_theory.limits.preserves_limit (category_theory.functor.empty C) G] : category_theory.limits.has_terminal D :=\n\n/--  If all but one object in a diagram is strict terminal, the the limit is isomorphic to the said object via `limit.Ï€`. -/\ntheorem {C : Type u} [category_theory.category C] [category_theory.limits.has_strict_terminal_objects C] {J : Type v} [category_theory.small_category J] (F : J â¥¤ C) [category_theory.limits.has_limit F] (i : J) (H : Î  (j : J), j â‰  i â†’ category_theory.limits.is_terminal (F.obj j)) [subsingleton (i âŸ¶ i)] : category_theory.is_iso (category_theory.limits.limit.Ï€ F i) :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem "}
{"text": "The complement of the union of two sets is the intersection of their complements.", "fullPrompt": "/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {Î³ : Type w} [semilattice_sup Î³] {s t : set Î³} : bdd_above (s âˆª t) â†” bdd_above s âˆ§ bdd_above t :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem {Î³ : Type w} [semilattice_inf Î³] {s t : set Î³} : bdd_below (s âˆª t) â†” bdd_below s âˆ§ bdd_below t :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.bounded (s âˆª t) â†” metric.bounded s âˆ§ metric.bounded t :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s âˆª t) :=\n\n/-- The union of two GÎ´ sets is a GÎ´ set. -/\ntheorem {Î± : Type u_1} [topological_space Î±] {s t : set Î±} (hs : is_GÎ´ s) (ht : is_GÎ´ t) : is_GÎ´ (s âˆª t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t) :=\n\n/-- If `s` is bounded, then so is `s âˆ© t` -/\ntheorem {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_above s) : bdd_above (s âˆ© t) :=\n\n/-- If `s` is bounded, then so is `s âˆ© t` -/\ntheorem {Î± : Type u} [preorder Î±] {s t : set Î±} (h : bdd_below s) : bdd_below (s âˆ© t) :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t) :=\n\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem {Î± : Type u_1} {Î¹ : Type u_3} [complete_lattice Î±] {t : Î¹ â†’ Î±} (ht : complete_lattice.independent t) : pairwise (disjoint on t) :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t) :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem "}
{"text": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "fullPrompt": "/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/--  Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity. -/\ntheorem {x y z : â„¤} : pythagorean_triple x y z â†” pythagorean_triple y x z :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n â‰¥ b 3. n âˆˆ Ico a b -/\ntheorem (n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b :=\n\n/--  A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`. -/\ntheorem {x y z : â„¤} (h : pythagorean_triple x y z) (k : â„¤) : pythagorean_triple (k * x) (k * y) (k * z) :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/-- Additive congruence relations preserve negation. -/\ntheorem {M : Type u_1} [add_group M] (c : add_con M) {w x : M} : â‡‘c w x â†’ â‡‘c (-w) (-x) :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p :=\n\n/-- We now have four different results that all encode the idea that inequality of multisets corresponds to divisibility of positive integers. -/\ntheorem {m n : â„•+} : m.factor_multiset â‰¤ n.factor_multiset â†” m âˆ£ n :=\n\n/-- The gcd and lcm operations on positive integers correspond to the inf and sup operations on multisets. -/\ntheorem (m n : â„•+) : (m.gcd n).factor_multiset = m.factor_multiset âŠ“ n.factor_multiset :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem "}
{"text": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "fullPrompt": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_mul S] (a : S) : commute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem {S : Type u_1} [has_add S] (a : S) : add_commute a a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c) :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c) :=\n\n/-- Moving to the opposite group or group_with_zero commutes with taking powers. -/\ntheorem {M : Type u} [div_inv_monoid M] (x : M) (z : â„¤) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x :=\n\n/-- Commuting elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/--  If `A` is a family of enough low-degree polynomials over a finite ring, there is a pair of elements in `A` (with different indices but not necessarily distinct), such that their difference has small degree. -/\ntheorem {Fq : Type u_1} [fintype Fq] [ring Fq] {d m : â„•} (hm : fintype.card Fq ^ d â‰¤ m) (b : polynomial Fq) (A : fin m.succ â†’ polynomial Fq) (hA : âˆ€ (i : fin m.succ), (A i).degree < b.degree) : âˆƒ (iâ‚€ iâ‚ : fin m.succ), iâ‚€ â‰  iâ‚ âˆ§ (A iâ‚ - A iâ‚€).degree < â†‘(b.nat_degree - d) :=\n\n/-- If a set `s` does not contain any elements between any pair of elements `x, z âˆˆ s` with `x â‰¤ z` (i.e if given `x, y, z âˆˆ s` such that `x â‰¤ y â‰¤ z`, then `y` is either `x` or `z`), then `s` is finite. -/\ntheorem {Î± : Type u_1} [linear_order Î±] (s : set Î±) (h : âˆ€ (x : Î±), x âˆˆ s â†’ âˆ€ (y : Î±), y âˆˆ s â†’ âˆ€ (z : Î±), z âˆˆ s â†’ x â‰¤ y â†’ y â‰¤ z â†’ x = y âˆ¨ y = z) : s.finite :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem "}
{"text": "The product of two consecutive natural numbers is even.", "fullPrompt": "/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : â„•} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/--  Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one. -/\ntheorem {Î± : Type u_1} [linear_ordered_ring Î±] [archimedean Î±] {x y : Î±} (hx : 1 â‰¤ x) (hy : 1 < y) : âˆƒ (n : â„•), y ^ n â‰¤ x âˆ§ x < y ^ (n + 1) :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : â„• | x â‰  0} :=\n\n/-- For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n â‰¥ b 3. n âˆˆ Ico a b -/\ntheorem (n a b : â„•) : n < a âˆ¨ b â‰¤ n âˆ¨ n âˆˆ list.Ico a b :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem "}
{"text": "Every index 2 subgroup of a group is normal.", "fullPrompt": "/-- The normal closure of a set is a subgroup. -/\ntheorem {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s) :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s âŠ† t) : group.normal_closure s âŠ† t :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î± :=\n\n/-- The lower central series of a group is a descending central series. -/\ntheorem {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G) :=\n\n/-- The upper central series of a group is an ascending central series. -/\ntheorem (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G) :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H :=\n\n/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_descending_central_series H) (n : â„•) : lower_central_series G n â‰¤ H n :=\n\n/-- If `0 < n`, then `dihedral_group n` has `2n` elements. -/\ntheorem {n : â„•} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : âˆƒ (V : open_add_subgroup R), â†‘V * â†‘V âŠ† â†‘U :=\n\n/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem {G : Type u_1} [group G] (H : â„• â†’ subgroup G) (hH : is_ascending_central_series H) (n : â„•) : H n â‰¤ upper_central_series G n :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem "}
{"text": "Every free group is torsion free.", "fullPrompt": "/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚ :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {Î± : Type u} : function.injective free_group.of :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚ :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G â†” monoid.fg G :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem {G : Type u_1} {H : Type u_2} [group G] {N : subgroup G} [group H] {f : G â†’* H} (hf : function.surjective â‡‘f) (hN : N = f.ker) (tN : monoid.is_torsion â†¥N) : monoid.is_torsion H â†” monoid.is_torsion G :=\n\n/-- If a group exponent exists, the group is torsion. -/\ntheorem {G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G :=\n\n/-- The image of a quotient is additively torsion iff the group is torsion. -/\ntheorem {G : Type u_1} {H : Type u_2} [add_group G] {N : add_subgroup G} [add_group H] {f : G â†’+ H} (hf : function.surjective â‡‘f) (hN : N = f.ker) (tN : add_monoid.is_torsion â†¥N) : add_monoid.is_torsion H â†” add_monoid.is_torsion G :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_group (Gs i)] (tfGs : âˆ€ (i : Î·), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G â§¸ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G â§¸ torsion G) :=\n\n/-- Every free group is torsion free. -/\ntheorem "}
{"text": "Every natural number greater than `1` is divisible by a prime number. ", "fullPrompt": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : â„• | x â‰  0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2 :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/\ntheorem {n : â„•} : is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n :=\n\n/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/\ntheorem {a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)) : a = p ^ (k + 1) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem (p' : â„•) : 2 < lucas_lehmer.q (p' + 2) :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem {n p k : â„•} (hn : n â‰  0) (h : n.factorization = finsupp.single p k) : n = p ^ k :=\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/\ntheorem {R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : â„•) [hq : exp_char R q] : nat.prime q âˆ¨ q = 1 :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p :=\n\n/--  If a small natural number is divisible by a larger natural number, the small number is zero. -/\ntheorem {a b : â„•} (w : a âˆ£ b) (h : b < a) : b = 0 :=\n\n/-- Every natural number greater than `1` is divisible by a prime number.  -/\ntheorem "}
{"text": "A finite torsion-free group is trivial", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î± :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : â„•} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î± :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1 :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem "}
{"text": "Every finite division ring is a field.", "fullPrompt": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g :=\n\n/-- A finite group of prime order is simple. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_simple_group Î± :=\n\n/-- A p-group is nilpotent -/\ntheorem {G : Type u_1} [hG : group G] [hf : fintype G] {p : â„•} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î± :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1 :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem "}
{"text": "Every finite topological space is compact.", "fullPrompt": "/-- In a `t2_space`, every compact set is closed. -/\ntheorem {Î± : Type u} [topological_space Î±] [t2_space Î±] {s : set Î±} (hs : is_compact s) : is_closed s :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K' :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U) :=\n\n/--  Every separated topological group in which there exists a compact set with nonempty interior is locally compact. -/\ntheorem {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) : is_compact (s âˆ© t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (ht : is_compact t) (hs : is_closed s) : is_compact (s âˆ© t) :=\n\n/-- An unordered closed interval is compact. -/\ntheorem {Î± : Type u_1} [linear_order Î±] [topological_space Î±] [compact_Icc_space Î±] {a b : Î±} : is_compact (set.interval a b) :=\n\n/-- A compact set is bounded above -/\ntheorem {Î± : Type u} [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_above s :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {Î¹ : Type w} [fintype Î¹] (h : basis Î¹ K V) : finite_dimensional K V :=\n\n/-- The span of a finite subset is compact in the lattice of submodules. -/\ntheorem {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R â†‘S) :=\n\n/-- If X is is_compact then prâ‚‚ : X Ã— Y â†’ Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- Every finite topological space is compact. -/\ntheorem "}
{"text": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "fullPrompt": "/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {Î± : Type u} : function.injective free_group.of :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 1 â†’ a = 1 :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem {Î± : Type u} {Î² : Type v} [add_group Î±] [add_group Î²] {f : Î± â†’ Î²} (hf : is_add_group_hom f) : function.injective f â†” âˆ€ (a : Î±), f a = 0 â†’ a = 0 :=\n\n/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚ :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : f 1 = 1 :=\n\n/-- Given a map f from Î± to Î², the natural map from the quotient of Î± by the kernel of f is    injective. -/\ntheorem {Î± : Type u_1} {Î² : Type u_2} (f : Î± â†’ Î²) : function.injective (quotient.lift f _) :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem {Î± : Type u} {Î² : Type v} [group Î±] [group Î²] {f : Î± â†’ Î²} (hf : is_group_hom f) : is_monoid_hom f :=\n\n/-- A free module with a basis indexed by a `fintype` is finite. -/\ntheorem {R : Type u_1} {M : Type u_2} {Î¹ : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype Î¹] (b : basis Î¹ R M) : module.finite R M :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚ :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/--  Adding a group element to the point `p` is an injective function. -/\ntheorem {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (Î» (_x : G), _x +áµ¥ p) :=\n\n/-- The range of a surjective homomorphism from a nilpotent group is nilpotent -/\ntheorem {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G â†’* G') (hf : function.surjective â‡‘f) : group.is_nilpotent G' :=\n\n/-- Surjective `add_monoid` homomorphisms constant on an additive congruence relation `c`'s equivalence classes induce a surjective homomorphism on `c`'s quotient. -/\ntheorem {M : Type u_1} {P : Type u_3} [add_zero_class M] [add_zero_class P] {c : add_con M} {f : M â†’+ P} (h : c â‰¤ add_con.ker f) (hf : function.surjective â‡‘f) : function.surjective â‡‘(c.lift f h) :=\n\n/-- Surjective monoid homomorphisms constant on a congruence relation `c`'s equivalence classes    induce a surjective homomorphism on `c`'s quotient. -/\ntheorem {M : Type u_1} {P : Type u_3} [mul_one_class M] [mul_one_class P] {c : con M} {f : M â†’* P} (h : c â‰¤ con.ker f) (hf : function.surjective â‡‘f) : function.surjective â‡‘(c.lift f h) :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem "}
{"text": "Every positive even integer can be written as the sum of two primes.", "fullPrompt": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : â„• | x â‰  0} :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem (n : â„•) : n.factorization = 0 â†” n = 0 âˆ¨ n = 1 :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0 :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ m + n â†” m âˆ£ n :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ n + m â†” m âˆ£ n :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem (p : â„•) [fact (nat.prime p)] : â†‘((p - 1).factorial) = -1 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem {n : â„•} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0 :=\n\n/-- Factoring a prime gives the corresponding one-element multiset. -/\ntheorem (p : nat.primes) : â†‘p.factor_multiset = prime_multiset.of_prime p :=\n\n/-- A version of `nat.exists_infinite_primes` using the `bdd_above` predicate. -/\ntheorem  : Â¬bdd_above {p : â„• | nat.prime p} :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p :=\n\n/-- A version of `nat.exists_infinite_primes` using the `set.infinite` predicate. -/\ntheorem  : {p : â„• | nat.prime p}.infinite :=\n\n/-- For any positive `k : â„•` there are infinitely many primes `p` such that `p â‰¡ 1 [MOD k]`. -/\ntheorem {k : â„•} (n : â„•) (hpos : 0 < k) : âˆƒ (p : â„•), nat.prime p âˆ§ n â‰¤ p âˆ§ p â‰¡ 1 [MOD k] :=\n\n/-- If we start with a multiset of primes, take the product and then factor it, we get back the original multiset. -/\ntheorem (v : prime_multiset) : v.prod.factor_multiset = v :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem "}
{"text": "Every matrix satisfies its own characteristic polynomial.", "fullPrompt": "/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms. -/\ntheorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : â‡‘(polynomial.aeval M) M.charpoly = 0 :=\n\n/-- The exponential characteristic is one iff the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p q : â„•) [char_p R p] [exp_char R q] : q = 1 â†” p = 0 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] (p : â„•) [hp : char_p R p] [hq : exp_char R 1] : p = 0 :=\n\n/-- The exponential characteristic is one if the characteristic is zero. -/\ntheorem (R : Type u) [semiring R] (q : â„•) [hp : char_p R 0] [hq : exp_char R q] : q = 1 :=\n\n/-- The characteristic equals the exponential characteristic iff the former is prime. -/\ntheorem (R : Type u) [semiring R] (p q : â„•) [hp : char_p R p] [hq : exp_char R q] : p = q â†” nat.prime p :=\n\n/-- Characteristic `â‰  2` and nontrivial implies that `-1 â‰  1`. -/\ntheorem {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R â‰  2) : -1 â‰  1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : â„•) [hq : exp_char R q] : nat.prime q âˆ¨ q = 1 :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : â„•} [hp : char_p R p] (p_ne_zero : p â‰  0) : nat.prime p :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0 :=\n\n/--  In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`, and `0` otherwise. We give a formula that also works in infinite dimension, where we define the determinant to be `1`. -/\ntheorem {ð•œ : Type u_1} [field ð•œ] {M : Type u_2} [add_comm_group M] [module ð•œ M] : â‡‘linear_map.det 0 = 0 ^ finite_dimensional.finrank ð•œ M :=\n\n/-- If `R` has characteristic `0`, then so does Frac(R). -/\ntheorem (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K :=\n\n/--  The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace :=\n\n/--  The characteristic polynomial of the map `Î» x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates. -/\ntheorem {K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (â‡‘(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen :=\n\n/-- The geometric sequence `q^n` is a solution of `E` iff  `q` is a root of `E`'s characteristic polynomial. -/\ntheorem {Î± : Type u_1} [comm_ring Î±] (E : linear_recurrence Î±) (q : Î±) : E.is_solution (Î» (n : â„•), q ^ n) â†” E.char_poly.is_root q :=\n\n/--  The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) : â‡‘(polynomial.aeval f) f.charpoly = 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M â†’â‚—[R] M) {Î¹ : Type w} [fintype Î¹] (b : basis Î¹ R M) : (â‡‘(linear_map.to_matrix b b) f).charpoly = f.charpoly :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem "}
{"text": "The square root of an irrational number is irrational.", "fullPrompt": "/-- The golden ratio is irrational. -/\ntheorem  : irrational golden_ratio :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem  : irrational golden_conj :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem  : pythagorean_triple 0 0 0 :=\n\n/-- **Alias** of the forward direction of is_square_iff_exists_sq`. -/\ntheorem {Î± : Type u_2} [monoid Î±] (m : Î±) : is_square m â†’ (âˆƒ (c : Î±), m = c ^ 2) :=\n\n/-- Natural division is always less than division in the field. -/\ntheorem {Î± : Type u_1} [linear_ordered_field Î±] {m n : â„•} : â†‘(m / n) â‰¤ â†‘m / â†‘n :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0 :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) {a : F} (ha : a â‰  0) : is_square a â†” a ^ (fintype.card F / 2) = 1 :=\n\n/-- **Alias** of int.abs_le_self_sq`. -/\ntheorem (a : â„¤) : â†‘(a.nat_abs) â‰¤ a ^ 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem {a : â„•} : real.sqrt â†‘a â‰¤ â†‘(nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem {a : â„•} : â†‘(nat.sqrt a) â‰¤ real.sqrt â†‘a :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] {a b c : R} (h2 : 2 â‰  0) (ha : a â‰  0) (h : âˆ€ (s : R), discrim a b c â‰  s * s) (x : R) : a * x * x + b * x + c â‰  0 :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem {x y : â„} (h : x < y) : âˆƒ (r : â„), irrational r âˆ§ x < r âˆ§ r < y :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem {p x : â„} (h : liouville_with p x) (hp : 1 < p) : irrational x :=\n\n/-- A transcendental real number is irrational. -/\ntheorem {r : â„} (tr : transcendental â„š r) : irrational r :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem {x y : â„} : irrational (x + y) â†’ irrational x âˆ¨ irrational y :=\n\n/--  If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x` is irrational. -/\ntheorem {x : â„} (n : â„•) {m : â„¤} (hm : m â‰  0) (p : â„•) [hp : fact (nat.prime p)] (hxr : x ^ n = â†‘m) (hv : (multiplicity â†‘p m).get _ % n â‰  0) : irrational x :=\n\n/--  If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational. -/\ntheorem {x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = â†‘m) (hv : Â¬âˆƒ (y : â„¤), x = â†‘y) (hnpos : 0 < n) : irrational x :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem "}
{"text": "If the square of a number is even, the number itself is even.", "fullPrompt": "/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/\ntheorem {m n : â„•} : even (m ^ n) â†” even m âˆ§ n â‰  0 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem {Î± : Type u} [linear_ordered_ring Î±] {x y : Î±} : x * x + y * y = 0 â†” x = 0 âˆ§ y = 0 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2) : âˆƒ (a : F), Â¬is_square a :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem {n : â„•} : n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3 :=\n\n/-- Two natural numbers are equal if and only if the have the same multiples. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), m âˆ£ a â†” n âˆ£ a) â†” m = n :=\n\n/-- Two natural numbers are equal if and only if the have the same divisors. -/\ntheorem {m n : â„•} : (âˆ€ (a : â„•), a âˆ£ m â†” a âˆ£ n) â†” m = n :=\n\n/-- `0` is always a square (in a monoid with zero). -/\ntheorem (M : Type u_1) [monoid_with_zero M] : is_square 0 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/\ntheorem {p : â„•} [fact (nat.prime p)] : p % 2 = 1 â†” p â‰  2 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a :=\n\n/-- Note that most of the lemmas about powers of two refer to it as `sq`. -/\ntheorem {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a :=\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/\ntheorem {n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : Â¬âˆƒ (t : â„•), t * t = n :=\n\n/-- **Alias** of the reverse direction of is_square_iff_exists_sq`. -/\ntheorem {Î± : Type u_2} [monoid Î±] (m : Î±) : (âˆƒ (c : Î±), m = c ^ 2) â†’ is_square m :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem "}
{"text": "In a finite commutative ring, all prime ideals are maximal.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p :=\n\n/--  The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : p âˆ£ ring_char R â†” p âˆ£ fintype.card R :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0 :=\n\n/-- The variable of the power series ring over an integral domain is prime. -/\ntheorem {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem {Î± : Type u_1} [fintype Î±] [field Î±] : is_prime_pow (fintype.card Î±) :=\n\n/--  An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented. -/\ntheorem {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A â†” algebra.finite_presentation R A :=\n\n/-- A module over a division ring is noetherian if and only if it is finitely generated. -/\ntheorem {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V â†” module.finite K V :=\n\n/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/-- A minimal polynomial is prime. -/\ntheorem {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem {Î± : Type u} [group Î±] [fintype Î±] {p : â„•} [hp : fact (nat.prime p)] (h : fintype.card Î± = p) : is_cyclic Î± :=\n\n/--  A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain. -/\ntheorem (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K :=\n\n/-- If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c. -/\ntheorem {Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ b) : a âˆ£ b + c â†” a âˆ£ c :=\n\n/-- If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b. -/\ntheorem {Î± : Type u} [non_unital_ring Î±] {a b c : Î±} (h : a âˆ£ c) : a âˆ£ b + c â†” a âˆ£ b :=\n\n/--  A ring is a Jacobson ring if and only if for all prime ideals `P`, the Jacobson radical of `P` is equal to `P`. -/\ntheorem {R : Type u_1} [comm_ring R] : ideal.is_jacobson R â†” âˆ€ (P : ideal R), P.is_prime â†’ P.jacobson = P :=\n\n/--  In a Dedekind domain, the (nonzero) prime elements of the monoid with zero `ideal A` are exactly the prime ideals. -/\ntheorem {A : Type u_2} [comm_ring A] [is_domain A] [is_dedekind_domain A] {P : ideal A} (hP : P â‰  âŠ¥) : prime P â†” P.is_prime :=\n\n/--  If `R` is a ring, then prime ideals in the localization at `M` correspond to prime ideals in the original ring `R` that are disjoint from `M`. This lemma gives the particular case for an ideal and its comap, see `le_rel_iso_of_prime` for the more general relation isomorphism -/\ntheorem {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] (J : ideal S) : J.is_prime â†” (ideal.comap (algebra_map R S) J).is_prime âˆ§ disjoint â†‘M â†‘(ideal.comap (algebra_map R S) J) :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem "}
{"text": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$.", "fullPrompt": "/-- The Hausdorff distance between a set and itself is zero -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] {s : set Î±} : metric.Hausdorff_dist s s = 0 :=\n\n/-- The Hausdorff distance satisfies the triangular inequality -/\ntheorem {Î± : Type u} [pseudo_emetric_space Î±] {s t u : set Î±} : emetric.Hausdorff_edist s u â‰¤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u :=\n\n/-- The Hausdorff edistance of a set to itself vanishes -/\ntheorem {Î± : Type u} [pseudo_emetric_space Î±] {s : set Î±} : emetric.Hausdorff_edist s s = 0 :=\n\n/-- The distance to a set is controlled by the Hausdorff distance -/\ntheorem {Î± : Type u} [pseudo_emetric_space Î±] {x : Î±} {s t : set Î±} (h : x âˆˆ s) : emetric.inf_edist x t â‰¤ emetric.Hausdorff_edist s t :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : 0 â‰¤ metric.Hausdorff_dist s t :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.snd :=\n\n/-- If X is is_compact then prâ‚‚ : X Ã— Y â†’ Y is a closed map -/\ntheorem {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd :=\n\n/-- A Hausdorff space with a clopen basis is totally separated. -/\ntheorem {Î± : Type u} [topological_space Î±] [t2_space Î±] (h : topological_space.is_topological_basis {s : set Î± | is_clopen s}) : totally_separated_space Î± :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst :=\n\n/-- The Hausdorff distance from `s` to `t` and from `t` to `s` coincide -/\ntheorem {Î± : Type u} [pseudo_metric_space Î±] {s t : set Î±} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s â†” is_closed s :=\n\n/-- A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated. -/\ntheorem {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H â†” totally_separated_space H :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X Ã— X$. -/\ntheorem "}
{"text": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "fullPrompt": "/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 âˆˆ interior â†‘H) : is_open â†‘H :=\n\n/-- Any open set is the union of the basis sets contained in it. -/\ntheorem {Î± : Type u} [t : topological_space Î±] {B : set (set Î±)} (hB : topological_space.is_topological_basis B) {u : set Î±} (ou : is_open u) : u = â‹ƒâ‚€{s âˆˆ B | s âŠ† u} :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] {K : set Î±} (hK : is_compact K) : âˆƒ (K' : set Î±), is_compact K' âˆ§ K âŠ† interior K' :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s âˆ© t) :=\n\n/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s âˆ© t) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem {Î± : Type u} [topological_space Î±] {s t : set Î±} (hs : is_compact s) (ht : is_closed t) (h : t âŠ† s) : is_compact t :=\n\n/--  This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods. -/\ntheorem {X : Type u_1} [topological_space X] : discrete_topology X â†” nhds = has_pure.pure :=\n\n/-- An open set is a GÎ´ set. -/\ntheorem {Î± : Type u_1} [topological_space Î±] {s : set Î±} (h : is_open s) : is_GÎ´ s :=\n\n/-- In a locally compact Tâ‚‚ space, every point has an open neighborhood with compact closure -/\ntheorem {Î± : Type u} [topological_space Î±] [locally_compact_space Î±] [t2_space Î±] (x : Î±) : âˆƒ (U : set Î±), is_open U âˆ§ x âˆˆ U âˆ§ is_compact (closure U) :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem {Î± : Type u} {Î² : Type v} [topological_space Î±] [topological_space Î²] : is_open_map prod.fst :=\n\n/-- The closure of a (pre)connected set is (pre)connected as well. -/\ntheorem {Î± : Type u} [topological_space Î±] {s : set Î±} (H : is_preconnected s) : is_preconnected (closure s) :=\n\n/-- The frontier of a closed set has no interior point. -/\ntheorem {Î± : Type u} [topological_space Î±] {s : set Î±} (h : is_closed s) : interior (frontier s) = âˆ… :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space  is contained in a clopen set contained in the open set. -/\ntheorem {Î± : Type u} [topological_space Î±] [t2_space Î±] [compact_space Î±] [totally_disconnected_space Î±] {x : Î±} {U : set Î±} (is_open : _root_.is_open U) (memU : x âˆˆ U) : âˆƒ (V : set Î±) (hV : is_clopen V), x âˆˆ V âˆ§ V âŠ† U :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem "}
{"text": "Every non-identity element of a free group is of infinite order.", "fullPrompt": "/--  If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.mk Lâ‚ = free_group.mk Lâ‚‚) : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚ :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [monoid G] : 0 < order_of x â†” is_of_fin_order x :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem {G : Type u} [group G] {x : G} : is_of_fin_order xâ»Â¹ â†” is_of_fin_order x :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G :=\n\n/--  A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem {Î± : Type u} {L : list (Î± Ã— bool)} [decidable_eq Î±] : free_group.mk (free_group.reduce L) = free_group.mk L :=\n\n/--  If two words have a common maximal reduction, then they correspond to the same element in the free group. -/\ntheorem {Î± : Type u} {Lâ‚ Lâ‚‚ : list (Î± Ã— bool)} [decidable_eq Î±] (H : free_group.reduce Lâ‚ = free_group.reduce Lâ‚‚) : free_group.mk Lâ‚ = free_group.mk Lâ‚‚ :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x â†” is_of_fin_add_order x :=\n\n/-- The canonical injection from the type to the free group is an injection. -/\ntheorem {Î± : Type u} : function.injective free_group.of :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x) :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) â†” is_of_fin_add_order x :=\n\n/-- 1 is of finite order in any monoid. -/\ntheorem {G : Type u} [monoid G] : is_of_fin_order 1 :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_order g :=\n\n/-- An additive monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem (G : Type u_1) [add_monoid G] : Â¬add_monoid.is_torsion G â†” âˆƒ (g : G), Â¬is_of_fin_add_order g :=\n\n/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation  in $A_5$ is $A_5$. -/\ntheorem {g : equiv.perm (fin 5)} (ha : g âˆˆ alternating_group (fin 5)) (h1 : g â‰  1) (h2 : âˆ€ (n : â„•), n âˆˆ g.cycle_type â†’ n = 2) : is_conj (equiv.swap 0 4 * equiv.swap 1 3) g :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem "}
{"text": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "fullPrompt": "/-- An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem {Î“â‚€ : Type u_3} [linear_ordered_comm_monoid_with_zero Î“â‚€] [nontrivial Î“â‚€] {K : Type u_1} [division_ring K] (v : valuation K Î“â‚€) {x : K} : â‡‘v x = 0 â†” x = 0 :=\n\n/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R :=\n\n/--  An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`. -/\ntheorem {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a :=\n\n/-- A division_ring is one-dimensional as a vector space over itself. -/\ntheorem (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : Â¬is_unit (minpoly A x) :=\n\n/-- If `R` is an additive monoid, an element in `add_units R` is add-regular. -/\ntheorem {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a :=\n\n/-- In a local ring the characteristics is either zero or a prime power. -/\ntheorem (R : Type u_1) [comm_ring R] [local_ring R] (q : â„•) [char_R_q : char_p R q] : q = 0 âˆ¨ is_prime_pow q :=\n\n/-- A localization always has cardinality less than or equal to the base ring. -/\ntheorem {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L â‰¤ cardinal.mk R :=\n\n/--  The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances]. -/\ntheorem {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M â‰¤ non_zero_divisors A) : is_domain (localization M) :=\n\n/-- A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring. -/\ntheorem {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (hâ‚ : âˆƒ (p : R), irreducible p) (hâ‚‚ : âˆ€ â¦ƒp q : Râ¦„, irreducible p â†’ irreducible q â†’ associated p q) : discrete_valuation_ring R :=\n\n/--  If `ð’ª` satisfies `v.integers ð’ª` where `v` is a valuation on a field, then `ð’ª` is a valuation ring. -/\ntheorem {ð’ª : Type u} {K : Type v} {Î“ : Type w} [comm_ring ð’ª] [is_domain ð’ª] [field K] [algebra ð’ª K] [linear_ordered_comm_group_with_zero Î“] (v : valuation K Î“) (hh : v.integers ð’ª) : valuation_ring ð’ª :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem "}
{"text": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "fullPrompt": "/--  **BÃ©zout's lemma**: given `x y : â„•`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm. -/\ntheorem (x y : â„•) : â†‘(x.gcd y) = â†‘x * x.gcd_a y + â†‘y * x.gcd_b y :=\n\n/--  For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem {a b : â„¤} (ha : a â‰  0) : is_least {n : â„• | 0 < n âˆ§ âˆƒ (x y : â„¤), â†‘n = a * x + b * y} (a.gcd b) :=\n\n/-- A list with positive sum must have positive length. -/\ntheorem {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length :=\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ m + n â†” m âˆ£ n :=\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem {p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1) : âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p :=\n\n/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\ntheorem {n : â„•} {x : â„• Ã— â„•} : x âˆˆ list.nat.antidiagonal n â†” x.fst + x.snd = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem  : set.inj_on nat.factorization {x : â„• | x â‰  0} :=\n\n/-- `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem (m : â„•) {n : â„•} (hn : 0 < n) : (âˆƒ (k : â„•), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`. -/\ntheorem {m n : â„•} : m âˆ£ n + m â†” m âˆ£ n :=\n\n/--  Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]` of `SL(2,â„¤)`. -/\ntheorem {R : Type u_1} [comm_ring R] : set.surj_on (Î» (g : matrix.special_linear_group (fin 2) R), â†‘g 1) set.univ {cd : fin 2 â†’ R | is_coprime (cd 0) (cd 1)} :=\n\n/--  Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p â‰¥ n`. -/\ntheorem (n : â„•) : âˆƒ (p : â„•), n â‰¤ p âˆ§ nat.prime p :=\n\n/-- If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`. -/\ntheorem (m : â„¤) {n : â„¤} (hn : 0 < n) : (âˆƒ (k : â„¤), n * k < m âˆ§ m < n * (k + 1)) â†” Â¬n âˆ£ m :=\n\n/-- We now have four different results that all encode the idea that inequality of multisets corresponds to divisibility of positive integers. -/\ntheorem {m n : â„•+} : m.factor_multiset â‰¤ n.factor_multiset â†” m âˆ£ n :=\n\n/-- The gcd and lcm operations on positive integers correspond to the inf and sup operations on multisets. -/\ntheorem (m n : â„•+) : (m.gcd n).factor_multiset = m.factor_multiset âŠ“ n.factor_multiset :=\n\n/--  Viewing a module as an affine space modelled on itself, a `weighted_vsub` is just a linear combination. -/\ntheorem {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] {Î¹ : Type u_3} (s : finset Î¹) {w : Î¹ â†’ k} {p : Î¹ â†’ V} (hw : s.sum w = 0) : â‡‘(s.weighted_vsub p) w = s.sum (Î» (i : Î¹), w i â€¢ p i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ð•œ v) (l : Î¹ â†’â‚€ ð•œ) (i : Î¹) : has_inner.inner (â‡‘(finsupp.total Î¹ E ð•œ v) l) (v i) = â‡‘(star_ring_end ð•œ) (â‡‘l i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} {v : Î¹ â†’ E} (hv : orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) {s : finset Î¹} {i : Î¹} (hi : i âˆˆ s) : has_inner.inner (s.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ð•œ) (l i) :=\n\n/--  The inner product of a linear combination of a set of orthonormal vectors with one of those vectors picks out the coefficient of that vector. -/\ntheorem {ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {Î¹ : Type u_4} [fintype Î¹] {v : Î¹ â†’ E} (hv : orthonormal ð•œ v) (l : Î¹ â†’ ð•œ) (i : Î¹) : has_inner.inner (finset.univ.sum (Î» (i : Î¹), l i â€¢ v i)) (v i) = â‡‘(star_ring_end ð•œ) (l i) :=\n\n/-- `f = O(g)` if and only if `âˆ€á¶  x in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g xâˆ¥` for all sufficiently large `c`. -/\ntheorem {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, âˆ€á¶  (x : Î±) in l, âˆ¥f xâˆ¥ â‰¤ c * âˆ¥g' xâˆ¥ :=\n\n/-- \"Semicontinuity of the `lp` norm\": If all sufficiently large elements of a sequence in `lp E p` have `lp` norm `â‰¤ C`, then the pointwise limit, if it exists, also has `lp` norm `â‰¤ C`. -/\ntheorem {Î± : Type u_1} {E : Î± â†’ Type u_2} {p : ennreal} [Î  (i : Î±), normed_group (E i)] {Î¹ : Type u_3} {l : filter Î¹} [l.ne_bot] [fact (1 â‰¤ p)] {C : â„} {F : Î¹ â†’ â†¥(lp E p)} (hCF : âˆ€á¶  (k : Î¹) in l, âˆ¥F kâˆ¥ â‰¤ C) {f : â†¥(lp E p)} (hf : filter.tendsto (id (Î» (i : Î¹), â‡‘(F i))) l (nhds â‡‘f)) : âˆ¥fâˆ¥ â‰¤ C :=\n\n/-- `f = O(g)` if and only if `is_O_with c f g` for all sufficiently large `c`. -/\ntheorem {Î± : Type u_1} {E : Type u_3} {F' : Type u_7} [has_norm E] [semi_normed_group F'] {f : Î± â†’ E} {g' : Î± â†’ F'} {l : filter Î±} : f =O[l] g' â†” âˆ€á¶  (c : â„) in filter.at_top, asymptotics.is_O_with c l f g' :=\n\n/--  If two integers are congruent to a sufficiently large modulus, they are equal. -/\ntheorem {a b c : â„¤} (h1 : a % b = c) (h2 : (a - c).nat_abs < b.nat_abs) : a = c :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem "}
{"text": "Every field is a ring.", "fullPrompt": "/-- `â„¤` with its usual ring structure is not a field. -/\ntheorem  : Â¬is_field â„¤ :=\n\n/-- `polynomial R` is never a field for any ring `R`. -/\ntheorem {R : Type u} [ring R] : Â¬is_field (polynomial R) :=\n\n/-- The characteristic of a finite ring cannot be zero. -/\ntheorem (R : Type u) [non_assoc_ring R] (p : â„•) [hc : char_p R p] [fintype R] : p â‰  0 :=\n\n/-- For a perfect ring, it itself is the perfection. -/\ntheorem (p : â„•) [fact (nat.prime p)] (R : Type uâ‚) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R) :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x â†” is_integral K x :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a :=\n\n/-- There is a field structure on type if and only if its cardinality is a prime power. -/\ntheorem {Î± : Type u} : nonempty (field Î±) â†” is_prime_pow (cardinal.mk Î±) :=\n\n/--  For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful. -/\ntheorem (R : Type u) [ring R] (hf : is_field R) (x : R) : x â‰  0 â†’ (âˆƒ! (y : R), x * y = 1) :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a :=\n\n/--  If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`. -/\ntheorem {Î± : Type u_1} [topological_space Î±] [non_assoc_ring Î±] (h : topological_semiring Î±) : topological_ring Î± :=\n\n/-- We have `2 â‰  0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R â‰  2) : 2 â‰  0 :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), y * x) :=\n\n/-- Every field is a ring. -/\ntheorem "}
{"text": "The set of units in a ring forms a group.", "fullPrompt": "/--  A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`. -/\ntheorem {R : Type u_1} [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] (hp : p âˆ£ fintype.card R) : Â¬is_unit â†‘p :=\n\n/-- Units of a monoid divide any element of the monoid. -/\ntheorem {Î± : Type u_1} [monoid Î±] {a u : Î±} (hu : is_unit u) : u âˆ£ a :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : a * -1 = -a :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive  inverse. -/\ntheorem {Î± : Type u} [mul_one_class Î±] [has_distrib_neg Î±] (a : Î±) : (-1) * a = -a :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y) :=\n\n/--  A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic. -/\ntheorem (R : Type u_1) [comm_ring R] [fintype R] (p : â„•) [fact (nat.prime p)] : is_unit â†‘p â†” Â¬p âˆ£ ring_char R :=\n\n/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/\ntheorem {M : Type u_1} [monoid M] {x y z : M} : y âˆˆ powers x â†’ z âˆˆ powers x â†’ y * z âˆˆ powers x :=\n\n/-- If `R` is an additive monoid, an element in `add_units R` is add-regular. -/\ntheorem {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular â†‘a :=\n\n/-- An element of a monoid is in the set of that element's natural number powers. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : x âˆˆ powers x :=\n\n/-- Elements of finite additive order are closed under addition. -/\ntheorem {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y) :=\n\n/-- Left multiplication in a ring is an additive monoid morphism. -/\ntheorem {Î³ : Type u_1} [non_unital_non_assoc_semiring Î³] (x : Î³) : is_add_monoid_hom (Î» (y : Î³), x * y) :=\n\n/-- 1 is in the set of natural number powers of an element of a monoid. -/\ntheorem {M : Type u_1} [monoid M] {x : M} : 1 âˆˆ powers x :=\n\n/-- When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] {v : n â†’ Î±} : is_unit (matrix.diagonal v) â†” is_unit v :=\n\n/-- When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`. -/\ntheorem {n : Type u'} {Î± : Type v} [fintype n] [decidable_eq n] [comm_ring Î±] (A : matrix n n Î±) : is_unit A â†” is_unit A.det :=\n\n/--  *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`. -/\ntheorem {R : Type uâ‚} {L : Type uâ‚‚} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L :=\n\n/--  The map `B.polar : set E â†’ set F` forms an order-reversing Galois connection with `B.flip.polar : set F â†’ set E`. We use `order_dual.to_dual` and `order_dual.of_dual` to express that `polar` is order-reversing. -/\ntheorem {ð•œ : Type u_1} {E : Type u_2} {F : Type u_3} [normed_comm_ring ð•œ] [add_comm_monoid E] [add_comm_monoid F] [module ð•œ E] [module ð•œ F] (B : E â†’â‚—[ð•œ] F â†’â‚—[ð•œ] ð•œ) : galois_connection (â‡‘order_dual.to_dual âˆ˜ B.polar) (B.flip.polar âˆ˜ â‡‘order_dual.of_dual) :=\n\n/--  If a family of submodules is `independent`, then a choice of nonzero vector from each submodule forms a linearly independent family. -/\ntheorem {Î¹ : Type u_1} {R : Type u_2} {N : Type u_5} [ring R] [add_comm_group N] [module R N] [no_zero_smul_divisors R N] (p : Î¹ â†’ submodule R N) (hp : complete_lattice.independent p) {v : Î¹ â†’ N} (hv : âˆ€ (i : Î¹), v i âˆˆ p i) (hv' : âˆ€ (i : Î¹), v i â‰  0) : linear_independent R v :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem "}
{"text": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "fullPrompt": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (tfGs : âˆ€ (i : Î·), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G â†’ Â¬monoid.is_torsion_free G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G â†’ Â¬monoid.is_torsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G :=\n\n/-- If a direct product has finite order then so does each component. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_order x) (i : Î·) : is_of_fin_order (x i) :=\n\n/-- If a direct product has finite additive order then so does each component. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_monoid (Gs i)] {x : Î  (i : Î·), Gs i} (h : is_of_fin_add_order x) (i : Î·) : is_of_fin_add_order (x i) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem (G : Type u_1) [monoid G] : Â¬monoid.is_torsion_free G â†” âˆƒ (g : G), g â‰  1 âˆ§ is_of_fin_order g :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem {G : Type u_3} [group G] : group.fg G â†” monoid.fg G :=\n\n/--  If `Î±` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero. -/\ntheorem {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” a â‰  0 âˆ§ b â‰  0 :=\n\n/--  If `Î±` has no zero divisors, then for elements `a, b : Î±`, `a * b` is nonzero iff so is `b * a`. -/\ntheorem {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : a * b â‰  0 â†” b * a â‰  0 :=\n\n/-- A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type. -/\ntheorem {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) â†” group.fg G :=\n\n/--  If `Î±` has no zero divisors, then the product of two elements equals zero iff one of them equals zero. -/\ntheorem {Mâ‚€ : Type u_1} [mul_zero_class Mâ‚€] [no_zero_divisors Mâ‚€] {a b : Mâ‚€} : 0 = a * b â†” a = 0 âˆ¨ b = 0 :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), add_group (Gs i)] (tfGs : âˆ€ (i : Î·), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Î  (i : Î·), Gs i) :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem (G : Type u_1) [add_comm_group G] : add_monoid.is_torsion_free (G â§¸ add_torsion G) :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G â§¸ torsion G) :=\n\n/-- The commutator of a finite direct product is contained in the direct product of the commutators. -/\ntheorem {Î· : Type u_1} [fintype Î·] {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (H K : Î  (i : Î·), subgroup (Gs i)) : â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† = subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†) :=\n\n/--  The commutator of direct product is contained in the direct product of the commutators.  See `commutator_pi_pi_of_fintype` for equality given `fintype Î·`. -/\ntheorem {Î· : Type u_1} {Gs : Î· â†’ Type u_2} [Î  (i : Î·), group (Gs i)] (H K : Î  (i : Î·), subgroup (Gs i)) : â…subgroup.pi set.univ H,subgroup.pi set.univ Kâ† â‰¤ subgroup.pi set.univ (Î» (i : Î·), â…H i,K iâ†) :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem "}
