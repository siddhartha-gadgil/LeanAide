/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathbin.Topology.UniformSpace.UniformConvergence
import Mathbin.Topology.UniformSpace.Pi

/-!
# Topology and uniform structure of uniform convergence

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±` (in the `uniform_convergence` namespace)
- uniform convergence on a specified family `ð”–` of sets of `Î±`
  (in the `uniform_convergence_on` namespace), also called `ð”–`-convergence

Usual examples of the second construction include :
- the topology of compact convergence, when `ð”–` is the set of compacts of `Î±`
- the strong topology on the dual of a TVS `E`, when `ð”–` is the set of Von Neuman bounded subsets
  of `E`
- the weak-* topology on the dual of a TVS `E`, when `ð”–` is the set of singletons of `E`.

## Main definitions

* `uniform_convergence.gen` : basis sets for the uniformity of uniform convergence
* `uniform_convergence.uniform_space` : uniform structure of uniform convergence
* `uniform_convergence_on.uniform_space` : uniform structure of ð”–-convergence

## Main statements

* `uniform_convergence.uniform_continuous_eval` : evaluation is uniformly continuous
* `uniform_convergence.t2_space` : the topology of uniform convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2.
* `uniform_convergence.tendsto_iff_tendsto_uniformly` : `uniform_convergence.uniform_space` is
  indeed the uniform structure of uniform convergence

* `uniform_convergence_on.uniform_continuous_eval_of_mem` : evaluation at a point contained in a
  set of `ð”–` is uniformly continuous
* `uniform_convergence.t2_space` : the topology of `ð”–`-convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2 and `ð”–` covers `Î±`
* `uniform_convergence_on.tendsto_iff_tendsto_uniformly_on` :
  `uniform_convergence_on.uniform_space` is indeed the uniform structure of `ð”–`-convergence

## Implementation details

We do not declare these structures as instances, since they would conflict with `Pi.uniform_space`.

## TODO

* Show that the uniform structure of `ð”–`-convergence is exactly the structure of `ð”–'`-convergence,
  where `ð”–'` is the bornology generated by `ð”–`.
* Add a type synonym for `Î± â†’ Î²` endowed with the structures of uniform convergence

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]

## Tags

uniform convergence
-/


noncomputable section

open TopologicalSpace Classical uniformity Filter

attribute [-instance] Pi.uniformSpace

open Set Filter

namespace UniformConvergence

variable (Î± Î² : Type _) {Î³ Î¹ : Type _}

variable {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of uniform convergence -/
protected def Gen (V : Set (Î² Ã— Î²)) : Set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  { uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x, (uv.1 x, uv.2 x) âˆˆ V }

variable [UniformSpace Î²]

protected theorem is_basis_gen : IsBasis (fun V : Set (Î² Ã— Î²) => V âˆˆ ð“¤ Î²) (UniformConvergence.Gen Î± Î²) :=
  âŸ¨âŸ¨Univ, univ_memâŸ©, fun U V hU hV =>
    âŸ¨U âˆ© V, inter_mem hU hV, fun uv huv => âŸ¨fun x => (huv x).left, fun x => (huv x).rightâŸ©âŸ©âŸ©

/-- Filter basis for the uniformity of uniform convergence -/
protected def uniformityBasis : FilterBasis ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  (UniformConvergence.is_basis_gen Î± Î²).FilterBasis

/-- Core of the uniform structure of uniform convergence -/
protected def uniformCore : UniformSpace.Core (Î± â†’ Î²) :=
  UniformSpace.Core.mkOfBasis (UniformConvergence.uniformityBasis Î± Î²)
    (fun U âŸ¨V, hV, hVUâŸ© f => hVU â–¸ fun x => refl_mem_uniformity hV)
    (fun U âŸ¨V, hV, hVUâŸ© =>
      hVU â–¸
        âŸ¨UniformConvergence.Gen Î± Î² (Prod.swap â»Â¹' V), âŸ¨Prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©,
          fun uv huv x => huv xâŸ©)
    fun U âŸ¨V, hV, hVUâŸ© =>
    hVU â–¸
      let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV
      âŸ¨UniformConvergence.Gen Î± Î² W, âŸ¨W, hW, rflâŸ©, fun uv âŸ¨w, huw, hwvâŸ© x => hWV âŸ¨w x, âŸ¨huw x, hwv xâŸ©âŸ©âŸ©

/-- Uniform structure of uniform convergence -/
protected def uniformSpace : UniformSpace (Î± â†’ Î²) :=
  UniformSpace.ofCore (UniformConvergence.uniformCore Î± Î²)

protected theorem has_basis_uniformity :
    (@uniformity (Î± â†’ Î²) (UniformConvergence.uniformSpace Î± Î²)).HasBasis (fun V => V âˆˆ ð“¤ Î²)
      (UniformConvergence.Gen Î± Î²) :=
  (UniformConvergence.is_basis_gen Î± Î²).HasBasis

/-- Topology of uniform convergence -/
protected def topologicalSpace : TopologicalSpace (Î± â†’ Î²) :=
  (UniformConvergence.uniformSpace Î± Î²).toTopologicalSpace

protected theorem has_basis_nhds :
    (@nhds (Î± â†’ Î²) (UniformConvergence.topologicalSpace Î± Î²) f).HasBasis (fun V => V âˆˆ ð“¤ Î²) fun V =>
      { g | (g, f) âˆˆ UniformConvergence.Gen Î± Î² V } :=
  by
  let this : UniformSpace (Î± â†’ Î²) := UniformConvergence.uniformSpace Î± Î²
  exact nhds_basis_uniformity (UniformConvergence.has_basis_uniformity Î± Î²)

variable {Î±}

theorem uniform_continuous_eval (x : Î±) :
    @UniformContinuous _ _ (UniformConvergence.uniformSpace Î± Î²) _ (Function.eval x) := by
  change _ â‰¤ _
  rw [map_le_iff_le_comap, (UniformConvergence.has_basis_uniformity Î± Î²).le_basis_iff ((ð“¤ _).basis_sets.comap _)]
  exact fun U hU => âŸ¨U, hU, fun uv huv => huv xâŸ©

variable {Î²}

theorem t2_space [T2Space Î²] : @T2Space _ (UniformConvergence.topologicalSpace Î± Î²) :=
  { t2 := by
      let this : UniformSpace (Î± â†’ Î²) := UniformConvergence.uniformSpace Î± Î²
      let this : TopologicalSpace (Î± â†’ Î²) := UniformConvergence.topologicalSpace Î± Î²
      intro f g h
      obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext h)
      exact separated_by_continuous (uniform_continuous_eval Î² x).Continuous hx }

protected theorem le_Pi : UniformConvergence.uniformSpace Î± Î² â‰¤ Pi.uniformSpace fun _ => Î² := by
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi]
  intro x
  exact uniform_continuous_eval Î² x

protected theorem tendsto_iff_tendsto_uniformly :
    Tendsto F p (@nhds _ (UniformConvergence.topologicalSpace Î± Î²) f) â†” TendstoUniformly F f p := by
  let this : UniformSpace (Î± â†’ Î²) := UniformConvergence.uniformSpace Î± Î²
  rw [(UniformConvergence.has_basis_nhds Î± Î²).tendsto_right_iff, TendstoUniformly]
  constructor <;>
    Â· intro h U hU
      filter_upwards [h (Prod.swap â»Â¹' U) (tendsto_swap_uniformity hU)]
      exact fun n => id
      

variable {Î±}

end UniformConvergence

namespace UniformConvergenceOn

variable (Î± Î² : Type _) {Î³ Î¹ : Type _} [UniformSpace Î²] (ð”– : Set (Set Î±))

variable {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : Set Î±} {x : Î±} {p : Filter Î¹} {g : Î¹ â†’ Î±}

/-- Uniform structure of uniform convergence on the sets of `ð”–`. -/
protected def uniformSpace : UniformSpace (Î± â†’ Î²) :=
  â¨… (s : Set Î±) (hs : s âˆˆ ð”–), UniformSpace.comap (fun f => s.restrict f) (UniformConvergence.uniformSpace s Î²)

/-- Topology of uniform convergence on the sets of `ð”–`. -/
protected def topologicalSpace : TopologicalSpace (Î± â†’ Î²) :=
  (UniformConvergenceOn.uniformSpace Î± Î² ð”–).toTopologicalSpace

protected theorem topological_space_eq :
    UniformConvergenceOn.topologicalSpace Î± Î² ð”– =
      â¨… (s : Set Î±) (hs : s âˆˆ ð”–),
        TopologicalSpace.induced (fun f => s.restrict f) (UniformConvergence.topologicalSpace s Î²) :=
  by
  simp only [â† UniformConvergenceOn.topologicalSpace, â† to_topological_space_infi, â† to_topological_space_infi, â†
    to_topological_space_comap]
  rfl

protected theorem uniform_continuous_restrict (h : s âˆˆ ð”–) :
    @UniformContinuous _ _ (UniformConvergenceOn.uniformSpace Î± Î² ð”–) (UniformConvergence.uniformSpace s Î²) s.restrict :=
  by
  change _ â‰¤ _
  rw [UniformConvergenceOn.uniformSpace, map_le_iff_le_comap, uniformity, infi_uniformity]
  refine' infi_le_of_le s _
  rw [infi_uniformity]
  exact infi_le _ h

protected theorem uniform_space_antitone : Antitone (UniformConvergenceOn.uniformSpace Î± Î²) := fun ð”–â‚ ð”–â‚‚ hâ‚â‚‚ =>
  infi_le_infi_of_subset hâ‚â‚‚

variable {Î±}

theorem uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ð”–) :
    @UniformContinuous _ _ (UniformConvergenceOn.uniformSpace Î± Î² ð”–) _ (Function.eval x) := by
  change _ â‰¤ _
  rw [map_le_iff_le_comap, ((ð“¤ _).basis_sets.comap _).ge_iff, UniformConvergenceOn.uniformSpace, infi_uniformity']
  intro U hU
  refine' mem_infi_of_mem s _
  rw [infi_uniformity']
  exact
    mem_infi_of_mem hs
      (mem_comap.mpr
        âŸ¨UniformConvergence.Gen s Î² U, (UniformConvergence.has_basis_uniformity s Î²).mem_of_mem hU, fun uv huv =>
          huv âŸ¨x, hxsâŸ©âŸ©)

variable {Î²}

theorem t2_space_of_covering [T2Space Î²] (h : â‹ƒâ‚€ð”– = univ) : @T2Space _ (UniformConvergenceOn.topologicalSpace Î± Î² ð”–) :=
  { t2 := by
      let this : UniformSpace (Î± â†’ Î²) := UniformConvergenceOn.uniformSpace Î± Î² ð”–
      let this : TopologicalSpace (Î± â†’ Î²) := UniformConvergenceOn.topologicalSpace Î± Î² ð”–
      intro f g hfg
      obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg)
      obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ð”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ True.intro)
      exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ð”– hxs hs).Continuous hx }

protected theorem le_Pi_of_covering (h : â‹ƒâ‚€ð”– = univ) :
    UniformConvergenceOn.uniformSpace Î± Î² ð”– â‰¤ Pi.uniformSpace fun _ => Î² := by
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi]
  intro x
  obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ð”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ True.intro)
  exact uniform_continuous_eval_of_mem Î² ð”– hxs hs

protected theorem tendsto_iff_tendsto_uniformly_on :
    Tendsto F p (@nhds _ (UniformConvergenceOn.topologicalSpace Î± Î² ð”–) f) â†” âˆ€, âˆ€ s âˆˆ ð”–, âˆ€, TendstoUniformlyOn F f p s :=
  by
  let this : UniformSpace (Î± â†’ Î²) := UniformConvergenceOn.uniformSpace Î± Î² ð”–
  rw [UniformConvergenceOn.topological_space_eq, nhds_infi, tendsto_infi]
  refine' forall_congrâ‚“ fun s => _
  rw [nhds_infi, tendsto_infi]
  refine' forall_congrâ‚“ fun hs => _
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
    UniformConvergence.tendsto_iff_tendsto_uniformly]
  rfl

end UniformConvergenceOn

