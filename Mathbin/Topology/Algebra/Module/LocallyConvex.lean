/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathbin.Analysis.Convex.Topology

/-!
# Locally convex topological modules

A `locally_convex_space` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locally_convex_space_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `seminorm.locally_convex_space` : a topology generated by a family of seminorms is locally convex
- `normed_space.locally_convex_space` : a normed space is locally convex

## TODO

- define a structure `locally_convex_filter_basis`, extending `module_filter_basis`, for filter
  bases generating a locally convex topology
- show that any locally convex topology is generated by a family of seminorms

-/


open TopologicalSpace Filter Set

open TopologicalSpace

section Semimodule

/-- A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class LocallyConvexSpace (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommMonoidâ‚“ E] [Module ğ•œ E] [TopologicalSpace E] :
  Prop where
  convex_basis : âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id

variable (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommMonoidâ‚“ E] [Module ğ•œ E] [TopologicalSpace E]

theorem locally_convex_space_iff :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, (ğ“ x).HasBasis (fun s : Set E => s âˆˆ ğ“ x âˆ§ Convex ğ•œ s) id :=
  âŸ¨@LocallyConvexSpace.convex_basis _ _ _ _ _ _, LocallyConvexSpace.mkâŸ©

theorem LocallyConvexSpace.of_bases {Î¹ : Type _} (b : E â†’ Î¹ â†’ Set E) (p : E â†’ Î¹ â†’ Prop)
    (hbasis : âˆ€ x : E, (ğ“ x).HasBasis (p x) (b x)) (hconvex : âˆ€ x i, p x i â†’ Convex ğ•œ (b x i)) :
    LocallyConvexSpace ğ•œ E :=
  âŸ¨fun x =>
    (hbasis x).to_has_basis (fun i hi => âŸ¨b x i, âŸ¨âŸ¨(hbasis x).mem_of_mem hi, hconvex x i hiâŸ©, le_reflâ‚“ (b x i)âŸ©âŸ©)
      fun s hs => âŸ¨(hbasis x).index s hs.1, âŸ¨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1âŸ©âŸ©âŸ©

theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace ğ•œ E] :
    (ğ“ 0 : Filter E).HasBasis (fun s => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  LocallyConvexSpace.convex_basis 0

theorem locally_convex_space_iff_exists_convex_subset :
    LocallyConvexSpace ğ•œ E â†” âˆ€ x : E, âˆ€, âˆ€ U âˆˆ ğ“ x, âˆ€, âˆƒ S âˆˆ ğ“ x, Convex ğ•œ S âˆ§ S âŠ† U :=
  (locally_convex_space_iff ğ•œ E).trans (forall_congrâ‚“ fun x => has_basis_self)

end Semimodule

section Module

variable (ğ•œ E : Type _) [OrderedSemiring ğ•œ] [AddCommGroupâ‚“ E] [Module ğ•œ E] [TopologicalSpace E] [TopologicalAddGroup E]

theorem LocallyConvexSpace.of_basis_zero {Î¹ : Type _} (b : Î¹ â†’ Set E) (p : Î¹ â†’ Prop) (hbasis : (ğ“ 0).HasBasis p b)
    (hconvex : âˆ€ i, p i â†’ Convex ğ•œ (b i)) : LocallyConvexSpace ğ•œ E := by
  refine'
    LocallyConvexSpace.of_bases ğ•œ E (fun (x : E) (i : Î¹) => (Â· + Â·) x '' b i) (fun _ => p) (fun x => _) fun x i hi =>
      (hconvex i hi).translate x
  rw [â† map_add_left_nhds_zero]
  exact hbasis.map _

theorem locally_convex_space_iff_zero :
    LocallyConvexSpace ğ•œ E â†” (ğ“ 0 : Filter E).HasBasis (fun s : Set E => s âˆˆ (ğ“ 0 : Filter E) âˆ§ Convex ğ•œ s) id :=
  âŸ¨fun h => @LocallyConvexSpace.convex_basis _ _ _ _ _ _ h 0, fun h =>
    LocallyConvexSpace.of_basis_zero ğ•œ E _ _ h fun s => And.rightâŸ©

theorem locally_convex_space_iff_exists_convex_subset_zero :
    LocallyConvexSpace ğ•œ E â†” âˆ€, âˆ€ U âˆˆ (ğ“ 0 : Filter E), âˆ€, âˆƒ S âˆˆ (ğ“ 0 : Filter E), Convex ğ•œ S âˆ§ S âŠ† U :=
  (locally_convex_space_iff_zero ğ•œ E).trans has_basis_self

end Module

section LatticeOps

variable {Î¹ : Sort _} {ğ•œ E F : Type _} [OrderedSemiring ğ•œ] [AddCommMonoidâ‚“ E] [Module ğ•œ E] [AddCommMonoidâ‚“ F]
  [Module ğ•œ F]

theorem locally_convex_space_Inf {ts : Set (TopologicalSpace E)} (h : âˆ€, âˆ€ t âˆˆ ts, âˆ€, @LocallyConvexSpace ğ•œ E _ _ _ t) :
    @LocallyConvexSpace ğ•œ E _ _ _ (inf ts) := by
  let this : TopologicalSpace E := Inf ts
  refine'
    LocallyConvexSpace.of_bases ğ•œ E (fun x => fun If : Set ts Ã— (ts â†’ Set E) => â‹‚ i âˆˆ If.1, If.2 i)
      (fun x => fun If : Set ts Ã— (ts â†’ Set E) =>
        If.1.Finite âˆ§ âˆ€, âˆ€ i âˆˆ If.1, âˆ€, If.2 i âˆˆ @nhds _ (â†‘i) x âˆ§ Convex ğ•œ (If.2 i))
      (fun x => _) fun x If hif => convex_Inter fun i => convex_Inter fun hi => (hif.2 i hi).2
  rw [nhds_Inf, â† infi_subtype'']
  exact has_basis_infi fun i : ts => (@locally_convex_space_iff ğ•œ E _ _ _ â†‘i).mp (h (â†‘i) i.2) x

theorem locally_convex_space_infi {ts' : Î¹ â†’ TopologicalSpace E} (h' : âˆ€ i, @LocallyConvexSpace ğ•œ E _ _ _ (ts' i)) :
    @LocallyConvexSpace ğ•œ E _ _ _ (â¨… i, ts' i) := by
  refine' locally_convex_space_Inf _
  rwa [forall_range_iff]

theorem locally_convex_space_inf {tâ‚ tâ‚‚ : TopologicalSpace E} (hâ‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚)
    (hâ‚‚ : @LocallyConvexSpace ğ•œ E _ _ _ tâ‚‚) : @LocallyConvexSpace ğ•œ E _ _ _ (tâ‚âŠ“tâ‚‚) := by
  rw [inf_eq_infi]
  refine' locally_convex_space_infi fun b => _
  cases b <;> assumption

theorem locally_convex_space_induced {t : TopologicalSpace F} [LocallyConvexSpace ğ•œ F] (f : E â†’â‚—[ğ•œ] F) :
    @LocallyConvexSpace ğ•œ E _ _ _ (t.induced f) := by
  let this : TopologicalSpace E := t.induced f
  refine'
    LocallyConvexSpace.of_bases ğ•œ E (fun x => preimage f) (fun x => fun s : Set F => s âˆˆ ğ“ (f x) âˆ§ Convex ğ•œ s)
      (fun x => _) fun x s âŸ¨_, hsâŸ© => hs.linear_preimage f
  rw [nhds_induced]
  exact (LocallyConvexSpace.convex_basis <| f x).comap f

instance {Î¹ : Type _} {X : Î¹ â†’ Type _} [âˆ€ i, AddCommMonoidâ‚“ (X i)] [âˆ€ i, TopologicalSpace (X i)] [âˆ€ i, Module ğ•œ (X i)]
    [âˆ€ i, LocallyConvexSpace ğ•œ (X i)] : LocallyConvexSpace ğ•œ (âˆ€ i, X i) :=
  locally_convex_space_infi fun i => locally_convex_space_induced (LinearMap.proj i)

instance [TopologicalSpace E] [TopologicalSpace F] [LocallyConvexSpace ğ•œ E] [LocallyConvexSpace ğ•œ F] :
    LocallyConvexSpace ğ•œ (E Ã— F) :=
  locally_convex_space_inf (locally_convex_space_induced (LinearMap.fst _ _ _))
    (locally_convex_space_induced (LinearMap.snd _ _ _))

end LatticeOps

