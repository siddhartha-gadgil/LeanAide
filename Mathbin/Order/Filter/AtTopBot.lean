/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathbin.Algebra.Order.Field
import Mathbin.Data.Finset.Preimage
import Mathbin.Data.Set.Intervals.Disjoint
import Mathbin.Order.Filter.Bases

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n ‚Üí +‚àû`;
* `at_bot`: corresponds to `n ‚Üí -‚àû`.

Then we prove many lemmas like ‚Äúif `f ‚Üí +‚àû`, then `f ¬± c ‚Üí +‚àû`‚Äù.
-/


variable {Œπ Œπ' Œ± Œ≤ Œ≥ : Type _}

open Set

open Classical Filter BigOperators

namespace Filter

/-- `at_top` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
  It is generated by the collection of up-sets `{b | a ‚â§ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def atTop [Preorder‚Çì Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Ici a)

/-- `at_bot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
  It is generated by the collection of down-sets `{b | b ‚â§ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def atBot [Preorder‚Çì Œ±] : Filter Œ± :=
  ‚®Ö a, ùìü (Iic a)

theorem mem_at_top [Preorder‚Çì Œ±] (a : Œ±) : { b : Œ± | a ‚â§ b } ‚àà @atTop Œ± _ :=
  mem_infi_of_mem a <| Subset.refl _

theorem Ici_mem_at_top [Preorder‚Çì Œ±] (a : Œ±) : Ici a ‚àà (atTop : Filter Œ±) :=
  mem_at_top a

theorem Ioi_mem_at_top [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (x : Œ±) : Ioi x ‚àà (atTop : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_gt x
  (mem_of_superset (mem_at_top z)) fun y h => lt_of_lt_of_le‚Çì hz h

theorem mem_at_bot [Preorder‚Çì Œ±] (a : Œ±) : { b : Œ± | b ‚â§ a } ‚àà @atBot Œ± _ :=
  mem_infi_of_mem a <| Subset.refl _

theorem Iic_mem_at_bot [Preorder‚Çì Œ±] (a : Œ±) : Iic a ‚àà (atBot : Filter Œ±) :=
  mem_at_bot a

theorem Iio_mem_at_bot [Preorder‚Çì Œ±] [NoMinOrder Œ±] (x : Œ±) : Iio x ‚àà (atBot : Filter Œ±) :=
  let ‚ü®z, hz‚ü© := exists_lt x
  (mem_of_superset (mem_at_bot z)) fun y h => lt_of_le_of_lt‚Çì h hz

theorem disjoint_at_bot_principal_Ioi [Preorder‚Çì Œ±] (x : Œ±) : Disjoint atBot (ùìü (Ioi x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_at_bot x) (mem_principal_self _)

theorem disjoint_at_top_principal_Iio [Preorder‚Çì Œ±] (x : Œ±) : Disjoint atTop (ùìü (Iio x)) :=
  @disjoint_at_bot_principal_Ioi Œ±·µí·µà _ _

theorem disjoint_at_top_principal_Iic [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (x : Œ±) : Disjoint atTop (ùìü (Iic x)) :=
  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_at_top x) (mem_principal_self _)

theorem disjoint_at_bot_principal_Ici [Preorder‚Çì Œ±] [NoMinOrder Œ±] (x : Œ±) : Disjoint atBot (ùìü (Ici x)) :=
  @disjoint_at_top_principal_Iic Œ±·µí·µà _ _ _

theorem disjoint_pure_at_top [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (x : Œ±) : Disjoint (pure x) atTop :=
  Disjoint.symm ((disjoint_at_top_principal_Iic x).mono_right <| le_principal_iff.2 le_rfl)

theorem disjoint_pure_at_bot [Preorder‚Çì Œ±] [NoMinOrder Œ±] (x : Œ±) : Disjoint (pure x) atBot :=
  @disjoint_pure_at_top Œ±·µí·µà _ _ _

theorem not_tendsto_const_at_top [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.ne_bot] :
    ¬¨Tendsto (fun _ => x) l atTop :=
  tendsto_const_pure.not_tendsto (disjoint_pure_at_top x)

theorem not_tendsto_const_at_bot [Preorder‚Çì Œ±] [NoMinOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.ne_bot] :
    ¬¨Tendsto (fun _ => x) l atBot :=
  tendsto_const_pure.not_tendsto (disjoint_pure_at_bot x)

theorem disjoint_at_bot_at_top [PartialOrder‚Çì Œ±] [Nontrivial Œ±] : Disjoint (atBot : Filter Œ±) atTop := by
  rcases exists_pair_ne Œ± with ‚ü®x, y, hne‚ü©
  by_cases' hle : x ‚â§ y
  ¬∑ refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot x) (Ici_mem_at_top y)
    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le
    
  ¬∑ refine' disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot y) (Ici_mem_at_top x)
    exact Iic_disjoint_Ici.2 hle
    

theorem disjoint_at_top_at_bot [PartialOrder‚Çì Œ±] [Nontrivial Œ±] : Disjoint (atTop : Filter Œ±) atBot :=
  disjoint_at_bot_at_top.symm

theorem at_top_basis [Nonempty Œ±] [SemilatticeSup Œ±] : (@atTop Œ± _).HasBasis (fun _ => True) Ici :=
  has_basis_infi_principal (directed_of_sup fun a b => Ici_subset_Ici.2)

theorem at_top_basis' [SemilatticeSup Œ±] (a : Œ±) : (@atTop Œ± _).HasBasis (fun x => a ‚â§ x) Ici :=
  ‚ü®fun t =>
    (@at_top_basis Œ± ‚ü®a‚ü© _).mem_iff.trans
      ‚ü®fun ‚ü®x, _, hx‚ü© => ‚ü®x‚äîa, le_sup_right, fun y hy => hx (le_trans‚Çì le_sup_left hy)‚ü©, fun ‚ü®x, _, hx‚ü© =>
        ‚ü®x, trivial‚Çì, hx‚ü©‚ü©‚ü©

theorem at_bot_basis [Nonempty Œ±] [SemilatticeInf Œ±] : (@atBot Œ± _).HasBasis (fun _ => True) Iic :=
  @at_top_basis Œ±·µí·µà _ _

theorem at_bot_basis' [SemilatticeInf Œ±] (a : Œ±) : (@atBot Œ± _).HasBasis (fun x => x ‚â§ a) Iic :=
  @at_top_basis' Œ±·µí·µà _ _

@[instance]
theorem at_top_ne_bot [Nonempty Œ±] [SemilatticeSup Œ±] : NeBot (atTop : Filter Œ±) :=
  at_top_basis.ne_bot_iff.2 fun a _ => nonempty_Ici

@[instance]
theorem at_bot_ne_bot [Nonempty Œ±] [SemilatticeInf Œ±] : NeBot (atBot : Filter Œ±) :=
  @at_top_ne_bot Œ±·µí·µà _ _

@[simp]
theorem mem_at_top_sets [Nonempty Œ±] [SemilatticeSup Œ±] {s : Set Œ±} :
    s ‚àà (atTop : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ, ‚àÄ b ‚â• a, ‚àÄ, b ‚àà s :=
  at_top_basis.mem_iff.trans <| exists_congr fun _ => exists_const _

@[simp]
theorem mem_at_bot_sets [Nonempty Œ±] [SemilatticeInf Œ±] {s : Set Œ±} :
    s ‚àà (atBot : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ, ‚àÄ b ‚â§ a, ‚àÄ, b ‚àà s :=
  @mem_at_top_sets Œ±·µí·µà _ _ _

@[simp]
theorem eventually_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ, ‚àÄ b ‚â• a, ‚àÄ, p b :=
  mem_at_top_sets

@[simp]
theorem eventually_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ, ‚àÄ b ‚â§ a, ‚àÄ, p b :=
  mem_at_bot_sets

theorem eventually_ge_at_top [Preorder‚Çì Œ±] (a : Œ±) : ‚àÄ·∂† x in at_top, a ‚â§ x :=
  mem_at_top a

theorem eventually_le_at_bot [Preorder‚Çì Œ±] (a : Œ±) : ‚àÄ·∂† x in at_bot, x ‚â§ a :=
  mem_at_bot a

theorem eventually_gt_at_top [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_top, a < x :=
  Ioi_mem_at_top a

theorem eventually_ne_at_top [Preorder‚Çì Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_top, x ‚â† a :=
  (eventually_gt_at_top a).mono fun x => ne_of_gt‚Çì

theorem Tendsto.eventually_gt_at_top [Preorder‚Çì Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atTop)
    (c : Œ≤) : ‚àÄ·∂† x in l, c < f x :=
  hf.Eventually (eventually_gt_at_top c)

theorem Tendsto.eventually_ge_at_top [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atTop) (c : Œ≤) :
    ‚àÄ·∂† x in l, c ‚â§ f x :=
  hf.Eventually (eventually_ge_at_top c)

theorem Tendsto.eventually_ne_at_top [Preorder‚Çì Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atTop)
    (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=
  hf.Eventually (eventually_ne_at_top c)

theorem eventually_lt_at_bot [Preorder‚Çì Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_bot, x < a :=
  Iio_mem_at_bot a

theorem eventually_ne_at_bot [Preorder‚Çì Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_bot, x ‚â† a :=
  (eventually_lt_at_bot a).mono fun x => ne_of_lt‚Çì

theorem Tendsto.eventually_lt_at_bot [Preorder‚Çì Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atBot)
    (c : Œ≤) : ‚àÄ·∂† x in l, f x < c :=
  hf.Eventually (eventually_lt_at_bot c)

theorem Tendsto.eventually_le_at_bot [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atBot) (c : Œ≤) :
    ‚àÄ·∂† x in l, f x ‚â§ c :=
  hf.Eventually (eventually_le_at_bot c)

theorem Tendsto.eventually_ne_at_bot [Preorder‚Çì Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hf : Tendsto f l atBot)
    (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=
  hf.Eventually (eventually_ne_at_bot c)

theorem at_top_basis_Ioi [Nonempty Œ±] [SemilatticeSup Œ±] [NoMaxOrder Œ±] : (@atTop Œ± _).HasBasis (fun _ => True) Ioi :=
  (at_top_basis.to_has_basis fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©) fun a ha =>
    (exists_gt a).imp fun b hb => ‚ü®ha, Ici_subset_Ioi.2 hb‚ü©

theorem at_top_countable_basis [Nonempty Œ±] [SemilatticeSup Œ±] [Encodable Œ±] :
    HasCountableBasis (atTop : Filter Œ±) (fun _ => True) Ici :=
  { at_top_basis with Countable := countable_encodable _ }

theorem at_bot_countable_basis [Nonempty Œ±] [SemilatticeInf Œ±] [Encodable Œ±] :
    HasCountableBasis (atBot : Filter Œ±) (fun _ => True) Iic :=
  { at_bot_basis with Countable := countable_encodable _ }

instance (priority := 200) atTop.is_countably_generated [Preorder‚Çì Œ±] [Encodable Œ±] :
    (atTop : Filter <| Œ±).IsCountablyGenerated :=
  is_countably_generated_seq _

instance (priority := 200) atBot.is_countably_generated [Preorder‚Çì Œ±] [Encodable Œ±] :
    (atBot : Filter <| Œ±).IsCountablyGenerated :=
  is_countably_generated_seq _

theorem OrderTop.at_top_eq (Œ±) [PartialOrder‚Çì Œ±] [OrderTop Œ±] : (atTop : Filter Œ±) = pure ‚ä§ :=
  le_antisymm‚Çì (le_pure_iff.2 <| (eventually_ge_at_top ‚ä§).mono fun b => top_unique)
    (le_infi fun b => le_principal_iff.2 le_top)

theorem OrderBot.at_bot_eq (Œ±) [PartialOrder‚Çì Œ±] [OrderBot Œ±] : (atBot : Filter Œ±) = pure ‚ä• :=
  @OrderTop.at_top_eq Œ±·µí·µà _ _

@[nontriviality]
theorem Subsingleton.at_top_eq (Œ±) [Subsingleton Œ±] [Preorder‚Çì Œ±] : (atTop : Filter Œ±) = ‚ä§ := by
  refine' top_unique fun s hs x => _
  let this : Unique Œ± := ‚ü®‚ü®x‚ü©, fun y => Subsingleton.elim‚Çì y x‚ü©
  rw [at_top, infi_unique, Unique.default_eq x, mem_principal] at hs
  exact hs left_mem_Ici

@[nontriviality]
theorem Subsingleton.at_bot_eq (Œ±) [Subsingleton Œ±] [Preorder‚Çì Œ±] : (atBot : Filter Œ±) = ‚ä§ :=
  @Subsingleton.at_top_eq Œ±·µí·µà _ _

theorem tendsto_at_top_pure [PartialOrder‚Çì Œ±] [OrderTop Œ±] (f : Œ± ‚Üí Œ≤) : Tendsto f atTop (pure <| f ‚ä§) :=
  (OrderTop.at_top_eq Œ±).symm ‚ñ∏ tendsto_pure_pure _ _

theorem tendsto_at_bot_pure [PartialOrder‚Çì Œ±] [OrderBot Œ±] (f : Œ± ‚Üí Œ≤) : Tendsto f atBot (pure <| f ‚ä•) :=
  @tendsto_at_top_pure Œ±·µí·µà _ _ _ _

theorem Eventually.exists_forall_of_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in at_top, p x) :
    ‚àÉ a, ‚àÄ, ‚àÄ b ‚â• a, ‚àÄ, p b :=
  eventually_at_top.mp h

theorem Eventually.exists_forall_of_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in at_bot, p x) :
    ‚àÉ a, ‚àÄ, ‚àÄ b ‚â§ a, ‚àÄ, p b :=
  eventually_at_bot.mp h

theorem frequently_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} : (‚àÉ·∂† x in at_top, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â• a, p b :=
  by
  simp [‚Üê at_top_basis.frequently_iff]

theorem frequently_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} : (‚àÉ·∂† x in at_bot, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â§ a, p b :=
  @frequently_at_top Œ±·µí·µà _ _ _

theorem frequently_at_top' [SemilatticeSup Œ±] [Nonempty Œ±] [NoMaxOrder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in at_top, p x) ‚Üî ‚àÄ a, ‚àÉ b > a, p b := by
  simp [‚Üê at_top_basis_Ioi.frequently_iff]

theorem frequently_at_bot' [SemilatticeInf Œ±] [Nonempty Œ±] [NoMinOrder Œ±] {p : Œ± ‚Üí Prop} :
    (‚àÉ·∂† x in at_bot, p x) ‚Üî ‚àÄ a, ‚àÉ b < a, p b :=
  @frequently_at_top' Œ±·µí·µà _ _ _ _

theorem Frequently.forall_exists_of_at_top [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÉ·∂† x in at_top, p x) :
    ‚àÄ a, ‚àÉ b ‚â• a, p b :=
  frequently_at_top.mp h

theorem Frequently.forall_exists_of_at_bot [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± ‚Üí Prop} (h : ‚àÉ·∂† x in at_bot, p x) :
    ‚àÄ a, ‚àÉ b ‚â§ a, p b :=
  frequently_at_bot.mp h

theorem map_at_top_eq [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} : atTop.map f = ‚®Ö a, ùìü <| f '' { a' | a ‚â§ a' } :=
  (at_top_basis.map _).eq_infi

theorem map_at_bot_eq [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} : atBot.map f = ‚®Ö a, ùìü <| f '' { a' | a' ‚â§ a } :=
  @map_at_top_eq Œ±·µí·µà _ _ _ _

theorem tendsto_at_top [Preorder‚Çì Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} : Tendsto m f atTop ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, b ‚â§ m a := by
  simp only [‚Üê at_top, ‚Üê tendsto_infi, ‚Üê tendsto_principal, ‚Üê mem_Ici]

theorem tendsto_at_bot [Preorder‚Çì Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} : Tendsto m f atBot ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, m a ‚â§ b :=
  @tendsto_at_top Œ± Œ≤·µí·µà _ m f

theorem tendsto_at_top_mono' [Preorder‚Çì Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
    Tendsto f‚ÇÅ l atTop ‚Üí Tendsto f‚ÇÇ l atTop := fun h‚ÇÅ =>
  tendsto_at_top.2 fun b => mp_mem (tendsto_at_top.1 h‚ÇÅ b) (monotone_mem (fun a ha ha‚ÇÅ => le_trans‚Çì ha‚ÇÅ ha) h)

theorem tendsto_at_bot_mono' [Preorder‚Çì Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
    Tendsto f‚ÇÇ l atBot ‚Üí Tendsto f‚ÇÅ l atBot :=
  @tendsto_at_top_mono' _ Œ≤·µí·µà _ _ _ _ h

theorem tendsto_at_top_mono [Preorder‚Çì Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
    Tendsto f l atTop ‚Üí Tendsto g l atTop :=
  tendsto_at_top_mono' l <| eventually_of_forall h

theorem tendsto_at_bot_mono [Preorder‚Çì Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
    Tendsto g l atBot ‚Üí Tendsto f l atBot :=
  @tendsto_at_top_mono _ Œ≤·µí·µà _ _ _ _ h

end Filter

namespace OrderIso

open Filter

variable [Preorder‚Çì Œ±] [Preorder‚Çì Œ≤]

@[simp]
theorem comap_at_top (e : Œ± ‚âÉo Œ≤) : comap e atTop = at_top := by
  simp [‚Üê at_top, e.surjective.infi_comp]

@[simp]
theorem comap_at_bot (e : Œ± ‚âÉo Œ≤) : comap e atBot = at_bot :=
  e.dual.comap_at_top

@[simp]
theorem map_at_top (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atTop = at_top := by
  rw [‚Üê e.comap_at_top, map_comap_of_surjective e.surjective]

@[simp]
theorem map_at_bot (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atBot = at_bot :=
  e.dual.map_at_top

theorem tendsto_at_top (e : Œ± ‚âÉo Œ≤) : Tendsto e atTop atTop :=
  e.map_at_top.le

theorem tendsto_at_bot (e : Œ± ‚âÉo Œ≤) : Tendsto e atBot atBot :=
  e.map_at_bot.le

@[simp]
theorem tendsto_at_top_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
    Tendsto (fun x => e (f x)) l atTop ‚Üî Tendsto f l atTop := by
  rw [‚Üê e.comap_at_top, tendsto_comap_iff]

@[simp]
theorem tendsto_at_bot_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
    Tendsto (fun x => e (f x)) l atBot ‚Üî Tendsto f l atBot :=
  e.dual.tendsto_at_top_iff

end OrderIso

namespace Filter

/-!
### Sequences
-/


theorem inf_map_at_top_ne_bot_iff [SemilatticeSup Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
    NeBot (F‚äìmap u atTop) ‚Üî ‚àÄ, ‚àÄ U ‚àà F, ‚àÄ, ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà U := by
  simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top] <;> rfl

theorem inf_map_at_bot_ne_bot_iff [SemilatticeInf Œ±] [Nonempty Œ±] {F : Filter Œ≤} {u : Œ± ‚Üí Œ≤} :
    NeBot (F‚äìmap u atBot) ‚Üî ‚àÄ, ‚àÄ U ‚àà F, ‚àÄ, ‚àÄ N, ‚àÉ n ‚â§ N, u n ‚àà U :=
  @inf_map_at_top_ne_bot_iff Œ±·µí·µà _ _ _ _ _

theorem extraction_of_frequently_at_top' {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ N, ‚àÉ n > N, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by
  choose u hu using h
  cases' forall_and_distrib.mp hu with hu hu'
  exact ‚ü®u ‚àò Nat.rec 0 fun n v => u v, strict_mono_nat_of_lt_succ fun n => hu _, fun n => hu' _‚ü©

theorem extraction_of_frequently_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÉ·∂† n in at_top, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by
  rw [frequently_at_top'] at h
  exact extraction_of_frequently_at_top' h

theorem extraction_of_eventually_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ·∂† n in at_top, P n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
  extraction_of_frequently_at_top h.Frequently

theorem extraction_forall_of_frequently {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ·∂† k in at_top, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) := by
  simp only [‚Üê frequently_at_top'] at h
  choose u hu hu' using h
  use (fun n => Nat.recOn n (u 0 0) fun n v => u (n + 1) v : ‚Ñï ‚Üí ‚Ñï)
  constructor
  ¬∑ apply strict_mono_nat_of_lt_succ
    intro n
    apply hu
    
  ¬∑ intro n
    cases n <;> simp [‚Üê hu']
    

theorem extraction_forall_of_eventually {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÄ·∂† k in at_top, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_frequently fun n => (h n).Frequently

theorem extraction_forall_of_eventually' {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ N, ‚àÄ, ‚àÄ k ‚â• N, ‚àÄ, P n k) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
  extraction_forall_of_eventually
    (by
      simp [‚Üê eventually_at_top, ‚Üê h])

theorem exists_le_of_tendsto_at_top [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {u : Œ± ‚Üí Œ≤} (h : Tendsto u atTop atTop) (a : Œ±)
    (b : Œ≤) : ‚àÉ a' ‚â• a, b ‚â§ u a' := by
  have : ‚àÄ·∂† x in at_top, a ‚â§ x ‚àß b ‚â§ u x := (eventually_ge_at_top a).And (h.eventually <| eventually_ge_at_top b)
  have : Nonempty Œ± := ‚ü®a‚ü©
  rcases this.exists with ‚ü®a', ha, hb‚ü©
  exact ‚ü®a', ha, hb‚ü©

-- see Note [nolint_ge]
@[nolint ge_or_gt]
theorem exists_le_of_tendsto_at_bot [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {u : Œ± ‚Üí Œ≤} (h : Tendsto u atTop atBot) :
    ‚àÄ a b, ‚àÉ a' ‚â• a, u a' ‚â§ b :=
  @exists_le_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ h

theorem exists_lt_of_tendsto_at_top [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoMaxOrder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atTop) (a : Œ±) (b : Œ≤) : ‚àÉ a' ‚â• a, b < u a' := by
  cases' exists_gt b with b' hb'
  rcases exists_le_of_tendsto_at_top h a b' with ‚ü®a', ha', ha''‚ü©
  exact ‚ü®a', ha', lt_of_lt_of_le‚Çì hb' ha''‚ü©

-- see Note [nolint_ge]
@[nolint ge_or_gt]
theorem exists_lt_of_tendsto_at_bot [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoMinOrder Œ≤] {u : Œ± ‚Üí Œ≤}
    (h : Tendsto u atTop atBot) : ‚àÄ a b, ‚àÉ a' ‚â• a, u a' < b :=
  @exists_lt_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ _ h

/-- If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores [LinearOrder‚Çì Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atTop) :
    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ, ‚àÄ k < n, ‚àÄ, u k < u n := by
  intro N
  obtain ‚ü®k : ‚Ñï, hkn : k ‚â§ N, hku : ‚àÄ, ‚àÄ l ‚â§ N, ‚àÄ, u l ‚â§ u k‚ü© : ‚àÉ k ‚â§ N, ‚àÄ, ‚àÄ l ‚â§ N, ‚àÄ, u l ‚â§ u k
  exact exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl‚Çì N‚ü©
  have ex : ‚àÉ n ‚â• N, u k < u n := exists_lt_of_tendsto_at_top hu _ _
  obtain ‚ü®n : ‚Ñï, hnN : n ‚â• N, hnk : u k < u n, hn_min : ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k‚ü© :
    ‚àÉ n ‚â• N, u k < u n ‚àß ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k := by
    rcases Nat.findX ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©
    push_neg  at hn_min
    exact ‚ü®n, hnN, hnk, hn_min‚ü©
  use n, hnN
  rintro (l : ‚Ñï) (hl : l < n)
  have hlk : u l ‚â§ u k := by
    cases' (le_total‚Çì l N : l ‚â§ N ‚à® N ‚â§ l) with H H
    ¬∑ exact hku l H
      
    ¬∑ exact hn_min l hl H
      
  calc u l ‚â§ u k := hlk _ < u n := hnk

/-- If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
-- see Note [nolint_ge]
@[nolint ge_or_gt]
theorem low_scores [LinearOrder‚Çì Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atBot) :
    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ, ‚àÄ k < n, ‚àÄ, u n < u k :=
  @high_scores Œ≤·µí·µà _ _ _ hu

/-- If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores [LinearOrder‚Çì Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atTop) :
    ‚àÉ·∂† n in at_top, ‚àÄ, ‚àÄ k < n, ‚àÄ, u k < u n := by
  simpa [‚Üê frequently_at_top] using high_scores hu

/-- If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores [LinearOrder‚Çì Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atBot) :
    ‚àÉ·∂† n in at_top, ‚àÄ, ‚àÄ k < n, ‚àÄ, u n < u k :=
  @frequently_high_scores Œ≤·µí·µà _ _ _ hu

theorem strict_mono_subseq_of_tendsto_at_top {Œ≤ : Type _} [LinearOrder‚Çì Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}
    (hu : Tendsto u atTop atTop) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  let ‚ü®œÜ, h, h'‚ü© := extraction_of_frequently_at_top (frequently_high_scores hu)
  ‚ü®œÜ, h, fun n m hnm => h' m _ (h hnm)‚ü©

theorem strict_mono_subseq_of_id_le {u : ‚Ñï ‚Üí ‚Ñï} (hu : ‚àÄ n, n ‚â§ u n) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=
  strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

theorem _root_.strict_mono.tendsto_at_top {œÜ : ‚Ñï ‚Üí ‚Ñï} (h : StrictMono œÜ) : Tendsto œÜ atTop atTop :=
  tendsto_at_top_mono h.id_le tendsto_id

section OrderedAddCommMonoid

variable [OrderedAddCommMonoid Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_add_nonneg_left' (hf : ‚àÄ·∂† x in l, 0 ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_mono' l (hf.mono fun x => le_add_of_nonneg_left) hg

theorem tendsto_at_bot_add_nonpos_left' (hf : ‚àÄ·∂† x in l, f x ‚â§ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_nonneg_left' _ Œ≤·µí·µà _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_left (hf : ‚àÄ x, 0 ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

theorem tendsto_at_bot_add_nonpos_left (hf : ‚àÄ x, f x ‚â§ 0) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_nonneg_left _ Œ≤·µí·µà _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right' (hf : Tendsto f l atTop) (hg : ‚àÄ·∂† x in l, 0 ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_mono' l (monotone_mem (fun x => le_add_of_nonneg_right) hg) hf

theorem tendsto_at_bot_add_nonpos_right' (hf : Tendsto f l atBot) (hg : ‚àÄ·∂† x in l, g x ‚â§ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_nonneg_right' _ Œ≤·µí·µà _ _ _ _ hf hg

theorem tendsto_at_top_add_nonneg_right (hf : Tendsto f l atTop) (hg : ‚àÄ x, 0 ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

theorem tendsto_at_bot_add_nonpos_right (hf : Tendsto f l atBot) (hg : ‚àÄ x, g x ‚â§ 0) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_nonneg_right _ Œ≤·µí·µà _ _ _ _ hf hg

theorem tendsto_at_top_add (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) : Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg

theorem tendsto_at_bot_add (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) : Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add _ Œ≤·µí·µà _ _ _ _ hf hg

theorem Tendsto.nsmul_at_top (hf : Tendsto f l atTop) {n : ‚Ñï} (hn : 0 < n) : Tendsto (fun x => n ‚Ä¢ f x) l atTop :=
  tendsto_at_top.2 fun y =>
    (tendsto_at_top.1 hf y).mp <|
      (tendsto_at_top.1 hf 0).mono fun x h‚ÇÄ hy =>
        calc
          y ‚â§ f x := hy
          _ = 1 ‚Ä¢ f x := (one_nsmul _).symm
          _ ‚â§ n ‚Ä¢ f x := nsmul_le_nsmul h‚ÇÄ hn
          

theorem Tendsto.nsmul_at_bot (hf : Tendsto f l atBot) {n : ‚Ñï} (hn : 0 < n) : Tendsto (fun x => n ‚Ä¢ f x) l atBot :=
  @Tendsto.nsmul_at_top Œ± Œ≤·µí·µà _ l f hf n hn

theorem tendsto_bit0_at_top : Tendsto bit0 (atTop : Filter Œ≤) atTop :=
  tendsto_at_top_add tendsto_id tendsto_id

theorem tendsto_bit0_at_bot : Tendsto bit0 (atBot : Filter Œ≤) atBot :=
  tendsto_at_bot_add tendsto_id tendsto_id

end OrderedAddCommMonoid

section OrderedCancelAddCommMonoid

variable [OrderedCancelAddCommMonoid Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_of_add_const_left (C : Œ≤) (hf : Tendsto (fun x => C + f x) l atTop) : Tendsto f l atTop :=
  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (C + b)).mono fun x => le_of_add_le_add_left

theorem tendsto_at_bot_of_add_const_left (C : Œ≤) (hf : Tendsto (fun x => C + f x) l atBot) : Tendsto f l atBot :=
  @tendsto_at_top_of_add_const_left _ Œ≤·µí·µà _ _ _ C hf

theorem tendsto_at_top_of_add_const_right (C : Œ≤) (hf : Tendsto (fun x => f x + C) l atTop) : Tendsto f l atTop :=
  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (b + C)).mono fun x => le_of_add_le_add_right

theorem tendsto_at_bot_of_add_const_right (C : Œ≤) (hf : Tendsto (fun x => f x + C) l atBot) : Tendsto f l atBot :=
  @tendsto_at_top_of_add_const_right _ Œ≤·µí·µà _ _ _ C hf

theorem tendsto_at_top_of_add_bdd_above_left' (C) (hC : ‚àÄ·∂† x in l, f x ‚â§ C) (h : Tendsto (fun x => f x + g x) l atTop) :
    Tendsto g l atTop :=
  tendsto_at_top_of_add_const_left C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_right hx (g x)) h)

theorem tendsto_at_bot_of_add_bdd_below_left' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ f x) (h : Tendsto (fun x => f x + g x) l atBot) :
    Tendsto g l atBot :=
  @tendsto_at_top_of_add_bdd_above_left' _ Œ≤·µí·µà _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_left (C) (hC : ‚àÄ x, f x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atTop ‚Üí Tendsto g l atTop :=
  tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_left (C) (hC : ‚àÄ x, C ‚â§ f x) :
    Tendsto (fun x => f x + g x) l atBot ‚Üí Tendsto g l atBot :=
  @tendsto_at_top_of_add_bdd_above_left _ Œ≤·µí·µà _ _ _ _ C hC

theorem tendsto_at_top_of_add_bdd_above_right' (C) (hC : ‚àÄ·∂† x in l, g x ‚â§ C)
    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto f l atTop :=
  tendsto_at_top_of_add_const_right C (tendsto_at_top_mono' l (hC.mono fun x hx => add_le_add_left hx (f x)) h)

theorem tendsto_at_bot_of_add_bdd_below_right' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ g x)
    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto f l atBot :=
  @tendsto_at_top_of_add_bdd_above_right' _ Œ≤·µí·µà _ _ _ _ C hC h

theorem tendsto_at_top_of_add_bdd_above_right (C) (hC : ‚àÄ x, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atTop ‚Üí Tendsto f l atTop :=
  tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)

theorem tendsto_at_bot_of_add_bdd_below_right (C) (hC : ‚àÄ x, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atBot ‚Üí Tendsto f l atBot :=
  @tendsto_at_top_of_add_bdd_above_right _ Œ≤·µí·µà _ _ _ _ C hC

end OrderedCancelAddCommMonoid

section OrderedGroup

variable [OrderedAddCommGroup Œ≤] (l : Filter Œ±) {f g : Œ± ‚Üí Œ≤}

theorem tendsto_at_top_add_left_of_le' (C : Œ≤) (hf : ‚àÄ·∂† x in l, C ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_at_top_of_add_bdd_above_left' _ _ _ l (fun x => -f x) (fun x => f x + g x) (-C)
    (by
      simpa)
    (by
      simpa)

theorem tendsto_at_bot_add_left_of_ge' (C : Œ≤) (hf : ‚àÄ·∂† x in l, f x ‚â§ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_left_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg

theorem tendsto_at_top_add_left_of_le (C : Œ≤) (hf : ‚àÄ x, C ‚â§ f x) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg

theorem tendsto_at_bot_add_left_of_ge (C : Œ≤) (hf : ‚àÄ x, f x ‚â§ C) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_left_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le' (C : Œ≤) (hf : Tendsto f l atTop) (hg : ‚àÄ·∂† x in l, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  @tendsto_at_top_of_add_bdd_above_right' _ _ _ l (fun x => f x + g x) (fun x => -g x) (-C)
    (by
      simp [‚Üê hg])
    (by
      simp [‚Üê hf])

theorem tendsto_at_bot_add_right_of_ge' (C : Œ≤) (hf : Tendsto f l atBot) (hg : ‚àÄ·∂† x in l, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_right_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg

theorem tendsto_at_top_add_right_of_le (C : Œ≤) (hf : Tendsto f l atTop) (hg : ‚àÄ x, C ‚â§ g x) :
    Tendsto (fun x => f x + g x) l atTop :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)

theorem tendsto_at_bot_add_right_of_ge (C : Œ≤) (hf : Tendsto f l atBot) (hg : ‚àÄ x, g x ‚â§ C) :
    Tendsto (fun x => f x + g x) l atBot :=
  @tendsto_at_top_add_right_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg

theorem tendsto_at_top_add_const_left (C : Œ≤) (hf : Tendsto f l atTop) : Tendsto (fun x => C + f x) l atTop :=
  tendsto_at_top_add_left_of_le' l C (univ_mem' fun _ => le_refl‚Çì C) hf

theorem tendsto_at_bot_add_const_left (C : Œ≤) (hf : Tendsto f l atBot) : Tendsto (fun x => C + f x) l atBot :=
  @tendsto_at_top_add_const_left _ Œ≤·µí·µà _ _ _ C hf

theorem tendsto_at_top_add_const_right (C : Œ≤) (hf : Tendsto f l atTop) : Tendsto (fun x => f x + C) l atTop :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem' fun _ => le_refl‚Çì C)

theorem tendsto_at_bot_add_const_right (C : Œ≤) (hf : Tendsto f l atBot) : Tendsto (fun x => f x + C) l atBot :=
  @tendsto_at_top_add_const_right _ Œ≤·µí·µà _ _ _ C hf

theorem map_neg_at_bot : map (Neg.neg : Œ≤ ‚Üí Œ≤) atBot = at_top :=
  (OrderIso.neg Œ≤).map_at_bot

theorem map_neg_at_top : map (Neg.neg : Œ≤ ‚Üí Œ≤) atTop = at_bot :=
  (OrderIso.neg Œ≤).map_at_top

@[simp]
theorem comap_neg_at_bot : comap (Neg.neg : Œ≤ ‚Üí Œ≤) atBot = at_top :=
  (OrderIso.neg Œ≤).comap_at_top

@[simp]
theorem comap_neg_at_top : comap (Neg.neg : Œ≤ ‚Üí Œ≤) atTop = at_bot :=
  (OrderIso.neg Œ≤).comap_at_bot

theorem tendsto_neg_at_top_at_bot : Tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) atTop atBot :=
  (OrderIso.neg Œ≤).tendsto_at_top

theorem tendsto_neg_at_bot_at_top : Tendsto (Neg.neg : Œ≤ ‚Üí Œ≤) atBot atTop :=
  @tendsto_neg_at_top_at_bot Œ≤·µí·µà _

@[simp]
theorem tendsto_neg_at_top_iff : Tendsto (fun x => -f x) l atTop ‚Üî Tendsto f l atBot :=
  (OrderIso.neg Œ≤).tendsto_at_bot_iff

@[simp]
theorem tendsto_neg_at_bot_iff : Tendsto (fun x => -f x) l atBot ‚Üî Tendsto f l atTop :=
  (OrderIso.neg Œ≤).tendsto_at_top_iff

end OrderedGroup

section OrderedSemiring

variable [OrderedSemiring Œ±] {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

theorem tendsto_bit1_at_top : Tendsto bit1 (atTop : Filter Œ±) atTop :=
  tendsto_at_top_add_nonneg_right tendsto_bit0_at_top fun _ => zero_le_one

theorem Tendsto.at_top_mul_at_top (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atTop := by
  refine' tendsto_at_top_mono' _ _ hg
  filter_upwards [hg.eventually (eventually_ge_at_top 0),
    hf.eventually (eventually_ge_at_top 1)] with _ using le_mul_of_one_le_left

theorem tendsto_mul_self_at_top : Tendsto (fun x : Œ± => x * x) atTop atTop :=
  tendsto_id.at_top_mul_at_top tendsto_id

/-- The monomial function `x^n` tends to `+‚àû` at `+‚àû` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
theorem tendsto_pow_at_top {n : ‚Ñï} (hn : n ‚â† 0) : Tendsto (fun x : Œ± => x ^ n) atTop atTop := by
  rw [‚Üê pos_iff_ne_zero, ‚Üê Nat.succ_le_iff] at hn
  refine' tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono fun x hx => _) tendsto_id
  simpa only [‚Üê pow_one‚Çì] using pow_le_pow hx hn

end OrderedSemiring

theorem zero_pow_eventually_eq [MonoidWithZero‚Çì Œ±] : (fun n : ‚Ñï => (0 : Œ±) ^ n) =·∂†[at_top] fun n => 0 :=
  eventually_at_top.2 ‚ü®1, fun n hn => zero_pow (zero_lt_one.trans_le hn)‚ü©

section OrderedRing

variable [OrderedRing Œ±] {l : Filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

theorem Tendsto.at_top_mul_at_bot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atBot := by
  have := hf.at_top_mul_at_top <| tendsto_neg_at_bot_at_top.comp hg
  simpa only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê neg_mul_eq_mul_neg, ‚Üê neg_neg‚Çì] using tendsto_neg_at_top_at_bot.comp this

theorem Tendsto.at_bot_mul_at_top (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :
    Tendsto (fun x => f x * g x) l atBot := by
  have : Tendsto (fun x => -f x * g x) l atTop := (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg
  simpa only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê neg_mul_eq_neg_mul‚Çì, ‚Üê neg_neg‚Çì] using tendsto_neg_at_top_at_bot.comp this

theorem Tendsto.at_bot_mul_at_bot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :
    Tendsto (fun x => f x * g x) l atTop := by
  have : Tendsto (fun x => -f x * -g x) l atTop :=
    (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg)
  simpa only [‚Üê neg_mul_neg] using this

end OrderedRing

section LinearOrderedAddCommGroup

variable [LinearOrderedAddCommGroup Œ±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_top_at_top : Tendsto (abs : Œ± ‚Üí Œ±) atTop atTop :=
  tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_bot_at_top : Tendsto (abs : Œ± ‚Üí Œ±) atBot atTop :=
  tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

@[simp]
theorem comap_abs_at_top : comap (abs : Œ± ‚Üí Œ±) atTop = at_bot‚äîat_top := by
  refine'
    le_antisymm‚Çì (((at_top_basis.comap _).le_basis_iff (at_bot_basis.sup at_top_basis)).2 _)
      (sup_le tendsto_abs_at_bot_at_top.le_comap tendsto_abs_at_top_at_top.le_comap)
  rintro ‚ü®a, b‚ü© -
  refine' ‚ü®max (-a) b, trivial‚Çì, fun x hx => _‚ü©
  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, ‚Üê min_neg_neg, le_min_iff, neg_neg‚Çì] at hx
  exact hx.imp And.left And.right

end LinearOrderedAddCommGroup

section LinearOrderedSemiring

variable [LinearOrderedSemiring Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±}

theorem Tendsto.at_top_of_const_mul {c : Œ±} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :
    Tendsto f l atTop :=
  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (c * b)).mono fun x hx => le_of_mul_le_mul_left hx hc

theorem Tendsto.at_top_of_mul_const {c : Œ±} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :
    Tendsto f l atTop :=
  tendsto_at_top.2 fun b => (tendsto_at_top.1 hf (b * c)).mono fun x hx => le_of_mul_le_mul_right hx hc

end LinearOrderedSemiring

theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing Œ±] {a : Œ±} (h : ‚àÄ·∂† n in at_top, 0 ‚â§ a ^ (n : ‚Ñï)) : 0 ‚â§ a :=
  let ‚ü®n, hn‚ü© := (tendsto_bit1_at_top.Eventually h).exists
  pow_bit1_nonneg_iff.1 hn

section LinearOrderedField

variable [LinearOrderedField Œ±] {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.const_mul_at_top'` instead. -/
theorem Tendsto.const_mul_at_top (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => r * f x) l atTop :=
  Tendsto.at_top_of_const_mul (inv_pos.2 hr) <| by
    simpa only [‚Üê inv_mul_cancel_left‚ÇÄ hr.ne']

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.at_top_mul_const'` instead. -/
theorem Tendsto.at_top_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atTop := by
  simpa only [‚Üê mul_comm] using hf.const_mul_at_top hr

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem Tendsto.at_top_div_const (hr : 0 < r) (hf : Tendsto f l atTop) : Tendsto (fun x => f x / r) l atTop := by
  simpa only [‚Üê div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem Tendsto.neg_const_mul_at_top (hr : r < 0) (hf : Tendsto f l atTop) : Tendsto (fun x => r * f x) l atBot := by
  simpa only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê neg_mul_eq_neg_mul‚Çì, ‚Üê neg_neg‚Çì] using
    tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem Tendsto.at_top_mul_neg_const (hr : r < 0) (hf : Tendsto f l atTop) : Tendsto (fun x => f x * r) l atBot := by
  simpa only [‚Üê mul_comm] using hf.neg_const_mul_at_top hr

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem Tendsto.const_mul_at_bot (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => r * f x) l atBot := by
  simpa only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê neg_mul_eq_mul_neg, ‚Üê neg_neg‚Çì] using
    tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem Tendsto.at_bot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atBot := by
  simpa only [‚Üê mul_comm] using hf.const_mul_at_bot hr

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem Tendsto.at_bot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) : Tendsto (fun x => f x / r) l atBot := by
  simpa only [‚Üê div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem Tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : Tendsto f l atBot) : Tendsto (fun x => r * f x) l atTop := by
  simpa only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê neg_mul_eq_neg_mul‚Çì, ‚Üê neg_neg‚Çì] using
    tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem Tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : Tendsto f l atBot) : Tendsto (fun x => f x * r) l atTop := by
  simpa only [‚Üê mul_comm] using hf.neg_const_mul_at_bot hr

theorem tendsto_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï} (hn : n ‚â† 0) (hc : 0 < c) :
    Tendsto (fun x => c * x ^ n) atTop atTop :=
  Tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)

theorem tendsto_const_mul_pow_at_top_iff {c : Œ±} {n : ‚Ñï} : Tendsto (fun x => c * x ^ n) atTop atTop ‚Üî n ‚â† 0 ‚àß 0 < c :=
  by
  refine' ‚ü®fun h => ‚ü®_, _‚ü©, fun h => tendsto_const_mul_pow_at_top h.1 h.2‚ü©
  ¬∑ rintro rfl
    simpa only [‚Üê pow_zero‚Çì, ‚Üê not_tendsto_const_at_top] using h
    
  ¬∑ rcases((h.eventually_gt_at_top 0).And (eventually_ge_at_top 0)).exists with ‚ü®k, hck, hk‚ü©
    exact pos_of_mul_pos_left hck (pow_nonneg hk _)
    

theorem tendsto_neg_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï} (hn : n ‚â† 0) (hc : c < 0) :
    Tendsto (fun x => c * x ^ n) atTop atBot :=
  Tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)

theorem tendsto_const_mul_pow_at_bot_iff {c : Œ±} {n : ‚Ñï} : Tendsto (fun x => c * x ^ n) atTop atBot ‚Üî n ‚â† 0 ‚àß c < 0 :=
  by
  simp only [tendsto_neg_at_top_iff, neg_mul, ‚Üê tendsto_const_mul_pow_at_top_iff, ‚Üê neg_pos]

end LinearOrderedField

open Filter

theorem tendsto_at_top' [Nonempty Œ±] [SemilatticeSup Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto f atTop l ‚Üî ‚àÄ, ‚àÄ s ‚àà l, ‚àÄ, ‚àÉ a, ‚àÄ, ‚àÄ b ‚â• a, ‚àÄ, f b ‚àà s := by
  simp only [‚Üê tendsto_def, ‚Üê mem_at_top_sets] <;> rfl

theorem tendsto_at_bot' [Nonempty Œ±] [SemilatticeInf Œ±] {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto f atBot l ‚Üî ‚àÄ, ‚àÄ s ‚àà l, ‚àÄ, ‚àÉ a, ‚àÄ, ‚àÄ b ‚â§ a, ‚àÄ, f b ‚àà s :=
  @tendsto_at_top' Œ±·µí·µà _ _ _ _ _

theorem tendsto_at_top_principal [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
    Tendsto f atTop (ùìü s) ‚Üî ‚àÉ N, ‚àÄ, ‚àÄ n ‚â• N, ‚àÄ, f n ‚àà s := by
  rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets] <;> rfl

theorem tendsto_at_bot_principal [Nonempty Œ≤] [SemilatticeInf Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ±} :
    Tendsto f atBot (ùìü s) ‚Üî ‚àÉ N, ‚àÄ, ‚àÄ n ‚â§ N, ‚àÄ, f n ‚àà s :=
  @tendsto_at_top_principal _ Œ≤·µí·µà _ _ _ _

/-- A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_top_at_top [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí b ‚â§ f a :=
  Iff.trans tendsto_infi <| forall_congr‚Çì fun b => tendsto_at_top_principal

theorem tendsto_at_top_at_bot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atTop atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí f a ‚â§ b :=
  @tendsto_at_top_at_top Œ± Œ≤·µí·µà _ _ _ f

theorem tendsto_at_bot_at_top [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atBot atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí b ‚â§ f a :=
  @tendsto_at_top_at_top Œ±·µí·µà Œ≤ _ _ _ f

theorem tendsto_at_bot_at_bot [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} :
    Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí f a ‚â§ b :=
  @tendsto_at_top_at_top Œ±·µí·µà Œ≤·µí·µà _ _ _ f

theorem tendsto_at_top_at_top_of_monotone [Preorder‚Çì Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
    (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) : Tendsto f atTop atTop :=
  tendsto_infi.2 fun b =>
    tendsto_principal.2 <|
      let ‚ü®a, ha‚ü© := h b
      (mem_of_superset (mem_at_top a)) fun a' ha' => le_trans‚Çì ha (hf ha')

theorem tendsto_at_bot_at_bot_of_monotone [Preorder‚Çì Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)
    (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) : Tendsto f atBot atBot :=
  tendsto_infi.2 fun b =>
    tendsto_principal.2 <|
      let ‚ü®a, ha‚ü© := h b
      (mem_of_superset (mem_at_bot a)) fun a' ha' => le_trans‚Çì (hf ha') ha

theorem tendsto_at_top_at_top_iff_of_monotone [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Monotone f) : Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, b ‚â§ f a :=
  tendsto_at_top_at_top.trans <|
    forall_congr‚Çì fun b => exists_congr fun a => ‚ü®fun h => h a (le_refl‚Çì a), fun h a' ha' => le_trans‚Çì h <| hf ha'‚ü©

theorem tendsto_at_bot_at_bot_iff_of_monotone [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] {f : Œ± ‚Üí Œ≤}
    (hf : Monotone f) : Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, f a ‚â§ b :=
  tendsto_at_bot_at_bot.trans <|
    forall_congr‚Çì fun b => exists_congr fun a => ‚ü®fun h => h a (le_refl‚Çì a), fun h a' ha' => le_trans‚Çì (hf ha') h‚ü©

alias tendsto_at_top_at_top_of_monotone ‚Üê _root_.monotone.tendsto_at_top_at_top

alias tendsto_at_bot_at_bot_of_monotone ‚Üê _root_.monotone.tendsto_at_bot_at_bot

alias tendsto_at_top_at_top_iff_of_monotone ‚Üê _root_.monotone.tendsto_at_top_at_top_iff

alias tendsto_at_bot_at_bot_iff_of_monotone ‚Üê _root_.monotone.tendsto_at_bot_at_bot_iff

theorem comap_embedding_at_top [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {e : Œ≤ ‚Üí Œ≥} (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ)
    (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) : comap e atTop = at_top :=
  le_antisymm‚Çì (le_infi fun b => le_principal_iff.2 <| mem_comap.2 ‚ü®Ici (e b), mem_at_top _, fun x => (hm _ _).1‚ü©)
    (tendsto_at_top_at_top_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap

theorem comap_embedding_at_bot [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {e : Œ≤ ‚Üí Œ≥} (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ)
    (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) : comap e atBot = at_bot :=
  @comap_embedding_at_top Œ≤·µí·µà Œ≥·µí·µà _ _ e (Function.swap hm) hu

theorem tendsto_at_top_embedding [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) : Tendsto (e ‚àò f) l atTop ‚Üî Tendsto f l atTop := by
  rw [‚Üê comap_embedding_at_top hm hu, tendsto_comap_iff]

/-- A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_bot_embedding [Preorder‚Çì Œ≤] [Preorder‚Çì Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}
    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) : Tendsto (e ‚àò f) l atBot ‚Üî Tendsto f l atBot :=
  @tendsto_at_top_embedding Œ± Œ≤·µí·µà Œ≥·µí·µà _ _ f e l (Function.swap hm) hu

theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=
  Finset.range_mono.tendsto_at_top_at_top Finset.exists_nat_subset_range

theorem at_top_finset_eq_infi : (atTop : Filter <| Finset Œ±) = ‚®Ö x : Œ±, ùìü (Ici {x}) := by
  refine' le_antisymm‚Çì (le_infi fun i => le_principal_iff.2 <| mem_at_top {i}) _
  refine' le_infi fun s => le_principal_iff.2 <| mem_infi_of_Inter s.finite_to_set (fun i => mem_principal_self _) _
  simp only [‚Üê subset_def, ‚Üê mem_Inter, ‚Üê SetCoe.forall, ‚Üê mem_Ici, ‚Üê Finset.le_iff_subset, ‚Üê Finset.mem_singleton, ‚Üê
    Finset.subset_iff, ‚Üê forall_eq]
  dsimp'
  exact fun t => id

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
theorem tendsto_at_top_finset_of_monotone [Preorder‚Çì Œ≤] {f : Œ≤ ‚Üí Finset Œ±} (h : Monotone f)
    (h' : ‚àÄ x : Œ±, ‚àÉ n, x ‚àà f n) : Tendsto f atTop atTop := by
  simp only [‚Üê at_top_finset_eq_infi, ‚Üê tendsto_infi, ‚Üê tendsto_principal]
  intro a
  rcases h' a with ‚ü®b, hb‚ü©
  exact eventually.mono (mem_at_top b) fun b' hb' => le_trans‚Çì (Finset.singleton_subset_iff.2 hb) (h hb')

alias tendsto_at_top_finset_of_monotone ‚Üê _root_.monotone.tendsto_at_top_finset

theorem tendsto_finset_image_at_top_at_top {i : Œ≤ ‚Üí Œ≥} {j : Œ≥ ‚Üí Œ≤} (h : Function.LeftInverse j i) :
    Tendsto (Finset.image j) atTop atTop :=
  (Finset.image_mono j).tendsto_at_top_finset fun a =>
    ‚ü®{i a}, by
      simp only [‚Üê Finset.image_singleton, ‚Üê h a, ‚Üê Finset.mem_singleton]‚ü©

theorem tendsto_finset_preimage_at_top_at_top {f : Œ± ‚Üí Œ≤} (hf : Function.Injective f) :
    Tendsto (fun s : Finset Œ≤ => s.Preimage f (hf.InjOn _)) atTop atTop :=
  (Finset.monotone_preimage hf).tendsto_at_top_finset fun x =>
    ‚ü®{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _‚ü©

theorem prod_at_top_at_top_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeSup Œ≤‚ÇÅ] [SemilatticeSup Œ≤‚ÇÇ] :
    (atTop : Filter Œ≤‚ÇÅ) √ó·∂† (atTop : Filter Œ≤‚ÇÇ) = (atTop : Filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) := by
  cases (is_empty_or_nonempty Œ≤‚ÇÅ).symm
  cases (is_empty_or_nonempty Œ≤‚ÇÇ).symm
  ¬∑ simp [‚Üê at_top, ‚Üê prod_infi_left, ‚Üê prod_infi_right, ‚Üê infi_prod]
    exact infi_comm
    
  ¬∑ simp only [‚Üê at_top.filter_eq_bot_of_is_empty, ‚Üê prod_bot]
    
  ¬∑ simp only [‚Üê at_top.filter_eq_bot_of_is_empty, ‚Üê bot_prod]
    

theorem prod_at_bot_at_bot_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeInf Œ≤‚ÇÅ] [SemilatticeInf Œ≤‚ÇÇ] :
    (atBot : Filter Œ≤‚ÇÅ) √ó·∂† (atBot : Filter Œ≤‚ÇÇ) = (atBot : Filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
  @prod_at_top_at_top_eq Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _

theorem prod_map_at_top_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeSup Œ≤‚ÇÅ] [SemilatticeSup Œ≤‚ÇÇ] (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ)
    (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atTop √ó·∂† map u‚ÇÇ atTop = map (Prod.map u‚ÇÅ u‚ÇÇ) atTop := by
  rw [prod_map_map_eq, prod_at_top_at_top_eq, Prod.map_def]

theorem prod_map_at_bot_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type _} [SemilatticeInf Œ≤‚ÇÅ] [SemilatticeInf Œ≤‚ÇÇ] (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ)
    (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atBot √ó·∂† map u‚ÇÇ atBot = map (Prod.map u‚ÇÅ u‚ÇÇ) atBot :=
  @prod_map_at_top_eq _ _ Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _ _ _

theorem Tendsto.subseq_mem {F : Filter Œ±} {V : ‚Ñï ‚Üí Set Œ±} (h : ‚àÄ n, V n ‚àà F) {u : ‚Ñï ‚Üí Œ±} (hu : Tendsto u atTop F) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, u (œÜ n) ‚àà V n :=
  extraction_forall_of_eventually' (fun n => tendsto_at_top'.mp hu _ (h n) : ‚àÄ n, ‚àÉ N, ‚àÄ, ‚àÄ k ‚â• N, ‚àÄ, u k ‚àà V n)

theorem tendsto_at_bot_diagonal [SemilatticeInf Œ±] : Tendsto (fun a : Œ± => (a, a)) atBot atBot := by
  rw [‚Üê prod_at_bot_at_bot_eq]
  exact tendsto_id.prod_mk tendsto_id

theorem tendsto_at_top_diagonal [SemilatticeSup Œ±] : Tendsto (fun a : Œ± => (a, a)) atTop atTop := by
  rw [‚Üê prod_at_top_at_top_eq]
  exact tendsto_id.prod_mk tendsto_id

theorem Tendsto.prod_map_prod_at_bot [SemilatticeInf Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥}
    (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) : Tendsto (Prod.map f g) (F √ó·∂† G) atBot := by
  rw [‚Üê prod_at_bot_at_bot_eq]
  exact hf.prod_map hg

theorem Tendsto.prod_map_prod_at_top [SemilatticeSup Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥}
    (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) : Tendsto (Prod.map f g) (F √ó·∂† G) atTop := by
  rw [‚Üê prod_at_top_at_top_eq]
  exact hf.prod_map hg

theorem Tendsto.prod_at_bot [SemilatticeInf Œ±] [SemilatticeInf Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : Tendsto f atBot atBot)
    (hg : Tendsto g atBot atBot) : Tendsto (Prod.map f g) atBot atBot := by
  rw [‚Üê prod_at_bot_at_bot_eq]
  exact hf.prod_map_prod_at_bot hg

theorem Tendsto.prod_at_top [SemilatticeSup Œ±] [SemilatticeSup Œ≥] {f g : Œ± ‚Üí Œ≥} (hf : Tendsto f atTop atTop)
    (hg : Tendsto g atTop atTop) : Tendsto (Prod.map f g) atTop atTop := by
  rw [‚Üê prod_at_top_at_top_eq]
  exact hf.prod_map_prod_at_top hg

theorem eventually_at_bot_prod_self [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ k l, k ‚â§ a ‚Üí l ‚â§ a ‚Üí p (k, l) := by
  simp [prod_at_bot_at_bot_eq, ‚Üê at_bot_basis.prod_self.eventually_iff]

theorem eventually_at_top_prod_self [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ k l, a ‚â§ k ‚Üí a ‚â§ l ‚Üí p (k, l) := by
  simp [prod_at_top_at_top_eq, ‚Üê at_top_basis.prod_self.eventually_iff]

theorem eventually_at_bot_prod_self' [SemilatticeInf Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_bot, p x) ‚Üî ‚àÉ a, ‚àÄ, ‚àÄ k ‚â§ a, ‚àÄ, ‚àÄ, ‚àÄ l ‚â§ a, ‚àÄ, p (k, l) := by
  rw [Filter.eventually_at_bot_prod_self]
  apply exists_congr
  tauto

theorem eventually_at_top_prod_self' [SemilatticeSup Œ±] [Nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
    (‚àÄ·∂† x in at_top, p x) ‚Üî ‚àÉ a, ‚àÄ, ‚àÄ k ‚â• a, ‚àÄ, ‚àÄ, ‚àÄ l ‚â• a, ‚àÄ, p (k, l) := by
  rw [Filter.eventually_at_top_prod_self]
  apply exists_congr
  tauto

theorem eventually_at_top_curry [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atTop, p x) : ‚àÄ·∂† k in at_top, ‚àÄ·∂† l in at_top, p (k, l) := by
  rw [‚Üê prod_at_top_at_top_eq] at hp
  exact hp.curry

theorem eventually_at_bot_curry [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atBot, p x) : ‚àÄ·∂† k in at_bot, ‚àÄ·∂† l in at_bot, p (k, l) :=
  @eventually_at_top_curry Œ±·µí·µà Œ≤·µí·µà _ _ _ hp

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
theorem map_at_top_eq_of_gc [SemilatticeSup Œ±] [SemilatticeSup Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤) (hf : Monotone f)
    (gc : ‚àÄ a, ‚àÄ, ‚àÄ b ‚â• b', ‚àÄ, f a ‚â§ b ‚Üî a ‚â§ g b) (hgi : ‚àÄ, ‚àÄ b ‚â• b', ‚àÄ, b ‚â§ f (g b)) : map f atTop = at_top := by
  refine' le_antisymm‚Çì (hf.tendsto_at_top_at_top fun b => ‚ü®g (b‚äîb'), le_sup_left.trans <| hgi _ le_sup_right‚ü©) _
  rw [@map_at_top_eq _ _ ‚ü®g b'‚ü©]
  refine' le_infi fun a => infi_le_of_le (f a‚äîb') <| principal_mono.2 fun b hb => _
  rw [mem_Ici, sup_le_iff] at hb
  exact ‚ü®g b, (gc _ _ hb.2).1 hb.1, le_antisymm‚Çì ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)‚ü©

theorem map_at_bot_eq_of_gc [SemilatticeInf Œ±] [SemilatticeInf Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤) (hf : Monotone f)
    (gc : ‚àÄ a, ‚àÄ, ‚àÄ b ‚â§ b', ‚àÄ, b ‚â§ f a ‚Üî g b ‚â§ a) (hgi : ‚àÄ, ‚àÄ b ‚â§ b', ‚àÄ, f (g b) ‚â§ b) : map f atBot = at_bot :=
  @map_at_top_eq_of_gc Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ hf.dual gc hgi

theorem map_coe_at_top_of_Ici_subset [SemilatticeSup Œ±] {a : Œ±} {s : Set Œ±} (h : Ici a ‚äÜ s) :
    map (coe : s ‚Üí Œ±) atTop = at_top := by
  have : Directed (¬∑ ‚â• ¬∑) fun x : s => ùìü (Ici x) := by
    intro x y
    use ‚ü®x‚äîy‚äîa, h le_sup_right‚ü©
    simp only [‚Üê ge_iff_le, ‚Üê principal_mono, ‚Üê Ici_subset_Ici, Subtype.coe_le_coe, ‚Üê Subtype.coe_mk]
    exact ‚ü®le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left‚ü©
  have : Nonempty s := ‚ü®‚ü®a, h le_rfl‚ü©‚ü©
  simp only [‚Üê le_antisymm_iff‚Çì, ‚Üê at_top, ‚Üê le_infi_iff, ‚Üê le_principal_iff, ‚Üê mem_map, ‚Üê mem_set_of_eq, ‚Üê
    map_infi_eq this, ‚Üê map_principal]
  constructor
  ¬∑ intro x
    refine' mem_of_superset (mem_infi_of_mem ‚ü®x‚äîa, h le_sup_right‚ü© (mem_principal_self _)) _
    rintro _ ‚ü®y, hy, rfl‚ü©
    exact le_trans‚Çì le_sup_left (Subtype.coe_le_coe.2 hy)
    
  ¬∑ intro x
    filter_upwards [mem_at_top (‚Üëx‚äîa)] with b hb
    exact ‚ü®‚ü®b, h <| le_sup_right.trans hb‚ü©, Subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl‚ü©
    

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ici_at_top [SemilatticeSup Œ±] (a : Œ±) : map (coe : Ici a ‚Üí Œ±) atTop = at_top :=
  map_coe_at_top_of_Ici_subset (Subset.refl _)

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp]
theorem map_coe_Ioi_at_top [SemilatticeSup Œ±] [NoMaxOrder Œ±] (a : Œ±) : map (coe : Ioi a ‚Üí Œ±) atTop = at_top :=
  let ‚ü®b, hb‚ü© := exists_gt a
  map_coe_at_top_of_Ici_subset <| Ici_subset_Ioi.2 hb

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ioi_eq [SemilatticeSup Œ±] (a : Œ±) : at_top = comap (coe : Ioi a ‚Üí Œ±) atTop := by
  nontriviality
  rcases nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫ with ‚ü®b, hb‚ü©
  rw [‚Üê map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ici_eq [SemilatticeSup Œ±] (a : Œ±) : at_top = comap (coe : Ici a ‚Üí Œ±) atTop := by
  rw [‚Üê map_coe_Ici_at_top a, comap_map Subtype.coe_injective]

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iio_at_bot [SemilatticeInf Œ±] [NoMinOrder Œ±] (a : Œ±) : map (coe : Iio a ‚Üí Œ±) atBot = at_bot :=
  @map_coe_Ioi_at_top Œ±·µí·µà _ _ _

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iio_eq [SemilatticeInf Œ±] (a : Œ±) : at_bot = comap (coe : Iio a ‚Üí Œ±) atBot :=
  @at_top_Ioi_eq Œ±·µí·µà _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp]
theorem map_coe_Iic_at_bot [SemilatticeInf Œ±] (a : Œ±) : map (coe : Iic a ‚Üí Œ±) atBot = at_bot :=
  @map_coe_Ici_at_top Œ±·µí·µà _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iic_eq [SemilatticeInf Œ±] (a : Œ±) : at_bot = comap (coe : Iic a ‚Üí Œ±) atBot :=
  @at_top_Ici_eq Œ±·µí·µà _ _

theorem tendsto_Ioi_at_top [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ioi a} {l : Filter Œ≤} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by
  rw [at_top_Ioi_eq, tendsto_comap_iff]

theorem tendsto_Iio_at_bot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iio a} {l : Filter Œ≤} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot := by
  rw [at_bot_Iio_eq, tendsto_comap_iff]

theorem tendsto_Ici_at_top [SemilatticeSup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ici a} {l : Filter Œ≤} :
    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by
  rw [at_top_Ici_eq, tendsto_comap_iff]

theorem tendsto_Iic_at_bot [SemilatticeInf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iic a} {l : Filter Œ≤} :
    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot := by
  rw [at_bot_Iic_eq, tendsto_comap_iff]

@[simp]
theorem tendsto_comp_coe_Ioi_at_top [SemilatticeSup Œ±] [NoMaxOrder Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Ioi a => f x) atTop l ‚Üî Tendsto f atTop l := by
  rw [‚Üê map_coe_Ioi_at_top a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Ici_at_top [SemilatticeSup Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Ici a => f x) atTop l ‚Üî Tendsto f atTop l := by
  rw [‚Üê map_coe_Ici_at_top a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iio_at_bot [SemilatticeInf Œ±] [NoMinOrder Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Iio a => f x) atBot l ‚Üî Tendsto f atBot l := by
  rw [‚Üê map_coe_Iio_at_bot a, tendsto_map'_iff]

@[simp]
theorem tendsto_comp_coe_Iic_at_bot [SemilatticeInf Œ±] {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :
    Tendsto (fun x : Iic a => f x) atBot l ‚Üî Tendsto f atBot l := by
  rw [‚Üê map_coe_Iic_at_bot a, tendsto_map'_iff]

theorem map_add_at_top_eq_nat (k : ‚Ñï) : map (fun a => a + k) atTop = at_top :=
  map_at_top_eq_of_gc (fun a => a - k) k (fun a b h => add_le_add_right h k) (fun a b h => (le_tsub_iff_right h).symm)
    fun a h => by
    rw [tsub_add_cancel_of_le h]

theorem map_sub_at_top_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = at_top :=
  map_at_top_eq_of_gc (fun a => a + k) 0 (fun a b h => tsub_le_tsub_right h _) (fun a b _ => tsub_le_iff_right)
    fun b _ => by
    rw [add_tsub_cancel_right]

theorem tendsto_add_at_top_nat (k : ‚Ñï) : Tendsto (fun a => a + k) atTop atTop :=
  le_of_eq‚Çì (map_add_at_top_eq_nat k)

theorem tendsto_sub_at_top_nat (k : ‚Ñï) : Tendsto (fun a => a - k) atTop atTop :=
  le_of_eq‚Çì (map_sub_at_top_eq_nat k)

theorem tendsto_add_at_top_iff_nat {f : ‚Ñï ‚Üí Œ±} {l : Filter Œ±} (k : ‚Ñï) :
    Tendsto (fun n => f (n + k)) atTop l ‚Üî Tendsto f atTop l :=
  show Tendsto (f ‚àò fun n => n + k) atTop l ‚Üî Tendsto f atTop l by
    rw [‚Üê tendsto_map'_iff, map_add_at_top_eq_nat]

theorem map_div_at_top_eq_nat (k : ‚Ñï) (hk : 0 < k) : map (fun a => a / k) atTop = at_top :=
  map_at_top_eq_of_gc (fun b => b * k + (k - 1)) 1 (fun a b h => Nat.div_le_div_right h)
    (fun a b _ =>
      calc
        a / k ‚â§ b ‚Üî a / k < b + 1 := by
          rw [‚Üê Nat.succ_eq_add_one, Nat.lt_succ_iff‚Çì]
        _ ‚Üî a < (b + 1) * k := Nat.div_lt_iff_lt_mul‚Çì hk
        _ ‚Üî _ := by
          cases k
          exact (lt_irrefl‚Çì _ hk).elim
          rw [add_mul‚Çì, one_mul‚Çì, Nat.succ_sub_succ_eq_sub, tsub_zero, Nat.add_succ, Nat.lt_succ_iff‚Çì]
        )
    fun b _ =>
    calc
      b = b * k / k := by
        rw [Nat.mul_div_cancel‚Çì b hk]
      _ ‚â§ (b * k + (k - 1)) / k := Nat.div_le_div_right <| Nat.le_add_right‚Çì _ _
      

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
theorem tendsto_at_top_at_top_of_monotone' [Preorder‚Çì Œπ] [LinearOrder‚Çì Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
    (H : ¬¨BddAbove (Range u)) : Tendsto u atTop atTop := by
  apply h.tendsto_at_top_at_top
  intro b
  rcases not_bdd_above_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©
  exact ‚ü®N, le_of_lt‚Çì hN‚ü©

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
theorem tendsto_at_bot_at_bot_of_monotone' [Preorder‚Çì Œπ] [LinearOrder‚Çì Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)
    (H : ¬¨BddBelow (Range u)) : Tendsto u atBot atBot :=
  @tendsto_at_top_at_top_of_monotone' Œπ·µí·µà Œ±·µí·µà _ _ _ h.dual H

theorem unbounded_of_tendsto_at_top [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤}
    (h : Tendsto f atTop atTop) : ¬¨BddAbove (Range f) := by
  rintro ‚ü®M, hM‚ü©
  cases' mem_at_top_sets.mp (h <| Ioi_mem_at_top M) with a ha
  apply lt_irrefl‚Çì M
  calc M < f a := ha a le_rfl _ ‚â§ M := hM (Set.mem_range_self a)

theorem unbounded_of_tendsto_at_bot [Nonempty Œ±] [SemilatticeSup Œ±] [Preorder‚Çì Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤}
    (h : Tendsto f atTop atBot) : ¬¨BddBelow (Range f) :=
  @unbounded_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ _ _ h

theorem unbounded_of_tendsto_at_top' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤}
    (h : Tendsto f atBot atTop) : ¬¨BddAbove (Range f) :=
  @unbounded_of_tendsto_at_top Œ±·µí·µà _ _ _ _ _ _ h

theorem unbounded_of_tendsto_at_bot' [Nonempty Œ±] [SemilatticeInf Œ±] [Preorder‚Çì Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤}
    (h : Tendsto f atBot atBot) : ¬¨BddBelow (Range f) :=
  @unbounded_of_tendsto_at_top Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ h

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
theorem tendsto_at_top_of_monotone_of_filter [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±} (h : Monotone u)
    [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=
  h.tendsto_at_top_at_top fun b => (hu.Eventually (mem_at_top b)).exists

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
theorem tendsto_at_bot_of_monotone_of_filter [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±} (h : Monotone u)
    [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=
  @tendsto_at_top_of_monotone_of_filter Œπ·µí·µà Œ±·µí·µà _ _ _ _ h.dual _ hu

theorem tendsto_at_top_of_monotone_of_subseq [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ} (h : Monotone u)
    {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atTop) : Tendsto u atTop atTop :=
  tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

theorem tendsto_at_bot_of_monotone_of_subseq [Preorder‚Çì Œπ] [Preorder‚Çì Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ} (h : Monotone u)
    {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atBot) : Tendsto u atBot atBot :=
  tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Œª s, ‚àè b in s, f b)` with
`at_top.map (Œª s, ‚àè b in s, g b)`. This is useful to compare the set of limit points of
`Œ† b in s, f b` as `s ‚Üí at_top` with the similar set for `g`. -/
@[to_additive
      "Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `at_top.map (Œª s, ‚àë b in s, f b)` with\n`at_top.map (Œª s, ‚àë b in s, g b)`. This is useful to compare the set of limit points of\n`‚àë b in s, f b` as `s ‚Üí at_top` with the similar set for `g`."]
theorem map_at_top_finset_prod_le_of_prod_eq [CommMonoid‚Çì Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±}
    (h_eq : ‚àÄ u : Finset Œ≥, ‚àÉ v : Finset Œ≤, ‚àÄ v', v ‚äÜ v' ‚Üí ‚àÉ u', u ‚äÜ u' ‚àß (‚àè x in u', g x) = ‚àè b in v', f b) :
    (atTop.map fun s : Finset Œ≤ => ‚àè b in s, f b) ‚â§ atTop.map fun s : Finset Œ≥ => ‚àè x in s, g x := by
  rw [map_at_top_eq, map_at_top_eq] <;>
    exact
      le_infi fun b =>
        let ‚ü®v, hv‚ü© := h_eq b
        infi_le_of_le v <| by
          simp [‚Üê Set.image_subset_iff] <;> exact hv

theorem HasAntitoneBasis.eventually_subset [Preorder‚Çì Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±} (hl : l.HasAntitoneBasis s)
    {t : Set Œ±} (ht : t ‚àà l) : ‚àÄ·∂† i in at_top, s i ‚äÜ t :=
  let ‚ü®i, _, hi‚ü© := hl.to_has_basis.mem_iff.1 ht
  (eventually_ge_at_top i).mono fun j hj => (hl.Antitone hj).trans hi

protected theorem HasAntitoneBasis.tendsto [Preorder‚Çì Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±} (hl : l.HasAntitoneBasis s)
    {œÜ : Œπ ‚Üí Œ±} (h : ‚àÄ i : Œπ, œÜ i ‚àà s i) : Tendsto œÜ atTop l := fun t ht =>
  mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)

theorem HasAntitoneBasis.comp_mono [SemilatticeSup Œπ] [Nonempty Œπ] [Preorder‚Çì Œπ'] {l : Filter Œ±} {s : Œπ' ‚Üí Set Œ±}
    (hs : l.HasAntitoneBasis s) {œÜ : Œπ ‚Üí Œπ'} (œÜ_mono : Monotone œÜ) (hœÜ : Tendsto œÜ atTop atTop) :
    l.HasAntitoneBasis (s ‚àò œÜ) :=
  ‚ü®hs.to_has_basis.to_has_basis
      (fun n hn => (hœÜ.Eventually (eventually_ge_at_top n)).exists.imp fun m hm => ‚ü®trivial‚Çì, hs.Antitone hm‚ü©)
      fun n hn => ‚ü®œÜ n, trivial‚Çì, Subset.rfl‚ü©,
    hs.Antitone.comp_monotone œÜ_mono‚ü©

theorem HasAntitoneBasis.comp_strict_mono {l : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s) {œÜ : ‚Ñï ‚Üí ‚Ñï}
    (hœÜ : StrictMono œÜ) : l.HasAntitoneBasis (s ‚àò œÜ) :=
  hs.comp_mono hœÜ.Monotone hœÜ.tendsto_at_top

/-- Given an antitone basis `s : ‚Ñï ‚Üí set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,
`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an
antitone basis with basis sets decreasing "sufficiently fast". -/
theorem HasAntitoneBasis.subbasis_with_rel {f : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±} (hs : f.HasAntitoneBasis s) {r : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop}
    (hr : ‚àÄ m, ‚àÄ·∂† n in at_top, r m n) :
    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí r (œÜ m) (œÜ n)) ‚àß f.HasAntitoneBasis (s ‚àò œÜ) := by
  suffices ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ m n, m < n ‚Üí r (œÜ m) (œÜ n) by
    rcases this with ‚ü®œÜ, hœÜ, hrœÜ‚ü©
    exact ‚ü®œÜ, hœÜ, hrœÜ, hs.comp_strict_mono hœÜ‚ü©
  have : ‚àÄ t : Set ‚Ñï, t.Finite ‚Üí ‚àÄ·∂† n in at_top, ‚àÄ, ‚àÄ m ‚àà t, ‚àÄ, m < n ‚àß r m n := fun t ht =>
    (eventually_all_finite ht).2 fun m hm => (eventually_gt_at_top m).And (hr _)
  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with ‚ü®œÜ, hœÜ‚ü©
  simp only [‚Üê ball_image_iff, ‚Üê forall_and_distrib, ‚Üê mem_Iio] at hœÜ
  exact ‚ü®œÜ, forall_swap.2 hœÜ.1, forall_swap.2 hœÜ.2‚ü©

/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges
to `f`. -/
theorem exists_seq_tendsto (f : Filter Œ±) [IsCountablyGenerated f] [NeBot f] : ‚àÉ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop f := by
  obtain ‚ü®B, h‚ü© := f.exists_antitone_basis
  choose x hx using fun n => Filter.nonempty_of_mem (h.mem n)
  exact ‚ü®x, h.tendsto hx‚ü©

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f ‚àò u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.IsCountablyGenerated] :
    Tendsto f k l ‚Üî ‚àÄ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop k ‚Üí Tendsto (f ‚àò x) atTop l := by
  refine' ‚ü®fun h x hx => h.comp hx, fun H s hs => _‚ü©
  contrapose! H
  have : ne_bot (k‚äìùìü (f ‚Åª¬π' s·∂ú)) := by
    simpa [‚Üê ne_bot_iff, ‚Üê inf_principal_eq_bot]
  rcases(k‚äìùìü (f ‚Åª¬π' s·∂ú)).exists_seq_tendsto with ‚ü®x, hx‚ü©
  rw [tendsto_inf, tendsto_principal] at hx
  refine' ‚ü®x, hx.1, fun h => _‚ü©
  rcases(hx.2.And (h hs)).exists with ‚ü®N, hnmem, hmem‚ü©
  exact hnmem hmem

theorem tendsto_of_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [k.IsCountablyGenerated] :
    (‚àÄ x : ‚Ñï ‚Üí Œ±, Tendsto x atTop k ‚Üí Tendsto (f ‚àò x) atTop l) ‚Üí Tendsto f k l :=
  tendsto_iff_seq_tendsto.2

theorem tendsto_iff_forall_eventually_mem {Œ± Œπ : Type _} {x : Œπ ‚Üí Œ±} {f : Filter Œ±} {l : Filter Œπ} :
    Tendsto x l f ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, ‚àÄ·∂† n in l, x n ‚àà s := by
  rw [tendsto_def]
  refine' forall_congr‚Çì fun s => imp_congr_right fun hsf => _
  rfl

theorem not_tendsto_iff_exists_frequently_nmem {Œ± Œπ : Type _} {x : Œπ ‚Üí Œ±} {f : Filter Œ±} {l : Filter Œπ} :
    ¬¨Tendsto x l f ‚Üî ‚àÉ s ‚àà f, ‚àÉ·∂† n in l, x n ‚àâ s := by
  rw [tendsto_iff_forall_eventually_mem]
  push_neg
  refine' exists_congr fun s => _
  rw [not_eventually, exists_prop]

theorem frequently_iff_seq_frequently {Œπ : Type _} {l : Filter Œπ} {p : Œπ ‚Üí Prop} [hl : l.IsCountablyGenerated] :
    (‚àÉ·∂† n in l, p n) ‚Üî ‚àÉ x : ‚Ñï ‚Üí Œπ, Tendsto x atTop l ‚àß ‚àÉ·∂† n : ‚Ñï in at_top, p (x n) := by
  refine' ‚ü®fun h_freq => _, fun h_exists_freq => _‚ü©
  ¬∑ have : ne_bot (l‚äìùìü { x : Œπ | p x }) := by
      simpa [‚Üê ne_bot_iff, ‚Üê inf_principal_eq_bot]
    obtain ‚ü®x, hx‚ü© := exists_seq_tendsto (l‚äìùìü { x : Œπ | p x })
    rw [tendsto_inf] at hx
    cases' hx with hx_l hx_p
    refine' ‚ü®x, hx_l, _‚ü©
    rw [tendsto_principal] at hx_p
    exact hx_p.frequently
    
  ¬∑ obtain ‚ü®x, hx_tendsto, hx_freq‚ü© := h_exists_freq
    simp_rw [Filter.Frequently, Filter.Eventually] at hx_freq‚ä¢
    have : { n : ‚Ñï | ¬¨p (x n) } = { n | x n ‚àà { y | ¬¨p y } } := rfl
    rw [this, ‚Üê mem_map'] at hx_freq
    contrapose! hx_freq
    exact hx_tendsto hx_freq
    

theorem eventually_iff_seq_eventually {Œπ : Type _} {l : Filter Œπ} {p : Œπ ‚Üí Prop} [hl : l.IsCountablyGenerated] :
    (‚àÄ·∂† n in l, p n) ‚Üî ‚àÄ x : ‚Ñï ‚Üí Œπ, Tendsto x atTop l ‚Üí ‚àÄ·∂† n : ‚Ñï in at_top, p (x n) := by
  have : (‚àÄ·∂† n in l, p n) ‚Üî ¬¨‚àÉ·∂† n in l, ¬¨p n := by
    rw [not_frequently]
    simp_rw [not_not]
  rw [this, frequently_iff_seq_frequently]
  push_neg
  simp_rw [not_frequently, not_not]

theorem subseq_forall_of_frequently {Œπ : Type _} {x : ‚Ñï ‚Üí Œπ} {p : Œπ ‚Üí Prop} {l : Filter Œπ}
    (h_tendsto : Tendsto x atTop l) (h : ‚àÉ·∂† n in at_top, p (x n)) :
    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, Tendsto (fun n => x (ns n)) atTop l ‚àß ‚àÄ n, p (x (ns n)) := by
  rw [tendsto_iff_seq_tendsto] at h_tendsto
  choose ns hge hns using frequently_at_top.1 h
  exact ‚ü®ns, h_tendsto ns (tendsto_at_top_mono hge tendsto_id), hns‚ü©

theorem exists_seq_forall_of_frequently {Œπ : Type _} {l : Filter Œπ} {p : Œπ ‚Üí Prop} [hl : l.IsCountablyGenerated]
    (h : ‚àÉ·∂† n in l, p n) : ‚àÉ ns : ‚Ñï ‚Üí Œπ, Tendsto ns atTop l ‚àß ‚àÄ n, p (ns n) := by
  rw [frequently_iff_seq_frequently] at h
  obtain ‚ü®x, hx_tendsto, hx_freq‚ü© := h
  obtain ‚ü®n_to_n, h_tendsto, h_freq‚ü© := subseq_forall_of_frequently hx_tendsto hx_freq
  exact ‚ü®x ‚àò n_to_n, h_tendsto, h_freq‚ü©

/-- A sequence converges if every subsequence has a convergent subsequence. -/
theorem tendsto_of_subseq_tendsto {Œ± Œπ : Type _} {x : Œπ ‚Üí Œ±} {f : Filter Œ±} {l : Filter Œπ} [l.IsCountablyGenerated]
    (hxy : ‚àÄ ns : ‚Ñï ‚Üí Œπ, Tendsto ns atTop l ‚Üí ‚àÉ ms : ‚Ñï ‚Üí ‚Ñï, Tendsto (fun n => x (ns <| ms n)) atTop f) :
    Tendsto x l f := by
  by_contra h
  obtain ‚ü®s, hs, hfreq‚ü© : ‚àÉ s ‚àà f, ‚àÉ·∂† n in l, x n ‚àâ s := by
    rwa [not_tendsto_iff_exists_frequently_nmem] at h
  obtain ‚ü®y, hy_tendsto, hy_freq‚ü© := exists_seq_forall_of_frequently hfreq
  specialize hxy y hy_tendsto
  obtain ‚ü®ms, hms_tendsto‚ü© := hxy
  specialize hms_tendsto hs
  rw [mem_map] at hms_tendsto
  have hms_freq : ‚àÄ n : ‚Ñï, x (y (ms n)) ‚àâ s := fun n => hy_freq (ms n)
  have h_empty : (fun n : ‚Ñï => x (y (ms n))) ‚Åª¬π' s = ‚àÖ := by
    ext1 n
    simp only [‚Üê Set.mem_preimage, ‚Üê Set.mem_empty_eq, ‚Üê iff_false‚Çì]
    exact hms_freq n
  rw [h_empty] at hms_tendsto
  exact empty_not_mem at_top hms_tendsto

theorem subseq_tendsto_of_ne_bot {f : Filter Œ±} [IsCountablyGenerated f] {u : ‚Ñï ‚Üí Œ±} (hx : NeBot (f‚äìmap u atTop)) :
    ‚àÉ Œ∏ : ‚Ñï ‚Üí ‚Ñï, StrictMono Œ∏ ‚àß Tendsto (u ‚àò Œ∏) atTop f := by
  obtain ‚ü®B, h‚ü© := f.exists_antitone_basis
  have : ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà B N := fun N =>
    filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial‚Çì) N
  choose œÜ hœÜ using this
  cases' forall_and_distrib.mp hœÜ with œÜ_ge œÜ_in
  have lim_uœÜ : tendsto (u ‚àò œÜ) at_top f := h.tendsto œÜ_in
  have lim_œÜ : tendsto œÜ at_top at_top := tendsto_at_top_mono œÜ_ge tendsto_id
  obtain ‚ü®œà, hœà, hœàœÜ‚ü© : ‚àÉ œà : ‚Ñï ‚Üí ‚Ñï, StrictMono œà ‚àß StrictMono (œÜ ‚àò œà)
  exact strict_mono_subseq_of_tendsto_at_top lim_œÜ
  exact ‚ü®œÜ ‚àò œà, hœàœÜ, lim_uœÜ.comp hœà.tendsto_at_top‚ü©

end Filter

open Filter Finset

section

variable {R : Type _} [LinearOrderedSemiring R]

theorem exists_lt_mul_self (a : R) : ‚àÉ x ‚â• 0, a < x * x :=
  let ‚ü®x, hxa, hx0‚ü© :=
    ((tendsto_mul_self_at_top.Eventually (eventually_gt_at_top a)).And (eventually_ge_at_top 0)).exists
  ‚ü®x, hx0, hxa‚ü©

theorem exists_le_mul_self (a : R) : ‚àÉ x ‚â• 0, a ‚â§ x * x :=
  let ‚ü®x, hx0, hxa‚ü© := exists_lt_mul_self a
  ‚ü®x, hx0, hxa.le‚ü©

end

-- ./././Mathport/Syntax/Translate/Basic.lean:710:2: warning: expanding binder collection (x ¬´expr ‚àâ ¬ª set.range g)
/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Œª s, ‚àè i in s, f (g i))` and `at_top.map (Œª s, ‚àè i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
@[to_additive]
theorem Function.Injective.map_at_top_finset_prod_eq [CommMonoid‚Çì Œ±] {g : Œ≥ ‚Üí Œ≤} (hg : Function.Injective g) {f : Œ≤ ‚Üí Œ±}
    (hf : ‚àÄ (x) (_ : x ‚àâ Set.Range g), f x = 1) :
    map (fun s => ‚àè i in s, f (g i)) atTop = map (fun s => ‚àè i in s, f i) atTop := by
  apply le_antisymm‚Çì <;> refine' map_at_top_finset_prod_le_of_prod_eq fun s => _
  ¬∑ refine' ‚ü®s.preimage g (hg.inj_on _), fun t ht => _‚ü©
    refine' ‚ü®t.image g ‚à™ s, Finset.subset_union_right _ _, _‚ü©
    rw [‚Üê Finset.prod_image (hg.inj_on _)]
    refine' (prod_subset (subset_union_left _ _) _).symm
    simp only [‚Üê Finset.mem_union, ‚Üê Finset.mem_image]
    refine' fun y hy hyt => hf y (mt _ hyt)
    rintro ‚ü®x, rfl‚ü©
    exact ‚ü®x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl‚ü©
    
  ¬∑ refine' ‚ü®s.image g, fun t ht => _‚ü©
    simp only [prod_preimage _ _ (hg.inj_on _) _ fun x _ => hf x]
    exact ‚ü®_, (image_subset_iff_subset_preimage _).1 ht, rfl‚ü©
    

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Œª s, ‚àë i in s, f (g i))` and `at_top.map (Œª s, ‚àë i in s, f i)` coincide.

This lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
add_decl_doc Function.Injective.map_at_top_finset_sum_eq

