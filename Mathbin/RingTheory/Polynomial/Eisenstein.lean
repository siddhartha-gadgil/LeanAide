/-
Copyright (c) 2022 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca
-/
import Mathbin.RingTheory.EisensteinCriterion
import Mathbin.RingTheory.IntegrallyClosed
import Mathbin.RingTheory.Norm
import Mathbin.RingTheory.Polynomial.Cyclotomic.Basic

/-!
# Eisenstein polynomials
Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]` is
*Eisenstein at `ğ“Ÿ`* if `f.leading_coeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ` and
`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. In this file we gather miscellaneous results about Eisenstein polynomials.

## Main definitions
* `polynomial.is_eisenstein_at f ğ“Ÿ`: the property of being Eisenstein at `ğ“Ÿ`.

## Main results
* `polynomial.is_eisenstein_at.irreducible`: if a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`,
  where `ğ“Ÿ.is_prime`, then `f` is irreducible.
* `mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at`: let `K` be the field of fraction
  of an integrally closed domain `R` and let `L` be a separable extension of `K`, generated by an
  integral power basis `B` such that the minimal polynomial of `B.gen` is Eisenstein at `p`. Given
  `z : L` integral over `R`, if `p ^ n â€¢ z âˆˆ adjoin R {B.gen}`, then `z âˆˆ adjoin R {B.gen}`.
  Together with `algebra.discr_mul_is_integral_mem_adjoin` this result often allows to compute the
  ring of integers of `L`.

## Implementation details
We also define a notion `is_weakly_eisenstein_at` requiring only that
`âˆ€ n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ`. This makes certain results slightly more general and it is
useful since it is sometimes better behaved (for example it is stable under `polynomial.map`).

-/


universe u v w z

variable {R : Type u}

open Ideal Algebra Finset

open BigOperators Polynomial

namespace Polynomial

/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *weakly Eisenstein at `ğ“Ÿ`* if `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ`. -/
@[mk_iff]
structure IsWeaklyEisensteinAt [CommSemiringâ‚“ R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where
  Mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ

/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`
is *Eisenstein at `ğ“Ÿ`* if `f.leading_coeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.nat_degree â†’ f.coeff n âˆˆ ğ“Ÿ` and
`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/
@[mk_iff]
structure IsEisensteinAt [CommSemiringâ‚“ R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where
  leading : f.leadingCoeff âˆ‰ ğ“Ÿ
  Mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ
  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2

namespace IsWeaklyEisensteinAt

section CommSemiringâ‚“

variable [CommSemiringâ‚“ R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)

include hf

theorem map {A : Type v} [CommRingâ‚“ A] (Ï† : R â†’+* A) : (f.map Ï†).IsWeaklyEisensteinAt (ğ“Ÿ.map Ï†) := by
  refine' (is_weakly_eisenstein_at_iff _ _).2 fun n hn => _
  rw [coeff_map]
  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_leâ‚“ hn (nat_degree_map_le _ _)))

end CommSemiringâ‚“

section CommRingâ‚“

variable [CommRingâ‚“ R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)

variable {S : Type v} [CommRingâ‚“ S] [Algebra R S]

section Principal

variable {p : R}

-- mathport name: Â«exprPÂ»
local notation "P" => Submodule.span R {p}

theorem exists_mem_adjoin_mul_eq_pow_nat_degree {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).natDegree := by
  rw [aeval_def, Polynomial.evalâ‚‚_eq_eval_map, eval_eq_sum_range, range_add_one, sum_insert not_mem_range_self,
    sum_range, (hmo.map (algebraMap R S)).coeff_nat_degree, one_mulâ‚“] at hx
  replace hx := eq_neg_of_add_eq_zero_left hx
  have : âˆ€, âˆ€ n < f.nat_degree, âˆ€, p âˆ£ f.coeff n := by
    intro n hn
    refine'
      mem_span_singleton.1
        (by
          simpa using hf.mem hn)
  choose! Ï† hÏ† using this
  conv_rhs at hx =>
    congr congr skip ext
      rw [Finâ‚“.coe_eq_val, coeff_map, hÏ† i.1 (lt_of_lt_of_leâ‚“ i.2 (nat_degree_map_le _ _)), RingHom.map_mul, mul_assoc]
  rw [hx, â† mul_sum, neg_eq_neg_one_mul, â† mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]
  refine' âŸ¨-1 * âˆ‘ i : Finâ‚“ (f.map (algebraMap R S)).natDegree, (algebraMap R S) (Ï† i.1) * x ^ i.1, _, rflâŸ©
  exact
    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))
      (Subalgebra.sum_mem _ fun i hi =>
        Subalgebra.mul_mem _ (Subalgebra.algebra_map_mem _ _)
          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))

theorem exists_mem_adjoin_mul_eq_pow_nat_degree_le {x : S} (hx : aeval x f = 0) (hmo : f.Monic)
    (hf : f.IsWeaklyEisensteinAt P) :
    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’ âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i := by
  intro i hi
  obtain âŸ¨k, hkâŸ© := le_iff_exists_add.1 hi
  rw [hk, pow_addâ‚“]
  obtain âŸ¨y, hy, HâŸ© := exists_mem_adjoin_mul_eq_pow_nat_degree hx hmo hf
  refine' âŸ¨y * x ^ k, _, _âŸ©
  Â· exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)
    
  Â· rw [â† mul_assoc _ y, H]
    

end Principal

include hf

theorem pow_nat_degree_le_of_root_of_monic_mem {x : R} (hroot : IsRoot f x) (hmo : f.Monic) :
    âˆ€ i, f.natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ := by
  intro i hi
  obtain âŸ¨k, hkâŸ© := le_iff_exists_add.1 hi
  rw [hk, pow_addâ‚“]
  suffices x ^ f.nat_degree âˆˆ ğ“Ÿ by
    exact mul_mem_right (x ^ k) ğ“Ÿ this
  rw [is_root.def, eval_eq_sum_range, Finset.range_add_one, Finset.sum_insert Finset.not_mem_range_self,
    Finset.sum_range, hmo.coeff_nat_degree, one_mulâ‚“] at hroot
  rw [eq_neg_of_add_eq_zero_left hroot, neg_mem_iff]
  refine' Submodule.sum_mem _ fun i hi => mul_mem_right _ _ (hf.mem (Finâ‚“.is_lt i))

theorem pow_nat_degree_le_of_aeval_zero_of_monic_mem_map {x : S} (hx : aeval x f = 0) (hmo : f.Monic) :
    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ.map (algebraMap R S) := by
  suffices x ^ (f.map (algebraMap R S)).natDegree âˆˆ ğ“Ÿ.map (algebraMap R S) by
    intro i hi
    obtain âŸ¨k, hkâŸ© := le_iff_exists_add.1 hi
    rw [hk, pow_addâ‚“]
    refine' mul_mem_right _ _ this
  rw [aeval_def, evalâ‚‚_eq_eval_map, â† is_root.def] at hx
  refine' pow_nat_degree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le

end CommRingâ‚“

end IsWeaklyEisensteinAt

section ScaleRoots

variable {A : Type _} [CommRingâ‚“ R] [CommRingâ‚“ A]

theorem scaleRoots.is_weakly_eisenstein_at (p : R[X]) {x : R} {P : Ideal R} (hP : x âˆˆ P) :
    (scaleRoots p x).IsWeaklyEisensteinAt P := by
  refine' âŸ¨fun i hi => _âŸ©
  rw [coeff_scale_roots]
  rw [nat_degree_scale_roots, â† tsub_pos_iff_lt] at hi
  exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ hi)

theorem dvd_pow_nat_degree_of_evalâ‚‚_eq_zero {f : R â†’+* A} (hf : Function.Injective f) {p : R[X]} (hp : p.Monic)
    (x y : R) (z : A) (h : p.evalâ‚‚ f z = 0) (hz : f x * z = f y) : x âˆ£ y ^ p.natDegree := by
  rw [â† nat_degree_scale_roots p x, â† Ideal.mem_span_singleton]
  refine'
    (scale_roots.is_weakly_eisenstein_at _
          (ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_nat_degree_le_of_root_of_monic_mem
      _ ((monic_scale_roots_iff x).mpr hp) _ le_rfl
  rw [injective_iff_map_eq_zero'] at hf
  have := scale_roots_evalâ‚‚_eq_zero f h
  rwa [hz, Polynomial.evalâ‚‚_at_apply, hf] at this

theorem dvd_pow_nat_degree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSmulDivisors R A] {p : R[X]}
    (hp : p.Monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0) (hz : z * algebraMap R A x = algebraMap R A y) :
    x âˆ£ y ^ p.natDegree :=
  dvd_pow_nat_degree_of_evalâ‚‚_eq_zero (NoZeroSmulDivisors.algebra_map_injective R A) hp x y z h
    ((mul_comm _ _).trans hz)

end ScaleRoots

namespace IsEisensteinAt

section CommSemiringâ‚“

variable [CommSemiringâ‚“ R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ğ“Ÿ)

theorem _root_.polynomial.monic.leading_coeff_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤) : Â¬f.leadingCoeff âˆˆ ğ“Ÿ :=
  hf.leadingCoeff.symm â–¸ (Ideal.ne_top_iff_one _).1 h

theorem _root_.polynomial.monic.is_eisenstein_at_of_mem_of_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤)
    (hmem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ) (hnot_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2) : f.IsEisensteinAt ğ“Ÿ :=
  { leading := hf.leading_coeff_not_mem h, Mem := fun n hn => hmem hn, not_mem := hnot_mem }

include hf

theorem is_weakly_eisenstein_at : IsWeaklyEisensteinAt f ğ“Ÿ :=
  âŸ¨hf.MemâŸ©

theorem coeff_mem {n : â„•} (hn : n â‰  f.natDegree) : f.coeff n âˆˆ ğ“Ÿ := by
  cases ne_iff_lt_or_gtâ‚“.1 hn
  Â· exact hf.mem h
    
  Â· rw [coeff_eq_zero_of_nat_degree_lt h]
    exact Ideal.zero_mem _
    

end CommSemiringâ‚“

section IsDomain

variable [CommRingâ‚“ R] [IsDomain R] {ğ“Ÿ : Ideal R} {f : R[X]} (hf : f.IsEisensteinAt ğ“Ÿ)

/-- If a primitive `f` satisfies `f.is_eisenstein_at ğ“Ÿ`, where `ğ“Ÿ.is_prime`, then `f` is
irreducible. -/
theorem irreducible (hprime : ğ“Ÿ.IsPrime) (hu : f.IsPrimitive) (hfd0 : 0 < f.natDegree) : Irreducible f :=
  irreducible_of_eisenstein_criterion hprime hf.leading (fun n hn => hf.Mem (coe_lt_degree.1 hn))
    (nat_degree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu

end IsDomain

end IsEisensteinAt

end Polynomial

section Cyclotomic

variable (p : â„•)

-- mathport name: Â«exprğ“ŸÂ»
local notation "ğ“Ÿ" => Submodule.span â„¤ {p}

open Polynomial

theorem cyclotomic_comp_X_add_one_is_eisenstein_at [hp : Fact p.Prime] :
    ((cyclotomic p â„¤).comp (X + 1)).IsEisensteinAt ğ“Ÿ := by
  refine'
    monic.is_eisenstein_at_of_mem_of_not_mem _
      (Ideal.IsPrime.ne_top <|
        (Ideal.span_singleton_prime
              (by
                exact_mod_cast hp.out.ne_zero)).2 <|
          Nat.prime_iff_prime_int.1 hp.out)
      (fun i hi => _) _
  Â· rw
      [show (X + 1 : â„¤[X]) = X + C 1 by
        simp ]
    refine' (cyclotomic.monic p â„¤).comp (monic_X_add_C 1) fun h => _
    rw [nat_degree_X_add_C] at h
    exact zero_ne_one h.symm
    
  Â· rw [cyclotomic_eq_geom_sum hp.out, geom_sum_X_comp_X_add_one_eq_sum, â† lcoeff_apply, LinearMap.map_sum]
    conv => congr congr skip ext rw [lcoeff_apply, â† C_eq_nat_cast, â† monomial_eq_C_mul_X, coeff_monomial]
    rw [nat_degree_comp,
      show (X + 1 : â„¤[X]) = X + C 1 by
        simp ,
      nat_degree_X_add_C, mul_oneâ‚“, nat_degree_cyclotomic, Nat.totient_prime hp.out] at hi
    simp only [â† lt_of_lt_of_leâ‚“ hi (Nat.sub_leâ‚“ _ _), â† sum_ite_eq', â† mem_range, â† if_true, â† Ideal.submodule_span_eq,
      â† Ideal.mem_span_singleton]
    exact Int.coe_nat_dvd.2 (Nat.Prime.dvd_choose_self (Nat.succ_posâ‚“ i) (lt_tsub_iff_right.1 hi) hp.out)
    
  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_eq_geom_sum hp.out, eval_add, eval_X, eval_one, zero_addâ‚“,
      eval_geom_sum, one_geom_sum, Ideal.submodule_span_eq, Ideal.span_singleton_pow, Ideal.mem_span_singleton]
    intro h
    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h
    rw [â† mul_assoc, mul_oneâ‚“, mul_assoc] at hk
    nth_rw 0[â† Nat.mul_one p]  at hk
    rw [Nat.mul_right_inj hp.out.pos] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)
    

theorem cyclotomic_prime_pow_comp_X_add_one_is_eisenstein_at [hp : Fact p.Prime] (n : â„•) :
    ((cyclotomic (p ^ (n + 1)) â„¤).comp (X + 1)).IsEisensteinAt ğ“Ÿ := by
  refine'
    monic.is_eisenstein_at_of_mem_of_not_mem _
      (Ideal.IsPrime.ne_top <|
        (Ideal.span_singleton_prime
              (by
                exact_mod_cast hp.out.ne_zero)).2 <|
          Nat.prime_iff_prime_int.1 hp.out)
      _ _
  Â· rw
      [show (X + 1 : â„¤[X]) = X + C 1 by
        simp ]
    refine' (cyclotomic.monic _ â„¤).comp (monic_X_add_C 1) fun h => _
    rw [nat_degree_X_add_C] at h
    exact zero_ne_one h.symm
    
  Â· induction' n with n hn
    Â· intro i hi
      rw [zero_addâ‚“, pow_oneâ‚“] at hiâŠ¢
      exact (cyclotomic_comp_X_add_one_is_eisenstein_at p).Mem hi
      
    Â· intro i hi
      rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, â† Zmod.int_coe_zmod_eq_zero_iff_dvd, â†
        Int.coe_cast_ring_hom, â† coeff_map, map_comp, map_cyclotomic, Polynomial.map_add, map_X, Polynomial.map_one,
        pow_addâ‚“, pow_oneâ‚“, cyclotomic_mul_prime_dvd_eq_pow, pow_comp, â† Zmod.expand_card, coeff_expand hp.out.pos]
      Â· simp only [â† ite_eq_right_iff]
        rintro âŸ¨k, hkâŸ©
        rw [nat_degree_comp,
          show (X + 1 : â„¤[X]) = X + C 1 by
            simp ,
          nat_degree_X_add_C, mul_oneâ‚“, nat_degree_cyclotomic, Nat.totient_prime_pow hp.out (Nat.succ_posâ‚“ _),
          Nat.succ_sub_one] at hn hi
        rw [hk, pow_succâ‚“, mul_assoc] at hi
        rw [hk, mul_comm, Nat.mul_div_cancelâ‚“ _ hp.out.pos]
        replace hn := hn (lt_of_mul_lt_mul_left' hi)
        rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, â† Zmod.int_coe_zmod_eq_zero_iff_dvd, â†
          Int.coe_cast_ring_hom, â† coeff_map] at hn
        simpa [â† map_comp] using hn
        
      Â· exact
          âŸ¨p ^ n, by
            rw [pow_succâ‚“]âŸ©
        
      
    
  Â· rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add, eval_X, eval_one,
      zero_addâ‚“, eval_finset_sum]
    simp only [â† eval_pow, â† eval_X, â† one_pow, â† sum_const, â† card_range, â† Nat.smul_one_eq_coe, â† submodule_span_eq, â†
      Ideal.submodule_span_eq, â† Ideal.span_singleton_pow, â† Ideal.mem_span_singleton]
    intro h
    obtain âŸ¨k, hkâŸ© := Int.coe_nat_dvd.1 h
    rw [â† mul_assoc, mul_oneâ‚“, mul_assoc] at hk
    nth_rw 0[â† Nat.mul_one p]  at hk
    rw [Nat.mul_right_inj hp.out.pos] at hk
    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)
    

end Cyclotomic

section IsIntegral

variable {K : Type v} {L : Type z} {p : R} [CommRingâ‚“ R] [Field K] [Field L]

variable [Algebra K L] [Algebra R L] [Algebra R K] [IsScalarTower R K L] [IsSeparable K L]

variable [IsDomain R] [NormalizedGcdMonoid R] [IsFractionRing R K] [IsIntegrallyClosed R]

-- mathport name: Â«exprğ“ŸÂ»
local notation "ğ“Ÿ" => Submodule.span R {p}

open IsIntegrallyClosed PowerBasis Nat Polynomial IsScalarTower

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : polynomial R` is such that
`aeval B.gen Q = p â€¢ z`, then `p âˆ£ Q.coeff 0`. -/
theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {z : L} {Q : Polynomial R} (hQ : aeval B.gen Q = p â€¢ z) (hzint : IsIntegral R z)
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : p âˆ£ Q.coeff 0 := by
  -- First define some abbreviations.
  let this := B.finite_dimensional
  let P := minpoly R B.gen
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have finrank_K_L : FiniteDimensional.finrank K L = B.dim := B.finrank
  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.nat_degree_minpoly
  have deg_R_P : P.nat_degree = B.dim := by
    rw [â† deg_K_P, minpoly.gcd_domain_eq_field_fractions' K hBint,
      (minpoly.monic hBint).nat_degree_map (algebraMap R K)]
  choose! f hf using
    hei.is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)
  simp only [â† (minpoly.monic hBint).nat_degree_map, â† deg_R_P] at hf
  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`
  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:
  suffices p ^ n.succ âˆ£ Q.coeff 0 ^ n.succ * (-1 ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by
    have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
      hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
    refine' Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd hp (_ : _ ^ n.succ âˆ£ _) hndiv
    convert (IsUnit.dvd_mul_right âŸ¨-1 ^ (n.succ * n), rflâŸ©).mpr this using 1
    push_cast
    ring_nf
    simp [â† pow_right_comm _ _ 2]
  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:
  have aux : âˆ€, âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0, âˆ€, B.dim â‰¤ i + n := by
    intro i hi
    simp only [â† mem_range, â† mem_erase] at hi
    rw [hn]
    exact le_add_pred_of_pos _ hi.1
  have hintsum : IsIntegral R (z * B.gen ^ n - âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ f (x + n)) :=
    by
    refine'
      is_integral_sub (is_integral_mul hzint (IsIntegral.pow hBint _))
        (IsIntegral.sum _ fun i hi => is_integral_smul _ _)
    exact adjoin_le_integral_closure hBint (hf _ (aux i hi)).1
  obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)
  use r
  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.
  apply IsFractionRing.injective R K
  simp only [â† _root_.map_mul, â† _root_.map_pow, â† _root_.map_neg, â† _root_.map_one]
  -- Both sides are actually norms:
  calc _ = norm K (Q.coeff 0 â€¢ B.gen ^ n) :=
      _ _ = norm K (p â€¢ (z * B.gen ^ n) - âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, p â€¢ Q.coeff x â€¢ f (x + n)) :=
      congr_arg (norm K) (eq_sub_of_add_eq _)_ = _ := _
  Â· simp only [â† Algebra.smul_def, â† algebra_map_apply R K L, â† Algebra.norm_algebra_map, â† _root_.map_mul, â†
      _root_.map_pow, â† finrank_K_L, â† power_basis.norm_gen_eq_coeff_zero_minpoly, â†
      minpoly.gcd_domain_eq_field_fractions' K hBint, â† coeff_map, hn]
    ring_exp
    
  swap
  Â· simp_rw [â† smul_sum, â† smul_sub, Algebra.smul_def p, algebra_map_apply R K L, _root_.map_mul,
      Algebra.norm_algebra_map, finrank_K_L, hr, â† hn]
    
  calc _ = (Q.coeff 0 â€¢ 1 + âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n :=
      _ _ =
        (Q.coeff 0 â€¢ B.gen ^ 0 + âˆ‘ x : â„• in (range (Q.nat_degree + 1)).erase 0, Q.coeff x â€¢ B.gen ^ x) * B.gen ^ n :=
      by
      rw [pow_zeroâ‚“]_ = aeval B.gen Q * B.gen ^ n := _ _ = _ := by
      rw [hQ, Algebra.smul_mul_assoc]
  Â· have :
      âˆ€, âˆ€ i âˆˆ (range (Q.nat_degree + 1)).erase 0, âˆ€, Q.coeff i â€¢ (B.gen ^ i * B.gen ^ n) = p â€¢ Q.coeff i â€¢ f (i + n) :=
      by
      intro i hi
      rw [â† pow_addâ‚“, â† (hf _ (aux i hi)).2, â† Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]
    simp only [â† add_mulâ‚“, â† smul_mul_assoc, â† one_mulâ‚“, â† sum_mul, â† sum_congr rfl this]
    
  Â· rw [aeval_eq_sum_range, Finset.add_sum_erase (range (Q.nat_degree + 1)) fun i => Q.coeff i â€¢ B.gen ^ i]
    simp
    

theorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type _} [CommSemiringâ‚“ A] [CommRingâ‚“ B] [Algebra A B]
    [NoZeroSmulDivisors A B] {Q : Polynomial A} {p : A} {x z : B} (hp : p â‰  0)
    (hQ : âˆ€, âˆ€ i âˆˆ range (Q.natDegree + 1), âˆ€, p âˆ£ Q.coeff i) (hz : aeval x Q = p â€¢ z) : z âˆˆ adjoin A ({x} : Set B) :=
  by
  choose! f hf using hQ
  rw [aeval_eq_sum_range, sum_range] at hz
  conv_lhs at hz => congr skip ext rw [hf i (mem_range.2 (Finâ‚“.is_lt i)), â† smul_smul]
  rw [â† smul_sum] at hz
  rw [â† smul_right_injective _ hp hz]
  exact
    Subalgebra.sum_mem _ fun _ _ =>
      Subalgebra.smul_mem _ (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p â€¢ z âˆˆ adjoin R {B.gen}`, then
`z âˆˆ adjoin R {B.gen}`. -/
theorem mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z) (hz : p â€¢ z âˆˆ adjoin R ({B.gen} : Set L))
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : z âˆˆ adjoin R ({B.gen} : Set L) := by
  -- First define some abbreviations.
  have hndiv : Â¬p ^ 2 âˆ£ (minpoly R B.gen).coeff 0 := fun h =>
    hei.not_mem ((span_singleton_pow p 2).symm â–¸ Ideal.mem_span_singleton.2 h)
  let this := FiniteDimensional B
  set P := minpoly R B.gen with hP
  obtain âŸ¨n, hnâŸ© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'
  have : NoZeroSmulDivisors R L := NoZeroSmulDivisors.trans R K L
  let Pâ‚ := P.map (algebraMap R L)
  -- There is a polynomial `Q` such that `p â€¢ z = aeval B.gen Q`. We can assume that
  -- `Q.degree < P.degree` and `Q â‰  0`.
  rw [adjoin_singleton_eq_range_aeval] at hz
  obtain âŸ¨Qâ‚, hQâŸ© := hz
  set Q := Qâ‚ %â‚˜ P with hQâ‚
  replace hQ : aeval B.gen Q = p â€¢ z
  Â· rw [â† mod_by_monic_add_div Qâ‚ (minpoly.monic hBint)] at hQ
    simpa using hQ
    
  by_cases' hQzero : Q = 0
  Â· simp only [â† hQzero, â† Algebra.smul_def, â† zero_eq_mul, â† aeval_zero] at hQ
    cases' hQ with H Hâ‚
    Â· have : Function.Injective (algebraMap R L) := by
        rw [algebra_map_eq R K L]
        exact (algebraMap K L).Injective.comp (IsFractionRing.injective R K)
      exfalso
      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)
      
    Â· rw [Hâ‚]
      exact Subalgebra.zero_mem _
      
    
  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.
  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at`.
  refine' mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => _) hQ
  refine' Nat.case_strong_induction_onâ‚“ i _ fun j hind => _
  Â· intro H
    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_is_eiseinstein_at hp hBint hQ hzint hei
    
  Â· intro hj
    refine' hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd _ hndiv
    exact n
    -- Two technical results we will need about `P.nat_degree` and `Q.nat_degree`.
    have H := degree_mod_by_monic_lt Qâ‚ (minpoly.monic hBint)
    rw [â† hQâ‚, â† hP] at H
    replace H :=
      Nat.lt_iff_add_one_le.1
        (lt_of_lt_of_leâ‚“
          (lt_of_le_of_ltâ‚“ (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succâ‚“ (mem_range.1 hj))) (lt_succ_self _))
          (Nat.lt_iff_add_one_le.1 ((nat_degree_lt_nat_degree_iff hQzero).2 H)))
    rw [add_assocâ‚“] at H
    have Hj : Q.nat_degree + 1 = j + 1 + (Q.nat_degree - j) := by
      rw [â† add_commâ‚“ 1, â† add_commâ‚“ 1, add_assocâ‚“, add_right_injâ‚“, â†
        Nat.add_sub_assocâ‚“ (Nat.lt_of_succ_lt_succâ‚“ (mem_range.1 hj)).le, add_commâ‚“, Nat.add_sub_cancel]
    -- By induction hypothesis we can find `g : â„• â†’ R` such that
    -- `k âˆˆ range (j + 1) â†’ Q.coeff k â€¢ B.gen ^ k = (algebra_map R L) p * g k â€¢ B.gen ^ k`-
    choose! g hg using hind
    replace hg : âˆ€, âˆ€ k âˆˆ range (j + 1), âˆ€, Q.coeff k â€¢ B.gen ^ k = algebraMap R L p * g k â€¢ B.gen ^ k
    Â· intro k hk
      rw
        [hg k (mem_range_succ_iff.1 hk)
          (mem_range_succ_iff.2 (le_transâ‚“ (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),
        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]
      
    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : â„• â†’ L` such that
    -- `(map (algebra_map R L) (minpoly R B.gen)).nat_degree â‰¤ i` implies `f i âˆˆ adjoin R {B.gen}`
    -- and `(algebra_map R L) p * f i = B.gen ^ i`. We will also need `hfâ‚`, a reformulation of this
    -- property.
    choose! f hf using
      is_weakly_eisenstein_at.exists_mem_adjoin_mul_eq_pow_nat_degree_le (minpoly.aeval R B.gen) (minpoly.monic hBint)
        hei.is_weakly_eisenstein_at
    have hfâ‚ :
      âˆ€,
        âˆ€ k âˆˆ (range (Q.nat_degree - j)).erase 0,
          âˆ€,
            Q.coeff (j + 1 + k) â€¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.nat_degree - (j + 2)) =
              (algebraMap R L) p * Q.coeff (j + 1 + k) â€¢ f (k + P.nat_degree - 1) :=
      by
      intro k hk
      rw [smul_mul_assoc, â† pow_addâ‚“, â† Nat.add_sub_assocâ‚“ H, â† add_assocâ‚“ j 1 1, add_commâ‚“ (j + 1) 1,
        add_assocâ‚“ (j + 1), add_commâ‚“ _ (k + P.nat_degree), Nat.add_sub_add_right, â† (hf (k + P.nat_degree - 1) _).2,
        mul_smul_comm]
      rw [(minpoly.monic hBint).nat_degree_map, add_commâ‚“, Nat.add_sub_assocâ‚“, le_add_iff_nonneg_right]
      Â· exact Nat.zero_leâ‚“ _
        
      Â· refine' one_le_iff_ne_zero.2 fun h => _
        rw [h] at hk
        simpa using hk
        
      Â· infer_instance
        
    -- The Eisenstein condition shows that `p` divides `Q.coeff j`
    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:
    suffices p ^ n.succ âˆ£ Q.coeff (succ j) ^ n.succ * (minpoly R B.gen).coeff 0 ^ (succ j + (P.nat_degree - (j + 2))) by
      convert this
      rw [Nat.succ_eq_add_one, add_assocâ‚“, â† Nat.add_sub_assocâ‚“ H, â† add_assocâ‚“, add_commâ‚“ (j + 1),
        Nat.add_sub_add_left, â† Nat.add_sub_assocâ‚“, Nat.add_sub_add_left, hP, â†
        (minpoly.monic hBint).nat_degree_map (algebraMap R K), â† minpoly.gcd_domain_eq_field_fractions' K hBint,
        nat_degree_minpoly, hn, Nat.sub_one, Nat.pred_succ]
      linarith
    -- Using `hQ : aeval B.gen Q = p â€¢ z`, we write `p â€¢ z` as a sum of terms of degree less than
    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.
    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_add_left_embedding _ _), sum_congr rfl hg,
      add_commâ‚“] at hQ
    -- We multiply this equality by `B.gen ^ (P.nat_degree-(j+2))`, so we can use `hfâ‚` on the terms
    -- we didn't know were multiples of `p`, and we take the norm on both sides.
    replace hQ := congr_arg (fun x => x * B.gen ^ (P.nat_degree - (j + 2))) hQ
    simp_rw [sum_map, add_left_embedding_apply, add_mulâ‚“, sum_mul, mul_assoc] at hQ
    rw [â† insert_erase (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succâ‚“ <| mem_range.1 hj)),
      sum_insert (not_mem_erase 0 _), add_zeroâ‚“, sum_congr rfl hfâ‚, â† mul_sum, â† mul_sum, add_assocâ‚“, â† mul_addâ‚“,
      smul_mul_assoc, â† pow_addâ‚“, Algebra.smul_def] at hQ
    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)
    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`
    -- and simplify `hQ`.
    have hintsum :
      IsIntegral R
        (z * B.gen ^ (P.nat_degree - (j + 2)) -
          ((âˆ‘ x : â„• in (range (Q.nat_degree - j)).erase 0, Q.coeff (j + 1 + x) â€¢ f (x + P.nat_degree - 1)) +
            âˆ‘ x : â„• in range (j + 1), g x â€¢ B.gen ^ x * B.gen ^ (P.nat_degree - (j + 2)))) :=
      by
      refine'
        is_integral_sub (is_integral_mul hzint (IsIntegral.pow hBint _))
          (is_integral_add (IsIntegral.sum _ fun k hk => is_integral_smul _ _)
            (IsIntegral.sum _ fun k hk =>
              is_integral_mul (is_integral_smul _ (IsIntegral.pow hBint _)) (IsIntegral.pow hBint _)))
      refine' adjoin_le_integral_closure hBint (hf _ _).1
      rw [(minpoly.monic hBint).nat_degree_map (algebraMap R L)]
      rw [add_commâ‚“, Nat.add_sub_assocâ‚“, le_add_iff_nonneg_right]
      Â· exact zero_le _
        
      Â· refine' one_le_iff_ne_zero.2 fun h => _
        rw [h] at hk
        simpa using hk
        
    obtain âŸ¨r, hrâŸ© := is_integral_iff.1 (is_integral_norm K hintsum)
    rw [Algebra.smul_def, mul_assoc, â† mul_sub, _root_.map_mul, algebra_map_apply R K L, map_pow,
      Algebra.norm_algebra_map, _root_.map_mul, algebra_map_apply R K L, Algebra.norm_algebra_map, finrank B, â† hr,
      power_basis.norm_gen_eq_coeff_zero_minpoly, minpoly.gcd_domain_eq_field_fractions' K hBint, coeff_map,
      show (-1 : K) = algebraMap R K (-1) by
        simp ,
      â† map_pow, â† map_pow, â† _root_.map_mul, â† map_pow, â† _root_.map_mul, â† map_pow, â† _root_.map_mul] at hQ
    -- We can now finish the proof.
    have hppdiv : p ^ B.dim âˆ£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _
    rwa [â† IsFractionRing.injective R K hQ, mul_comm, â† Units.coe_neg_one, mul_powâ‚“, â† Units.coe_pow, â† Units.coe_pow,
      mul_assoc, IsUnit.dvd_mul_left _ _ _ âŸ¨_, rflâŸ©, mul_comm, â† Nat.succ_eq_add_one, hn] at hppdiv
    

/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable
extension of `K`, generated by an integral power basis `B` such that the minimal polynomial of
`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n â€¢ z âˆˆ adjoin R {B.gen}`,
then `z âˆˆ adjoin R {B.gen}`. Together with `algebra.discr_mul_is_integral_mem_adjoin` this result
often allows to compute the ring of integers of `L`. -/
theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_is_eiseinstein_at {B : PowerBasis K L} (hp : Prime p)
    (hBint : IsIntegral R B.gen) {n : â„•} {z : L} (hzint : IsIntegral R z) (hz : p ^ n â€¢ z âˆˆ adjoin R ({B.gen} : Set L))
    (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) : z âˆˆ adjoin R ({B.gen} : Set L) := by
  induction' n with n hn
  Â· simpa using hz
    
  Â· rw [pow_succâ‚“, mul_smul] at hz
    exact hn (mem_adjoin_of_smul_prime_smul_of_minpoly_is_eiseinstein_at hp hBint (is_integral_smul _ hzint) hz hei)
    

end IsIntegral

