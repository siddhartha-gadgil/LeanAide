/-
Copyright (c) 2021 Martin Zinkevich. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Martin Zinkevich, Rémy Degenne
-/
import Mathbin.Logic.Encodable.Lattice
import Mathbin.MeasureTheory.MeasurableSpaceDef

/-!
# Induction principles for measurable sets, related to π-systems and λ-systems.

## Main statements

* The main theorem of this file is Dynkin's π-λ theorem, which appears
  here as an induction principle `induction_on_inter`. Suppose `s` is a
  collection of subsets of `α` such that the intersection of two members
  of `s` belongs to `s` whenever it is nonempty. Let `m` be the σ-algebra
  generated by `s`. In order to check that a predicate `C` holds on every
  member of `m`, it suffices to check that `C` holds on the members of `s` and
  that `C` is preserved by complementation and *disjoint* countable
  unions.

* The proof of this theorem relies on the notion of `is_pi_system`, i.e., a collection of sets
  which is closed under binary non-empty intersections. Note that this is a small variation around
  the usual notion in the literature, which often requires that a π-system is non-empty, and closed
  also under disjoint intersections. This variation turns out to be convenient for the
  formalization.

* The proof of Dynkin's π-λ theorem also requires the notion of `dynkin_system`, i.e., a collection
  of sets which contains the empty set, is closed under complementation and under countable union
  of pairwise disjoint sets. The disjointness condition is the only difference with `σ`-algebras.

* `generate_pi_system g` gives the minimal π-system containing `g`.
  This can be considered a Galois insertion into both measurable spaces and sets.

* `generate_from_generate_pi_system_eq` proves that if you start from a collection of sets `g`,
  take the generated π-system, and then the generated σ-algebra, you get the same result as
  the σ-algebra generated from `g`. This is useful because there are connections between
  independent sets that are π-systems and the generated independent spaces.

* `mem_generate_pi_system_Union_elim` and `mem_generate_pi_system_Union_elim'` show that any
  element of the π-system generated from the union of a set of π-systems can be
  represented as the intersection of a finite number of elements from these sets.

* `pi_Union_Inter` defines a new π-system from a family of π-systems `π : ι → set (set α)` and a
  set of finsets `S : set (finset α)`. `pi_Union_Inter π S` is the set of sets that can be written
  as `⋂ x ∈ t, f x` for some `t ∈ S` and sets `f x ∈ π x`. If `S` is union-closed, then it is a
  π-system. The π-systems used to prove Kolmogorov's 0-1 law will be defined using this mechanism
  (TODO).

## Implementation details

* `is_pi_system` is a predicate, not a type. Thus, we don't explicitly define the galois
  insertion, nor do we define a complete lattice. In theory, we could define a complete
  lattice and galois insertion on the subtype corresponding to `is_pi_system`.
-/


open MeasurableSpace Set

open Classical MeasureTheory

-- ./././Mathport/Syntax/Translate/Basic.lean:710:2: warning: expanding binder collection (s t «expr ∈ » C)
/-- A π-system is a collection of subsets of `α` that is closed under binary intersection of
  non-disjoint sets. Usually it is also required that the collection is nonempty, but we don't do
  that here. -/
def IsPiSystem {α} (C : Set (Set α)) : Prop :=
  ∀ (s t) (_ : s ∈ C) (_ : t ∈ C), (s ∩ t : Set α).Nonempty → s ∩ t ∈ C

namespace MeasurableSpace

theorem is_pi_system_measurable_set {α : Type _} [MeasurableSpace α] : IsPiSystem { s : Set α | MeasurableSet s } :=
  fun s hs t ht _ => hs.inter ht

end MeasurableSpace

theorem IsPiSystem.singleton {α} (S : Set α) : IsPiSystem ({S} : Set (Set α)) := by
  intro s h_s t h_t h_ne
  rw [Set.mem_singleton_iff.1 h_s, Set.mem_singleton_iff.1 h_t, Set.inter_self, Set.mem_singleton_iff]

theorem IsPiSystem.insert_empty {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : IsPiSystem (insert ∅ S) := by
  intro s hs t ht hst
  cases hs
  · simp [← hs]
    
  · cases ht
    · simp [← ht]
      
    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
      
    

theorem IsPiSystem.insert_univ {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : IsPiSystem (insert Set.Univ S) := by
  intro s hs t ht hst
  cases hs
  · cases ht <;> simp [← hs, ← ht]
    
  · cases ht
    · simp [← hs, ← ht]
      
    · exact Set.mem_insert_of_mem _ (h_pi s hs t ht hst)
      
    

theorem IsPiSystem.comap {α β} {S : Set (Set β)} (h_pi : IsPiSystem S) (f : α → β) :
    IsPiSystem { s : Set α | ∃ t ∈ S, f ⁻¹' t = s } := by
  rintro _ ⟨s, hs_mem, rfl⟩ _ ⟨t, ht_mem, rfl⟩ hst
  rw [← Set.preimage_inter] at hst⊢
  refine' ⟨s ∩ t, h_pi s hs_mem t ht_mem _, rfl⟩
  by_contra
  rw [Set.not_nonempty_iff_eq_empty] at h
  rw [h] at hst
  simpa using hst

section Order

variable {α : Type _} {ι ι' : Sort _} [LinearOrderₓ α]

theorem is_pi_system_image_Iio (s : Set α) : IsPiSystem (Iio '' s) := by
  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ -
  exact ⟨a⊓b, inf_ind a b ha hb, Iio_inter_Iio.symm⟩

theorem is_pi_system_Iio : IsPiSystem (Range Iio : Set (Set α)) :=
  @image_univ α _ Iio ▸ is_pi_system_image_Iio Univ

theorem is_pi_system_image_Ioi (s : Set α) : IsPiSystem (Ioi '' s) :=
  @is_pi_system_image_Iio αᵒᵈ _ s

theorem is_pi_system_Ioi : IsPiSystem (Range Ioi : Set (Set α)) :=
  @image_univ α _ Ioi ▸ is_pi_system_image_Ioi Univ

theorem is_pi_system_Ixx_mem {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)
    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (s t : Set α) :
    IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ hlu : p l u, Ixx l u = S } := by
  rintro _ ⟨l₁, hls₁, u₁, hut₁, hlu₁, rfl⟩ _ ⟨l₂, hls₂, u₂, hut₂, hlu₂, rfl⟩
  simp only [← Hi, sup_eq_max, inf_eq_min]
  exact fun H => ⟨l₁⊔l₂, sup_ind l₁ l₂ hls₁ hls₂, u₁⊓u₂, inf_ind u₁ u₂ hut₁ hut₂, Hne H, rfl⟩

theorem is_pi_system_Ixx {Ixx : α → α → Set α} {p : α → α → Prop} (Hne : ∀ {a b}, (Ixx a b).Nonempty → p a b)
    (Hi : ∀ {a₁ b₁ a₂ b₂}, Ixx a₁ b₁ ∩ Ixx a₂ b₂ = Ixx (max a₁ a₂) (min b₁ b₂)) (f : ι → α) (g : ι' → α) :
    @IsPiSystem α { S | ∃ (i j : _)(h : p (f i) (g j)), Ixx (f i) (g j) = S } := by
  simpa only [← exists_range_iff] using is_pi_system_Ixx_mem (@Hne) (@Hi) (range f) (range g)

theorem is_pi_system_Ioo_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ioo l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) s t

theorem is_pi_system_Ioo (f : ι → α) (g : ι' → α) :
    @IsPiSystem α { S | ∃ (l u : _)(h : f l < g u), Ioo (f l) (g u) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans hxb) (fun _ _ _ _ => Ioo_inter_Ioo) f g

theorem is_pi_system_Ioc_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ioc l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) s t

theorem is_pi_system_Ioc (f : ι → α) (g : ι' → α) :
    @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ioc (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_le hxb) (fun _ _ _ _ => Ioc_inter_Ioc) f g

theorem is_pi_system_Ico_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l < u, Ico l u = S } :=
  is_pi_system_Ixx_mem (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) s t

theorem is_pi_system_Ico (f : ι → α) (g : ι' → α) :
    @IsPiSystem α { S | ∃ (i j : _)(h : f i < g j), Ico (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b ⟨x, hax, hxb⟩ => hax.trans_lt hxb) (fun _ _ _ _ => Ico_inter_Ico) f g

theorem is_pi_system_Icc_mem (s t : Set α) : IsPiSystem { S | ∃ l ∈ s, ∃ u ∈ t, ∃ h : l ≤ u, Icc l u = S } :=
  is_pi_system_Ixx_mem (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) s t

theorem is_pi_system_Icc (f : ι → α) (g : ι' → α) :
    @IsPiSystem α { S | ∃ (i j : _)(h : f i ≤ g j), Icc (f i) (g j) = S } :=
  is_pi_system_Ixx (fun a b => nonempty_Icc.1) (fun _ _ _ _ => Icc_inter_Icc) f g

end Order

/-- Given a collection `S` of subsets of `α`, then `generate_pi_system S` is the smallest
π-system containing `S`. -/
inductive GeneratePiSystem {α} (S : Set (Set α)) : Set (Set α)
  | base {s : Set α} (h_s : s ∈ S) : GeneratePiSystem s
  | inter {s t : Set α} (h_s : GeneratePiSystem s) (h_t : GeneratePiSystem t) (h_nonempty : (s ∩ t).Nonempty) :
    GeneratePiSystem (s ∩ t)

theorem is_pi_system_generate_pi_system {α} (S : Set (Set α)) : IsPiSystem (GeneratePiSystem S) :=
  fun s h_s t h_t h_nonempty => GeneratePiSystem.inter h_s h_t h_nonempty

theorem subset_generate_pi_system_self {α} (S : Set (Set α)) : S ⊆ GeneratePiSystem S := fun s => GeneratePiSystem.base

theorem generate_pi_system_subset_self {α} {S : Set (Set α)} (h_S : IsPiSystem S) : GeneratePiSystem S ⊆ S := by
  intro x h
  induction' h with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
  · exact h_s
    
  · exact h_S _ h_s _ h_u h_nonempty
    

theorem generate_pi_system_eq {α} {S : Set (Set α)} (h_pi : IsPiSystem S) : GeneratePiSystem S = S :=
  Set.Subset.antisymm (generate_pi_system_subset_self h_pi) (subset_generate_pi_system_self S)

theorem generate_pi_system_mono {α} {S T : Set (Set α)} (hST : S ⊆ T) : GeneratePiSystem S ⊆ GeneratePiSystem T := by
  intro t ht
  induction' ht with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
  · exact GeneratePiSystem.base (Set.mem_of_subset_of_mem hST h_s)
    
  · exact is_pi_system_generate_pi_system T _ h_s _ h_u h_nonempty
    

theorem generate_pi_system_measurable_set {α} [M : MeasurableSpace α] {S : Set (Set α)}
    (h_meas_S : ∀, ∀ s ∈ S, ∀, MeasurableSet s) (t : Set α) (h_in_pi : t ∈ GeneratePiSystem S) : MeasurableSet t := by
  induction' h_in_pi with s h_s s u h_gen_s h_gen_u h_nonempty h_s h_u
  · apply h_meas_S _ h_s
    
  · apply MeasurableSet.inter h_s h_u
    

theorem generate_from_measurable_set_of_generate_pi_system {α} {g : Set (Set α)} (t : Set α)
    (ht : t ∈ GeneratePiSystem g) : measurable_set[generateFrom g] t :=
  @generate_pi_system_measurable_set α (generateFrom g) g (fun s h_s_in_g => measurable_set_generate_from h_s_in_g) t ht

theorem generate_from_generate_pi_system_eq {α} {g : Set (Set α)} :
    generateFrom (GeneratePiSystem g) = generateFrom g := by
  apply le_antisymmₓ <;> apply generate_from_le
  · exact fun t h_t => generate_from_measurable_set_of_generate_pi_system t h_t
    
  · exact fun t h_t => measurable_set_generate_from (GeneratePiSystem.base h_t)
    

/- Every element of the π-system generated by the union of a family of π-systems
is a finite intersection of elements from the π-systems.
For an indexed union version, see `mem_generate_pi_system_Union_elim'`. -/
theorem mem_generate_pi_system_Union_elim {α β} {g : β → Set (Set α)} (h_pi : ∀ b, IsPiSystem (g b)) (t : Set α)
    (h_t : t ∈ GeneratePiSystem (⋃ b, g b)) :
    ∃ (T : Finset β)(f : β → Set α), (t = ⋂ b ∈ T, f b) ∧ ∀, ∀ b ∈ T, ∀, f b ∈ g b := by
  induction' h_t with s h_s s t' h_gen_s h_gen_t' h_nonempty h_s h_t'
  · rcases h_s with ⟨t', ⟨⟨b, rfl⟩, h_s_in_t'⟩⟩
    refine' ⟨{b}, fun _ => s, _⟩
    simpa using h_s_in_t'
    
  · rcases h_t' with ⟨T_t', ⟨f_t', ⟨rfl, h_t'⟩⟩⟩
    rcases h_s with ⟨T_s, ⟨f_s, ⟨rfl, h_s⟩⟩⟩
    use T_s ∪ T_t', fun b : β =>
      if b ∈ T_s then if b ∈ T_t' then f_s b ∩ f_t' b else f_s b else if b ∈ T_t' then f_t' b else (∅ : Set α)
    constructor
    · ext a
      simp_rw [Set.mem_inter_iff, Set.mem_Inter, Finset.mem_union, or_imp_distrib]
      rw [← forall_and_distrib]
      constructor <;>
        intro h1 b <;>
          by_cases' hbs : b ∈ T_s <;>
            by_cases' hbt : b ∈ T_t' <;>
              specialize h1 b <;>
                simp only [← hbs, ← hbt, ← if_true, ← if_false, ← true_implies_iff, ← and_selfₓ, ← false_implies_iff, ←
                  and_trueₓ, ← true_andₓ] at h1⊢
      all_goals
        exact h1
      
    intro b h_b
    split_ifs with hbs hbt hbt
    · refine' h_pi b (f_s b) (h_s b hbs) (f_t' b) (h_t' b hbt) (Set.Nonempty.mono _ h_nonempty)
      exact Set.inter_subset_inter (Set.bInter_subset_of_mem hbs) (Set.bInter_subset_of_mem hbt)
      
    · exact h_s b hbs
      
    · exact h_t' b hbt
      
    · rw [Finset.mem_union] at h_b
      apply False.elim (h_b.elim hbs hbt)
      
    

/- Every element of the π-system generated by an indexed union of a family of π-systems
is a finite intersection of elements from the π-systems.
For a total union version, see `mem_generate_pi_system_Union_elim`. -/
theorem mem_generate_pi_system_Union_elim' {α β} {g : β → Set (Set α)} {s : Set β}
    (h_pi : ∀, ∀ b ∈ s, ∀, IsPiSystem (g b)) (t : Set α) (h_t : t ∈ GeneratePiSystem (⋃ b ∈ s, g b)) :
    ∃ (T : Finset β)(f : β → Set α), ↑T ⊆ s ∧ (t = ⋂ b ∈ T, f b) ∧ ∀, ∀ b ∈ T, ∀, f b ∈ g b := by
  have : t ∈ GeneratePiSystem (⋃ b : Subtype s, (g ∘ Subtype.val) b) := by
    suffices h1 : (⋃ b : Subtype s, (g ∘ Subtype.val) b) = ⋃ b ∈ s, g b
    · rwa [h1]
      
    ext x
    simp only [← exists_prop, ← Set.mem_Union, ← Function.comp_app, ← Subtype.exists, ← Subtype.coe_mk]
    rfl
  rcases@mem_generate_pi_system_Union_elim α (Subtype s) (g ∘ Subtype.val) (fun b => h_pi b.val b.property) t this with
    ⟨T, ⟨f, ⟨rfl, h_t'⟩⟩⟩
  refine'
    ⟨T.image Subtype.val, Function.extendₓ Subtype.val f fun b : β => (∅ : Set α), by
      simp , _, _⟩
  · ext a
    constructor <;>
      · simp only [← Set.mem_Inter, ← Subtype.forall, ← Finset.set_bInter_finset_image]
        intro h1 b h_b h_b_in_T
        have h2 := h1 b h_b h_b_in_T
        revert h2
        rw [Function.extend_applyₓ Subtype.val_injective]
        apply id
        
    
  · intro b h_b
    simp_rw [Finset.mem_image, exists_prop, Subtype.exists, exists_and_distrib_right, exists_eq_right] at h_b
    cases h_b
    have h_b_alt : b = (Subtype.mk b h_b_w).val := rfl
    rw [h_b_alt, Function.extend_applyₓ Subtype.val_injective]
    apply h_t'
    apply h_b_h
    

section UnionInter

/-! ### π-system generated by finite intersections of sets of a π-system family -/


/-- From a set of finsets `S : set (finset ι)` and a family of sets of sets `π : ι → set (set α)`,
define the set of sets that can be written as `⋂ x ∈ t, f x` for some `t ∈ S` and sets `f x ∈ π x`.

If `S` is union-closed and `π` is a family of π-systems, then it is a π-system.
The π-systems used to prove Kolmogorov's 0-1 law are of that form. -/
def PiUnionInter {α ι} (π : ι → Set (Set α)) (S : Set (Finset ι)) : Set (Set α) :=
  { s : Set α | ∃ (t : Finset ι)(htS : t ∈ S)(f : ι → Set α)(hf : ∀ x, x ∈ t → f x ∈ π x), s = ⋂ x ∈ t, f x }

/-- If `S` is union-closed and `π` is a family of π-systems, then `pi_Union_Inter π S` is a
π-system. -/
theorem is_pi_system_pi_Union_Inter {α ι} (π : ι → Set (Set α)) (hpi : ∀ x, IsPiSystem (π x)) (S : Set (Finset ι))
    (h_sup : SupClosed S) : IsPiSystem (PiUnionInter π S) := by
  rintro t1 ⟨p1, hp1S, f1, hf1m, ht1_eq⟩ t2 ⟨p2, hp2S, f2, hf2m, ht2_eq⟩ h_nonempty
  simp_rw [PiUnionInter, Set.mem_set_of_eq]
  let g := fun n => ite (n ∈ p1) (f1 n) Set.Univ ∩ ite (n ∈ p2) (f2 n) Set.Univ
  use p1 ∪ p2, h_sup p1 p2 hp1S hp2S, g
  have h_inter_eq : t1 ∩ t2 = ⋂ i ∈ p1 ∪ p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [← Set.inf_eq_inter, g]
    ext1 x
    simp only [← inf_eq_inter, ← mem_inter_eq, ← mem_Inter, ← Finset.mem_union]
    refine' ⟨fun h i hi_mem_union => _, fun h => ⟨fun i hi1 => _, fun i hi2 => _⟩⟩
    · split_ifs
      exacts[⟨h.1 i h_1, h.2 i h_2⟩, ⟨h.1 i h_1, Set.mem_univ _⟩, ⟨Set.mem_univ _, h.2 i h_2⟩,
        ⟨Set.mem_univ _, Set.mem_univ _⟩]
      
    · specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
      
    · specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
      
  refine' ⟨fun n hn => _, h_inter_eq⟩
  simp_rw [g]
  split_ifs with hn1 hn2
  · refine' hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (set.ne_empty_iff_nonempty.mp fun h => _)
    rw [h_inter_eq] at h_nonempty
    suffices h_empty : (⋂ i ∈ p1 ∪ p2, g i) = ∅
    exact (set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    refine' le_antisymmₓ (Set.Inter_subset_of_subset n _) (Set.empty_subset _)
    refine' Set.Inter_subset_of_subset hn _
    simp_rw [g, if_pos hn1, if_pos hn2]
    exact h.subset
    
  · simp [← hf1m n hn1]
    
  · simp [← hf2m n h]
    
  · exact
      absurd hn
        (by
          simp [← hn1, ← h])
    

theorem pi_Union_Inter_mono_left {α ι} {π π' : ι → Set (Set α)} (h_le : ∀ i, π i ⊆ π' i) (S : Set (Finset ι)) :
    PiUnionInter π S ⊆ PiUnionInter π' S := by
  rintro s ⟨t, ht_mem, ft, hft_mem_pi, rfl⟩
  exact ⟨t, ht_mem, ft, fun x hxt => h_le x (hft_mem_pi x hxt), rfl⟩

theorem generate_from_pi_Union_Inter_le {α ι} {m : MeasurableSpace α} (π : ι → Set (Set α))
    (h : ∀ n, generateFrom (π n) ≤ m) (S : Set (Finset ι)) : generateFrom (PiUnionInter π S) ≤ m := by
  refine' generate_from_le _
  rintro t ⟨ht_p, ht_p_mem, ft, hft_mem_pi, rfl⟩
  refine' Finset.measurable_set_bInter _ fun x hx_mem => (h x) _ _
  exact measurable_set_generate_from (hft_mem_pi x hx_mem)

theorem subset_pi_Union_Inter {α ι} {π : ι → Set (Set α)} {S : Set (Finset ι)} (h_univ : ∀ i, Set.Univ ∈ π i) {i : ι}
    {s : Finset ι} (hsS : s ∈ S) (his : i ∈ s) : π i ⊆ PiUnionInter π S := by
  refine' fun t ht_pii => ⟨s, hsS, fun j => ite (j = i) t Set.Univ, ⟨fun m h_pm => _, _⟩⟩
  · split_ifs
    · rwa [h]
      
    · exact h_univ m
      
    
  · ext1 x
    simp_rw [Set.mem_Inter]
    constructor <;> intro hx
    · intro j h_p_j
      split_ifs
      · exact hx
        
      · exact Set.mem_univ _
        
      
    · simpa using hx i his
      
    

theorem mem_pi_Union_Inter_of_measurable_set {α ι} (m : ι → MeasurableSpace α) {S : Set (Finset ι)} {i : ι}
    {t : Finset ι} (htS : t ∈ S) (hit : i ∈ t) (s : Set α) (hs : measurable_set[m i] s) :
    s ∈ PiUnionInter (fun n => { s | measurable_set[m n] s }) S :=
  subset_pi_Union_Inter (fun i => MeasurableSet.univ) htS hit hs

theorem le_generate_from_pi_Union_Inter {α ι} {π : ι → Set (Set α)} (S : Set (Finset ι)) (h_univ : ∀ n, Set.Univ ∈ π n)
    {x : ι} {t : Finset ι} (htS : t ∈ S) (hxt : x ∈ t) : generateFrom (π x) ≤ generateFrom (PiUnionInter π S) :=
  generate_from_mono (subset_pi_Union_Inter h_univ htS hxt)

theorem measurable_set_supr_of_mem_pi_Union_Inter {α ι} (m : ι → MeasurableSpace α) (S : Set (Finset ι)) (t : Set α)
    (ht : t ∈ PiUnionInter (fun n => { s | measurable_set[m n] s }) S) :
    measurable_set[⨆ (i) (hi : ∃ s ∈ S, i ∈ s), m i] t := by
  rcases ht with ⟨pt, hpt, ft, ht_m, rfl⟩
  refine' pt.measurable_set_bInter fun i hi => _
  suffices h_le : m i ≤ ⨆ (i) (hi : ∃ s ∈ S, i ∈ s), m i
  exact h_le (ft i) (ht_m i hi)
  have hi' : ∃ s ∈ S, i ∈ s := ⟨pt, hpt, hi⟩
  exact le_supr₂ i hi'

theorem generate_from_pi_Union_Inter_measurable_space {α ι} (m : ι → MeasurableSpace α) (S : Set (Finset ι)) :
    generateFrom (PiUnionInter (fun n => { s | measurable_set[m n] s }) S) = ⨆ (i) (hi : ∃ p ∈ S, i ∈ p), m i := by
  refine' le_antisymmₓ _ _
  · rw [← @generate_from_measurable_set α (⨆ (i) (hi : ∃ p ∈ S, i ∈ p), m i)]
    exact generate_from_mono (measurable_set_supr_of_mem_pi_Union_Inter m S)
    
  · refine' supr₂_le fun i hi => _
    rcases hi with ⟨p, hpS, hpi⟩
    rw [← @generate_from_measurable_set α (m i)]
    exact generate_from_mono (mem_pi_Union_Inter_of_measurable_set m hpS hpi)
    

end UnionInter

namespace MeasurableSpace

variable {α : Type _}

/-! ## Dynkin systems and Π-λ theorem -/


/-- A Dynkin system is a collection of subsets of a type `α` that contains the empty set,
  is closed under complementation and under countable union of pairwise disjoint sets.
  The disjointness condition is the only difference with `σ`-algebras.

  The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras
  generated by a collection of sets which is stable under intersection.

  A Dynkin system is also known as a "λ-system" or a "d-system".
-/
structure DynkinSystem (α : Type _) where
  Has : Set α → Prop
  has_empty : has ∅
  HasCompl : ∀ {a}, has a → has (aᶜ)
  has_Union_nat : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, has (f i)) → has (⋃ i, f i)

namespace DynkinSystem

@[ext]
theorem ext : ∀ {d₁ d₂ : DynkinSystem α}, (∀ s : Set α, d₁.Has s ↔ d₂.Has s) → d₁ = d₂
  | ⟨s₁, _, _, _⟩, ⟨s₂, _, _, _⟩, h => by
    have : s₁ = s₂ := funext fun x => propext <| h x
    subst this

variable (d : DynkinSystem α)

theorem has_compl_iff {a} : d.Has (aᶜ) ↔ d.Has a :=
  ⟨fun h => by
    simpa using d.has_compl h, fun h => d.HasCompl h⟩

theorem has_univ : d.Has Univ := by
  simpa using d.has_compl d.has_empty

theorem has_Union {β} [Encodable β] {f : β → Set α} (hd : Pairwise (Disjoint on f)) (h : ∀ i, d.Has (f i)) :
    d.Has (⋃ i, f i) := by
  rw [← Encodable.Union_decode₂]
  exact d.has_Union_nat (Encodable.Union_decode₂_disjoint_on hd) fun n => Encodable.Union_decode₂_cases d.has_empty h

theorem has_union {s₁ s₂ : Set α} (h₁ : d.Has s₁) (h₂ : d.Has s₂) (h : s₁ ∩ s₂ ⊆ ∅) : d.Has (s₁ ∪ s₂) := by
  rw [union_eq_Union]
  exact d.has_Union (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 ⟨h₂, h₁⟩)

theorem has_diff {s₁ s₂ : Set α} (h₁ : d.Has s₁) (h₂ : d.Has s₂) (h : s₂ ⊆ s₁) : d.Has (s₁ \ s₂) := by
  apply d.has_compl_iff.1
  simp [← diff_eq, ← compl_inter]
  exact d.has_union (d.has_compl h₁) h₂ fun x ⟨h₁, h₂⟩ => h₁ (h h₂)

instance : LE (DynkinSystem α) where le := fun m₁ m₂ => m₁.Has ≤ m₂.Has

theorem le_def {α} {a b : DynkinSystem α} : a ≤ b ↔ a.Has ≤ b.Has :=
  Iff.rfl

instance : PartialOrderₓ (DynkinSystem α) :=
  { DynkinSystem.hasLe with le_refl := fun a b => le_rfl,
    le_trans := fun a b c hab hbc => le_def.mpr (le_transₓ hab hbc),
    le_antisymm := fun a b h₁ h₂ => ext fun s => ⟨h₁ s, h₂ s⟩ }

/-- Every measurable space (σ-algebra) forms a Dynkin system -/
def ofMeasurableSpace (m : MeasurableSpace α) : DynkinSystem α where
  Has := m.MeasurableSet'
  has_empty := m.measurable_set_empty
  HasCompl := m.measurable_set_compl
  has_Union_nat := fun f _ hf => m.measurable_set_Union f hf

theorem of_measurable_space_le_of_measurable_space_iff {m₁ m₂ : MeasurableSpace α} :
    ofMeasurableSpace m₁ ≤ ofMeasurableSpace m₂ ↔ m₁ ≤ m₂ :=
  Iff.rfl

/-- The least Dynkin system containing a collection of basic sets.
  This inductive type gives the underlying collection of sets. -/
inductive GenerateHas (s : Set (Set α)) : Set α → Prop
  | basic : ∀, ∀ t ∈ s, ∀, generate_has t
  | Empty : generate_has ∅
  | compl : ∀ {a}, generate_has a → generate_has (aᶜ)
  | Union : ∀ {f : ℕ → Set α}, Pairwise (Disjoint on f) → (∀ i, generate_has (f i)) → generate_has (⋃ i, f i)

theorem generate_has_compl {C : Set (Set α)} {s : Set α} : GenerateHas C (sᶜ) ↔ GenerateHas C s := by
  refine' ⟨_, generate_has.compl⟩
  intro h
  convert generate_has.compl h
  simp

/-- The least Dynkin system containing a collection of basic sets. -/
def generate (s : Set (Set α)) : DynkinSystem α where
  Has := GenerateHas s
  has_empty := GenerateHas.empty
  HasCompl := fun a => GenerateHas.compl
  has_Union_nat := fun f => GenerateHas.Union

theorem generate_has_def {C : Set (Set α)} : (generate C).Has = GenerateHas C :=
  rfl

instance : Inhabited (DynkinSystem α) :=
  ⟨generate Univ⟩

/-- If a Dynkin system is closed under binary intersection, then it forms a `σ`-algebra. -/
def toMeasurableSpace (h_inter : ∀ s₁ s₂, d.Has s₁ → d.Has s₂ → d.Has (s₁ ∩ s₂)) where
  MeasurableSet' := d.Has
  measurable_set_empty := d.has_empty
  measurable_set_compl := fun s h => d.HasCompl h
  measurable_set_Union := fun f hf => by
    rw [← Union_disjointed]
    exact
      d.has_Union (disjoint_disjointed _) fun n =>
        disjointedRecₓ (fun t i h => h_inter _ _ h <| d.has_compl <| hf i) (hf n)

theorem of_measurable_space_to_measurable_space (h_inter : ∀ s₁ s₂, d.Has s₁ → d.Has s₂ → d.Has (s₁ ∩ s₂)) :
    ofMeasurableSpace (d.toMeasurableSpace h_inter) = d :=
  ext fun s => Iff.rfl

/-- If `s` is in a Dynkin system `d`, we can form the new Dynkin system `{s ∩ t | t ∈ d}`. -/
def restrictOn {s : Set α} (h : d.Has s) : DynkinSystem α where
  Has := fun t => d.Has (t ∩ s)
  has_empty := by
    simp [← d.has_empty]
  HasCompl := fun t hts => by
    have : tᶜ ∩ s = (t ∩ s)ᶜ \ sᶜ :=
      Set.ext fun x => by
        by_cases' x ∈ s <;> simp [← h]
    rw [this]
    exact d.has_diff (d.has_compl hts) (d.has_compl h) (compl_subset_compl.mpr <| inter_subset_right _ _)
  has_Union_nat := fun f hd hf => by
    rw [inter_comm, inter_Union]
    apply d.has_Union_nat
    · exact fun i j h x ⟨⟨_, h₁⟩, _, h₂⟩ => hd i j h ⟨h₁, h₂⟩
      
    · simpa [← inter_comm] using hf
      

theorem generate_le {s : Set (Set α)} (h : ∀, ∀ t ∈ s, ∀, d.Has t) : generate s ≤ d := fun t ht =>
  ht.recOn h d.has_empty (fun a _ h => d.HasCompl h) fun f hd _ hf => d.has_Union hd hf

theorem generate_has_subset_generate_measurable {C : Set (Set α)} {s : Set α} (hs : (generate C).Has s) :
    measurable_set[generateFrom C] s :=
  generate_le (ofMeasurableSpace (generateFrom C)) (fun t => measurable_set_generate_from) s hs

theorem generate_inter {s : Set (Set α)} (hs : IsPiSystem s) {t₁ t₂ : Set α} (ht₁ : (generate s).Has t₁)
    (ht₂ : (generate s).Has t₂) : (generate s).Has (t₁ ∩ t₂) :=
  have : generate s ≤ (generate s).restrictOn ht₂ :=
    (generate_le _) fun s₁ hs₁ =>
      have : (generate s).Has s₁ := GenerateHas.basic s₁ hs₁
      have : generate s ≤ (generate s).restrictOn this :=
        (generate_le _) fun s₂ hs₂ =>
          show (generate s).Has (s₂ ∩ s₁) from
            (s₂ ∩ s₁).eq_empty_or_nonempty.elim (fun h => h.symm ▸ generate_has.empty) fun h =>
              GenerateHas.basic _ <| hs _ hs₂ _ hs₁ h
      have : (generate s).Has (t₂ ∩ s₁) := this _ ht₂
      show (generate s).Has (s₁ ∩ t₂) by
        rwa [inter_comm]
  this _ ht₁

/-- **Dynkin's π-λ theorem**:
  Given a collection of sets closed under binary intersections, then the Dynkin system it
  generates is equal to the σ-algebra it generates.
  This result is known as the π-λ theorem.
  A collection of sets closed under binary intersection is called a π-system (often requiring
  additionnally that is is non-empty, but we drop this condition in the formalization).
-/
theorem generate_from_eq {s : Set (Set α)} (hs : IsPiSystem s) :
    generateFrom s = (generate s).toMeasurableSpace fun t₁ t₂ => generate_inter hs :=
  le_antisymmₓ (generate_from_le fun t ht => GenerateHas.basic t ht)
    (of_measurable_space_le_of_measurable_space_iff.mp <| by
      rw [of_measurable_space_to_measurable_space]
      exact (generate_le _) fun t ht => measurable_set_generate_from ht)

end DynkinSystem

theorem induction_on_inter {C : Set α → Prop} {s : Set (Set α)} [m : MeasurableSpace α] (h_eq : m = generateFrom s)
    (h_inter : IsPiSystem s) (h_empty : C ∅) (h_basic : ∀, ∀ t ∈ s, ∀, C t)
    (h_compl : ∀ t, MeasurableSet t → C t → C (tᶜ))
    (h_union : ∀ f : ℕ → Set α, Pairwise (Disjoint on f) → (∀ i, MeasurableSet (f i)) → (∀ i, C (f i)) → C (⋃ i, f i)) :
    ∀ ⦃t⦄, MeasurableSet t → C t :=
  have eq : MeasurableSet = DynkinSystem.GenerateHas s := by
    rw [h_eq, dynkin_system.generate_from_eq h_inter]
    rfl
  fun t ht =>
  have : DynkinSystem.GenerateHas s t := by
    rwa [Eq] at ht
  this.recOn h_basic h_empty
    (fun t ht =>
      h_compl t <| by
        rw [Eq]
        exact ht)
    fun f hf ht =>
    (h_union f hf) fun i => by
      rw [Eq]
      exact ht _

end MeasurableSpace

