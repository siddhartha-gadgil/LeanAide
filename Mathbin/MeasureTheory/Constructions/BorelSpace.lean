/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import Mathbin.Analysis.Complex.Basic
import Mathbin.Analysis.NormedSpace.FiniteDimension
import Mathbin.MeasureTheory.Function.AeMeasurableSequence
import Mathbin.MeasureTheory.Group.Arithmetic
import Mathbin.MeasureTheory.Lattice
import Mathbin.MeasureTheory.Measure.OpenPos
import Mathbin.Topology.Algebra.Order.LiminfLimsup
import Mathbin.Topology.ContinuousFunction.Basic
import Mathbin.Topology.Instances.Ereal
import Mathbin.Topology.GDelta
import Mathbin.Topology.Order.Lattice
import Mathbin.Topology.Semicontinuous
import Mathbin.Topology.MetricSpace.Metrizable

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‚Äπmeasurable_space Œ±‚Ä∫ = borel Œ±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚Äπmeasurable_space Œ±‚Ä∫`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `Œª x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/


noncomputable section

open Classical Set Filter MeasureTheory

open Classical BigOperators TopologicalSpace Nnreal Ennreal MeasureTheory

universe u v w x y

variable {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type _} {Œπ : Sort y} {s t u : Set Œ±}

open MeasurableSpace TopologicalSpace

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Œ± : Type u) [TopologicalSpace Œ±] : MeasurableSpace Œ± :=
  generateFrom { s : Set Œ± | IsOpen s }

theorem borel_eq_top_of_discrete [TopologicalSpace Œ±] [DiscreteTopology Œ±] : borel Œ± = ‚ä§ :=
  top_le_iff.1 fun s hs => GenerateMeasurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_encodable [TopologicalSpace Œ±] [T1Space Œ±] [Encodable Œ±] : borel Œ± = ‚ä§ := by
  refine' top_le_iff.1 fun s hs => bUnion_of_singleton s ‚ñ∏ _
  apply MeasurableSet.bUnion s.countable_encodable
  intro x hx
  apply MeasurableSet.of_compl
  apply generate_measurable.basic
  exact is_closed_singleton.is_open_compl

theorem borel_eq_generate_from_of_subbasis {s : Set (Set Œ±)} [t : TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    (hs : t = generateFrom s) : borel Œ± = generateFrom s :=
  le_antisymm‚Çì
    (generate_from_le fun u (hu : t.IsOpen u) => by
      rw [hs] at hu
      induction hu
      case generate_open.basic u hu =>
        exact generate_measurable.basic u hu
      case generate_open.univ =>
        exact @MeasurableSet.univ Œ± (generate_from s)
      case generate_open.inter s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ =>
        exact @MeasurableSet.inter Œ± (generate_from s) _ _ hs‚ÇÅ hs‚ÇÇ
      case generate_open.sUnion f hf ih =>
        rcases is_open_sUnion_countable f
            (by
              rwa [hs]) with
          ‚ü®v, hv, vf, vu‚ü©
        rw [‚Üê vu]
        exact @MeasurableSet.sUnion Œ± (generate_from s) _ hv fun x xv => ih _ (vf xv))
    (generate_from_le fun u hu =>
      GenerateMeasurable.basic _ <|
        show t.IsOpen u by
          rw [hs] <;> exact generate_open.basic _ hu)

theorem TopologicalSpace.IsTopologicalBasis.borel_eq_generate_from [TopologicalSpace Œ±] [SecondCountableTopology Œ±]
    {s : Set (Set Œ±)} (hs : IsTopologicalBasis s) : borel Œ± = generateFrom s :=
  borel_eq_generate_from_of_subbasis hs.eq_generate_from

theorem is_pi_system_is_open [TopologicalSpace Œ±] : IsPiSystem (IsOpen : Set Œ± ‚Üí Prop) := fun s hs t ht hst =>
  IsOpen.inter hs ht

theorem borel_eq_generate_from_is_closed [TopologicalSpace Œ±] : borel Œ± = generateFrom { s | IsClosed s } :=
  le_antisymm‚Çì
    (generate_from_le fun t ht =>
      @MeasurableSet.of_compl Œ± _ (generateFrom { s | IsClosed s })
        (GenerateMeasurable.basic _ <| is_closed_compl_iff.2 ht))
    (generate_from_le fun t ht =>
      @MeasurableSet.of_compl Œ± _ (borel Œ±) (GenerateMeasurable.basic _ <| is_open_compl_iff.2 ht))

section OrderTopology

variable (Œ±)

variable [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder‚Çì Œ±] [OrderTopology Œ±]

theorem borel_eq_generate_from_Iio : borel Œ± = generateFrom (Range Iio) := by
  refine' le_antisymm‚Çì _ (generate_from_le _)
  ¬∑ rw [borel_eq_generate_from_of_subbasis (@OrderTopology.topology_eq_generate_intervals Œ± _ _ _)]
    let this : MeasurableSpace Œ± := MeasurableSpace.generateFrom (range Iio)
    have H : ‚àÄ a : Œ±, MeasurableSet (Iio a) := fun a => generate_measurable.basic _ ‚ü®_, rfl‚ü©
    refine' generate_from_le _
    rintro _ ‚ü®a, rfl | rfl‚ü© <;> [skip, apply H]
    by_cases' h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b
    ¬∑ rcases h with ‚ü®a', ha'‚ü©
      rw [(_ : Ioi a = Iio a'·∂ú)]
      ¬∑ exact (H _).compl
        
      simp [‚Üê Set.ext_iff, ‚Üê ha']
      
    ¬∑ rcases is_open_Union_countable (fun a' : { a' : Œ± // a < a' } => { b | a'.1 < b }) fun a' => is_open_lt' _ with
        ‚ü®v, ‚ü®hv‚ü©, vu‚ü©
      simp [‚Üê Set.ext_iff] at vu
      have : Ioi a = ‚ãÉ x : v, Iio x.1.1·∂ú := by
        simp [‚Üê Set.ext_iff]
        refine' fun x => ‚ü®fun ax => _, fun ‚ü®a', ‚ü®h, av‚ü©, ax‚ü© => lt_of_lt_of_le‚Çì h ax‚ü©
        rcases(vu x).2 _ with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©
        ¬∑ exact ‚ü®a', h‚ÇÅ, le_of_lt‚Çì h‚ÇÇ‚ü©
          
        refine' not_imp_comm.1 (fun h => _) h
        exact ‚ü®x, fun b => ‚ü®fun ab => le_of_not_lt‚Çì fun h' => h ‚ü®b, ab, h'‚ü©, lt_of_lt_of_le‚Çì ax‚ü©‚ü©
      rw [this]
      skip
      apply MeasurableSet.Union
      exact fun _ => (H _).compl
      
    
  ¬∑ rw [forall_range_iff]
    intro a
    exact generate_measurable.basic _ is_open_Iio
    

theorem borel_eq_generate_from_Ioi : borel Œ± = generateFrom (Range Ioi) :=
  @borel_eq_generate_from_Iio Œ±·µí·µà _
    (by
      infer_instance : SecondCountableTopology Œ±)
    _ _

end OrderTopology

theorem borel_comap {f : Œ± ‚Üí Œ≤} {t : TopologicalSpace Œ≤} : @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
  comap_generate_from.symm

theorem Continuous.borel_measurable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Continuous f) :
    @Measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
  Measurable.of_le_map <| generate_from_le fun s hs => GenerateMeasurable.basic (f ‚Åª¬π' s) (hs.Preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class OpensMeasurableSpace (Œ± : Type _) [TopologicalSpace Œ±] [h : MeasurableSpace Œ±] : Prop where
  borel_le : borel Œ± ‚â§ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class BorelSpace (Œ± : Type _) [TopologicalSpace Œ±] [MeasurableSpace Œ±] : Prop where
  measurable_eq : ‚ÄπMeasurableSpace Œ±‚Ä∫ = borel Œ±

namespace Tactic

/-- Add instances `borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`. -/
unsafe def add_borel_instance (Œ± : expr) : tactic Unit := do
  let n1 ‚Üê get_unused_name "_inst"
  to_expr (pquote.1 (borel (%%‚ÇìŒ±))) >>= pose n1
  reset_instance_cache
  let n2 ‚Üê get_unused_name "_inst"
  let v ‚Üê to_expr (pquote.1 (BorelSpace.mk rfl : BorelSpace (%%‚ÇìŒ±)))
  note n2 none v
  reset_instance_cache

/-- Given a type `Œ±`, an assumption `i : measurable_space Œ±`, and an instance `[borel_space Œ±]`,
replace `i` with `borel Œ±`. -/
unsafe def borel_to_refl (Œ± i : expr) : tactic Unit := do
  let n ‚Üê get_unused_name "h"
  to_expr (pquote.1 ((%%‚Çìi) = borel (%%‚ÇìŒ±))) >>= assert n
  applyc `borel_space.measurable_eq
  unfreezing (tactic.subst i)
  let n1 ‚Üê get_unused_name "_inst"
  to_expr (pquote.1 (borel (%%‚ÇìŒ±))) >>= pose n1
  reset_instance_cache

/-- Given a type `Œ±`, if there is an assumption `[i : measurable_space Œ±]`, then try to prove
`[borel_space Œ±]` and replace `i` with `borel Œ±`. Otherwise, add instances
`borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`. -/
unsafe def borelize (Œ± : expr) : tactic Unit := do
  let i ‚Üê optional‚Çì (to_expr (pquote.1 (MeasurableSpace (%%‚ÇìŒ±))) >>= find_assumption)
  i (add_borel_instance Œ±) (borel_to_refl Œ±)

namespace Interactive

setup_tactic_parser

/-- The behaviour of `borelize Œ±` depends on the existing assumptions on `Œ±`.

- if `Œ±` is a topological space with instances `[measurable_space Œ±] [borel_space Œ±]`, then
  `borelize Œ±` replaces the former instance by `borel Œ±`;
- otherwise, `borelize Œ±` adds instances `borel Œ± : measurable_space Œ±` and `‚ü®rfl‚ü© : borel_space Œ±`.

Finally, `borelize [Œ±, Œ≤, Œ≥]` runs `borelize Œ±, borelize Œ≤, borelize Œ≥`.
-/
unsafe def borelize (ts : parse pexpr_list_or_texpr) : tactic Unit :=
  mmap'‚Çì (fun t => to_expr t >>= tactic.borelize) ts

add_tactic_doc
  { Name := "borelize", category := DocCategory.tactic, declNames := [`tactic.interactive.borelize],
    tags := ["type class"] }

end Interactive

end Tactic

instance (priority := 100) OrderDual.opens_measurable_space {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] : OpensMeasurableSpace Œ±·µí·µà where borel_le := h.borel_le

instance (priority := 100) OrderDual.borel_space {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : BorelSpace Œ±] : BorelSpace Œ±·µí·µà where measurable_eq := h.measurable_eq

/-- In a `borel_space` all open sets are measurable. -/
instance (priority := 100) BorelSpace.opens_measurable {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [BorelSpace Œ±] : OpensMeasurableSpace Œ± :=
  ‚ü®ge_of_eq <| BorelSpace.measurable_eq‚ü©

instance Subtype.borel_space {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±] [hŒ± : BorelSpace Œ±] (s : Set Œ±) :
    BorelSpace s :=
  ‚ü®by
    rw [hŒ±.1, Subtype.measurableSpace, ‚Üê borel_comap]
    rfl‚ü©

instance Subtype.opens_measurable_space {Œ± : Type _} [TopologicalSpace Œ±] [MeasurableSpace Œ±]
    [h : OpensMeasurableSpace Œ±] (s : Set Œ±) : OpensMeasurableSpace s :=
  ‚ü®by
    rw [borel_comap]
    exact comap_mono h.1‚ü©

theorem _root_.measurable_set.induction_on_open [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±]
    {C : Set Œ± ‚Üí Prop} (h_open : ‚àÄ U, IsOpen U ‚Üí C U) (h_compl : ‚àÄ t, MeasurableSet t ‚Üí C t ‚Üí C (t·∂ú))
    (h_union : ‚àÄ f : ‚Ñï ‚Üí Set Œ±, Pairwise (Disjoint on f) ‚Üí (‚àÄ i, MeasurableSet (f i)) ‚Üí (‚àÄ i, C (f i)) ‚Üí C (‚ãÉ i, f i)) :
    ‚àÄ ‚¶Ét‚¶Ñ, MeasurableSet t ‚Üí C t :=
  MeasurableSpace.induction_on_inter BorelSpace.measurable_eq is_pi_system_is_open (h_open _ is_open_empty) h_open
    h_compl h_union

section

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±] [TopologicalSpace Œ≤] [MeasurableSpace Œ≤]
  [OpensMeasurableSpace Œ≤] [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥] [TopologicalSpace Œ≥‚ÇÇ]
  [MeasurableSpace Œ≥‚ÇÇ] [BorelSpace Œ≥‚ÇÇ] [MeasurableSpace Œ¥]

theorem IsOpen.measurable_set (h : IsOpen s) : MeasurableSet s :=
  OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ h

@[measurability]
theorem measurable_set_interior : MeasurableSet (Interior s) :=
  is_open_interior.MeasurableSet

theorem IsGŒ¥.measurable_set (h : IsGŒ¥ s) : MeasurableSet s := by
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©
  exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).MeasurableSet

theorem measurable_set_of_continuous_at {Œ≤} [EmetricSpace Œ≤] (f : Œ± ‚Üí Œ≤) : MeasurableSet { x | ContinuousAt f x } :=
  (is_GŒ¥_set_of_continuous_at f).MeasurableSet

theorem IsClosed.measurable_set (h : IsClosed s) : MeasurableSet s :=
  h.is_open_compl.MeasurableSet.of_compl

theorem IsCompact.measurable_set [T2Space Œ±] (h : IsCompact s) : MeasurableSet s :=
  h.IsClosed.MeasurableSet

@[measurability]
theorem measurable_set_closure : MeasurableSet (Closure s) :=
  is_closed_closure.MeasurableSet

theorem measurable_of_is_open {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsOpen s ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  rw [‚ÄπBorelSpace Œ≥‚Ä∫.measurable_eq]
  exact measurable_generate_from hf

theorem measurable_of_is_closed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí MeasurableSet (f ‚Åª¬π' s)) : Measurable f := by
  apply measurable_of_is_open
  intro s hs
  rw [‚Üê MeasurableSet.compl_iff, ‚Üê preimage_compl]
  apply hf
  rw [is_closed_compl_iff]
  exact hs

theorem measurable_of_is_closed' {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, IsClosed s ‚Üí s.Nonempty ‚Üí s ‚â† univ ‚Üí MeasurableSet (f ‚Åª¬π' s)) :
    Measurable f := by
  apply measurable_of_is_closed
  intro s hs
  cases' eq_empty_or_nonempty s with h1 h1
  ¬∑ simp [‚Üê h1]
    
  by_cases' h2 : s = univ
  ¬∑ simp [‚Üê h2]
    
  exact hf s hs h1 h2

instance nhds_is_measurably_generated (a : Œ±) : (ùìù a).IsMeasurablyGenerated := by
  rw [nhds, infi_subtype']
  refine' @Filter.infi_is_measurably_generated _ _ _ _ fun i => _
  exact i.2.2.MeasurableSet.principal_is_measurably_generated

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
theorem MeasurableSet.nhds_within_is_measurably_generated {s : Set Œ±} (hs : MeasurableSet s) (a : Œ±) :
    (ùìù[s] a).IsMeasurablyGenerated :=
  have := hs.principal_is_measurably_generated
  Filter.inf_is_measurably_generated _ _

-- see Note [lower instance priority]
instance (priority := 100) OpensMeasurableSpace.to_measurable_singleton_class [T1Space Œ±] :
    MeasurableSingletonClass Œ± :=
  ‚ü®fun x => is_closed_singleton.MeasurableSet‚ü©

instance Pi.opens_measurable_space_encodable {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Encodable Œπ]
    [t' : ‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)]
    [‚àÄ i, OpensMeasurableSpace (œÄ i)] : OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  constructor
  have :
    Pi.topologicalSpace =
      generate_from
        { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, s a ‚àà countable_basis (œÄ a)) ‚àß t = pi (‚Üëi) s } :=
    by
    rw [funext fun a => @eq_generate_from_countable_basis (œÄ a) _ _, pi_generate_from_eq]
  rw [borel_eq_generate_from_of_subbasis this]
  apply generate_from_le
  rintro _ ‚ü®s, i, hi, rfl‚ü©
  refine' MeasurableSet.pi i.countable_to_set fun a ha => IsOpen.measurable_set _
  rw [eq_generate_from_countable_basis (œÄ a)]
  exact generate_open.basic _ (hi a ha)

instance Pi.opens_measurable_space_fintype {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Fintype Œπ] [t' : ‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, OpensMeasurableSpace (œÄ i)] :
    OpensMeasurableSpace (‚àÄ i, œÄ i) := by
  let this := Fintype.toEncodable Œπ
  infer_instance

instance Prod.opens_measurable_space [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] :
    OpensMeasurableSpace (Œ± √ó Œ≤) := by
  constructor
  rw [((is_basis_countable_basis Œ±).Prod (is_basis_countable_basis Œ≤)).borel_eq_generate_from]
  apply generate_from_le
  rintro _ ‚ü®u, v, hu, hv, rfl‚ü©
  exact (is_open_of_mem_countable_basis hu).MeasurableSet.Prod (is_open_of_mem_countable_basis hv).MeasurableSet

variable {Œ±' : Type _} [TopologicalSpace Œ±'] [MeasurableSpace Œ±']

theorem interior_ae_eq_of_null_frontier {Œº : Measure‚Çì Œ±'} {s : Set Œ±'} (h : Œº (Frontier s) = 0) : Interior s =·µê[Œº] s :=
  interior_subset.EventuallyLe.antisymm <| subset_closure.EventuallyLe.trans (ae_le_set.2 h)

theorem measure_interior_of_null_frontier {Œº : Measure‚Çì Œ±'} {s : Set Œ±'} (h : Œº (Frontier s) = 0) :
    Œº (Interior s) = Œº s :=
  measure_congr (interior_ae_eq_of_null_frontier h)

theorem null_measurable_set_of_null_frontier {s : Set Œ±} {Œº : Measure‚Çì Œ±} (h : Œº (Frontier s) = 0) :
    NullMeasurableSet s Œº :=
  ‚ü®Interior s, is_open_interior.MeasurableSet, (interior_ae_eq_of_null_frontier h).symm‚ü©

theorem closure_ae_eq_of_null_frontier {Œº : Measure‚Çì Œ±'} {s : Set Œ±'} (h : Œº (Frontier s) = 0) : Closure s =·µê[Œº] s :=
  ((ae_le_set.2 h).trans interior_subset.EventuallyLe).antisymm <| subset_closure.EventuallyLe

theorem measure_closure_of_null_frontier {Œº : Measure‚Çì Œ±'} {s : Set Œ±'} (h : Œº (Frontier s) = 0) :
    Œº (Closure s) = Œº s :=
  measure_congr (closure_ae_eq_of_null_frontier h)

section Preorder‚Çì

variable [Preorder‚Çì Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

@[simp, measurability]
theorem measurable_set_Ici : MeasurableSet (Ici a) :=
  is_closed_Ici.MeasurableSet

@[simp, measurability]
theorem measurable_set_Iic : MeasurableSet (Iic a) :=
  is_closed_Iic.MeasurableSet

@[simp, measurability]
theorem measurable_set_Icc : MeasurableSet (Icc a b) :=
  is_closed_Icc.MeasurableSet

instance nhds_within_Ici_is_measurably_generated : (ùìù[Ici b] a).IsMeasurablyGenerated :=
  measurable_set_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated : (ùìù[Iic b] a).IsMeasurablyGenerated :=
  measurable_set_Iic.nhds_within_is_measurably_generated _

instance nhds_within_Icc_is_measurably_generated : IsMeasurablyGenerated (ùìù[Icc a b] x) := by
  rw [‚Üê Ici_inter_Iic, nhds_within_inter]
  infer_instance

instance at_top_is_measurably_generated : (Filter.atTop : Filter Œ±).IsMeasurablyGenerated :=
  (@Filter.infi_is_measurably_generated _ _ _ _) fun a =>
    (measurable_set_Ici : MeasurableSet (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (Filter.atBot : Filter Œ±).IsMeasurablyGenerated :=
  (@Filter.infi_is_measurably_generated _ _ _ _) fun a =>
    (measurable_set_Iic : MeasurableSet (Iic a)).principal_is_measurably_generated

end Preorder‚Çì

section PartialOrder‚Çì

variable [PartialOrder‚Çì Œ±] [OrderClosedTopology Œ±] [SecondCountableTopology Œ±] {a b : Œ±}

@[measurability]
theorem measurable_set_le' : MeasurableSet { p : Œ± √ó Œ± | p.1 ‚â§ p.2 } :=
  OrderClosedTopology.is_closed_le'.MeasurableSet

@[measurability]
theorem measurable_set_le {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) : MeasurableSet { a | f a ‚â§ g a } :=
  hf.prod_mk hg measurable_set_le'

end PartialOrder‚Çì

section LinearOrder‚Çì

variable [LinearOrder‚Çì Œ±] [OrderClosedTopology Œ±] {a b x : Œ±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open Interval

@[simp, measurability]
theorem measurable_set_Iio : MeasurableSet (Iio a) :=
  is_open_Iio.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioi : MeasurableSet (Ioi a) :=
  is_open_Ioi.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioo : MeasurableSet (Ioo a b) :=
  is_open_Ioo.MeasurableSet

@[simp, measurability]
theorem measurable_set_Ioc : MeasurableSet (Ioc a b) :=
  measurable_set_Ioi.inter measurable_set_Iic

@[simp, measurability]
theorem measurable_set_Ico : MeasurableSet (Ico a b) :=
  measurable_set_Ici.inter measurable_set_Iio

instance nhds_within_Ioi_is_measurably_generated : (ùìù[Ioi b] a).IsMeasurablyGenerated :=
  measurable_set_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated : (ùìù[Iio b] a).IsMeasurablyGenerated :=
  measurable_set_Iio.nhds_within_is_measurably_generated _

-- ./././Mathport/Syntax/Translate/Basic.lean:958:47: unsupported (impossible)
instance nhds_within_interval_is_measurably_generated :
    IsMeasurablyGenerated (ùìù["./././Mathport/Syntax/Translate/Basic.lean:958:47: unsupported (impossible)"] x) :=
  nhds_within_Icc_is_measurably_generated

@[measurability]
theorem measurable_set_lt' [SecondCountableTopology Œ±] : MeasurableSet { p : Œ± √ó Œ± | p.1 < p.2 } :=
  (is_open_lt continuous_fst continuous_snd).MeasurableSet

@[measurability]
theorem measurable_set_lt [SecondCountableTopology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    MeasurableSet { a | f a < g a } :=
  hf.prod_mk hg measurable_set_lt'

theorem Set.OrdConnected.measurable_set (h : OrdConnected s) : MeasurableSet s := by
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y
  have huopen : IsOpen u := is_open_bUnion fun x hx => is_open_bUnion fun y hy => is_open_Ioo
  have humeas : MeasurableSet u := huopen.measurable_set
  have hfinite : (s \ u).Finite := by
    refine' Set.finite_of_forall_between_eq_endpoints (s \ u) fun x hx y hy z hz hxy hyz => _
    by_contra' h
    exact hy.2 (mem_Union‚ÇÇ.mpr ‚ü®x, hx.1, mem_Union‚ÇÇ.mpr ‚ü®z, hz.1, lt_of_le_of_ne‚Çì hxy h.1, lt_of_le_of_ne‚Çì hyz h.2‚ü©‚ü©)
  have : u ‚äÜ s := Union‚ÇÇ_subset fun x hx => Union‚ÇÇ_subset fun y hy => Ioo_subset_Icc_self.trans (h.out hx hy)
  rw [‚Üê union_diff_cancel this]
  exact humeas.union hfinite.measurable_set

theorem IsPreconnected.measurable_set (h : IsPreconnected s) : MeasurableSet s :=
  h.OrdConnected.MeasurableSet

-- ./././Mathport/Syntax/Translate/Basic.lean:647:16: unsupported tactic `borelize #[[expr Œ±]]
theorem generate_from_Ico_mem_le_borel {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderClosedTopology Œ±]
    (s t : Set Œ±) : MeasurableSpace.generateFrom { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà t, ‚àÉ h : l < u, Ico l u = S } ‚â§ borel Œ± := by
  apply generate_from_le
  trace "./././Mathport/Syntax/Translate/Basic.lean:647:16: unsupported tactic `borelize #[[expr Œ±]]"
  rintro _ ‚ü®a, -, b, -, -, rfl‚ü©
  exact measurable_set_Ico

theorem Dense.borel_eq_generate_from_Ico_mem_aux {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderTopology Œ±]
    [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s) (hbot : ‚àÄ x, IsBot x ‚Üí x ‚àà s)
    (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí y ‚àà s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } := by
  set S : Set (Set Œ±) := { S | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S }
  refine' le_antisymm‚Çì _ (generate_from_Ico_mem_le_borel _ _)
  let this : MeasurableSpace Œ± := generate_from S
  rw [borel_eq_generate_from_Iio]
  refine' generate_from_le (forall_range_iff.2 fun a => _)
  rcases hd.exists_countable_dense_subset_bot_top with ‚ü®t, hts, hc, htd, htb, htt‚ü©
  by_cases' ha : ‚àÄ, ‚àÄ b < a, ‚àÄ, (Ioo b a).Nonempty
  ¬∑ convert_to MeasurableSet (‚ãÉ (l ‚àà t) (u ‚àà t) (hlu : l < u) (hu : u ‚â§ a), Ico l u)
    ¬∑ ext y
      simp only [‚Üê mem_Union, ‚Üê mem_Iio, ‚Üê mem_Ico]
      constructor
      ¬∑ intro hy
        rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) y with ‚ü®l, hlt, hly‚ü©
        rcases htd.exists_mem_open is_open_Ioo (ha y hy) with ‚ü®u, hut, hyu, hua‚ü©
        exact ‚ü®l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyu‚ü©
        
      ¬∑ rintro ‚ü®l, -, u, -, -, hua, -, hyu‚ü©
        exact hyu.trans_le hua
        
      
    ¬∑ refine' MeasurableSet.bUnion hc fun a ha => (MeasurableSet.bUnion hc) fun b hb => _
      refine' MeasurableSet.Union_Prop fun hab => MeasurableSet.Union_Prop fun hb' => _
      exact generate_measurable.basic _ ‚ü®a, hts ha, b, hts hb, hab, mem_singleton _‚ü©
      
    
  ¬∑ simp only [‚Üê not_forall, ‚Üê not_nonempty_iff_eq_empty] at ha
    replace ha : a ‚àà s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd
    convert_to MeasurableSet (‚ãÉ (l ‚àà t) (hl : l < a), Ico l a)
    ¬∑ symm
      simp only [Ici_inter_Iio, Union_inter, ‚Üê inter_eq_right_iff_subset, ‚Üê subset_def, ‚Üê mem_Union, ‚Üê mem_Ici, ‚Üê
        mem_Iio]
      intro x hx
      rcases htd.exists_le' (fun b hb => htb _ hb (hbot b hb)) x with ‚ü®z, hzt, hzx‚ü©
      exact ‚ü®z, hzt, hzx.trans_lt hx, hzx‚ü©
      
    ¬∑ refine' MeasurableSet.bUnion hc fun x hx => MeasurableSet.Union_Prop fun hlt => _
      exact generate_measurable.basic _ ‚ü®x, hts hx, a, ha, hlt, mem_singleton _‚ü©
      
    

theorem Dense.borel_eq_generate_from_Ico_mem {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderTopology Œ±]
    [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMinOrder Œ±] {s : Set Œ±} (hd : Dense s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ico l u = S } :=
  (hd.borel_eq_generate_from_Ico_mem_aux
      (by
        simp ))
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ico (Œ± : Type _) [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder‚Çì Œ±]
    [OrderTopology Œ±] : borel Œ± = generateFrom { S : Set Œ± | ‚àÉ (l u : _)(h : l < u), Ico l u = S } := by
  simpa only [‚Üê exists_prop, ‚Üê mem_univ, ‚Üê true_and‚Çì] using
    (@dense_univ Œ± _).borel_eq_generate_from_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

theorem Dense.borel_eq_generate_from_Ioc_mem_aux {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderTopology Œ±]
    [SecondCountableTopology Œ±] {s : Set Œ±} (hd : Dense s) (hbot : ‚àÄ x, IsTop x ‚Üí x ‚àà s)
    (hIoo : ‚àÄ x y : Œ±, x < y ‚Üí Ioo x y = ‚àÖ ‚Üí x ‚àà s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } := by
  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot fun x y hlt he => hIoo y x hlt _
  ¬∑ ext s
    constructor <;> rintro ‚ü®l, hl, u, hu, hlt, rfl‚ü©
    exacts[‚ü®u, hu, l, hl, hlt, dual_Ico‚ü©, ‚ü®u, hu, l, hl, hlt, dual_Ioc‚ü©]
    
  ¬∑ erw [dual_Ioo]
    exact he
    

theorem Dense.borel_eq_generate_from_Ioc_mem {Œ± : Type _} [TopologicalSpace Œ±] [LinearOrder‚Çì Œ±] [OrderTopology Œ±]
    [SecondCountableTopology Œ±] [DenselyOrdered Œ±] [NoMaxOrder Œ±] {s : Set Œ±} (hd : Dense s) :
    borel Œ± = generateFrom { S : Set Œ± | ‚àÉ l ‚àà s, ‚àÉ u ‚àà s, ‚àÉ h : l < u, Ioc l u = S } :=
  (hd.borel_eq_generate_from_Ioc_mem_aux
      (by
        simp ))
    fun x y hxy H => ((nonempty_Ioo.2 hxy).ne_empty H).elim

theorem borel_eq_generate_from_Ioc (Œ± : Type _) [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [LinearOrder‚Çì Œ±]
    [OrderTopology Œ±] : borel Œ± = generateFrom { S : Set Œ± | ‚àÉ (l u : _)(h : l < u), Ioc l u = S } := by
  simpa only [‚Üê exists_prop, ‚Üê mem_univ, ‚Üê true_and‚Çì] using
    (@dense_univ Œ± _).borel_eq_generate_from_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ => mem_univ _

namespace MeasureTheory.Measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ico_finite {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure‚Çì Œ±) [IsFiniteMeasure Œº] (hŒºŒΩ : Œº Univ = ŒΩ Univ)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ := by
  refine'
    ext_of_generate_finite _ (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Œ±))
      (is_pi_system_Ico (id : Œ± ‚Üí Œ±) id) _ hŒºŒΩ
  ¬∑ rintro - ‚ü®a, b, hlt, rfl‚ü©
    exact h hlt
    

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Œ±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Œº` and
`ŒΩ`. -/
theorem ext_of_Ioc_finite {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure‚Çì Œ±) [IsFiniteMeasure Œº] (hŒºŒΩ : Œº Univ = ŒΩ Univ)
    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ := by
  refine' @ext_of_Ico_finite Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ Œº ŒΩ _ hŒºŒΩ fun a b hab => _
  erw [dual_Ico]
  exact h hab

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico' {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure‚Çì Œ±)
    (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) ‚â† ‚àû) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ := by
  rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, hsb, hst‚ü©
  have : (‚ãÉ (l ‚àà s) (u ‚àà s) (h : l < u), {Ico l u} : Set (Set Œ±)).Countable :=
    hsc.bUnion fun l hl => hsc.bUnion fun u hu => countable_Union_Prop fun _ => countable_singleton _
  simp only [set_of_eq_eq_singleton, set_of_exists] at this
  refine'
    measure.ext_of_generate_from_of_cover_subset (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Œ±))
      (is_pi_system_Ico id id) _ this _ _ _
  ¬∑ rintro _ ‚ü®l, -, u, -, h, rfl‚ü©
    exact ‚ü®l, u, h, rfl‚ü©
    
  ¬∑ refine' sUnion_eq_univ_iff.2 fun x => _
    rcases hsd.exists_le' hsb x with ‚ü®l, hls, hlx‚ü©
    rcases hsd.exists_gt x with ‚ü®u, hus, hxu‚ü©
    exact ‚ü®_, ‚ü®l, hls, u, hus, hlx.trans_lt hxu, rfl‚ü©, hlx, hxu‚ü©
    
  ¬∑ rintro _ ‚ü®l, -, u, -, hlt, rfl‚ü©
    exact hŒº hlt
    
  ¬∑ rintro _ ‚ü®l, u, hlt, rfl‚ü©
    exact h hlt
    

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc' {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure‚Çì Œ±)
    (hŒº : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) ‚â† ‚àû) (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ := by
  refine' @ext_of_Ico' Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ Œº ŒΩ _ _ <;> intro a b hab <;> erw [dual_Ico]
  exacts[hŒº hab, h hab]

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
theorem ext_of_Ico {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMaxOrder Œ±] (Œº ŒΩ : Measure‚Çì Œ±)
    [IsLocallyFiniteMeasure Œº] (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ico a b) = ŒΩ (Ico a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ico' ŒΩ (fun a b hab => measure_Ico_lt_top.Ne) h

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
theorem ext_of_Ioc {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [BorelSpace Œ±] [NoMinOrder Œ±] (Œº ŒΩ : Measure‚Çì Œ±)
    [IsLocallyFiniteMeasure Œº] (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí Œº (Ioc a b) = ŒΩ (Ioc a b)) : Œº = ŒΩ :=
  Œº.ext_of_Ioc' ŒΩ (fun a b hab => measure_Ioc_lt_top.Ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
theorem ext_of_Iic {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure‚Çì Œ±) [IsFiniteMeasure Œº]
    (h : ‚àÄ a, Œº (Iic a) = ŒΩ (Iic a)) : Œº = ŒΩ := by
  refine' ext_of_Ioc_finite Œº ŒΩ _ fun a b hlt => _
  ¬∑ rcases exists_countable_dense_bot_top Œ± with ‚ü®s, hsc, hsd, -, hst‚ü©
    have : DirectedOn (¬∑ ‚â§ ¬∑) s := directed_on_iff_directed.2 (directed_of_sup fun _ _ => id)
    simp only [bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, ‚Üê h]
    
  rw [‚Üê Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic,
    measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic, h a, h b]
  ¬∑ rw [‚Üê h a]
    exact (measure_lt_top Œº _).Ne
    
  ¬∑ exact (measure_lt_top Œº _).Ne
    

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
theorem ext_of_Ici {Œ± : Type _} [TopologicalSpace Œ±] {m : MeasurableSpace Œ±} [SecondCountableTopology Œ±]
    [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [BorelSpace Œ±] (Œº ŒΩ : Measure‚Çì Œ±) [IsFiniteMeasure Œº]
    (h : ‚àÄ a, Œº (Ici a) = ŒΩ (Ici a)) : Œº = ŒΩ :=
  @ext_of_Iic Œ±·µí·µà _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ h

end MeasureTheory.Measure

end LinearOrder‚Çì

section LinearOrder‚Çì

variable [LinearOrder‚Çì Œ±] [OrderClosedTopology Œ±]

@[measurability]
theorem measurable_set_interval {a b : Œ±} : MeasurableSet (Interval a b) :=
  measurable_set_Icc

@[measurability]
theorem measurable_set_interval_oc {a b : Œ±} : MeasurableSet (IntervalOc a b) :=
  measurable_set_Ioc

variable [SecondCountableTopology Œ±]

@[measurability]
theorem Measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => max (f a) (g a) := by
  simpa only [‚Üê max_def] using hf.piecewise (measurable_set_le hg hf) hg

@[measurability]
theorem AeMeasurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : Measure‚Çì Œ¥} (hf : AeMeasurable f Œº) (hg : AeMeasurable g Œº) :
    AeMeasurable (fun a => max (f a) (g a)) Œº :=
  ‚ü®fun a => max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

@[measurability]
theorem Measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) : Measurable fun a => min (f a) (g a) := by
  simpa only [‚Üê min_def] using hf.piecewise (measurable_set_le hf hg) hg

@[measurability]
theorem AeMeasurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : Measure‚Çì Œ¥} (hf : AeMeasurable f Œº) (hg : AeMeasurable g Œº) :
    AeMeasurable (fun a => min (f a) (g a)) Œº :=
  ‚ü®fun a => min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
    EventuallyEq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

end LinearOrder‚Çì

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem Continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Measurable f :=
  hf.borel_measurable.mono OpensMeasurableSpace.borel_le (le_of_eq‚Çì <| BorelSpace.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
theorem Continuous.ae_measurable {f : Œ± ‚Üí Œ≥} (h : Continuous f) {Œº : Measure‚Çì Œ±} : AeMeasurable f Œº :=
  h.Measurable.AeMeasurable

theorem ClosedEmbedding.measurable {f : Œ± ‚Üí Œ≥} (hf : ClosedEmbedding f) : Measurable f :=
  hf.Continuous.Measurable

theorem Continuous.is_open_pos_measure_map {f : Œ≤ ‚Üí Œ≥} (hf : Continuous f) (hf_surj : Function.Surjective f)
    {Œº : Measure‚Çì Œ≤} [Œº.IsOpenPosMeasure] : (Measure.map f Œº).IsOpenPosMeasure := by
  refine' ‚ü®fun U hUo hUne => _‚ü©
  rw [measure.map_apply hf.measurable hUo.measurable_set]
  exact (hUo.preimage hf).measure_ne_zero Œº (hf_surj.nonempty_preimage.mpr hUne)

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
theorem ContinuousOn.measurable_piecewise {f g : Œ± ‚Üí Œ≥} {s : Set Œ±} [‚àÄ j : Œ±, Decidable (j ‚àà s)] (hf : ContinuousOn f s)
    (hg : ContinuousOn g (s·∂ú)) (hs : MeasurableSet s) : Measurable (s.piecewise f g) := by
  refine' measurable_of_is_open fun t ht => _
  rw [piecewise_preimage, Set.Ite]
  apply MeasurableSet.union
  ¬∑ rcases _root_.continuous_on_iff'.1 hf t ht with ‚ü®u, u_open, hu‚ü©
    rw [hu]
    exact u_open.measurable_set.inter hs
    
  ¬∑ rcases _root_.continuous_on_iff'.1 hg t ht with ‚ü®u, u_open, hu‚ü©
    rw [diff_eq_compl_inter, inter_comm, hu]
    exact u_open.measurable_set.inter hs.compl
    

@[to_additive]
instance (priority := 100) HasContinuousMul.has_measurable_mul [Mul Œ≥] [HasContinuousMul Œ≥] : HasMeasurableMul Œ≥ where
  measurable_const_mul := fun c => (continuous_const.mul continuous_id).Measurable
  measurable_mul_const := fun c => (continuous_id.mul continuous_const).Measurable

instance (priority := 100) HasContinuousSub.has_measurable_sub [Sub Œ≥] [HasContinuousSub Œ≥] : HasMeasurableSub Œ≥ where
  measurable_const_sub := fun c => (continuous_const.sub continuous_id).Measurable
  measurable_sub_const := fun c => (continuous_id.sub continuous_const).Measurable

@[to_additive]
instance (priority := 100) TopologicalGroup.has_measurable_inv [Group‚Çì Œ≥] [TopologicalGroup Œ≥] : HasMeasurableInv Œ≥ :=
  ‚ü®continuous_inv.Measurable‚ü©

instance (priority := 100) HasContinuousSmul.has_measurable_smul {M Œ±} [TopologicalSpace M] [TopologicalSpace Œ±]
    [MeasurableSpace M] [MeasurableSpace Œ±] [OpensMeasurableSpace M] [BorelSpace Œ±] [HasSmul M Œ±]
    [HasContinuousSmul M Œ±] : HasMeasurableSmul M Œ± :=
  ‚ü®fun c => (continuous_const_smul _).Measurable, fun y => (continuous_id.smul continuous_const).Measurable‚ü©

section Lattice

instance (priority := 100) HasContinuousSup.has_measurable_sup [HasSup Œ≥] [HasContinuousSup Œ≥] :
    HasMeasurableSup Œ≥ where
  measurable_const_sup := fun c => (continuous_const.sup continuous_id).Measurable
  measurable_sup_const := fun c => (continuous_id.sup continuous_const).Measurable

instance (priority := 100) HasContinuousSup.has_measurable_sup‚ÇÇ [SecondCountableTopology Œ≥] [HasSup Œ≥]
    [HasContinuousSup Œ≥] : HasMeasurableSup‚ÇÇ Œ≥ :=
  ‚ü®continuous_sup.Measurable‚ü©

instance (priority := 100) HasContinuousInf.has_measurable_inf [HasInf Œ≥] [HasContinuousInf Œ≥] :
    HasMeasurableInf Œ≥ where
  measurable_const_inf := fun c => (continuous_const.inf continuous_id).Measurable
  measurable_inf_const := fun c => (continuous_id.inf continuous_const).Measurable

instance (priority := 100) HasContinuousInf.has_measurable_inf‚ÇÇ [SecondCountableTopology Œ≥] [HasInf Œ≥]
    [HasContinuousInf Œ≥] : HasMeasurableInf‚ÇÇ Œ≥ :=
  ‚ü®continuous_inf.Measurable‚ü©

end Lattice

section Homeomorph

@[measurability]
protected theorem Homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : Measurable h :=
  h.Continuous.Measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def Homeomorph.toMeasurableEquiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ where
  measurable_to_fun := h.Measurable
  measurable_inv_fun := h.symm.Measurable
  toEquiv := h.toEquiv

@[simp]
theorem Homeomorph.to_measurable_equiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
  rfl

@[simp]
theorem Homeomorph.to_measurable_equiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.toMeasurableEquiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
  rfl

end Homeomorph

@[measurability]
theorem ContinuousMap.measurable (f : C(Œ±, Œ≥)) : Measurable f :=
  f.Continuous.Measurable

theorem measurable_of_continuous_on_compl_singleton [T1Space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±) (hf : ContinuousOn f ({a}·∂ú)) :
    Measurable f :=
  measurable_of_measurable_on_compl_singleton a (continuous_on_iff_continuous_restrict.1 hf).Measurable

theorem Continuous.measurable2 [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤}
    {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : Measurable f) (hg : Measurable g) :
    Measurable fun a => c (f a) (g a) :=
  h.Measurable.comp (hf.prod_mk hg)

theorem Continuous.ae_measurable2 [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤}
    {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : Measure‚Çì Œ¥} (h : Continuous fun p : Œ± √ó Œ≤ => c p.1 p.2) (hf : AeMeasurable f Œº)
    (hg : AeMeasurable g Œº) : AeMeasurable (fun a => c (f a) (g a)) Œº :=
  h.Measurable.comp_ae_measurable (hf.prod_mk hg)

instance (priority := 100) HasContinuousInv‚ÇÄ.has_measurable_inv [GroupWithZero‚Çì Œ≥] [T1Space Œ≥] [HasContinuousInv‚ÇÄ Œ≥] :
    HasMeasurableInv Œ≥ :=
  ‚ü®measurable_of_continuous_on_compl_singleton 0 continuous_on_inv‚ÇÄ‚ü©

@[to_additive]
instance (priority := 100) HasContinuousMul.has_measurable_mul‚ÇÇ [SecondCountableTopology Œ≥] [Mul Œ≥]
    [HasContinuousMul Œ≥] : HasMeasurableMul‚ÇÇ Œ≥ :=
  ‚ü®continuous_mul.Measurable‚ü©

instance (priority := 100) HasContinuousSub.has_measurable_sub‚ÇÇ [SecondCountableTopology Œ≥] [Sub Œ≥]
    [HasContinuousSub Œ≥] : HasMeasurableSub‚ÇÇ Œ≥ :=
  ‚ü®continuous_sub.Measurable‚ü©

instance (priority := 100) HasContinuousSmul.has_measurable_smul‚ÇÇ {M Œ±} [TopologicalSpace M] [SecondCountableTopology M]
    [MeasurableSpace M] [OpensMeasurableSpace M] [TopologicalSpace Œ±] [SecondCountableTopology Œ±] [MeasurableSpace Œ±]
    [BorelSpace Œ±] [HasSmul M Œ±] [HasContinuousSmul M Œ±] : HasMeasurableSmul‚ÇÇ M Œ± :=
  ‚ü®continuous_smul.Measurable‚ü©

end

section BorelSpace

variable [TopologicalSpace Œ±] [MeasurableSpace Œ±] [BorelSpace Œ±] [TopologicalSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]
  [TopologicalSpace Œ≥] [MeasurableSpace Œ≥] [BorelSpace Œ≥] [MeasurableSpace Œ¥]

theorem pi_le_borel_pi {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, MeasurableSpace (œÄ i)]
    [‚àÄ i, BorelSpace (œÄ i)] : MeasurableSpace.pi ‚â§ borel (‚àÄ i, œÄ i) := by
  have : ‚Äπ‚àÄ i, MeasurableSpace (œÄ i)‚Ä∫ = fun i => borel (œÄ i) := funext fun i => BorelSpace.measurable_eq
  rw [this]
  exact supr_le fun i => comap_le_iff_le_map.2 <| (continuous_apply i).borel_measurable

theorem prod_le_borel_prod : Prod.measurableSpace ‚â§ borel (Œ± √ó Œ≤) := by
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, ‚ÄπBorelSpace Œ≤‚Ä∫.measurable_eq]
  refine' sup_le _ _
  ¬∑ exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable
    
  ¬∑ exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable
    

instance Pi.borel_space_fintype_encodable {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Encodable Œπ] [t' : ‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] : BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm‚Çì pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©

instance Pi.borel_space_fintype {Œπ : Type _} {œÄ : Œπ ‚Üí Type _} [Fintype Œπ] [t' : ‚àÄ i, TopologicalSpace (œÄ i)]
    [‚àÄ i, MeasurableSpace (œÄ i)] [‚àÄ i, SecondCountableTopology (œÄ i)] [‚àÄ i, BorelSpace (œÄ i)] : BorelSpace (‚àÄ i, œÄ i) :=
  ‚ü®le_antisymm‚Çì pi_le_borel_pi OpensMeasurableSpace.borel_le‚ü©

instance Prod.borel_space [SecondCountableTopology Œ±] [SecondCountableTopology Œ≤] : BorelSpace (Œ± √ó Œ≤) :=
  ‚ü®le_antisymm‚Çì prod_le_borel_prod OpensMeasurableSpace.borel_le‚ü©

protected theorem Embedding.measurable_embedding {f : Œ± ‚Üí Œ≤} (h‚ÇÅ : Embedding f) (h‚ÇÇ : MeasurableSet (Range f)) :
    MeasurableEmbedding f :=
  show MeasurableEmbedding (coe ‚àò (Homeomorph.ofEmbedding f h‚ÇÅ).toMeasurableEquiv) from
    (MeasurableEmbedding.subtype_coe h‚ÇÇ).comp (MeasurableEquiv.measurable_embedding _)

protected theorem ClosedEmbedding.measurable_embedding {f : Œ± ‚Üí Œ≤} (h : ClosedEmbedding f) : MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.closed_range.MeasurableSet

protected theorem OpenEmbedding.measurable_embedding {f : Œ± ‚Üí Œ≤} (h : OpenEmbedding f) : MeasurableEmbedding f :=
  h.toEmbedding.MeasurableEmbedding h.open_range.MeasurableSet

section LinearOrder‚Çì

variable [LinearOrder‚Çì Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

theorem measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iio x)) : Measurable f := by
  convert measurable_generate_from _
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _)
  rintro _ ‚ü®x, rfl‚ü©
  exact hf x

theorem UpperSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : UpperSemicontinuous f) : Measurable f :=
  measurable_of_Iio fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ioi x)) : Measurable f := by
  convert measurable_generate_from _
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _)
  rintro _ ‚ü®x, rfl‚ü©
  exact hf x

theorem LowerSemicontinuous.measurable [TopologicalSpace Œ¥] [OpensMeasurableSpace Œ¥] {f : Œ¥ ‚Üí Œ±}
    (hf : LowerSemicontinuous f) : Measurable f :=
  measurable_of_Ioi fun y => (hf.is_open_preimage y).MeasurableSet

theorem measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Iic x)) : Measurable f := by
  apply measurable_of_Ioi
  simp_rw [‚Üê compl_Iic, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, MeasurableSet (f ‚Åª¬π' Ici x)) : Measurable f := by
  apply measurable_of_Iio
  simp_rw [‚Üê compl_Ici, preimage_compl, MeasurableSet.compl_iff]
  assumption

theorem Measurable.is_lub {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsLub { a | ‚àÉ i, f i b = a } (g b)) : Measurable g := by
  change ‚àÄ b, IsLub (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generate_from_Ioi Œ±]
  apply measurable_generate_from
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.Preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.Union fun i => hf i (is_open_lt' _).MeasurableSet

private theorem ae_measurable.is_lub_of_nonempty {Œπ} (hŒπ : Nonempty Œπ) {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, AeMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLub { a | ‚àÉ i, f i b = a } (g b)) :
    AeMeasurable g Œº := by
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsLub { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := fun x => ite (x ‚àà AeSeqSet hf p) (g x) (‚ü®g x‚ü© : Nonempty Œ±).some
  have hg_seq : ‚àÄ b, IsLub { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    have hŒ± : Nonempty Œ± := Nonempty.map g ‚ü®b‚ü©
    simp only [‚Üê aeSeq, ‚Üê g_seq]
    split_ifs
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } := by
        ext x
        simp_rw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_ae_seq_set hf h
      
    ¬∑ have h_singleton : { a : Œ± | ‚àÉ i : Œπ, hŒ±.some = a } = {hŒ±.some} := by
        ext1 x
        exact ‚ü®fun hx => hx.some_spec.symm, fun hx => ‚ü®hŒπ.some, hx.symm‚ü©‚ü©
      rw [h_singleton]
      exact is_lub_singleton
      
  refine' ‚ü®g_seq, Measurable.is_lub (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®g x‚ü© : Nonempty Œ±).some) (AeSeqSet hf p)
        (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.is_lub {Œπ} {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AeMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsLub { a | ‚àÉ i, f i b = a } (g b)) : AeMeasurable g Œº := by
  by_cases' hŒº : Œº = 0
  ¬∑ rw [hŒº]
    exact ae_measurable_zero_measure
    
  have : Œº.ae.ne_bot := by
    simpa [‚Üê ne_bot_iff]
  by_cases' hŒπ : Nonempty Œπ
  ¬∑ exact ae_measurable.is_lub_of_nonempty hŒπ hf hg
    
  suffices ‚àÉ x, g =·µê[Œº] fun y => g x by
    exact ‚ü®fun y => g this.some, measurable_const, this.some_spec‚ü©
  have h_empty : ‚àÄ x, { a : Œ± | ‚àÉ i : Œπ, f i x = a } = ‚àÖ := by
    intro x
    ext1 y
    rw [Set.mem_set_of_eq, Set.mem_empty_eq, iff_false‚Çì]
    exact fun hi => hŒπ (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  exact ‚ü®hg.exists.some, hg.mono fun y hy => IsLub.unique hy hg.exists.some_spec‚ü©

theorem Measurable.is_glb {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i))
    (hg : ‚àÄ b, IsGlb { a | ‚àÉ i, f i b = a } (g b)) : Measurable g := by
  change ‚àÄ b, IsGlb (range fun i => f i b) (g b) at hg
  rw [‚ÄπBorelSpace Œ±‚Ä∫.measurable_eq, borel_eq_generate_from_Iio Œ±]
  apply measurable_generate_from
  rintro _ ‚ü®a, rfl‚ü©
  simp_rw [Set.Preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists]
  exact MeasurableSet.Union fun i => hf i (is_open_gt' _).MeasurableSet

private theorem ae_measurable.is_glb_of_nonempty {Œπ} (hŒπ : Nonempty Œπ) {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
    {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, AeMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGlb { a | ‚àÉ i, f i b = a } (g b)) :
    AeMeasurable g Œº := by
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := fun x f' => IsGlb { a | ‚àÉ i, f' i = a } (g x)
  let g_seq := fun x => ite (x ‚àà AeSeqSet hf p) (g x) (‚ü®g x‚ü© : Nonempty Œ±).some
  have hg_seq : ‚àÄ b, IsGlb { a | ‚àÉ i, aeSeq hf p i b = a } (g_seq b) := by
    intro b
    have hŒ± : Nonempty Œ± := Nonempty.map g ‚ü®b‚ü©
    simp only [‚Üê aeSeq, ‚Üê g_seq]
    split_ifs
    ¬∑ have h_set_eq : { a : Œ± | ‚àÉ i : Œπ, (hf i).mk (f i) b = a } = { a : Œ± | ‚àÉ i : Œπ, f i b = a } := by
        ext x
        simp_rw [Set.mem_set_of_eq, aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h]
      rw [h_set_eq]
      exact aeSeq.fun_prop_of_mem_ae_seq_set hf h
      
    ¬∑ have h_singleton : { a : Œ± | ‚àÉ i : Œπ, hŒ±.some = a } = {hŒ±.some} := by
        ext1 x
        exact ‚ü®fun hx => hx.some_spec.symm, fun hx => ‚ü®hŒπ.some, hx.symm‚ü©‚ü©
      rw [h_singleton]
      exact is_glb_singleton
      
  refine' ‚ü®g_seq, Measurable.is_glb (aeSeq.measurable hf p) hg_seq, _‚ü©
  exact
    (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®g x‚ü© : Nonempty Œ±).some) (AeSeqSet hf p)
        (aeSeq.measure_compl_ae_seq_set_eq_zero hf hg)).symm

theorem AeMeasurable.is_glb {Œπ} {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
    (hf : ‚àÄ i, AeMeasurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, IsGlb { a | ‚àÉ i, f i b = a } (g b)) : AeMeasurable g Œº := by
  by_cases' hŒº : Œº = 0
  ¬∑ rw [hŒº]
    exact ae_measurable_zero_measure
    
  have : Œº.ae.ne_bot := by
    simpa [‚Üê ne_bot_iff]
  by_cases' hŒπ : Nonempty Œπ
  ¬∑ exact ae_measurable.is_glb_of_nonempty hŒπ hf hg
    
  suffices ‚àÉ x, g =·µê[Œº] fun y => g x by
    exact ‚ü®fun y => g this.some, measurable_const, this.some_spec‚ü©
  have h_empty : ‚àÄ x, { a : Œ± | ‚àÉ i : Œπ, f i x = a } = ‚àÖ := by
    intro x
    ext1 y
    rw [Set.mem_set_of_eq, Set.mem_empty_eq, iff_false‚Çì]
    exact fun hi => hŒπ (nonempty_of_exists hi)
  simp_rw [h_empty] at hg
  exact ‚ü®hg.exists.some, hg.mono fun y hy => IsGlb.unique hy hg.exists.some_spec‚ü©

protected theorem Monotone.measurable [LinearOrder‚Çì Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : Monotone f) :
    Measurable f :=
  suffices h : ‚àÄ x, OrdConnected (f ‚Åª¬π' Ioi x) from measurable_of_Ioi fun x => (h x).MeasurableSet
  fun x => ord_connected_def.mpr fun a ha b hb c hc => lt_of_lt_of_le‚Çì ha (hf hc.1)

theorem ae_measurable_restrict_of_monotone_on [LinearOrder‚Çì Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure‚Çì Œ≤} {s : Set Œ≤}
    (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : MonotoneOn f s) : AeMeasurable f (Œº.restrict s) :=
  have this : Monotone (f ‚àò coe : s ‚Üí Œ±) := fun ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© (hxy : x ‚â§ y) => hf hx hy hxy
  ae_measurable_restrict_of_measurable_subtype hs this.Measurable

protected theorem Antitone.measurable [LinearOrder‚Çì Œ≤] [OrderClosedTopology Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : Antitone f) :
    Measurable f :=
  @Monotone.measurable Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf

theorem ae_measurable_restrict_of_antitone_on [LinearOrder‚Çì Œ≤] [OrderClosedTopology Œ≤] {Œº : Measure‚Çì Œ≤} {s : Set Œ≤}
    (hs : MeasurableSet s) {f : Œ≤ ‚Üí Œ±} (hf : AntitoneOn f s) : AeMeasurable f (Œº.restrict s) :=
  @ae_measurable_restrict_of_monotone_on Œ±·µí·µà Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf

theorem measurable_set_of_mem_nhds_within_Ioi_aux {s : Set Œ±} (h : ‚àÄ, ‚àÄ x ‚àà s, ‚àÄ, s ‚àà ùìù[>] x)
    (h' : ‚àÄ, ‚àÄ x ‚àà s, ‚àÄ, ‚àÉ y, x < y) : MeasurableSet s := by
  choose! M hM using h'
  suffices H : (s \ Interior s).Countable
  ¬∑ have : s = Interior s ‚à™ s \ Interior s := by
      rw [union_diff_cancel interior_subset]
    rw [this]
    exact is_open_interior.measurable_set.union H.measurable_set
    
  have A : ‚àÄ, ‚àÄ x ‚àà s, ‚àÄ, ‚àÉ y ‚àà Ioi x, Ioo x y ‚äÜ s := fun x hx =>
    (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (hM x hx)).1 (h x hx)
  choose! y hy h'y using A
  have B : Set.PairwiseDisjoint (s \ Interior s) fun x => Ioo x (y x) := by
    intro x hx x' hx' hxx'
    rcases lt_or_gt_of_ne‚Çì hxx' with (h' | h')
    ¬∑ apply disjoint_left.2 fun z hz h'z => _
      have : x' ‚àà Interior s := mem_interior.2 ‚ü®Ioo x (y x), h'y _ hx.1, is_open_Ioo, ‚ü®h', h'z.1.trans hz.2‚ü©‚ü©
      exact False.elim (hx'.2 this)
      
    ¬∑ apply disjoint_left.2 fun z hz h'z => _
      have : x ‚àà Interior s := mem_interior.2 ‚ü®Ioo x' (y x'), h'y _ hx'.1, is_open_Ioo, ‚ü®h', hz.1.trans h'z.2‚ü©‚ü©
      exact False.elim (hx.2 this)
      
  exact B.countable_of_Ioo fun x hx => hy x hx.1

/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/
theorem measurable_set_of_mem_nhds_within_Ioi {s : Set Œ±} (h : ‚àÄ, ‚àÄ x ‚àà s, ‚àÄ, s ‚àà ùìù[>] x) : MeasurableSet s := by
  by_cases' H : ‚àÉ x ‚àà s, IsTop x
  ¬∑ rcases H with ‚ü®x‚ÇÄ, x‚ÇÄs, h‚ÇÄ‚ü©
    have : s = {x‚ÇÄ} ‚à™ s \ {x‚ÇÄ} := by
      rw [union_diff_cancel (singleton_subset_iff.2 x‚ÇÄs)]
    rw [this]
    refine' (measurable_set_singleton _).union _
    have A : ‚àÄ, ‚àÄ x ‚àà s \ {x‚ÇÄ}, ‚àÄ, x < x‚ÇÄ := fun x hx =>
      lt_of_le_of_ne‚Çì (h‚ÇÄ _)
        (by
          simpa using hx.2)
    refine' measurable_set_of_mem_nhds_within_Ioi_aux (fun x hx => _) fun x hx => ‚ü®x‚ÇÄ, A x hx‚ü©
    obtain ‚ü®u, hu, us‚ü© : ‚àÉ (u : Œ±)(H : u ‚àà Ioi x), Ioo x u ‚äÜ s :=
      (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).1 (h x hx.1)
    refine' (mem_nhds_within_Ioi_iff_exists_Ioo_subset' (A x hx)).2 ‚ü®u, hu, fun y hy => ‚ü®us hy, _‚ü©‚ü©
    exact ne_of_lt‚Çì (hy.2.trans_le (h‚ÇÄ _))
    
  ¬∑ apply measurable_set_of_mem_nhds_within_Ioi_aux h
    simp only [‚Üê IsTop] at H
    push_neg  at H
    exact H
    

end LinearOrder‚Çì

@[measurability]
theorem Measurable.supr_Prop {Œ±} [MeasurableSpace Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) :
    Measurable fun b => ‚®Ü h : p, f b :=
  Classical.by_cases
    (fun h : p => by
      convert hf
      funext
      exact supr_pos h)
    fun h : ¬¨p => by
    convert measurable_const
    funext
    exact supr_neg h

@[measurability]
theorem Measurable.infi_Prop {Œ±} [MeasurableSpace Œ±] [CompleteLattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : Measurable f) :
    Measurable fun b => ‚®Ö h : p, f b :=
  Classical.by_cases
    (fun h : p => by
      convert hf
      funext
      exact infi_pos h)
    fun h : ¬¨p => by
    convert measurable_const
    funext
    exact infi_neg h

section CompleteLinearOrder

variable [CompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_supr {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ü i, f i b :=
  (Measurable.is_lub hf) fun b => is_lub_supr

@[measurability]
theorem ae_measurable_supr {Œπ} {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, AeMeasurable (f i) Œº) :
    AeMeasurable (fun b => ‚®Ü i, f i b) Œº :=
  AeMeasurable.is_lub hf <| ae_of_all Œº fun b => is_lub_supr

@[measurability]
theorem measurable_infi {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i, f i b :=
  (Measurable.is_glb hf) fun b => is_glb_infi

@[measurability]
theorem ae_measurable_infi {Œπ} {Œº : Measure‚Çì Œ¥} [Encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, AeMeasurable (f i) Œº) :
    AeMeasurable (fun b => ‚®Ö i, f i b) Œº :=
  AeMeasurable.is_glb hf <| ae_of_all Œº fun b => is_glb_infi

theorem measurable_bsupr {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable) (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ü i ‚àà s, f i b := by
  have : Encodable s := hs.to_encodable
  simp only [‚Üê supr_subtype']
  exact measurable_supr fun i => hf i

theorem ae_measurable_bsupr {Œπ} {Œº : Measure‚Çì Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, AeMeasurable (f i) Œº) : AeMeasurable (fun b => ‚®Ü i ‚àà s, f i b) Œº := by
  have : Encodable s := hs.to_encodable
  simp only [‚Üê supr_subtype']
  exact ae_measurable_supr fun i => hf i

theorem measurable_binfi {Œπ} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable) (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun b => ‚®Ö i ‚àà s, f i b := by
  have : Encodable s := hs.to_encodable
  simp only [‚Üê infi_subtype']
  exact measurable_infi fun i => hf i

theorem ae_measurable_binfi {Œπ} {Œº : Measure‚Çì Œ¥} (s : Set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : s.Countable)
    (hf : ‚àÄ i, AeMeasurable (f i) Œº) : AeMeasurable (fun b => ‚®Ö i ‚àà s, f i b) Œº := by
  have : Encodable s := hs.to_encodable
  simp only [‚Üê infi_subtype']
  exact ae_measurable_infi fun i => hf i

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
theorem measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i)) {p : Œπ' ‚Üí Prop}
    {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => liminf‚Çì u fun i => f i x := by
  simp_rw [hu.to_has_basis.liminf_eq_supr_infi]
  refine' measurable_bsupr _ hu.countable _
  exact fun i => measurable_binfi _ (hs i) hf

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
theorem measurable_limsup' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : Filter Œπ} (hf : ‚àÄ i, Measurable (f i)) {p : Œπ' ‚Üí Prop}
    {s : Œπ' ‚Üí Set Œπ} (hu : u.HasCountableBasis p s) (hs : ‚àÄ i, (s i).Countable) :
    Measurable fun x => limsup‚Çì u fun i => f i x := by
  simp_rw [hu.to_has_basis.limsup_eq_infi_supr]
  refine' measurable_binfi _ hu.countable _
  exact fun i => measurable_bsupr _ (hs i) hf

/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
theorem measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => liminf‚Çì atTop fun i => f i x :=
  measurable_liminf' hf at_top_countable_basis fun i => countable_encodable _

/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
theorem measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => limsup‚Çì atTop fun i => f i x :=
  measurable_limsup' hf at_top_countable_basis fun i => countable_encodable _

end CompleteLinearOrder

section ConditionallyCompleteLinearOrder

variable [ConditionallyCompleteLinearOrder Œ±] [OrderTopology Œ±] [SecondCountableTopology Œ±]

theorem measurable_cSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : Set Œπ} (hs : s.Countable) (hf : ‚àÄ i, Measurable (f i))
    (bdd : ‚àÄ x, BddAbove ((fun i => f i x) '' s)) : Measurable fun x => sup ((fun i => f i x) '' s) := by
  cases' eq_empty_or_nonempty s with h2s h2s
  ¬∑ simp [‚Üê h2s, ‚Üê measurable_const]
    
  ¬∑ apply measurable_of_Iic
    intro y
    simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall]
    exact MeasurableSet.bInter hs fun i hi => measurable_set_le (hf i) measurable_const
    

end ConditionallyCompleteLinearOrder

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def Homemorph.toMeasurableEquiv (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤ where
  toEquiv := h.toEquiv
  measurable_to_fun := h.continuous_to_fun.Measurable
  measurable_inv_fun := h.continuous_inv_fun.Measurable

protected theorem IsFiniteMeasureOnCompacts.map {Œ± : Type _} {m0 : MeasurableSpace Œ±} [TopologicalSpace Œ±]
    [OpensMeasurableSpace Œ±] {Œ≤ : Type _} [MeasurableSpace Œ≤] [TopologicalSpace Œ≤] [BorelSpace Œ≤] [T2Space Œ≤]
    (Œº : Measure‚Çì Œ±) [IsFiniteMeasureOnCompacts Œº] (f : Œ± ‚âÉ‚Çú Œ≤) : IsFiniteMeasureOnCompacts (Measure.map f Œº) :=
  ‚ü®by
    intro K hK
    rw [measure.map_apply f.measurable hK.measurable_set]
    apply IsCompact.measure_lt_top
    rwa [f.compact_preimage]‚ü©

end BorelSpace

instance Empty.borel_space : BorelSpace Empty :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Unit.borel_space : BorelSpace Unit :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Bool.borel_space : BorelSpace Bool :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Nat.borel_space : BorelSpace ‚Ñï :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Int.borel_space : BorelSpace ‚Ñ§ :=
  ‚ü®borel_eq_top_of_discrete.symm‚ü©

instance Rat.borel_space : BorelSpace ‚Ñö :=
  ‚ü®borel_eq_top_of_encodable.symm‚ü©

instance (priority := 900) IsROrC.measurableSpace {ùïú : Type _} [IsROrC ùïú] : MeasurableSpace ùïú :=
  borel ùïú

instance (priority := 900) IsROrC.borel_space {ùïú : Type _} [IsROrC ùïú] : BorelSpace ùïú :=
  ‚ü®rfl‚ü©

/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,
Lean fails to prove `borel_space (Œπ ‚Üí ‚Ñù)`, so we leave them here. -/
instance Real.measurableSpace : MeasurableSpace ‚Ñù :=
  borel ‚Ñù

instance Real.borel_space : BorelSpace ‚Ñù :=
  ‚ü®rfl‚ü©

instance Nnreal.measurableSpace : MeasurableSpace ‚Ñù‚â•0 :=
  Subtype.measurableSpace

instance Nnreal.borel_space : BorelSpace ‚Ñù‚â•0 :=
  Subtype.borel_space _

instance Ennreal.measurableSpace : MeasurableSpace ‚Ñù‚â•0‚àû :=
  borel ‚Ñù‚â•0‚àû

instance Ennreal.borel_space : BorelSpace ‚Ñù‚â•0‚àû :=
  ‚ü®rfl‚ü©

instance Ereal.measurableSpace : MeasurableSpace Ereal :=
  borel Ereal

instance Ereal.borel_space : BorelSpace Ereal :=
  ‚ü®rfl‚ü©

instance Complex.measurableSpace : MeasurableSpace ‚ÑÇ :=
  borel ‚ÑÇ

instance Complex.borel_space : BorelSpace ‚ÑÇ :=
  ‚ü®rfl‚ü©

/-- One can cut out `‚Ñù‚â•0‚àû` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : ‚Ñ§` and `{‚àû}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
theorem measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [MeasurableSpace Œ±] (Œº : Measure‚Çì Œ±) {f : Œ± ‚Üí ‚Ñù‚â•0‚àû}
    (hf : Measurable f) {s : Set Œ±} (hs : MeasurableSet s) {t : ‚Ñù‚â•0 } (ht : 1 < t) :
    Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' {‚àû}) + ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico (t ^ n) (t ^ (n + 1))) := by
  have A : Œº s = Œº (s ‚à© f ‚Åª¬π' {0}) + Œº (s ‚à© f ‚Åª¬π' Ioi 0) := by
    rw [‚Üê measure_union]
    ¬∑ congr 1
      ext x
      have : 0 = f x ‚à® 0 < f x := eq_or_lt_of_le bot_le
      rw [eq_comm] at this
      simp only [and_or_distrib_left, ‚Üê this, ‚Üê mem_singleton_iff, ‚Üê mem_inter_eq, ‚Üê and_true‚Çì, ‚Üê mem_union_eq, ‚Üê
        mem_Ioi, ‚Üê mem_preimage]
      
    ¬∑ apply disjoint_left.2 fun x hx h'x => _
      have : 0 < f x := h'x.2
      exact lt_irrefl‚Çì 0 (this.trans_le hx.2.le)
      
    ¬∑ exact hs.inter (hf measurable_set_Ioi)
      
  have B : Œº (s ‚à© f ‚Åª¬π' Ioi 0) = Œº (s ‚à© f ‚Åª¬π' {‚àû}) + Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) := by
    rw [‚Üê measure_union]
    ¬∑ rw [‚Üê inter_union_distrib_left]
      congr
      ext x
      simp only [‚Üê mem_singleton_iff, ‚Üê mem_union_eq, ‚Üê mem_Ioo, ‚Üê mem_Ioi, ‚Üê mem_preimage]
      have H : f x = ‚àû ‚à® f x < ‚àû := eq_or_lt_of_le le_top
      cases H
      ¬∑ simp only [‚Üê H, ‚Üê eq_self_iff_true, ‚Üê or_false‚Çì, ‚Üê WithTop.zero_lt_top, ‚Üê not_top_lt, ‚Üê and_false‚Çì]
        
      ¬∑ simp only [‚Üê H, ‚Üê H.ne, ‚Üê and_true‚Çì, ‚Üê false_or‚Çì]
        
      
    ¬∑ apply disjoint_left.2 fun x hx h'x => _
      have : f x < ‚àû := h'x.2.2
      exact lt_irrefl‚Çì _ (this.trans_le (le_of_eq‚Çì hx.2.symm))
      
    ¬∑ exact hs.inter (hf measurable_set_Ioo)
      
  have C : Œº (s ‚à© f ‚Åª¬π' Ioo 0 ‚àû) = ‚àë' n : ‚Ñ§, Œº (s ‚à© f ‚Åª¬π' Ico (t ^ n) (t ^ (n + 1))) := by
    rw [‚Üê measure_Union, Ennreal.Ioo_zero_top_eq_Union_Ico_zpow (Ennreal.one_lt_coe_iff.2 ht) Ennreal.coe_ne_top,
      preimage_Union, inter_Union]
    ¬∑ intro i j
      simp only [‚Üê Function.onFun]
      wlog (discharger := tactic.skip) h : i ‚â§ j := le_total‚Çì i j using i j, j i
      ¬∑ intro hij
        replace hij : i + 1 ‚â§ j := lt_of_le_of_ne‚Çì h hij
        apply disjoint_left.2 fun x hx h'x => lt_irrefl‚Çì (f x) _
        calc f x < t ^ (i + 1) := hx.2.2_ ‚â§ t ^ j :=
            Ennreal.zpow_le_of_le (Ennreal.one_le_coe_iff.2 ht.le) hij _ ‚â§ f x := h'x.2.1
        
      ¬∑ intro hij
        rw [Disjoint.comm]
        exact this hij.symm
        
      
    ¬∑ intro n
      exact hs.inter (hf measurable_set_Ico)
      
  rw [A, B, C, add_assoc‚Çì]

section PseudoMetricSpace

variable [PseudoMetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open Metric

@[measurability]
theorem measurable_set_ball : MeasurableSet (Metric.Ball x Œµ) :=
  Metric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_set_closed_ball : MeasurableSet (Metric.ClosedBall x Œµ) :=
  Metric.is_closed_ball.MeasurableSet

@[measurability]
theorem measurable_inf_dist {s : Set Œ±} : Measurable fun x => infDist x s :=
  (continuous_inf_dist_pt s).Measurable

@[measurability]
theorem Measurable.inf_dist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} : Measurable fun x => infDist (f x) s :=
  measurable_inf_dist.comp hf

@[measurability]
theorem measurable_inf_nndist {s : Set Œ±} : Measurable fun x => infNndist x s :=
  (continuous_inf_nndist_pt s).Measurable

@[measurability]
theorem Measurable.inf_nndist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} : Measurable fun x => infNndist (f x) s :=
  measurable_inf_nndist.comp hf

section

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_dist : Measurable fun p : Œ± √ó Œ± => dist p.1 p.2 :=
  continuous_dist.Measurable

@[measurability]
theorem Measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) : Measurable fun b => dist (f b) (g b) :=
  (@continuous_dist Œ± _).measurable2 hf hg

@[measurability]
theorem measurable_nndist : Measurable fun p : Œ± √ó Œ± => nndist p.1 p.2 :=
  continuous_nndist.Measurable

@[measurability]
theorem Measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => nndist (f b) (g b) :=
  (@continuous_nndist Œ± _).measurable2 hf hg

end

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening {Œº : Measure‚Çì Œ±} {s : Set Œ±} (hs : ‚àÉ R > 0, Œº (Cthickening R s) ‚â† ‚àû) :
    Tendsto (fun r => Œº (Cthickening r s)) (ùìù 0) (ùìù (Œº (Closure s))) := by
  have A : tendsto (fun r => Œº (cthickening r s)) (ùìù[Ioi 0] 0) (ùìù (Œº (Closure s))) := by
    rw [closure_eq_Inter_cthickening]
    exact
      tendsto_measure_bInter_gt (fun r hr => is_closed_cthickening.measurable_set)
        (fun i j ipos ij => cthickening_mono ij _) hs
  have B : tendsto (fun r => Œº (cthickening r s)) (ùìù[Iic 0] 0) (ùìù (Œº (Closure s))) := by
    apply tendsto.congr' _ tendsto_const_nhds
    filter_upwards [self_mem_nhds_within] with _ hr
    rw [cthickening_of_nonpos hr]
  convert B.sup A
  exact (nhds_left_sup_nhds_right' 0).symm

/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_is_closed {Œº : Measure‚Çì Œ±} {s : Set Œ±} (hs : ‚àÉ R > 0, Œº (Cthickening R s) ‚â† ‚àû)
    (h's : IsClosed s) : Tendsto (fun r => Œº (Cthickening r s)) (ùìù 0) (ùìù (Œº s)) := by
  convert tendsto_measure_cthickening hs
  exact h's.closure_eq.symm

end PseudoMetricSpace

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
theorem tendsto_measure_cthickening_of_is_compact [MetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]
    [ProperSpace Œ±] {Œº : Measure‚Çì Œ±} [IsFiniteMeasureOnCompacts Œº] {s : Set Œ±} (hs : IsCompact s) :
    Tendsto (fun r => Œº (Metric.Cthickening r s)) (ùìù 0) (ùìù (Œº s)) :=
  tendsto_measure_cthickening_of_is_closed ‚ü®1, zero_lt_one, hs.Bounded.Cthickening.measure_lt_top.Ne‚ü© hs.IsClosed

section PseudoEmetricSpace

variable [PseudoEmetricSpace Œ±] [MeasurableSpace Œ±] [OpensMeasurableSpace Œ±]

variable [MeasurableSpace Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open Emetric

@[measurability]
theorem measurable_set_eball : MeasurableSet (Emetric.Ball x Œµ) :=
  Emetric.is_open_ball.MeasurableSet

@[measurability]
theorem measurable_edist_right : Measurable (edist x) :=
  (continuous_const.edist continuous_id).Measurable

@[measurability]
theorem measurable_edist_left : Measurable fun y => edist y x :=
  (continuous_id.edist continuous_const).Measurable

@[measurability]
theorem measurable_inf_edist {s : Set Œ±} : Measurable fun x => infEdist x s :=
  continuous_inf_edist.Measurable

@[measurability]
theorem Measurable.inf_edist {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) {s : Set Œ±} : Measurable fun x => infEdist (f x) s :=
  measurable_inf_edist.comp hf

variable [SecondCountableTopology Œ±]

@[measurability]
theorem measurable_edist : Measurable fun p : Œ± √ó Œ± => edist p.1 p.2 :=
  continuous_edist.Measurable

@[measurability]
theorem Measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : Measurable f) (hg : Measurable g) :
    Measurable fun b => edist (f b) (g b) :=
  (@continuous_edist Œ± _).measurable2 hf hg

@[measurability]
theorem AeMeasurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : Measure‚Çì Œ≤} (hf : AeMeasurable f Œº) (hg : AeMeasurable g Œº) :
    AeMeasurable (fun a => edist (f a) (g a)) Œº :=
  (@continuous_edist Œ± _).ae_measurable2 hf hg

end PseudoEmetricSpace

namespace Real

open MeasurableSpace MeasureTheory

-- ./././Mathport/Syntax/Translate/Basic.lean:853:6: warning: expanding binder group (a b)
theorem borel_eq_generate_from_Ioo_rat : borel ‚Ñù = generateFrom (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b}) :=
  is_topological_basis_Ioo_rat.borel_eq_generate_from

-- ./././Mathport/Syntax/Translate/Basic.lean:853:6: warning: expanding binder group (a b)
theorem is_pi_system_Ioo_rat : @IsPiSystem ‚Ñù (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b}) := by
  convert is_pi_system_Ioo (coe : ‚Ñö ‚Üí ‚Ñù) (coe : ‚Ñö ‚Üí ‚Ñù)
  ext x
  simp [‚Üê eq_comm]

-- ./././Mathport/Syntax/Translate/Basic.lean:853:6: warning: expanding binder group (a b)
/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finiteSpanningSetsInIooRat (Œº : Measure‚Çì ‚Ñù) [IsLocallyFiniteMeasure Œº] :
    Œº.FiniteSpanningSetsIn (‚ãÉ (a : ‚Ñö) (b : ‚Ñö) (h : a < b), {Ioo a b}) where
  Set := fun n => Ioo (-(n + 1)) (n + 1)
  set_mem := fun n => by
    simp only [‚Üê mem_Union, ‚Üê mem_singleton_iff]
    refine'
      ‚ü®-(n + 1 : ‚Ñï), n + 1, _, by
        simp ‚ü©
    -- TODO: norm_cast fails here?
    exact (neg_nonpos.2 (@Nat.cast_nonneg ‚Ñö _ (n + 1))).trans_lt n.cast_add_one_pos
  Finite := fun n => measure_Ioo_lt_top
  spanning :=
    Union_eq_univ_iff.2 fun x =>
      ‚ü®‚åäabs x‚åã‚Çä, neg_lt.1 ((neg_le_abs_self x).trans_lt (Nat.lt_floor_add_one _)),
        (le_abs_self x).trans_lt (Nat.lt_floor_add_one _)‚ü©

theorem measure_ext_Ioo_rat {Œº ŒΩ : Measure‚Çì ‚Ñù} [IsLocallyFiniteMeasure Œº] (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) :
    Œº = ŒΩ :=
  (finiteSpanningSetsInIooRat Œº).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat <| by
    simp only [‚Üê mem_Union, ‚Üê mem_singleton_iff]
    rintro _ ‚ü®a, b, -, rfl‚ü©
    apply h

theorem borel_eq_generate_from_Iio_rat : borel ‚Ñù = generateFrom (‚ãÉ a : ‚Ñö, {Iio a}) := by
  let g : MeasurableSpace ‚Ñù := generate_from (‚ãÉ a : ‚Ñö, {Iio a})
  refine' le_antisymm‚Çì _ _
  ¬∑ rw [borel_eq_generate_from_Ioo_rat]
    refine' generate_from_le fun t => _
    simp only [‚Üê mem_Union, ‚Üê mem_singleton_iff]
    rintro ‚ü®a, b, h, rfl‚ü©
    rw [(Set.ext fun x => _ : Ioo (a : ‚Ñù) b = (‚ãÉ c > a, Iio c·∂ú) ‚à© Iio b)]
    ¬∑ have hg : ‚àÄ q : ‚Ñö, measurable_set[g] (Iio q) := fun q =>
        generate_measurable.basic (Iio q)
          (by
            simp )
      refine' @MeasurableSet.inter _ g _ _ _ (hg _)
      refine' @MeasurableSet.bUnion _ _ g _ _ (countable_encodable _) fun c h => _
      exact @MeasurableSet.compl _ _ g (hg _)
      
    ¬∑ suffices x < ‚Üëb ‚Üí (‚Üëa < x ‚Üî ‚àÉ i : ‚Ñö, a < i ‚àß ‚Üëi ‚â§ x) by
        simpa
      refine' fun _ => ‚ü®fun h => _, fun ‚ü®i, hai, hix‚ü© => (Rat.cast_lt.2 hai).trans_le hix‚ü©
      rcases exists_rat_btwn h with ‚ü®c, ac, cx‚ü©
      exact ‚ü®c, Rat.cast_lt.1 ac, cx.le‚ü©
      
    
  ¬∑ refine' MeasurableSpace.generate_from_le fun _ => _
    simp only [‚Üê mem_Union, ‚Üê mem_singleton_iff]
    rintro ‚ü®r, rfl‚ü©
    exact measurable_set_Iio
    

end Real

variable [MeasurableSpace Œ±]

@[measurability]
theorem measurable_real_to_nnreal : Measurable Real.toNnreal :=
  continuous_real_to_nnreal.Measurable

@[measurability]
theorem Measurable.real_to_nnreal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) : Measurable fun x => Real.toNnreal (f x) :=
  measurable_real_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.real_to_nnreal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => Real.toNnreal (f x)) Œº :=
  measurable_real_to_nnreal.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_real : Measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
  Nnreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0 } (hf : Measurable f) : Measurable fun x => (f x : ‚Ñù) :=
  measurable_coe_nnreal_real.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0 } {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x : ‚Ñù)) Œº :=
  measurable_coe_nnreal_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_nnreal_ennreal : Measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  Ennreal.continuous_coe.Measurable

@[measurability]
theorem Measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0 } (hf : Measurable f) : Measurable fun x => (f x : ‚Ñù‚â•0‚àû) :=
  Ennreal.continuous_coe.Measurable.comp hf

@[measurability]
theorem AeMeasurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0 } {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº :=
  Ennreal.continuous_coe.Measurable.comp_ae_measurable hf

@[measurability]
theorem Measurable.ennreal_of_real {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) : Measurable fun x => Ennreal.ofReal (f x) :=
  Ennreal.continuous_of_real.Measurable.comp hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0 } : Measurable (fun x => f x : Œ± ‚Üí ‚Ñù) ‚Üî Measurable f :=
  ‚ü®fun h => by
    simpa only [‚Üê Real.to_nnreal_coe] using h.real_to_nnreal, Measurable.coe_nnreal_real‚ü©

@[simp, norm_cast]
theorem ae_measurable_coe_nnreal_real_iff {f : Œ± ‚Üí ‚Ñù‚â•0 } {Œº : Measure‚Çì Œ±} :
    AeMeasurable (fun x => f x : Œ± ‚Üí ‚Ñù) Œº ‚Üî AeMeasurable f Œº :=
  ‚ü®fun h => by
    simpa only [‚Üê Real.to_nnreal_coe] using h.real_to_nnreal, AeMeasurable.coe_nnreal_real‚ü©

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `measurable_equiv` to `‚Ñù‚â•0`. -/
def MeasurableEquiv.ennrealEquivNnreal : { r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû } ‚âÉ·µê ‚Ñù‚â•0 :=
  Ennreal.neTopHomeomorphNnreal.toMeasurableEquiv

namespace Ennreal

theorem measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} (h : Measurable fun p : ‚Ñù‚â•0 => f p) : Measurable f :=
  measurable_of_measurable_on_compl_singleton ‚àû (MeasurableEquiv.ennrealEquivNnreal.symm.measurable_comp_iff.1 h)

/-- `‚Ñù‚â•0‚àû` is `measurable_equiv` to `‚Ñù‚â•0 ‚äï unit`. -/
def ennrealEquivSum : ‚Ñù‚â•0‚àû ‚âÉ·µê Sum ‚Ñù‚â•0 Unit :=
  { Equiv‚Çì.optionEquivSumPunit ‚Ñù‚â•0 with measurable_to_fun := measurable_of_measurable_nnreal measurable_inl,
    measurable_inv_fun := measurable_sum measurable_coe_nnreal_ennreal (@measurable_const ‚Ñù‚â•0‚àû Unit _ _ ‚àû) }

open Function (uncurry)

theorem measurable_of_measurable_nnreal_prod [MeasurableSpace Œ≤] [MeasurableSpace Œ≥] {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥}
    (H‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó Œ≤ => f (p.1, p.2)) (H‚ÇÇ : Measurable fun x => f (‚àû, x)) : Measurable f :=
  let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê Sum ( ‚Ñù‚â•0 √ó Œ≤) (Unit √ó Œ≤) :=
    (ennrealEquivSum.prodCongr (MeasurableEquiv.refl Œ≤)).trans (MeasurableEquiv.sumProdDistrib _ _ _)
  e.symm.measurable_comp_iff.1 <| measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)

theorem measurable_of_measurable_nnreal_nnreal [MeasurableSpace Œ≤] {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤}
    (h‚ÇÅ : Measurable fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => f (p.1, p.2)) (h‚ÇÇ : Measurable fun r : ‚Ñù‚â•0 => f (‚àû, r))
    (h‚ÇÉ : Measurable fun r : ‚Ñù‚â•0 => f (r, ‚àû)) : Measurable f :=
  measurable_of_measurable_nnreal_prod
    (measurable_swap_iff.1 <| measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
    (measurable_of_measurable_nnreal h‚ÇÇ)

@[measurability]
theorem measurable_of_real : Measurable Ennreal.ofReal :=
  Ennreal.continuous_of_real.Measurable

@[measurability]
theorem measurable_to_real : Measurable Ennreal.toReal :=
  Ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
theorem measurable_to_nnreal : Measurable Ennreal.toNnreal :=
  Ennreal.measurable_of_measurable_nnreal measurable_id

instance : HasMeasurableMul‚ÇÇ ‚Ñù‚â•0‚àû := by
  refine' ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©
  ¬∑ simp only [Ennreal.coe_mul, ‚Üê measurable_mul.coe_nnreal_ennreal]
    
  ¬∑ simp only [‚Üê Ennreal.top_mul, ‚Üê Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const
    
  ¬∑ simp only [‚Üê Ennreal.mul_top, ‚Üê Ennreal.coe_eq_zero]
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const
    

instance : HasMeasurableSub‚ÇÇ ‚Ñù‚â•0‚àû :=
  ‚ü®by
    apply measurable_of_measurable_nnreal_nnreal <;>
      simp [WithTop.coe_sub, ‚Üê continuous_sub.measurable.coe_nnreal_ennreal]‚ü©

instance : HasMeasurableInv ‚Ñù‚â•0‚àû :=
  ‚ü®continuous_inv.Measurable‚ü©

end Ennreal

@[measurability]
theorem Measurable.ennreal_to_nnreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) : Measurable fun x => (f x).toNnreal :=
  Ennreal.measurable_to_nnreal.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_nnreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x).toNnreal) Œº :=
  Ennreal.measurable_to_nnreal.comp_ae_measurable hf

@[simp, norm_cast]
theorem measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0 } : (Measurable fun x => (f x : ‚Ñù‚â•0‚àû)) ‚Üî Measurable f :=
  ‚ü®fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennreal‚ü©

@[simp, norm_cast]
theorem ae_measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0 } {Œº : Measure‚Çì Œ±} :
    AeMeasurable (fun x => (f x : ‚Ñù‚â•0‚àû)) Œº ‚Üî AeMeasurable f Œº :=
  ‚ü®fun h => h.ennreal_to_nnreal, fun h => h.coe_nnreal_ennreal‚ü©

@[measurability]
theorem Measurable.ennreal_to_real {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) : Measurable fun x => Ennreal.toReal (f x) :=
  Ennreal.measurable_to_real.comp hf

@[measurability]
theorem AeMeasurable.ennreal_to_real {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => Ennreal.toReal (f x)) Œº :=
  Ennreal.measurable_to_real.comp_ae_measurable hf

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
theorem Measurable.ennreal_tsum {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [Ennreal.tsum_eq_supr_sum]
  apply measurable_supr
  exact fun s => s.measurable_sum fun i _ => h i

@[measurability]
theorem Measurable.ennreal_tsum' {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, Measurable (f i)) :
    Measurable (‚àë' i, f i) := by
  convert Measurable.ennreal_tsum h
  ext1 x
  exact tsum_apply (Pi.summable.2 fun _ => Ennreal.summable)

@[measurability]
theorem Measurable.nnreal_tsum {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0 } (h : ‚àÄ i, Measurable (f i)) :
    Measurable fun x => ‚àë' i, f i x := by
  simp_rw [Nnreal.tsum_eq_to_nnreal_tsum]
  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_to_nnreal

@[measurability]
theorem AeMeasurable.ennreal_tsum {Œπ} [Encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure‚Çì Œ±}
    (h : ‚àÄ i, AeMeasurable (f i) Œº) : AeMeasurable (fun x => ‚àë' i, f i x) Œº := by
  simp_rw [Ennreal.tsum_eq_supr_sum]
  apply ae_measurable_supr
  exact fun s => Finset.ae_measurable_sum s fun i _ => h i

@[measurability]
theorem measurable_coe_real_ereal : Measurable (coe : ‚Ñù ‚Üí Ereal) :=
  continuous_coe_real_ereal.Measurable

@[measurability]
theorem Measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_real_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x : Ereal)) Œº :=
  measurable_coe_real_ereal.comp_ae_measurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `‚Ñù`. -/
def MeasurableEquiv.erealEquivReal : ({‚ä•, ‚ä§}·∂ú : Set Ereal) ‚âÉ·µê ‚Ñù :=
  Ereal.neBotTopHomeomorphReal.toMeasurableEquiv

theorem Ereal.measurable_of_measurable_real {f : Ereal ‚Üí Œ±} (h : Measurable fun p : ‚Ñù => f p) : Measurable f :=
  measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§}
    (by
      simp )
    (MeasurableEquiv.erealEquivReal.symm.measurable_comp_iff.1 h)

@[measurability]
theorem measurable_ereal_to_real : Measurable Ereal.toReal :=
  Ereal.measurable_of_measurable_real
    (by
      simpa using measurable_id)

@[measurability]
theorem Measurable.ereal_to_real {f : Œ± ‚Üí Ereal} (hf : Measurable f) : Measurable fun x => (f x).toReal :=
  measurable_ereal_to_real.comp hf

@[measurability]
theorem AeMeasurable.ereal_to_real {f : Œ± ‚Üí Ereal} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x).toReal) Œº :=
  measurable_ereal_to_real.comp_ae_measurable hf

@[measurability]
theorem measurable_coe_ennreal_ereal : Measurable (coe : ‚Ñù‚â•0‚àû ‚Üí Ereal) :=
  continuous_coe_ennreal_ereal.Measurable

@[measurability]
theorem Measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) : Measurable fun x => (f x : Ereal) :=
  measurable_coe_ennreal_ereal.comp hf

@[measurability]
theorem AeMeasurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : Measure‚Çì Œ±} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun x => (f x : Ereal)) Œº :=
  measurable_coe_ennreal_ereal.comp_ae_measurable hf

section NormedGroup

variable [NormedGroup Œ±] [OpensMeasurableSpace Œ±] [MeasurableSpace Œ≤]

@[measurability]
theorem measurable_norm : Measurable (norm : Œ± ‚Üí ‚Ñù) :=
  continuous_norm.Measurable

@[measurability]
theorem Measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => norm (f a) :=
  measurable_norm.comp hf

@[measurability]
theorem AeMeasurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : Measure‚Çì Œ≤} (hf : AeMeasurable f Œº) : AeMeasurable (fun a => norm (f a)) Œº :=
  measurable_norm.comp_ae_measurable hf

@[measurability]
theorem measurable_nnnorm : Measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0 ) :=
  continuous_nnnorm.Measurable

@[measurability]
theorem Measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => ‚à•f a‚à•‚Çä :=
  measurable_nnnorm.comp hf

@[measurability]
theorem AeMeasurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure‚Çì Œ≤} (hf : AeMeasurable f Œº) : AeMeasurable (fun a => ‚à•f a‚à•‚Çä) Œº :=
  measurable_nnnorm.comp_ae_measurable hf

@[measurability]
theorem measurable_ennnorm : Measurable fun x : Œ± => (‚à•x‚à•‚Çä : ‚Ñù‚â•0‚àû) :=
  measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
theorem Measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : Measurable f) : Measurable fun a => (‚à•f a‚à•‚Çä : ‚Ñù‚â•0‚àû) :=
  hf.nnnorm.coe_nnreal_ennreal

@[measurability]
theorem AeMeasurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : Measure‚Çì Œ≤} (hf : AeMeasurable f Œº) :
    AeMeasurable (fun a => (‚à•f a‚à•‚Çä : ‚Ñù‚â•0‚àû)) Œº :=
  measurable_ennnorm.comp_ae_measurable hf

end NormedGroup

section Limits

variable [TopologicalSpace Œ≤] [PseudoMetrizableSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤]

open Metric

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto_ennreal' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (u : Filter Œπ) [NeBot u]
    [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) : Measurable g := by
  rcases u.exists_seq_tendsto with ‚ü®x, hx‚ü©
  rw [tendsto_pi_nhds] at lim
  have : (fun y => liminf at_top fun n => (f (x n) y : ‚Ñù‚â•0‚àû)) = g := by
    ext1 y
    exact ((lim‚Çì y).comp hx).liminf_eq
  rw [‚Üê this]
  show Measurable fun y => liminf at_top fun n => (f (x n) y : ‚Ñù‚â•0‚àû)
  exact measurable_liminf fun n => hf (x n)

/-- A sequential limit of measurable `‚Ñù‚â•0‚àû` valued functions is measurable. -/
theorem measurable_of_tendsto_ennreal {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto_ennreal' atTop hf lim‚Çì

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0 } {g : Œ± ‚Üí ‚Ñù‚â•0 } (u : Filter Œπ) [NeBot u]
    [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) : Measurable g := by
  simp_rw [‚Üê measurable_coe_nnreal_ennreal_iff] at hf‚ä¢
  refine' measurable_of_tendsto_ennreal' u hf _
  rw [tendsto_pi_nhds] at lim‚ä¢
  exact fun x => (ennreal.continuous_coe.tendsto (g x)).comp (lim‚Çì x)

/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0 } {g : Œ± ‚Üí ‚Ñù‚â•0 } (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto_nnreal' atTop hf lim‚Çì

/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is
measurable. -/
theorem measurable_of_tendsto_metrizable' {Œπ} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : Filter Œπ) [NeBot u]
    [IsCountablyGenerated u] (hf : ‚àÄ i, Measurable (f i)) (lim : Tendsto f u (ùìù g)) : Measurable g := by
  let this : PseudoMetricSpace Œ≤ := pseudo_metrizable_space_pseudo_metric Œ≤
  apply measurable_of_is_closed'
  intro s h1s h2s h3s
  have : Measurable fun x => inf_nndist (g x) s := by
    suffices : tendsto (fun i x => inf_nndist (f i x) s) u (ùìù fun x => inf_nndist (g x) s)
    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim‚ä¢
    intro x
    exact ((continuous_inf_nndist_pt s).Tendsto (g x)).comp (lim‚Çì x)
  have h4s : g ‚Åª¬π' s = (fun x => inf_nndist (g x) s) ‚Åª¬π' {0} := by
    ext x
    simp [‚Üê h1s, h1s.mem_iff_inf_dist_zero h2s, Nnreal.coe_eq_zero]
  rw [h4s]
  exact this (measurable_set_singleton 0)

/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is
measurable. -/
theorem measurable_of_tendsto_metrizable {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ i, Measurable (f i))
    (lim : Tendsto f atTop (ùìù g)) : Measurable g :=
  measurable_of_tendsto_metrizable' atTop hf lim‚Çì

theorem ae_measurable_of_tendsto_metrizable_ae {Œπ : Type _} {Œº : Measure‚Çì Œ±} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : Filter Œπ)
    [hu : NeBot u] [IsCountablyGenerated u] (hf : ‚àÄ n, AeMeasurable (f n) Œº)
    (h_tendsto : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) u (ùìù (g x))) : AeMeasurable g Œº := by
  rcases u.exists_seq_tendsto with ‚ü®v, hv‚ü©
  have h'f : ‚àÄ n, AeMeasurable (f (v n)) Œº := fun n => hf (v n)
  set p : Œ± ‚Üí (‚Ñï ‚Üí Œ≤) ‚Üí Prop := fun x f' => tendsto (fun n => f' n) at_top (ùìù (g x))
  have hp : ‚àÄ·µê x ‚àÇŒº, p x fun n => f (v n) x := by
    filter_upwards [h_tendsto] with x hx using hx.comp hv
  set ae_seq_lim := fun x => ite (x ‚àà AeSeqSet h'f p) (g x) (‚ü®f (v 0) x‚ü© : Nonempty Œ≤).some with hs
  refine'
    ‚ü®ae_seq_lim, measurable_of_tendsto_metrizable' at_top (aeSeq.measurable h'f p) (tendsto_pi_nhds.mpr fun x => _), _‚ü©
  ¬∑ simp_rw [aeSeq, ae_seq_lim]
    split_ifs with hx
    ¬∑ simp_rw [aeSeq.mk_eq_fun_of_mem_ae_seq_set h'f hx]
      exact @aeSeq.fun_prop_of_mem_ae_seq_set Œ± Œ≤ _ _ _ _ _ _ h'f x hx
      
    ¬∑ exact tendsto_const_nhds
      
    
  ¬∑ exact
      (ite_ae_eq_of_measure_compl_zero g (fun x => (‚ü®f (v 0) x‚ü© : Nonempty Œ≤).some) (AeSeqSet h'f p)
          (aeSeq.measure_compl_ae_seq_set_eq_zero h'f hp)).symm
    

theorem ae_measurable_of_tendsto_metrizable_ae' {Œº : Measure‚Çì Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ n, AeMeasurable (f n) Œº) (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :
    AeMeasurable g Œº :=
  ae_measurable_of_tendsto_metrizable_ae atTop hf h_ae_tendsto

theorem ae_measurable_of_unif_approx {Œ≤} [MeasurableSpace Œ≤] [PseudoMetricSpace Œ≤] [BorelSpace Œ≤] {Œº : Measure‚Çì Œ±}
    {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ, ‚àÄ Œµ > (0 : ‚Ñù), ‚àÄ, ‚àÉ f : Œ± ‚Üí Œ≤, AeMeasurable f Œº ‚àß ‚àÄ·µê x ‚àÇŒº, dist (f x) (g x) ‚â§ Œµ) :
    AeMeasurable g Œº := by
  obtain ‚ü®u, u_anti, u_pos, u_lim‚ü© : ‚àÉ u : ‚Ñï ‚Üí ‚Ñù, StrictAnti u ‚àß (‚àÄ n : ‚Ñï, 0 < u n) ‚àß tendsto u at_top (ùìù 0) :=
    exists_seq_strict_anti_tendsto (0 : ‚Ñù)
  choose f Hf using fun n : ‚Ñï => hf (u n) (u_pos n)
  have : ‚àÄ·µê x ‚àÇŒº, tendsto (fun n => f n x) at_top (ùìù (g x)) := by
    have : ‚àÄ·µê x ‚àÇŒº, ‚àÄ n, dist (f n x) (g x) ‚â§ u n := ae_all_iff.2 fun n => (Hf n).2
    filter_upwards [this]
    intro x hx
    rw [tendsto_iff_dist_tendsto_zero]
    exact squeeze_zero (fun n => dist_nonneg) hx u_lim
  exact ae_measurable_of_tendsto_metrizable_ae' (fun n => (Hf n).1) this

theorem measurable_of_tendsto_metrizable_ae {Œº : Measure‚Çì Œ±} [Œº.IsComplete] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
    (hf : ‚àÄ n, Measurable (f n)) (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) : Measurable g :=
  ae_measurable_iff_measurable.mp (ae_measurable_of_tendsto_metrizable_ae' (fun i => (hf i).AeMeasurable) h_ae_tendsto)

theorem measurable_limit_of_tendsto_metrizable_ae {Œπ} [Encodable Œπ] [Nonempty Œπ] {Œº : Measure‚Çì Œ±} {f : Œπ ‚Üí Œ± ‚Üí Œ≤}
    {L : Filter Œπ} [L.IsCountablyGenerated] (hf : ‚àÄ n, AeMeasurable (f n) Œº)
    (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, ‚àÉ l : Œ≤, Tendsto (fun n => f n x) L (ùìù l)) :
    ‚àÉ (f_lim : Œ± ‚Üí Œ≤)(hf_lim_meas : Measurable f_lim), ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) L (ùìù (f_lim x)) := by
  inhabit Œπ
  rcases eq_or_ne L ‚ä• with (rfl | hL)
  ¬∑ exact ‚ü®(hf default).mk _, (hf default).measurable_mk, eventually_of_forall fun x => tendsto_bot‚ü©
    
  have : ne_bot L := ‚ü®hL‚ü©
  let p : Œ± ‚Üí (Œπ ‚Üí Œ≤) ‚Üí Prop := fun x f' => ‚àÉ l : Œ≤, tendsto (fun n => f' n) L (ùìù l)
  have hp_mem : ‚àÄ, ‚àÄ x ‚àà AeSeqSet hf p, ‚àÄ, p x fun n => f n x := fun x hx => aeSeq.fun_prop_of_mem_ae_seq_set hf hx
  have h_ae_eq : ‚àÄ·µê x ‚àÇŒº, ‚àÄ n, aeSeq hf p n x = f n x := aeSeq.ae_seq_eq_fun_ae hf h_ae_tendsto
  let f_lim : Œ± ‚Üí Œ≤ := fun x =>
    dite (x ‚àà AeSeqSet hf p) (fun h => (hp_mem x h).some) fun h => (‚ü®f default x‚ü© : Nonempty Œ≤).some
  have hf_lim : ‚àÄ x, tendsto (fun n => aeSeq hf p n x) L (ùìù (f_lim x)) := by
    intro x
    simp only [‚Üê f_lim, ‚Üê aeSeq]
    split_ifs
    ¬∑ refine' (hp_mem x h).some_spec.congr fun n => _
      exact (aeSeq.mk_eq_fun_of_mem_ae_seq_set hf h n).symm
      
    ¬∑ exact tendsto_const_nhds
      
  have h_ae_tendsto_f_lim : ‚àÄ·µê x ‚àÇŒº, tendsto (fun n => f n x) L (ùìù (f_lim x)) :=
    h_ae_eq.mono fun x hx => (hf_lim x).congr hx
  have h_f_lim_meas : Measurable f_lim :=
    measurable_of_tendsto_metrizable' L (aeSeq.measurable hf p) (tendsto_pi_nhds.mpr fun x => hf_lim x)
  exact ‚ü®f_lim, h_f_lim_meas, h_ae_tendsto_f_lim‚ü©

end Limits

namespace ContinuousLinearMap

variable {ùïú : Type _} [NormedField ùïú]

variable {E : Type _} [NormedGroup E] [NormedSpace ùïú E] [MeasurableSpace E]

variable [OpensMeasurableSpace E]

variable {F : Type _} [NormedGroup F] [NormedSpace ùïú F] [MeasurableSpace F] [BorelSpace F]

@[measurability]
protected theorem measurable (L : E ‚ÜíL[ùïú] F) : Measurable L :=
  L.Continuous.Measurable

theorem measurable_comp (L : E ‚ÜíL[ùïú] F) {œÜ : Œ± ‚Üí E} (œÜ_meas : Measurable œÜ) : Measurable fun a : Œ± => L (œÜ a) :=
  L.Measurable.comp œÜ_meas

end ContinuousLinearMap

namespace ContinuousLinearMap

variable {ùïú : Type _} [NondiscreteNormedField ùïú]

variable {E : Type _} [NormedGroup E] [NormedSpace ùïú E] {F : Type _} [NormedGroup F] [NormedSpace ùïú F]

instance : MeasurableSpace (E ‚ÜíL[ùïú] F) :=
  borel _

instance : BorelSpace (E ‚ÜíL[ùïú] F) :=
  ‚ü®rfl‚ü©

@[measurability]
theorem measurable_apply [MeasurableSpace F] [BorelSpace F] (x : E) : Measurable fun f : E ‚ÜíL[ùïú] F => f x :=
  (apply ùïú F x).Continuous.Measurable

@[measurability]
theorem measurable_apply' [MeasurableSpace E] [OpensMeasurableSpace E] [MeasurableSpace F] [BorelSpace F] :
    Measurable fun (x : E) (f : E ‚ÜíL[ùïú] F) => f x :=
  (measurable_pi_lambda _) fun f => f.Measurable

@[measurability]
theorem measurable_coe [MeasurableSpace F] [BorelSpace F] : Measurable fun (f : E ‚ÜíL[ùïú] F) (x : E) => f x :=
  measurable_pi_lambda _ measurable_apply

end ContinuousLinearMap

section ContinuousLinearMapNondiscreteNormedField

variable {ùïú : Type _} [NondiscreteNormedField ùïú]

variable {E : Type _} [NormedGroup E] [NormedSpace ùïú E] [MeasurableSpace E] [BorelSpace E]

variable {F : Type _} [NormedGroup F] [NormedSpace ùïú F]

@[measurability]
theorem Measurable.apply_continuous_linear_map {œÜ : Œ± ‚Üí F ‚ÜíL[ùïú] E} (hœÜ : Measurable œÜ) (v : F) :
    Measurable fun a => œÜ a v :=
  (ContinuousLinearMap.apply ùïú E v).Measurable.comp hœÜ

@[measurability]
theorem AeMeasurable.apply_continuous_linear_map {œÜ : Œ± ‚Üí F ‚ÜíL[ùïú] E} {Œº : Measure‚Çì Œ±} (hœÜ : AeMeasurable œÜ Œº) (v : F) :
    AeMeasurable (fun a => œÜ a v) Œº :=
  (ContinuousLinearMap.apply ùïú E v).Measurable.comp_ae_measurable hœÜ

end ContinuousLinearMapNondiscreteNormedField

section NormedSpace

variable {ùïú : Type _} [NondiscreteNormedField ùïú] [CompleteSpace ùïú] [MeasurableSpace ùïú]

variable [BorelSpace ùïú]

variable {E : Type _} [NormedGroup E] [NormedSpace ùïú E] [MeasurableSpace E] [BorelSpace E]

theorem measurable_smul_const {f : Œ± ‚Üí ùïú} {c : E} (hc : c ‚â† 0) : (Measurable fun x => f x ‚Ä¢ c) ‚Üî Measurable f :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.measurable_comp_iff

theorem ae_measurable_smul_const {f : Œ± ‚Üí ùïú} {Œº : Measure‚Çì Œ±} {c : E} (hc : c ‚â† 0) :
    AeMeasurable (fun x => f x ‚Ä¢ c) Œº ‚Üî AeMeasurable f Œº :=
  (closed_embedding_smul_left hc).MeasurableEmbedding.ae_measurable_comp_iff

end NormedSpace

