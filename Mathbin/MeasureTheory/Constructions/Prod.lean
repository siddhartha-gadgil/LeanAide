/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Mathbin.MeasureTheory.Measure.GiryMonad
import Mathbin.Dynamics.Ergodic.MeasurePreserving
import Mathbin.MeasureTheory.Integral.SetIntegral
import Mathbin.MeasureTheory.Measure.OpenPos

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `Î±` and `Î²` have
Ïƒ-finite measures `Î¼` resp. `Î½` then `Î± Ã— Î²` can be equipped with a Ïƒ-finite measure `Î¼.prod Î½` that
satisfies `(Î¼.prod Î½) s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`.
We also have `(Î¼.prod Î½) (s Ã—Ë¢ t) = Î¼ s * Î½ t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem and Fubini's theorem.

## Main definition

* `measure_theory.measure.prod`: The product of two measures.

## Main results

* `measure_theory.measure.prod_apply` states `Î¼.prod Î½ s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`
  for measurable `s`. `measure_theory.measure.prod_apply_symm` is the reversed version.
* `measure_theory.measure.prod_prod` states `Î¼.prod Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t` for measurable sets
  `s` and `t`.
* `measure_theory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `Î± Ã— Î² â†’ â„â‰¥0âˆ` we have `âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼`. The version
  for functions `Î± â†’ Î² â†’ â„â‰¥0âˆ` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.
* `measure_theory.integrable_prod_iff` states that a binary function is integrable iff both
  * `y â†¦ f (x, y)` is integrable for almost every `x`, and
  * the function `x â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dy` is integrable.
* `measure_theory.integral_prod`: Fubini's theorem. It states that for a integrable function
  `Î± Ã— Î² â†’ E` (where `E` is a second countable Banach space) we have
  `âˆ« z, f z âˆ‚(Î¼.prod Î½) = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼`. This theorem has the same variants as
  Tonelli's theorem. The lemma `measure_theory.integrable.integral_prod_right` states that the
  inner integral of the right-hand side is integrable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`Î± â†’ Î² â†’ Î³`) and one for
functions in uncurried form (`Î± Ã— Î² â†’ Î³`). The former often has an assumption
`measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem and Fubini's theorem have a different naming scheme, since the version for the
uncurried version is reversed.

## Tags

product measure, Fubini's theorem, Tonelli's theorem, Fubini-Tonelli theorem
-/


noncomputable section

open Classical TopologicalSpace Ennreal MeasureTheory

open Set Function Real Ennreal

open MeasureTheory MeasurableSpace MeasureTheory.Measure

open TopologicalSpace hiding generateFrom

open Filter hiding prod_eq map

variable {Î± Î±' Î² Î²' Î³ E : Type _}

/-- Rectangles formed by Ï€-systems form a Ï€-system. -/
theorem IsPiSystem.prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsPiSystem C) (hD : IsPiSystem D) :
    IsPiSystem (Image2 (Â· Ã—Ë¢ Â·) C D) := by
  rintro _ âŸ¨sâ‚, tâ‚, hsâ‚, htâ‚, rflâŸ© _ âŸ¨sâ‚‚, tâ‚‚, hsâ‚‚, htâ‚‚, rflâŸ© hst
  rw [prod_inter_prod] at hstâŠ¢
  rw [prod_nonempty_iff] at hst
  exact mem_image2_of_mem (hC _ hsâ‚ _ hsâ‚‚ hst.1) (hD _ htâ‚ _ htâ‚‚ hst.2)

/-- Rectangles of countably spanning sets are countably spanning. -/
theorem IsCountablySpanning.prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) : IsCountablySpanning (Image2 (Â· Ã—Ë¢ Â·) C D) := by
  rcases hC, hD with âŸ¨âŸ¨s, h1s, h2sâŸ©, t, h1t, h2tâŸ©
  refine' âŸ¨fun n => s n.unpair.1 Ã—Ë¢ t n.unpair.2, fun n => mem_image2_of_mem (h1s _) (h1t _), _âŸ©
  rw [Union_unpair_prod, h2s, h2t, univ_prod_univ]

variable [MeasurableSpace Î±] [MeasurableSpace Î±'] [MeasurableSpace Î²] [MeasurableSpace Î²']

variable [MeasurableSpace Î³]

variable {Î¼ : Measureâ‚“ Î±} {Î½ : Measureâ‚“ Î²} {Ï„ : Measureâ‚“ Î³}

variable [NormedGroup E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/


/-- The product of generated Ïƒ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
theorem generate_from_prod_eq {Î± Î²} {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : IsCountablySpanning C)
    (hD : IsCountablySpanning D) :
    @Prod.measurableSpace _ _ (generateFrom C) (generateFrom D) = generateFrom (Image2 (Â· Ã—Ë¢ Â·) C D) := by
  apply le_antisymmâ‚“
  Â· refine' sup_le _ _ <;> rw [comap_generate_from] <;> apply generate_from_le <;> rintro _ âŸ¨s, hs, rflâŸ©
    Â· rcases hD with âŸ¨t, h1t, h2tâŸ©
      rw [â† prod_univ, â† h2t, prod_Union]
      apply MeasurableSet.Union
      intro n
      apply measurable_set_generate_from
      exact âŸ¨s, t n, hs, h1t n, rflâŸ©
      
    Â· rcases hC with âŸ¨t, h1t, h2tâŸ©
      rw [â† univ_prod, â† h2t, Union_prod_const]
      apply MeasurableSet.Union
      rintro n
      apply measurable_set_generate_from
      exact mem_image2_of_mem (h1t n) hs
      
    
  Â· apply generate_from_le
    rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    rw [prod_eq]
    apply (measurable_fst _).inter (measurable_snd _)
    Â· exact measurable_set_generate_from hs
      
    Â· exact measurable_set_generate_from ht
      
    

/-- If `C` and `D` generate the Ïƒ-algebras on `Î±` resp. `Î²`, then rectangles formed by `C` and `D`
  generate the Ïƒ-algebra on `Î± Ã— Î²`. -/
theorem generate_from_eq_prod {C : Set (Set Î±)} {D : Set (Set Î²)} (hC : generateFrom C = â€¹_â€º)
    (hD : generateFrom D = â€¹_â€º) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :
    generateFrom (Image2 (Â· Ã—Ë¢ Â·) C D) = Prod.measurableSpace := by
  rw [â† hC, â† hD, generate_from_prod_eq h2C h2D]

/-- The product Ïƒ-algebra is generated from boxes, i.e. `s Ã—Ë¢ t` for sets `s : set Î±` and
  `t : set Î²`. -/
theorem generate_from_prod :
    generateFrom (Image2 (Â· Ã—Ë¢ Â·) { s : Set Î± | MeasurableSet s } { t : Set Î² | MeasurableSet t }) =
      Prod.measurableSpace :=
  generate_from_eq_prod generate_from_measurable_set generate_from_measurable_set is_countably_spanning_measurable_set
    is_countably_spanning_measurable_set

/-- Rectangles form a Ï€-system. -/
theorem is_pi_system_prod :
    IsPiSystem (Image2 (Â· Ã—Ë¢ Â·) { s : Set Î± | MeasurableSet s } { t : Set Î² | MeasurableSet t }) :=
  is_pi_system_measurable_set.Prod is_pi_system_measurable_set

/-- If `Î½` is a finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
theorem measurable_measure_prod_mk_left_finite [IsFiniteMeasure Î½] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Measurable fun x => Î½ (Prod.mk x â»Â¹' s) := by
  refine' induction_on_inter generate_from_prod.symm is_pi_system_prod _ _ _ _ hs
  Â· simp [â† measurable_zero, â† const_def]
    
  Â· rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    simp only [â† mk_preimage_prod_right_eq_if, â† measure_if]
    exact measurable_const.indicator hs
    
  Â· intro t ht h2t
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top Î½ _)]
    exact h2t.const_sub _
    
  Â· intro f h1f h2f h3f
    simp_rw [preimage_Union]
    have : âˆ€ b, Î½ (â‹ƒ i, Prod.mk b â»Â¹' f i) = âˆ‘' i, Î½ (Prod.mk b â»Â¹' f i) := fun b =>
      measure_Union (fun i j hij => Disjoint.preimage _ (h1f i j hij)) fun i => measurable_prod_mk_left (h2f i)
    simp_rw [this]
    apply Measurable.ennreal_tsum h3f
    

/-- If `Î½` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_left [SigmaFinite Î½] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Measurable fun x => Î½ (Prod.mk x â»Â¹' s) := by
  have : âˆ€ x, MeasurableSet (Prod.mk x â»Â¹' s) := fun x => measurable_prod_mk_left hs
  simp only [@supr_restrict_spanning_sets _ _ Î½, â† this]
  apply measurable_supr
  intro i
  have := Fact.mk (measure_spanning_sets_lt_top Î½ i)
  exact measurable_measure_prod_mk_left_finite hs

/-- If `Î¼` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `y â†¦ Î¼ { x | (x, y) âˆˆ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_right {Î¼ : Measureâ‚“ Î±} [SigmaFinite Î¼] {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Measurable fun y => Î¼ ((fun x => (x, y)) â»Â¹' s) :=
  measurable_measure_prod_mk_left (measurable_set_swap_iff.mpr hs)

theorem Measurable.map_prod_mk_left [SigmaFinite Î½] : Measurable fun x : Î± => map (Prod.mk x) Î½ := by
  apply measurable_of_measurable_coe
  intro s hs
  simp_rw [map_apply measurable_prod_mk_left hs]
  exact measurable_measure_prod_mk_left hs

theorem Measurable.map_prod_mk_right {Î¼ : Measureâ‚“ Î±} [SigmaFinite Î¼] :
    Measurable fun y : Î² => map (fun x : Î± => (x, y)) Î¼ := by
  apply measurable_of_measurable_coe
  intro s hs
  simp_rw [map_apply measurable_prod_mk_right hs]
  exact measurable_measure_prod_mk_right hs

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_right' [SigmaFinite Î½] :
    âˆ€ {f : Î± Ã— Î² â†’ â„â‰¥0âˆ} (hf : Measurable f), Measurable fun x => âˆ«â» y, f (x, y) âˆ‚Î½ := by
  have m := @measurable_prod_mk_left
  refine' Measurable.ennreal_induction _ _ _
  Â· intro c s hs
    simp only [indicator_comp_right]
    suffices Measurable fun x => c * Î½ (Prod.mk x â»Â¹' s) by
      simpa [â† lintegral_indicator _ (m hs)]
    exact (measurable_measure_prod_mk_left hs).const_mul _
    
  Â· rintro f g - hf hg h2f h2g
    simp_rw [Pi.add_apply, lintegral_add_left (hf.comp m)]
    exact h2f.add h2g
    
  Â· intro f hf h2f h3f
    have := measurable_supr h3f
    have : âˆ€ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    simpa [â† lintegral_supr fun n => (hf n).comp m, â† this]
    

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_right [SigmaFinite Î½] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ} (hf : Measurable (uncurry f)) :
    Measurable fun x => âˆ«â» y, f x y âˆ‚Î½ :=
  hf.lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
theorem Measurable.lintegral_prod_left' [SigmaFinite Î¼] {f : Î± Ã— Î² â†’ â„â‰¥0âˆ} (hf : Measurable f) :
    Measurable fun y => âˆ«â» x, f (x, y) âˆ‚Î¼ :=
  (measurable_swap_iff.mpr hf).lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem Measurable.lintegral_prod_left [SigmaFinite Î¼] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ} (hf : Measurable (uncurry f)) :
    Measurable fun y => âˆ«â» x, f x y âˆ‚Î¼ :=
  hf.lintegral_prod_left'

theorem measurable_set_integrable [SigmaFinite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : StronglyMeasurable (uncurry f)) :
    MeasurableSet { x | Integrable (f x) Î½ } := by
  simp_rw [integrable, hf.of_uncurry_left.ae_strongly_measurable, true_andâ‚“]
  exact measurable_set_lt (Measurable.lintegral_prod_right hf.ennnorm) measurable_const

section

variable [NormedSpace â„ E] [CompleteSpace E]

-- ./././Mathport/Syntax/Translate/Basic.lean:647:16: unsupported tactic `borelize #[[expr E]]
/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem MeasureTheory.StronglyMeasurable.integral_prod_right [SigmaFinite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„
    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun x => âˆ« y, f x y âˆ‚Î½ := by
  trace "./././Mathport/Syntax/Translate/Basic.lean:647:16: unsupported tactic `borelize #[[expr E]]"
  have : separable_space (range (uncurry f) âˆª {0} : Set E) := hf.separable_space_range_union_singleton
  let s : â„• â†’ simple_func (Î± Ã— Î²) E :=
    simple_func.approx_on _ hf.measurable (range (uncurry f) âˆª {0}) 0
      (by
        simp )
  let s' : â„• â†’ Î± â†’ simple_func Î² E := fun n x => (s n).comp (Prod.mk x) measurable_prod_mk_left
  let f' : â„• â†’ Î± â†’ E := fun n => { x | integrable (f x) Î½ }.indicator fun x => (s' n x).integral Î½
  have hf' : âˆ€ n, strongly_measurable (f' n) := by
    intro n
    refine' strongly_measurable.indicator _ (measurable_set_integrable hf)
    have : âˆ€ x, ((s' n x).range.filter fun x => x â‰  0) âŠ† (s n).range := by
      intro x
      refine' Finset.Subset.trans (Finset.filter_subset _ _) _
      intro y
      simp_rw [simple_func.mem_range]
      rintro âŸ¨z, rflâŸ©
      exact âŸ¨(x, z), rflâŸ©
    simp only [â† simple_func.integral_eq_sum_of_subset (this _)]
    refine' Finset.strongly_measurable_sum _ fun x _ => _
    refine' (Measurable.ennreal_to_real _).StronglyMeasurable.smul_const _
    simp (config := { singlePass := true })only [â† simple_func.coe_comp, â† preimage_comp]
    apply measurable_measure_prod_mk_left
    exact (s n).measurable_set_fiber x
  have h2f' : tendsto f' at_top (ğ“ fun x : Î± => âˆ« y : Î², f x y âˆ‚Î½) := by
    rw [tendsto_pi_nhds]
    intro x
    by_cases' hfx : integrable (f x) Î½
    Â· have : âˆ€ n, integrable (s' n x) Î½ := by
        intro n
        apply (hfx.norm.add hfx.norm).mono' (s' n x).AeStronglyMeasurable
        apply eventually_of_forall
        intro y
        simp_rw [s', simple_func.coe_comp]
        exact simple_func.norm_approx_on_zero_le _ _ (x, y) n
      simp only [â† f', â† hfx, â† simple_func.integral_eq_integral _ (this _), â† indicator_of_mem, â† mem_set_of_eq]
      refine'
        tendsto_integral_of_dominated_convergence (fun y => âˆ¥f x yâˆ¥ + âˆ¥f x yâˆ¥) (fun n => (s' n x).AeStronglyMeasurable)
          (hfx.norm.add hfx.norm) _ _
      Â· exact fun n => eventually_of_forall fun y => simple_func.norm_approx_on_zero_le _ _ (x, y) n
        
      Â· refine' eventually_of_forall fun y => simple_func.tendsto_approx_on _ _ _
        apply subset_closure
        simp [-uncurry_apply_pair]
        
      
    Â· simpa [â† f', â† hfx, â† integral_undef] using @tendsto_const_nhds _ _ _ (0 : E) _
      
  exact strongly_measurable_of_tendsto _ hf' h2f'

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
theorem MeasureTheory.StronglyMeasurable.integral_prod_right' [SigmaFinite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => âˆ« y, f (x, y) âˆ‚Î½ := by
  rw [â† uncurry_curry f] at hf
  exact hf.integral_prod_right

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem MeasureTheory.StronglyMeasurable.integral_prod_left [SigmaFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„
    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun y => âˆ« x, f x y âˆ‚Î¼ :=
  (hf.comp_measurable measurable_swap).integral_prod_right'

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable. -/
theorem MeasureTheory.StronglyMeasurable.integral_prod_left' [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
    (hf : StronglyMeasurable f) : StronglyMeasurable fun y => âˆ« x, f (x, y) âˆ‚Î¼ :=
  (hf.comp_measurable measurable_swap).integral_prod_right'

end

/-! ### The product measure -/


namespace MeasureTheory

namespace Measureâ‚“

/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is Ïƒ-finite. -/
protected irreducible_def prod (Î¼ : Measure Î±) (Î½ : Measure Î²) : Measure (Î± Ã— Î²) :=
  (bind Î¼) fun x : Î± => map (Prod.mk x) Î½

instance prod.measureSpace {Î± Î²} [MeasureSpace Î±] [MeasureSpace Î²] :
    MeasureSpace (Î± Ã— Î²) where volume := volume.Prod volume

variable {Î¼ Î½} [SigmaFinite Î½]

theorem volume_eq_prod (Î± Î²) [MeasureSpace Î±] [MeasureSpace Î²] :
    (volume : Measure (Î± Ã— Î²)) = (volume : Measure Î±).Prod (volume : Measure Î²) :=
  rfl

theorem prod_apply {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) : Î¼.Prod Î½ s = âˆ«â» x, Î½ (Prod.mk x â»Â¹' s) âˆ‚Î¼ := by
  simp_rw [measure.prod, bind_apply hs Measurable.map_prod_mk_left, map_apply measurable_prod_mk_left hs]

/-- The product measure of the product of two sets is the product of their measures. Note that we
do not need the sets to be measurable. -/
@[simp]
theorem prod_prod (s : Set Î±) (t : Set Î²) : Î¼.Prod Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t := by
  apply le_antisymmâ‚“
  Â· set ST := to_measurable Î¼ s Ã—Ë¢ to_measurable Î½ t
    have hSTm : MeasurableSet ST := (measurable_set_to_measurable _ _).Prod (measurable_set_to_measurable _ _)
    calc Î¼.prod Î½ (s Ã—Ë¢ t) â‰¤ Î¼.prod Î½ ST :=
        measure_mono <|
          Set.prod_mono (subset_to_measurable _ _)
            (subset_to_measurable _ _)_ = Î¼ (to_measurable Î¼ s) * Î½ (to_measurable Î½ t) :=
        by
        simp_rw [prod_apply hSTm, mk_preimage_prod_right_eq_if, measure_if,
          lintegral_indicator _ (measurable_set_to_measurable _ _), lintegral_const, restrict_apply_univ,
          mul_comm]_ = Î¼ s * Î½ t :=
        by
        rw [measure_to_measurable, measure_to_measurable]
    
  Â· -- Formalization is based on https://mathoverflow.net/a/254134/136589
    set ST := to_measurable (Î¼.prod Î½) (s Ã—Ë¢ t)
    have hSTm : MeasurableSet ST := measurable_set_to_measurable _ _
    have hST : s Ã—Ë¢ t âŠ† ST := subset_to_measurable _ _
    set f : Î± â†’ â„â‰¥0âˆ := fun x => Î½ (Prod.mk x â»Â¹' ST)
    have hfm : Measurable f := measurable_measure_prod_mk_left hSTm
    set s' : Set Î± := { x | Î½ t â‰¤ f x }
    have hss' : s âŠ† s' := fun x hx => measure_mono fun y hy => hST <| mk_mem_prod hx hy
    calc Î¼ s * Î½ t â‰¤ Î¼ s' * Î½ t := mul_le_mul_right' (measure_mono hss') _ _ = âˆ«â» x in s', Î½ t âˆ‚Î¼ := by
        rw [set_lintegral_const, mul_comm]_ â‰¤ âˆ«â» x in s', f x âˆ‚Î¼ :=
        set_lintegral_mono measurable_const hfm fun x => id _ â‰¤ âˆ«â» x, f x âˆ‚Î¼ :=
        lintegral_mono' restrict_le_self le_rfl _ = Î¼.prod Î½ ST := (prod_apply hSTm).symm _ = Î¼.prod Î½ (s Ã—Ë¢ t) :=
        measure_to_measurable _
    

instance {X Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {m : MeasurableSpace X} {Î¼ : Measure X}
    [IsOpenPosMeasure Î¼] {m' : MeasurableSpace Y} {Î½ : Measure Y} [IsOpenPosMeasure Î½] [SigmaFinite Î½] :
    IsOpenPosMeasure (Î¼.Prod Î½) := by
  constructor
  rintro U U_open âŸ¨âŸ¨x, yâŸ©, hxyâŸ©
  rcases is_open_prod_iff.1 U_open x y hxy with âŸ¨u, v, u_open, v_open, xu, yv, huvâŸ©
  refine' ne_of_gtâ‚“ (lt_of_lt_of_leâ‚“ _ (measure_mono huv))
  simp only [â† prod_prod, â† CanonicallyOrderedCommSemiring.mul_pos]
  constructor
  Â· exact u_open.measure_pos Î¼ âŸ¨x, xuâŸ©
    
  Â· exact v_open.measure_pos Î½ âŸ¨y, yvâŸ©
    

instance {Î± Î² : Type _} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} (Î¼ : Measure Î±) (Î½ : Measure Î²)
    [IsFiniteMeasure Î¼] [IsFiniteMeasure Î½] : IsFiniteMeasure (Î¼.Prod Î½) := by
  constructor
  rw [â† univ_prod_univ, prod_prod]
  exact mul_lt_top (measure_lt_top _ _).Ne (measure_lt_top _ _).Ne

instance {Î± Î² : Type _} {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²} (Î¼ : Measure Î±) (Î½ : Measure Î²)
    [IsProbabilityMeasure Î¼] [IsProbabilityMeasure Î½] : IsProbabilityMeasure (Î¼.Prod Î½) :=
  âŸ¨by
    rw [â† univ_prod_univ, prod_prod, measure_univ, measure_univ, mul_oneâ‚“]âŸ©

instance {Î± Î² : Type _} [TopologicalSpace Î±] [TopologicalSpace Î²] {mÎ± : MeasurableSpace Î±} {mÎ² : MeasurableSpace Î²}
    (Î¼ : Measure Î±) (Î½ : Measure Î²) [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½] [SigmaFinite Î½] :
    IsFiniteMeasureOnCompacts (Î¼.Prod Î½) := by
  refine' âŸ¨fun K hK => _âŸ©
  set L := (Prod.fst '' K) Ã—Ë¢ (Prod.snd '' K) with hL
  have : K âŠ† L := by
    rintro âŸ¨x, yâŸ© hxy
    simp only [â† prod_mk_mem_set_prod_eq, â† mem_image, â† Prod.exists, â† exists_and_distrib_right, â† exists_eq_right]
    exact âŸ¨âŸ¨y, hxyâŸ©, âŸ¨x, hxyâŸ©âŸ©
  apply lt_of_le_of_ltâ‚“ (measure_mono this)
  rw [hL, prod_prod]
  exact
    mul_lt_top (IsCompact.measure_lt_top (hK.image continuous_fst)).Ne
      (IsCompact.measure_lt_top (hK.image continuous_snd)).Ne

theorem ae_measure_lt_top {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) (h2s : (Î¼.Prod Î½) s â‰  âˆ) :
    âˆ€áµ x âˆ‚Î¼, Î½ (Prod.mk x â»Â¹' s) < âˆ := by
  simp_rw [prod_apply hs] at h2s
  refine' ae_lt_top (measurable_measure_prod_mk_left hs) h2s

theorem integrable_measure_prod_mk_left {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) (h2s : (Î¼.Prod Î½) s â‰  âˆ) :
    Integrable (fun x => (Î½ (Prod.mk x â»Â¹' s)).toReal) Î¼ := by
  refine' âŸ¨(measurable_measure_prod_mk_left hs).ennreal_to_real.AeMeasurable.AeStronglyMeasurable, _âŸ©
  simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg]
  convert h2s.lt_top using 1
  simp_rw [prod_apply hs]
  apply lintegral_congr_ae
  refine' (ae_measure_lt_top hs h2s).mp _
  apply eventually_of_forall
  intro x hx
  rw [lt_top_iff_ne_top] at hx
  simp [â† of_real_to_real, â† hx]

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_prod_null {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) :
    Î¼.Prod Î½ s = 0 â†” (fun x => Î½ (Prod.mk x â»Â¹' s)) =áµ[Î¼] 0 := by
  simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_ae_null_of_prod_null {s : Set (Î± Ã— Î²)} (h : Î¼.Prod Î½ s = 0) : (fun x => Î½ (Prod.mk x â»Â¹' s)) =áµ[Î¼] 0 :=
  by
  obtain âŸ¨t, hst, mt, htâŸ© := exists_measurable_superset_of_null h
  simp_rw [measure_prod_null mt] at ht
  rw [eventually_le_antisymm_iff]
  exact
    âŸ¨eventually_le.trans_eq (eventually_of_forall fun x => (measure_mono (preimage_mono hst) : _)) ht,
      eventually_of_forall fun x => zero_le _âŸ©

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem ae_ae_of_ae_prod {p : Î± Ã— Î² â†’ Prop} (h : âˆ€áµ z âˆ‚Î¼.Prod Î½, p z) : âˆ€áµ x âˆ‚Î¼, âˆ€áµ y âˆ‚Î½, p (x, y) :=
  measure_ae_null_of_prod_null h

/-- `Î¼.prod Î½` has finite spanning sets in rectangles of finite spanning sets. -/
noncomputable def FiniteSpanningSetsIn.prod {Î½ : Measure Î²} {C : Set (Set Î±)} {D : Set (Set Î²)}
    (hÎ¼ : Î¼.FiniteSpanningSetsIn C) (hÎ½ : Î½.FiniteSpanningSetsIn D) :
    (Î¼.Prod Î½).FiniteSpanningSetsIn (Image2 (Â· Ã—Ë¢ Â·) C D) := by
  have := hÎ½.sigma_finite
  refine'
    âŸ¨fun n => hÎ¼.set n.unpair.1 Ã—Ë¢ hÎ½.set n.unpair.2, fun n => mem_image2_of_mem (hÎ¼.set_mem _) (hÎ½.set_mem _), fun n =>
      _, _âŸ©
  Â· rw [prod_prod]
    exact mul_lt_top (hÎ¼.finite _).Ne (hÎ½.finite _).Ne
    
  Â· simp_rw [Union_unpair_prod, hÎ¼.spanning, hÎ½.spanning, univ_prod_univ]
    

theorem prod_fst_absolutely_continuous : map Prod.fst (Î¼.Prod Î½) â‰ª Î¼ := by
  refine' absolutely_continuous.mk fun s hs h2s => _
  rw [map_apply measurable_fst hs, â† prod_univ, prod_prod, h2s, zero_mul]

theorem prod_snd_absolutely_continuous : map Prod.snd (Î¼.Prod Î½) â‰ª Î½ := by
  refine' absolutely_continuous.mk fun s hs h2s => _
  rw [map_apply measurable_snd hs, â† univ_prod, prod_prod, h2s, mul_zero]

variable [SigmaFinite Î¼]

instance prod.sigma_finite : SigmaFinite (Î¼.Prod Î½) :=
  (Î¼.toFiniteSpanningSetsIn.Prod Î½.toFiniteSpanningSetsIn).SigmaFinite

/-- A measure on a product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding Ïƒ-algebras. -/
theorem prod_eq_generate_from {Î¼ : Measure Î±} {Î½ : Measure Î²} {C : Set (Set Î±)} {D : Set (Set Î²)}
    (hC : generateFrom C = â€¹_â€º) (hD : generateFrom D = â€¹_â€º) (h2C : IsPiSystem C) (h2D : IsPiSystem D)
    (h3C : Î¼.FiniteSpanningSetsIn C) (h3D : Î½.FiniteSpanningSetsIn D) {Î¼Î½ : Measure (Î± Ã— Î²)}
    (hâ‚ : âˆ€, âˆ€ s âˆˆ C, âˆ€, âˆ€ t âˆˆ D, âˆ€, Î¼Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t) : Î¼.Prod Î½ = Î¼Î½ := by
  refine'
    (h3C.prod h3D).ext (generate_from_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm
      (h2C.prod h2D) _
  Â· rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    have := h3D.sigma_finite
    rw [hâ‚ s hs t ht, prod_prod]
    

/-- A measure on a product space equals the product measure if they are equal on rectangles. -/
theorem prod_eq {Î¼Î½ : Measure (Î± Ã— Î²)} (h : âˆ€ s t, MeasurableSet s â†’ MeasurableSet t â†’ Î¼Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t) :
    Î¼.Prod Î½ = Î¼Î½ :=
  prod_eq_generate_from generate_from_measurable_set generate_from_measurable_set is_pi_system_measurable_set
    is_pi_system_measurable_set Î¼.toFiniteSpanningSetsIn Î½.toFiniteSpanningSetsIn fun s hs t ht => h s t hs ht

theorem prod_swap : map Prod.swap (Î¼.Prod Î½) = Î½.Prod Î¼ := by
  refine' (prod_eq _).symm
  intro s t hs ht
  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod, mul_comm]

theorem prod_apply_symm {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s) : Î¼.Prod Î½ s = âˆ«â» y, Î¼ ((fun x => (x, y)) â»Â¹' s) âˆ‚Î½ :=
  by
  rw [â† prod_swap, map_apply measurable_swap hs]
  simp only [â† prod_apply (measurable_swap hs)]
  rfl

theorem prod_assoc_prod [SigmaFinite Ï„] : map MeasurableEquiv.prodAssoc ((Î¼.Prod Î½).Prod Ï„) = Î¼.Prod (Î½.Prod Ï„) := by
  refine'
    (prod_eq_generate_from generate_from_measurable_set generate_from_prod is_pi_system_measurable_set is_pi_system_prod
        Î¼.to_finite_spanning_sets_in (Î½.to_finite_spanning_sets_in.prod Ï„.to_finite_spanning_sets_in) _).symm
  rintro s hs _ âŸ¨t, u, ht, hu, rflâŸ©
  rw [mem_set_of_eq] at hs ht hu
  simp_rw [map_apply (MeasurableEquiv.measurable _) (hs.prod (ht.prod hu)), MeasurableEquiv.prodAssoc,
    MeasurableEquiv.coe_mk, Equivâ‚“.prod_assoc_preimage, prod_prod, mul_assoc]

/-! ### The product of specific measures -/


theorem prod_restrict (s : Set Î±) (t : Set Î²) : (Î¼.restrict s).Prod (Î½.restrict t) = (Î¼.Prod Î½).restrict (s Ã—Ë¢ t) := by
  refine' prod_eq fun s' t' hs' ht' => _
  rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod, restrict_apply hs', restrict_apply ht']

theorem restrict_prod_eq_prod_univ (s : Set Î±) : (Î¼.restrict s).Prod Î½ = (Î¼.Prod Î½).restrict (s Ã—Ë¢ (Univ : Set Î²)) := by
  have : Î½ = Î½.restrict Set.Univ := measure.restrict_univ.symm
  rwa [this, measure.prod_restrict, â† this]

theorem prod_dirac (y : Î²) : Î¼.Prod (dirac y) = map (fun x => (x, y)) Î¼ := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if, dirac_apply' _ ht,
    â† indicator_mul_right _ fun x => Î¼ s, Pi.one_apply, mul_oneâ‚“]

theorem dirac_prod (x : Î±) : (dirac x).Prod Î½ = map (Prod.mk x) Î½ := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if, dirac_apply' _ hs,
    â† indicator_mul_left _ _ fun x => Î½ t, Pi.one_apply, one_mulâ‚“]

theorem dirac_prod_dirac {x : Î±} {y : Î²} : (dirac x).Prod (dirac y) = dirac (x, y) := by
  rw [prod_dirac, map_dirac measurable_prod_mk_right]

theorem prod_sum {Î¹ : Type _} [Fintype Î¹] (Î½ : Î¹ â†’ Measure Î²) [âˆ€ i, SigmaFinite (Î½ i)] :
    Î¼.Prod (sum Î½) = sum fun i => Î¼.Prod (Î½ i) := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod, Ennreal.tsum_mul_left]

theorem sum_prod {Î¹ : Type _} [Fintype Î¹] (Î¼ : Î¹ â†’ Measure Î±) [âˆ€ i, SigmaFinite (Î¼ i)] :
    (sum Î¼).Prod Î½ = sum fun i => (Î¼ i).Prod Î½ := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod, Ennreal.tsum_mul_right]

theorem prod_add (Î½' : Measure Î²) [SigmaFinite Î½'] : Î¼.Prod (Î½ + Î½') = Î¼.Prod Î½ + Î¼.Prod Î½' := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [add_apply, prod_prod, left_distrib]

theorem add_prod (Î¼' : Measure Î±) [SigmaFinite Î¼'] : (Î¼ + Î¼').Prod Î½ = Î¼.Prod Î½ + Î¼'.Prod Î½ := by
  refine' prod_eq fun s t hs ht => _
  simp_rw [add_apply, prod_prod, right_distrib]

@[simp]
theorem zero_prod (Î½ : Measure Î²) : (0 : Measure Î±).Prod Î½ = 0 := by
  rw [measure.prod]
  exact bind_zero_left _

@[simp]
theorem prod_zero (Î¼ : Measure Î±) : Î¼.Prod (0 : Measure Î²) = 0 := by
  simp [â† measure.prod]

theorem map_prod_map {Î´} [MeasurableSpace Î´] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} {Î¼a : Measure Î±} {Î¼c : Measure Î³}
    (hfa : SigmaFinite (map f Î¼a)) (hgc : SigmaFinite (map g Î¼c)) (hf : Measurable f) (hg : Measurable g) :
    (map f Î¼a).Prod (map g Î¼c) = map (Prod.map f g) (Î¼a.Prod Î¼c) := by
  have := hgc.of_map Î¼c hg.ae_measurable
  refine' prod_eq fun s t hs ht => _
  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht]
  exact prod_prod (f â»Â¹' s) (g â»Â¹' t)

end Measureâ‚“

open Measureâ‚“

namespace MeasurePreserving

variable {Î´ : Type _} [MeasurableSpace Î´] {Î¼a : Measure Î±} {Î¼b : Measure Î²} {Î¼c : Measure Î³} {Î¼d : Measure Î´}

theorem skew_product [SigmaFinite Î¼b] [SigmaFinite Î¼d] {f : Î± â†’ Î²} (hf : MeasurePreserving f Î¼a Î¼b) {g : Î± â†’ Î³ â†’ Î´}
    (hgm : Measurable (uncurry g)) (hg : âˆ€áµ x âˆ‚Î¼a, map (g x) Î¼c = Î¼d) :
    MeasurePreserving (fun p : Î± Ã— Î³ => (f p.1, g p.1 p.2)) (Î¼a.Prod Î¼c) (Î¼b.Prod Î¼d) := by
  classical
  have : Measurable fun p : Î± Ã— Î³ => (f p.1, g p.1 p.2) := (hf.1.comp measurable_fst).prod_mk hgm
  /- if `Î¼a = 0`, then the lemma is trivial, otherwise we can use `hg`
    to deduce `sigma_finite Î¼c`. -/
  rcases eq_or_ne Î¼a 0 with (rfl | ha)
  Â· rw [â† hf.map_eq, zero_prod, measure.map_zero, zero_prod]
    exact
      âŸ¨this, by
        simp only [â† measure.map_zero]âŸ©
    
  have : sigma_finite Î¼c := by
    rcases(ae_ne_bot.2 ha).nonempty_of_mem hg with âŸ¨x, hx : map (g x) Î¼c = Î¼dâŸ©
    exact
      sigma_finite.of_map _ hgm.of_uncurry_left.ae_measurable
        (by
          rwa [hx])
  -- Thus we can apply `measure.prod_eq` to prove equality of measures.
  refine' âŸ¨this, (prod_eq fun s t hs ht => _).symmâŸ©
  rw [map_apply this (hs.prod ht)]
  refine' (prod_apply (this <| hs.prod ht)).trans _
  have : âˆ€áµ x âˆ‚Î¼a, Î¼c ((fun y => (f x, g x y)) â»Â¹' s Ã—Ë¢ t) = indicator (f â»Â¹' s) (fun y => Î¼d t) x := by
    refine' hg.mono fun x hx => _
    subst hx
    simp only [â† mk_preimage_prod_right_fn_eq_if, â† indicator_apply, â† mem_preimage]
    split_ifs
    exacts[(map_apply hgm.of_uncurry_left ht).symm, measure_empty]
  simp only [â† preimage_preimage]
  rw [lintegral_congr_ae this, lintegral_indicator _ (hf.1 hs), set_lintegral_const, hf.measure_preimage hs, mul_comm]

/-- If `f : Î± â†’ Î²` sends the measure `Î¼a` to `Î¼b` and `g : Î³ â†’ Î´` sends the measure `Î¼c` to `Î¼d`,
then `prod.map f g` sends `Î¼a.prod Î¼c` to `Î¼b.prod Î¼d`. -/
protected theorem prod [SigmaFinite Î¼b] [SigmaFinite Î¼d] {f : Î± â†’ Î²} {g : Î³ â†’ Î´} (hf : MeasurePreserving f Î¼a Î¼b)
    (hg : MeasurePreserving g Î¼c Î¼d) : MeasurePreserving (Prod.map f g) (Î¼a.Prod Î¼c) (Î¼b.Prod Î¼d) :=
  have : Measurable (uncurry fun _ : Î± => g) := hg.1.comp measurable_snd
  hf.skew_product this <| Filter.eventually_of_forall fun _ => hg.map_eq

end MeasurePreserving

namespace QuasiMeasurePreserving

theorem prod_of_right {f : Î± Ã— Î² â†’ Î³} {Î¼ : Measure Î±} {Î½ : Measure Î²} {Ï„ : Measure Î³} (hf : Measurable f)
    [SigmaFinite Î½] (h2f : âˆ€áµ x âˆ‚Î¼, QuasiMeasurePreserving (fun y => f (x, y)) Î½ Ï„) :
    QuasiMeasurePreserving f (Î¼.Prod Î½) Ï„ := by
  refine' âŸ¨hf, _âŸ©
  refine' absolutely_continuous.mk fun s hs h2s => _
  simp_rw [map_apply hf hs, prod_apply (hf hs), preimage_preimage,
    lintegral_congr_ae (h2f.mono fun x hx => hx.preimage_null h2s), lintegral_zero]

theorem prod_of_left {Î± Î² Î³} [MeasurableSpace Î±] [MeasurableSpace Î²] [MeasurableSpace Î³] {f : Î± Ã— Î² â†’ Î³} {Î¼ : Measure Î±}
    {Î½ : Measure Î²} {Ï„ : Measure Î³} (hf : Measurable f) [SigmaFinite Î¼] [SigmaFinite Î½]
    (h2f : âˆ€áµ y âˆ‚Î½, QuasiMeasurePreserving (fun x => f (x, y)) Î¼ Ï„) : QuasiMeasurePreserving f (Î¼.Prod Î½) Ï„ := by
  rw [â† prod_swap]
  convert
    (quasi_measure_preserving.prod_of_right (hf.comp measurable_swap) h2f).comp
      ((measurable_swap.measure_preserving (Î½.prod Î¼)).symm MeasurableEquiv.prodComm).QuasiMeasurePreserving
  ext âŸ¨x, yâŸ©
  rfl

end QuasiMeasurePreserving

end MeasureTheory

open MeasureTheory.Measure

section

theorem AeMeasurable.prod_swap [SigmaFinite Î¼] [SigmaFinite Î½] {f : Î² Ã— Î± â†’ Î³} (hf : AeMeasurable f (Î½.Prod Î¼)) :
    AeMeasurable (fun z : Î± Ã— Î² => f z.swap) (Î¼.Prod Î½) := by
  rw [â† prod_swap] at hf
  exact hf.comp_measurable measurable_swap

theorem MeasureTheory.AeStronglyMeasurable.prod_swap {Î³ : Type _} [TopologicalSpace Î³] [SigmaFinite Î¼] [SigmaFinite Î½]
    {f : Î² Ã— Î± â†’ Î³} (hf : AeStronglyMeasurable f (Î½.Prod Î¼)) :
    AeStronglyMeasurable (fun z : Î± Ã— Î² => f z.swap) (Î¼.Prod Î½) := by
  rw [â† prod_swap] at hf
  exact hf.comp_measurable measurable_swap

theorem AeMeasurable.fst [SigmaFinite Î½] {f : Î± â†’ Î³} (hf : AeMeasurable f Î¼) :
    AeMeasurable (fun z : Î± Ã— Î² => f z.1) (Î¼.Prod Î½) :=
  hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous

theorem AeMeasurable.snd [SigmaFinite Î½] {f : Î² â†’ Î³} (hf : AeMeasurable f Î½) :
    AeMeasurable (fun z : Î± Ã— Î² => f z.2) (Î¼.Prod Î½) :=
  hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous

theorem MeasureTheory.AeStronglyMeasurable.fst {Î³} [TopologicalSpace Î³] [SigmaFinite Î½] {f : Î± â†’ Î³}
    (hf : AeStronglyMeasurable f Î¼) : AeStronglyMeasurable (fun z : Î± Ã— Î² => f z.1) (Î¼.Prod Î½) :=
  hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous

theorem MeasureTheory.AeStronglyMeasurable.snd {Î³} [TopologicalSpace Î³] [SigmaFinite Î½] {f : Î² â†’ Î³}
    (hf : AeStronglyMeasurable f Î½) : AeStronglyMeasurable (fun z : Î± Ã— Î² => f z.2) (Î¼.Prod Î½) :=
  hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous

/-- The Bochner integral is a.e.-measurable.
  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/
theorem MeasureTheory.AeStronglyMeasurable.integral_prod_right' [SigmaFinite Î½] [NormedSpace â„ E] [CompleteSpace E]
    â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : AeStronglyMeasurable f (Î¼.Prod Î½)) : AeStronglyMeasurable (fun x => âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=
  âŸ¨fun x => âˆ« y, hf.mk f (x, y) âˆ‚Î½, hf.strongly_measurable_mk.integral_prod_right', by
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ hx using integral_congr_ae hxâŸ©

theorem MeasureTheory.AeStronglyMeasurable.prod_mk_left {Î³ : Type _} [SigmaFinite Î½] [TopologicalSpace Î³]
    {f : Î± Ã— Î² â†’ Î³} (hf : AeStronglyMeasurable f (Î¼.Prod Î½)) : âˆ€áµ x âˆ‚Î¼, AeStronglyMeasurable (fun y => f (x, y)) Î½ := by
  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx
  exact âŸ¨fun y => hf.mk f (x, y), hf.strongly_measurable_mk.comp_measurable measurable_prod_mk_left, hxâŸ©

end

namespace MeasureTheory

/-! ### The Lebesgue integral on a product -/


variable [SigmaFinite Î½]

theorem lintegral_prod_swap [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AeMeasurable f (Î¼.Prod Î½)) :
    (âˆ«â» z, f z.swap âˆ‚Î½.Prod Î¼) = âˆ«â» z, f z âˆ‚Î¼.Prod Î½ := by
  rw [â† prod_swap] at hf
  rw [â† lintegral_map' hf measurable_swap.ae_measurable, prod_swap]

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod_of_measurable :
    âˆ€ (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : Measurable f), (âˆ«â» z, f z âˆ‚Î¼.Prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  have m := @measurable_prod_mk_left
  refine' Measurable.ennreal_induction _ _ _
  Â· intro c s hs
    simp only [indicator_comp_right]
    simp [â† lintegral_indicator, â† m hs, â† hs, â† lintegral_const_mul, â† measurable_measure_prod_mk_left hs, â†
      prod_apply]
    
  Â· rintro f g - hf hg h2f h2g
    simp [â† lintegral_add_left, â† Measurable.lintegral_prod_right', â† hf.comp m, â† hf, â† h2f, â† h2g]
    
  Â· intro f hf h2f h3f
    have kf : âˆ€ x n, Measurable fun y => f n (x, y) := fun x n => (hf n).comp m
    have k2f : âˆ€ x, Monotone fun n y => f n (x, y) := fun x i j hij y => h2f hij (x, y)
    have lf : âˆ€ n, Measurable fun x => âˆ«â» y, f n (x, y) âˆ‚Î½ := fun n => (hf n).lintegral_prod_right'
    have l2f : Monotone fun n x => âˆ«â» y, f n (x, y) âˆ‚Î½ := fun i j hij x => lintegral_mono (k2f x hij)
    simp only [â† lintegral_supr hf h2f, â† lintegral_supr (kf _), â† k2f, â† lintegral_supr lf l2f, â† h3f]
    

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued almost everywhere measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AeMeasurable f (Î¼.Prod Î½)) :
    (âˆ«â» z, f z âˆ‚Î¼.Prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  have A : (âˆ«â» z, f z âˆ‚Î¼.prod Î½) = âˆ«â» z, hf.mk f z âˆ‚Î¼.prod Î½ := lintegral_congr_ae hf.ae_eq_mk
  have B : (âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼) = âˆ«â» x, âˆ«â» y, hf.mk f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
    apply lintegral_congr_ae
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ ha using lintegral_congr_ae ha
  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk]
  infer_instance

/-- The symmetric verion of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued almost everywhere measurable
functions on `Î± Ã— Î²`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : AeMeasurable f (Î¼.Prod Î½)) :
    (âˆ«â» z, f z âˆ‚Î¼.Prod Î½) = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ := by
  simp_rw [â† lintegral_prod_swap f hf]
  exact lintegral_prod _ hf.prod_swap

/-- The symmetric verion of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued measurable
functions on `Î± Ã— Î²`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm' [SigmaFinite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : Measurable f) :
    (âˆ«â» z, f z âˆ‚Î¼.Prod Î½) = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ :=
  lintegral_prod_symm f hf.AeMeasurable

/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which
makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„ (hf : AeMeasurable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ«â» z, f z.1 z.2 âˆ‚Î¼.Prod Î½ :=
  (lintegral_prod _ hf).symm

/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in
curried form, which makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral_symm [SigmaFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„ (hf : AeMeasurable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ«â» z, f z.2 z.1 âˆ‚Î½.Prod Î¼ :=
  (lintegral_prod_symm _ hf.prod_swap).symm

/-- Change the order of Lebesgue integration. -/
theorem lintegral_lintegral_swap [SigmaFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„ (hf : AeMeasurable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ«â» y, âˆ«â» x, f x y âˆ‚Î¼ âˆ‚Î½ :=
  (lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)

theorem lintegral_prod_mul {f : Î± â†’ â„â‰¥0âˆ} {g : Î² â†’ â„â‰¥0âˆ} (hf : AeMeasurable f Î¼) (hg : AeMeasurable g Î½) :
    (âˆ«â» z, f z.1 * g z.2 âˆ‚Î¼.Prod Î½) = (âˆ«â» x, f x âˆ‚Î¼) * âˆ«â» y, g y âˆ‚Î½ := by
  simp [â† lintegral_prod _ (hf.fst.mul hg.snd), â† lintegral_lintegral_mul hf hg]

/-! ### Integrability on a product -/


section

theorem Integrable.swap [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    Integrable (f âˆ˜ Prod.swap) (Î½.Prod Î¼) :=
  âŸ¨hf.AeStronglyMeasurable.prod_swap,
    (lintegral_prod_swap _ hf.AeStronglyMeasurable.ennnorm : _).le.trans_lt hf.HasFiniteIntegralâŸ©

theorem integrable_swap_iff [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ :
    Integrable (f âˆ˜ Prod.swap) (Î½.Prod Î¼) â†” Integrable f (Î¼.Prod Î½) :=
  âŸ¨fun hf => by
    convert hf.swap
    ext âŸ¨x, yâŸ©
    rfl, fun hf => hf.swapâŸ©

theorem has_finite_integral_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : StronglyMeasurable f) :
    HasFiniteIntegral f (Î¼.Prod Î½) â†”
      (âˆ€áµ x âˆ‚Î¼, HasFiniteIntegral (fun y => f (x, y)) Î½) âˆ§ HasFiniteIntegral (fun x => âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
  by
  simp only [â† has_finite_integral, â† lintegral_prod_of_measurable _ h1f.ennnorm]
  have : âˆ€ x, âˆ€áµ y âˆ‚Î½, 0 â‰¤ âˆ¥f (x, y)âˆ¥ := fun x => eventually_of_forall fun y => norm_nonneg _
  simp_rw
    [integral_eq_lintegral_of_nonneg_ae (this _)
      (h1f.norm.comp_measurable measurable_prod_mk_left).AeStronglyMeasurable,
    ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm]
  -- this fact is probably too specialized to be its own lemma
  have : âˆ€ {p q r : Prop} (h1 : r â†’ p), (r â†” p âˆ§ q) â†” p â†’ (r â†” q) := fun p q r h1 => by
    rw [â† And.congr_right_iff, and_iff_right_of_imp h1]
  rw [this]
  Â· intro h2f
    rw [lintegral_congr_ae]
    refine' h2f.mp _
    apply eventually_of_forall
    intro x hx
    dsimp' only
    rw [of_real_to_real]
    rw [â† lt_top_iff_ne_top]
    exact hx
    
  Â· intro h2f
    refine' ae_lt_top _ h2f.ne
    exact h1f.ennnorm.lintegral_prod_right'
    

theorem has_finite_integral_prod_iff' â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : AeStronglyMeasurable f (Î¼.Prod Î½)) :
    HasFiniteIntegral f (Î¼.Prod Î½) â†”
      (âˆ€áµ x âˆ‚Î¼, HasFiniteIntegral (fun y => f (x, y)) Î½) âˆ§ HasFiniteIntegral (fun x => âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
  by
  rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.strongly_measurable_mk]
  apply and_congr
  Â· apply eventually_congr
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]
    intro x hx
    exact has_finite_integral_congr hx
    
  Â· apply has_finite_integral_congr
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm] with _ hx using integral_congr_ae (eventually_eq.fun_comp hx _)
    
  Â· infer_instance
    

/-- A binary function is integrable if the function `y â†¦ f (x, y)` is integrable for almost every
  `x` and the function `x â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dy` is integrable. -/
theorem integrable_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : AeStronglyMeasurable f (Î¼.Prod Î½)) :
    Integrable f (Î¼.Prod Î½) â†”
      (âˆ€áµ x âˆ‚Î¼, Integrable (fun y => f (x, y)) Î½) âˆ§ Integrable (fun x => âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
  by
  simp [â† integrable, â† h1f, â† has_finite_integral_prod_iff', â† h1f.norm.integral_prod_right', â† h1f.prod_mk_left]

/-- A binary function is integrable if the function `x â†¦ f (x, y)` is integrable for almost every
  `y` and the function `y â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dx` is integrable. -/
theorem integrable_prod_iff' [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : AeStronglyMeasurable f (Î¼.Prod Î½)) :
    Integrable f (Î¼.Prod Î½) â†”
      (âˆ€áµ y âˆ‚Î½, Integrable (fun x => f (x, y)) Î¼) âˆ§ Integrable (fun y => âˆ« x, âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½ :=
  by
  convert integrable_prod_iff h1f.prod_swap using 1
  rw [integrable_swap_iff]

theorem Integrable.prod_left_ae [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    âˆ€áµ y âˆ‚Î½, Integrable (fun x => f (x, y)) Î¼ :=
  ((integrable_prod_iff' hf.AeStronglyMeasurable).mp hf).1

theorem Integrable.prod_right_ae [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    âˆ€áµ x âˆ‚Î¼, Integrable (fun y => f (x, y)) Î½ :=
  hf.swap.prod_left_ae

theorem Integrable.integral_norm_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    Integrable (fun x => âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
  ((integrable_prod_iff hf.AeStronglyMeasurable).mp hf).2

theorem Integrable.integral_norm_prod_right [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    Integrable (fun y => âˆ« x, âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½ :=
  hf.swap.integral_norm_prod_left

theorem integrable_prod_mul {f : Î± â†’ â„} {g : Î² â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î½) :
    Integrable (fun z : Î± Ã— Î² => f z.1 * g z.2) (Î¼.Prod Î½) := by
  refine' (integrable_prod_iff _).2 âŸ¨_, _âŸ©
  Â· apply ae_strongly_measurable.mul
    Â· exact (hf.1.mono' prod_fst_absolutely_continuous).comp_measurable measurable_fst
      
    Â· exact (hg.1.mono' prod_snd_absolutely_continuous).comp_measurable measurable_snd
      
    
  Â· exact eventually_of_forall fun x => hg.const_mul (f x)
    
  Â· simpa only [â† norm_mul, â† integral_mul_left] using hf.norm.mul_const _
    

end

variable [NormedSpace â„ E] [CompleteSpace E]

theorem Integrable.integral_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    Integrable (fun x => âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=
  Integrable.mono hf.integral_norm_prod_left hf.AeStronglyMeasurable.integral_prod_right' <|
    eventually_of_forall fun x =>
      (norm_integral_le_integral_norm _).trans_eq <|
        (norm_of_nonneg <| integral_nonneg_of_ae <| eventually_of_forall fun y => (norm_nonneg (f (x, y)) : _)).symm

theorem Integrable.integral_prod_right [SigmaFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) :
    Integrable (fun y => âˆ« x, f (x, y) âˆ‚Î¼) Î½ :=
  hf.swap.integral_prod_left

/-! ### The Bochner integral on a product -/


variable [SigmaFinite Î¼]

theorem integral_prod_swap (f : Î± Ã— Î² â†’ E) (hf : AeStronglyMeasurable f (Î¼.Prod Î½)) :
    (âˆ« z, f z.swap âˆ‚Î½.Prod Î¼) = âˆ« z, f z âˆ‚Î¼.Prod Î½ := by
  rw [â† prod_swap] at hf
  rw [â† integral_map measurable_swap.ae_measurable hf, prod_swap]

variable {E' : Type _} [NormedGroup E'] [CompleteSpace E'] [NormedSpace â„ E']

/-! Some rules about the sum/difference of double integrals. They follow from `integral_add`, but
  we separate them out as separate lemmas, because they involve quite some steps. -/


/-- Integrals commute with addition inside another integral. `F` can be any function. -/
theorem integral_fn_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : Integrable f (Î¼.Prod Î½))
    (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, F (âˆ« y, f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼) = âˆ« x, F ((âˆ« y, f (x, y) âˆ‚Î½) + âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by
  refine' integral_congr_ae _
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g
  simp [â† integral_add h2f h2g]

/-- Integrals commute with subtraction inside another integral.
  `F` can be any measurable function. -/
theorem integral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : Integrable f (Î¼.Prod Î½))
    (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼) = âˆ« x, F ((âˆ« y, f (x, y) âˆ‚Î½) - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by
  refine' integral_congr_ae _
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g
  simp [â† integral_sub h2f h2g]

/-- Integrals commute with subtraction inside a lower Lebesgue integral.
  `F` can be any function. -/
theorem lintegral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ â„â‰¥0âˆ) (hf : Integrable f (Î¼.Prod Î½))
    (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ«â» x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼) = âˆ«â» x, F ((âˆ« y, f (x, y) âˆ‚Î½) - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by
  refine' lintegral_congr_ae _
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g
  simp [â† integral_sub h2f h2g]

/-- Double integrals commute with addition. -/
theorem integral_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
  (integral_fn_integral_add id hf hg).trans <| integral_add hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`
  (instead of `f (x, y) + g (x, y)`) in the LHS. -/
theorem integral_integral_add' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
  integral_integral_add hf hg

/-- Double integrals commute with subtraction. -/
theorem integral_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
  (integral_fn_integral_sub id hf hg).trans <| integral_sub hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`
  (instead of `f (x, y) - g (x, y)`) in the LHS. -/
theorem integral_integral_sub' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.Prod Î½)) (hg : Integrable g (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
  integral_integral_sub hf hg

/-- The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. -/
theorem continuous_integral_integral : Continuous fun f : Î± Ã— Î² â†’â‚[Î¼.Prod Î½] E => âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  rw [continuous_iff_continuous_at]
  intro g
  refine'
    tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left
      (eventually_of_forall fun h => (L1.integrable_coe_fn h).integral_prod_left) _
  simp_rw [â† lintegral_fn_integral_sub (fun x => (âˆ¥xâˆ¥â‚Š : â„â‰¥0âˆ)) (L1.integrable_coe_fn _) (L1.integrable_coe_fn g)]
  refine' tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _
  Â· exact fun i => âˆ«â» x, âˆ«â» y, âˆ¥i (x, y) - g (x, y)âˆ¥â‚Š âˆ‚Î½ âˆ‚Î¼
    
  swap
  Â· exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
    
  show tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², âˆ¥i (x, y) - g (x, y)âˆ¥â‚Š âˆ‚Î½ âˆ‚Î¼) (ğ“ g) (ğ“ 0)
  have : âˆ€ i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E, Measurable fun z => (âˆ¥i z - g zâˆ¥â‚Š : â„â‰¥0âˆ) := fun i =>
    ((Lp.strongly_measurable i).sub (Lp.strongly_measurable g)).ennnorm
  simp_rw [â† lintegral_prod_of_measurable _ (this _), â† L1.of_real_norm_sub_eq_lintegral, â† of_real_zero]
  refine' (continuous_of_real.tendsto 0).comp _
  rw [â† tendsto_iff_norm_tendsto_zero]
  exact tendsto_id

/-- **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  `integrable_prod_iff` can be useful to show that the function in question in integrable.
  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral
  of the right-hand side is integrable. -/
theorem integral_prod :
    âˆ€ (f : Î± Ã— Î² â†’ E) (hf : Integrable f (Î¼.Prod Î½)), (âˆ« z, f z âˆ‚Î¼.Prod Î½) = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  apply integrable.induction
  Â· intro c s hs h2s
    simp_rw [integral_indicator hs, â† indicator_comp_right, Function.comp,
      integral_indicator (measurable_prod_mk_left hs), set_integral_const, integral_smul_const,
      integral_to_real (measurable_measure_prod_mk_left hs).AeMeasurable (ae_measure_lt_top hs h2s.ne), prod_apply hs]
    
  Â· intro f g hfg i_f i_g hf hg
    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg]
    
  Â· exact is_closed_eq continuous_integral continuous_integral_integral
    
  Â· intro f g hfg i_f hf
    convert hf using 1
    Â· exact integral_congr_ae hfg.symm
      
    Â· refine' integral_congr_ae _
      refine' (ae_ae_of_ae_prod hfg).mp _
      apply eventually_of_forall
      intro x hfgx
      exact integral_congr_ae (ae_eq_symm hfgx)
      
    

/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  This version has the integrals on the right-hand side in the other order. -/
theorem integral_prod_symm (f : Î± Ã— Î² â†’ E) (hf : Integrable f (Î¼.Prod Î½)) :
    (âˆ« z, f z âˆ‚Î¼.Prod Î½) = âˆ« y, âˆ« x, f (x, y) âˆ‚Î¼ âˆ‚Î½ := by
  simp_rw [â† integral_prod_swap f hf.ae_strongly_measurable]
  exact integral_prod _ hf.swap

/-- Reversed version of **Fubini's Theorem**. -/
theorem integral_integral {f : Î± â†’ Î² â†’ E} (hf : Integrable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ« z, f z.1 z.2 âˆ‚Î¼.Prod Î½ :=
  (integral_prod _ hf).symm

/-- Reversed version of **Fubini's Theorem** (symmetric version). -/
theorem integral_integral_symm {f : Î± â†’ Î² â†’ E} (hf : Integrable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ« z, f z.2 z.1 âˆ‚Î½.Prod Î¼ :=
  (integral_prod_symm _ hf.swap).symm

/-- Change the order of Bochner integration. -/
theorem integral_integral_swap â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : Integrable (uncurry f) (Î¼.Prod Î½)) :
    (âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼) = âˆ« y, âˆ« x, f x y âˆ‚Î¼ âˆ‚Î½ :=
  (integral_integral hf).trans (integral_prod_symm _ hf)

/-- **Fubini's Theorem** for set integrals. -/
theorem set_integral_prod (f : Î± Ã— Î² â†’ E) {s : Set Î±} {t : Set Î²} (hf : IntegrableOn f (s Ã—Ë¢ t) (Î¼.Prod Î½)) :
    (âˆ« z in s Ã—Ë¢ t, f z âˆ‚Î¼.Prod Î½) = âˆ« x in s, âˆ« y in t, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by
  simp only [measure.prod_restrict s t, â† integrable_on] at hfâŠ¢
  exact integral_prod f hf

theorem integral_prod_mul (f : Î± â†’ â„) (g : Î² â†’ â„) : (âˆ« z, f z.1 * g z.2 âˆ‚Î¼.Prod Î½) = (âˆ« x, f x âˆ‚Î¼) * âˆ« y, g y âˆ‚Î½ := by
  by_cases' h : integrable (fun z : Î± Ã— Î² => f z.1 * g z.2) (Î¼.prod Î½)
  Â· rw [integral_prod _ h]
    simp_rw [integral_mul_left, integral_mul_right]
    
  have H : Â¬integrable f Î¼ âˆ¨ Â¬integrable g Î½ := by
    contrapose! h
    exact integrable_prod_mul h.1 h.2
  cases H <;> simp [â† integral_undef h, â† integral_undef H]

theorem set_integral_prod_mul (f : Î± â†’ â„) (g : Î² â†’ â„) (s : Set Î±) (t : Set Î²) :
    (âˆ« z in s Ã—Ë¢ t, f z.1 * g z.2 âˆ‚Î¼.Prod Î½) = (âˆ« x in s, f x âˆ‚Î¼) * âˆ« y in t, g y âˆ‚Î½ := by
  simp only [measure.prod_restrict s t, â† integrable_on, â† integral_prod_mul]

end MeasureTheory

