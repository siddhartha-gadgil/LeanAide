{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " There are infinitely many odd numbers "}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " Every prime number is either `2` or odd "}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every field is a ring"}, "choices": [{"name": "is_add_monoid_hom.is_add_monoid_hom_mul_right", "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)", "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)", "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)", "doc_string": "Right multiplication in a ring is an additive monoid morphism.", "type": "is_add_monoid_hom (λ (y : γ), y * x)"}, {"name": "is_add_monoid_hom.is_add_monoid_hom_mul_left", "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)", "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)", "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)", "doc_string": "Left multiplication in a ring is an additive monoid morphism.", "type": "is_add_monoid_hom (λ (y : γ), x * y)"}, {"name": "ring.two_ne_zero", "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)", "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.", "type": "2 ≠ 0"}, {"name": "is_of_fin_add_order.add", "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)", "doc_string": "Elements of finite additive order are closed under addition.", "type": "is_of_fin_add_order (x + y)"}, {"name": "not_is_unit_prime_of_dvd_card", "statement": "theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p", "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p", "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R)", "doc_string": " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`.", "type": "¬is_unit ↑p"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every ring is a field"}, "choices": [{"name": "is_add_monoid_hom.is_add_monoid_hom_mul_right", "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)", "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)", "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)", "doc_string": "Right multiplication in a ring is an additive monoid morphism.", "type": "is_add_monoid_hom (λ (y : γ), y * x)"}, {"name": "is_add_monoid_hom.is_add_monoid_hom_mul_left", "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)", "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)", "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)", "doc_string": "Left multiplication in a ring is an additive monoid morphism.", "type": "is_add_monoid_hom (λ (y : γ), x * y)"}, {"name": "not_is_unit_prime_of_dvd_card", "statement": "theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p", "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p", "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R)", "doc_string": " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`.", "type": "¬is_unit ↑p"}, {"name": "ring.two_ne_zero", "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)", "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.", "type": "2 ≠ 0"}, {"name": "is_of_fin_add_order.add", "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)", "doc_string": "Elements of finite additive order are closed under addition.", "type": "is_of_fin_add_order (x + y)"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "If a vector space has dimension `2` then it is finite dimensional."}, "choices": [{"name": "ring.two_ne_zero", "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)", "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.", "type": "2 ≠ 0"}, {"name": "list.length_pos_of_sum_ne_zero", "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0)", "doc_string": "A list with sum not zero must have positive length.", "type": "0 < L.length"}, {"name": "is_coprime.ne_zero", "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1))", "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`.", "type": "p ≠ 0"}, {"name": "is_of_fin_order_zero", "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0", "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0", "args": "{G : Type u} [add_monoid G]", "doc_string": "0 is of finite order in any additive monoid.", "type": "is_of_fin_add_order 0"}, {"name": "is_of_fin_add_order.add", "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)", "doc_string": "Elements of finite additive order are closed under addition.", "type": "is_of_fin_add_order (x + y)"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " There are infinitely many odd numbers "}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " Every prime number is either `2` or odd "}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " There are infinitely many odd numbers "}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " Every prime number is either `2` or odd "}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " If a vector space has dimension `2` then it is finite dimensional. "}, "choices": [{"name": "ring.two_ne_zero", "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)", "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.", "type": "2 ≠ 0"}, {"name": "list.length_pos_of_sum_ne_zero", "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0)", "doc_string": "A list with sum not zero must have positive length.", "type": "0 < L.length"}, {"name": "is_coprime.ne_zero", "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1))", "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`.", "type": "p ≠ 0"}, {"name": "is_of_fin_order_zero", "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0", "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0", "args": "{G : Type u} [add_monoid G]", "doc_string": "0 is of finite order in any additive monoid.", "type": "is_of_fin_add_order 0"}, {"name": "is_of_fin_add_order.add", "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)", "doc_string": "Elements of finite additive order are closed under addition.", "type": "is_of_fin_add_order (x + y)"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "Every prime number is either `2` or odd"}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": "There are infinitely many odd numbers"}, "choices": [{"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "cardinal.cantor", "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a", "theorem": "(a : cardinal) : a < 2 ^ a", "args": "(a : cardinal)", "doc_string": "**Cantor's theorem**", "type": "a < 2 ^ a"}, {"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " Every prime number is either `2` or odd "}, "choices": [{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2", "args": "{p : ℕ} [fact (nat.prime p)]", "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.", "type": "p % 2 = 1 ↔ p ≠ 2"}, {"name": "nat.odd_mod_four_iff", "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3", "args": "{n : ℕ}", "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`", "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"}, {"name": "nat.factorization_eq_zero_iff", "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1", "args": "(n : ℕ)", "doc_string": "The only numbers with empty prime factorization are `0` and `1`", "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"}, {"name": "nat.even_pow", "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0", "args": "{m n : ℕ}", "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.", "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"}, {"name": "nat.factorization_inj", "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}", "args": "", "doc_string": "Every nonzero natural number has a unique prime factorization", "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " If a vector space has dimension `2` then it is finite dimensional. "}, "choices": [{"name": "ring.two_ne_zero", "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0", "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)", "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.", "type": "2 ≠ 0"}, {"name": "list.length_pos_of_sum_ne_zero", "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length", "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0)", "doc_string": "A list with sum not zero must have positive length.", "type": "0 < L.length"}, {"name": "is_coprime.ne_zero", "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0", "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1))", "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`.", "type": "p ≠ 0"}, {"name": "is_of_fin_order_zero", "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0", "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0", "args": "{G : Type u} [add_monoid G]", "doc_string": "0 is of finite order in any additive monoid.", "type": "is_of_fin_add_order 0"}, {"name": "is_of_fin_add_order.add", "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)", "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)", "doc_string": "Elements of finite additive order are closed under addition.", "type": "is_of_fin_add_order (x + y)"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " silly "}, "choices": [{"name": "gold_irrational", "statement": "theorem gold_irrational  : irrational golden_ratio", "theorem": " : irrational golden_ratio", "args": "", "doc_string": "The golden ratio is irrational.", "type": "irrational golden_ratio"}, {"name": "gold_conj_irrational", "statement": "theorem gold_conj_irrational  : irrational golden_conj", "theorem": " : irrational golden_conj", "args": "", "doc_string": "The conjugate of the golden ratio is irrational.", "type": "irrational golden_conj"}, {"name": "irrational_sqrt_two", "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)", "theorem": " : irrational (real.sqrt 2)", "args": "", "doc_string": "**Irrationality of the Square Root of 2**", "type": "irrational (real.sqrt 2)"}, {"name": "has_btw.btw.not_sbtw", "statement": "theorem has_btw.btw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a", "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a", "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)", "doc_string": "**Alias** of not_sbtw_of_btw`.", "type": "¬has_sbtw.sbtw c b a"}, {"name": "has_sbtw.sbtw.not_btw", "statement": "theorem has_sbtw.sbtw.not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a", "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a", "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)", "doc_string": "**Alias** of not_btw_of_sbtw`.", "type": "¬has_btw.btw c b a"}]}
{"query": {"n": 5, "model_name": "all-mpnet-base-v2", "filename": "data/safe_prompts.json", "field": "doc_string", "doc_string": " blah "}, "choices": [{"name": "rack.assoc_iff_id", "statement": "theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z", "theorem": "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z", "args": "{R : Type u_1} [rack R] {x y z : R}", "doc_string": "Associative racks are uninteresting.", "type": "shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z"}, {"name": "has_btw.btw.sbtw_of_not_btw", "statement": "theorem has_btw.btw.sbtw_of_not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c", "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c", "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a)", "doc_string": "**Alias** of sbtw_of_btw_not_btw`.", "type": "has_sbtw.sbtw a b c"}, {"name": "has_btw.btw.not_sbtw", "statement": "theorem has_btw.btw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a", "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a", "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)", "doc_string": "**Alias** of not_sbtw_of_btw`.", "type": "¬has_sbtw.sbtw c b a"}, {"name": "padic_val_nat.div", "statement": "theorem padic_val_nat.div {p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1", "theorem": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1", "args": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b)", "doc_string": "Dividing out by a prime factor reduces the padic_val_nat by 1.", "type": "padic_val_nat p (b / p) = padic_val_nat p b - 1"}, {"name": "nat.digits_lt_base", "statement": "theorem nat.digits_lt_base {b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b", "theorem": "{b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b", "args": "{b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m)", "doc_string": "The digits in the base b expansion of n are all less than b, if b ≥ 2", "type": "d < b"}]}
