[["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.952834328958786169749828331987373530864715576171875}],[" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Zero Î²], â‡‘0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.","distance":1.978654555354985244974841407383792102336883544921875}],["This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":1.967977171602309116593687576823867857456207275390625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9542340957750263807923829517676495015621185302734375}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ð•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ð•œ : Type u_1} {E : Type u_2} [inst : RCLike ð•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ð•œ E]\n  (x : E), âŸª0, xâŸ«_ð•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ð•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":1.9797685504673119272212034047697670757770538330078125}],["This theorem states that for any type `Î±` equipped with a Bornology structure and assumed to be a Bounded Space, the filter of cobounded sets in this Bornology is the bottom filter. In other words, in a bounded space, there are no cobounded sets in the corresponding Bornology, or the concept of cobounded sets becomes trivial.",{"type":"âˆ€ (Î± : Type u_2) [inst : Bornology Î±] [inst_1 : BoundedSpace Î±], Bornology.cobounded Î± = âŠ¥","name":"Bornology.cobounded_eq_bot","isProp":true,"docString":"This theorem states that for any type `Î±` equipped with a Bornology structure and assumed to be a Bounded Space, the filter of cobounded sets in this Bornology is the bottom filter. In other words, in a bounded space, there are no cobounded sets in the corresponding Bornology, or the concept of cobounded sets becomes trivial.","distance":1.971442707259997373370197237818501889705657958984375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.95471548161030295176487925346009433269500732421875}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.966373025880294722611552060698159039020538330078125}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.966566989170051460433796819415874779224395751953125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ð•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ð•œ E] [inst_4 : Module ð•œ Î²] [inst_5 : OrderedSMul ð•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ð•œ (segment ð•œ x y) f â†’ z âˆˆ segment ð•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.96822693657857694660151537391357123851776123046875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ð•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ð•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ð•œ Î²] [inst_3 : OrderedSMul ð•œ Î²] {f : ð•œ â†’ Î²} {x y z : ð•œ},\n  ConcaveOn ð•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.969005998386879952022354700602591037750244140625}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9690805857767139652736432253732345998287200927734375}],["Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ",{"type":"{K : semiOutParam (Type u_1)} â†’ [self : IsROrC K] â†’ K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ","distance":1.970716255784953574448081781156361103057861328125}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.9711622834016291339054305353784002363681793212890625}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.971866536162734551140829353244043886661529541015625}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.9731493665033041917666878362069837749004364013671875}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.973444951184438966862444431171752512454986572265625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.973485318905333851802197386859916150569915771484375}],["`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆž`. But since `â„â‰¥0âˆž` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ",{"type":"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  {f : MeasureTheory.SimpleFunc Î± E} {g : E â†’ ENNReal},\n  MeasureTheory.Integrable â†‘f â†’\n    g 0 = 0 â†’\n      (âˆ€ (b : E), g b â‰  âŠ¤) â†’\n        MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map (ENNReal.toReal âˆ˜ g) f) =\n          ENNReal.toReal (âˆ«â» (a : Î±), g (â†‘f a) âˆ‚Î¼)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","isProp":true,"docString":"`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆž`. But since `â„â‰¥0âˆž` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ","distance":1.973515673102231193780653484282083809375762939453125}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9738202313694814815647760042338632047176361083984375}],["Generate a random value of type `Î±` between `x` and `y` inclusive. ",{"type":"{m : Type u â†’ Type u_1} â†’\n  {g : Type} â†’\n    (Î± : Type u) â†’\n      [inst : Preorder Î±] â†’\n        [inst_1 : BoundedRandom m Î±] â†’\n          (lo hi : Î±) â†’ lo â‰¤ hi â†’ [inst_2 : RandomGen g] â†’ RandGT g m { a // lo â‰¤ a âˆ§ a â‰¤ hi }","name":"Random.randBound","isProp":false,"docString":"Generate a random value of type `Î±` between `x` and `y` inclusive. ","distance":1.9744962173621056766847914332174696028232574462890625}],["**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {N : Set Î±} {f : Î± â†’ ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure Î¼], AEMeasurable f â†’ â†‘â†‘Î¼ N = 0 â†’ âˆƒ x âˆ‰ N, f x â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼","name":"MeasureTheory.exists_not_mem_null_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ","distance":1.97509424939931665932135729235596954822540283203125}],["Default definition of `max`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.9759911771114584411179748713038861751556396484375}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.97695473309716351906217823852784931659698486328125}]]