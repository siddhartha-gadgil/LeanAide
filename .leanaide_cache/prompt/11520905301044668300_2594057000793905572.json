[["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9923973440768047993287837016396224498748779296875}],[" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Zero Î²], â‡‘0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.","distance":2.022029324001430428126013794098980724811553955078125}],["The theorem `TopCat.Presheaf.germ_stalkSpecializes` states that for any category `C` that has all small colimits, given a topological space `X` and a `C`-valued presheaf `F` on `X`, for any open set `U` in `X` and points `x` and `y` in `U` such that `x` specializes to `y`, the composition of the germ of `F` at `y` and the specialization of the stalk of `F` at `x` to `y` is equal to the germ of `F` at `x`. This essentially captures a certain commutativity property in the category of topological spaces related to presheaves and the specialization of points.",{"type":"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasColimits C] {X : TopCat}\n  (F : TopCat.Presheaf C X) {U : TopologicalSpace.Opens â†‘X} {y : â†¥U} {x : â†‘X} (h : x â¤³ â†‘y),\n  CategoryTheory.CategoryStruct.comp (F.germ y) (F.stalkSpecializes h) = F.germ âŸ¨x, â‹¯âŸ©","name":"TopCat.Presheaf.germ_stalkSpecializes","isProp":true,"docString":"The theorem `TopCat.Presheaf.germ_stalkSpecializes` states that for any category `C` that has all small colimits, given a topological space `X` and a `C`-valued presheaf `F` on `X`, for any open set `U` in `X` and points `x` and `y` in `U` such that `x` specializes to `y`, the composition of the germ of `F` at `y` and the specialization of the stalk of `F` at `x` to `y` is equal to the germ of `F` at `x`. This essentially captures a certain commutativity property in the category of topological spaces related to presheaves and the specialization of points.","distance":2.02836825896602501728693823679350316524505615234375}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9924047340885067125526575182448141276836395263671875}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":2.026886401405189719326926933717913925647735595703125}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":2.02948882245302808513542913715355098247528076171875}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9959849163476037769981985547929070889949798583984375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9977857735787971638075077862595207989215850830078125}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.003889110443143994899628523853607475757598876953125}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : (v : TypeVec.{u_2} 0) â†’ (v' : TypeVec.{u_3} 0) â†’ TypeVec.Arrow v v' â†’ Sort u_1} â†’\n  Î² Fin2.elim0 Fin2.elim0 TypeVec.nilFun â†’\n    (v : TypeVec.{u_2} 0) â†’ (v' : TypeVec.{u_3} 0) â†’ (fs : TypeVec.Arrow v v') â†’ Î² v v' fs","name":"TypeVec.typevecCasesNilâ‚ƒ","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":2.004382333236659707864646406960673630237579345703125}],["Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ",{"type":"{X : TopCat} â†’ {xâ‚€ xâ‚ : â†‘X} â†’ Path.Homotopic.Quotient xâ‚€ xâ‚ â†’ ({ as := xâ‚€ } âŸ¶ { as := xâ‚ })","name":"FundamentalGroupoid.fromPath","isProp":false,"docString":"Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ","distance":2.0048542337189996231927580083720386028289794921875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.008171791808663453338112958590500056743621826171875}],["The information required to build morphisms for `UniformSpace`. ",{"type":"CategoryTheory.UnbundledHom @UniformContinuous","name":"UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous","isProp":true,"docString":"The information required to build morphisms for `UniformSpace`. ","distance":2.008837314196120882314744449104182422161102294921875}],["Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax â†’ Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":2.0095667134508143902849042206071317195892333984375}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasColimits C] â†’ (X : AlgebraicGeometry.PresheafedSpace C) â†’ â†‘â†‘X â†’ C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":2.01107514090099659398447329294867813587188720703125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.01187937647802339569125251728110015392303466796875}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        {J : Type w} â†’\n          [inst_2 : CategoryTheory.Category.{w', w} J] â†’\n            {K : CategoryTheory.Functor J C} â†’\n              (F : CategoryTheory.Functor C D) â†’\n                {c : CategoryTheory.Limits.Cocone K} â†’\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) â†’\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] â†’ CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.012213962645764464554076766944490373134613037109375}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":2.013349024577060664142891255323775112628936767578125}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed âŠ£ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":2.0137005031580113012523725046776235103607177734375}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        {J : Type w} â†’\n          [inst_2 : CategoryTheory.Category.{w', w} J] â†’\n            {K : CategoryTheory.Functor J C} â†’\n              (F : CategoryTheory.Functor C D) â†’\n                {c : CategoryTheory.Limits.Cocone K} â†’\n                  CategoryTheory.Limits.IsColimit c â†’\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] â†’\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.01371461936003104398196228430606424808502197265625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":2.01525798519220611382252172916196286678314208984375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":2.015350284201435471231889096088707447052001953125}],["Function elaborating `initialize_simps_projections`. ",{"type":"Lean.Elab.Command.CommandElab","name":"Simps.elabInitializeSimpsProjections","isProp":false,"docString":"Function elaborating `initialize_simps_projections`. ","distance":2.015735383546872316884446263429708778858184814453125}],["`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ",{"type":"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  {f : MeasureTheory.SimpleFunc Î± E} {g : E â†’ ENNReal},\n  MeasureTheory.Integrable â†‘f â†’\n    g 0 = 0 â†’\n      (âˆ€ (b : E), g b â‰  âŠ¤) â†’\n        MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map (ENNReal.toReal âˆ˜ g) f) =\n          ENNReal.toReal (âˆ«â» (a : Î±), g (â†‘f a) âˆ‚Î¼)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","isProp":true,"docString":"`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ","distance":2.016157083249479509134971522144041955471038818359375}]]