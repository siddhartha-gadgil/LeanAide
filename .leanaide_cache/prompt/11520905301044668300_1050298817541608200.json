[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9786275818144078986193790115066803991794586181640625}],[" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ğ•œ E H),\n  UniqueDiffOn ğ•œ (Set.range â†‘I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.","distance":2.017405371908485900434016002691350877285003662109375}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.01252615172966731194037492969073355197906494140625}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9962533578930046207489112930488772690296173095703125}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":2.01968649643322795128597135771997272968292236328125}],["This theorem, `hammingDist_pos`, states that for any types `Î¹` and `Î²`, where `Î²` is a function from `Î¹` to another type and `Î¹` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Î¹` over `Î² i`, then the Hamming distance between two functions `x` and `y` (from `Î¹` to `Î²`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"This theorem, `hammingDist_pos`, states that for any types `Î¹` and `Î²`, where `Î²` is a function from `Î¹` to another type and `Î¹` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Î¹` over `Î² i`, then the Hamming distance between two functions `x` and `y` (from `Î¹` to `Î²`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.","distance":2.014388572725318571343677831464447081089019775390625}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":2.0020807282164643225996769615449011325836181640625}],["Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ",{"type":"{K : semiOutParam (Type u_1)} â†’ [self : IsROrC K] â†’ K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ","distance":2.00309725143900418942166652414016425609588623046875}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.00667197838141486698759763385169208049774169921875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.006672666698646967375907479436136782169342041015625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":2.006837805543260078167122628656215965747833251953125}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":2.007065849383700584240841635619290173053741455078125}],["**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {N : Set Î±} {f : Î± â†’ ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure Î¼], AEMeasurable f â†’ â†‘â†‘Î¼ N = 0 â†’ âˆƒ x âˆ‰ N, f x â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼","name":"MeasureTheory.exists_not_mem_null_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ","distance":2.007744772561230295337963980273343622684478759765625}],["Default definition of `max`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":2.007949713752265719080014605424366891384124755859375}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.008433976770643170084440498612821102142333984375}],["cases distinction for 0-length type vector ",{"type":"{Î² : TypeVec.{u_2} 0 â†’ Sort u_1} â†’ Î² Fin2.elim0 â†’ (v : TypeVec.{u_2} 0) â†’ Î² v","name":"TypeVec.casesNil","isProp":false,"docString":"cases distinction for 0-length type vector ","distance":2.00971474937281247008513673790730535984039306640625}],["Corresponds to `dist_pos`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":2.012669258440193065240464420639909803867340087890625}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":2.012982346602116390243963905959390103816986083984375}],["**First moment method**. The minimum of a measurable function is smaller than its integral. ",{"type":"âˆ€ {Î± : Type u_1} {m0 : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f : Î± â†’ ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure Î¼], AEMeasurable f â†’ âˆƒ x, f x â‰¤ âˆ«â» (a : Î±), f a âˆ‚Î¼","name":"MeasureTheory.exists_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral. ","distance":2.01300758798795609294529640465043485164642333984375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":2.013398626866757634701343704364262521266937255859375}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":2.013451058915288083284167441888712346553802490234375}],["If two simple functions are equal a.e., then their `lintegral`s are equal. ",{"type":"âˆ€ {Î± : Type u_1} {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±} {f g : MeasureTheory.SimpleFunc Î± ENNReal},\n  â†‘f =á¶ [MeasureTheory.Measure.ae Î¼] â†‘g â†’ MeasureTheory.SimpleFunc.lintegral f Î¼ = MeasureTheory.SimpleFunc.lintegral g Î¼","name":"MeasureTheory.SimpleFunc.lintegral_congr","isProp":true,"docString":"If two simple functions are equal a.e., then their `lintegral`s are equal. ","distance":2.013706770824501557370922455447725951671600341796875}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.014174704252455594399862093268893659114837646484375}],["Corresponds to `zero_eq_dist`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 = hammingDist x y â†” x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":2.014550332563876278157977139926515519618988037109375}]]