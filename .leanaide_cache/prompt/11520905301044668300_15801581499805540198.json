[["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9302716904702832412255020244629122316837310791015625}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":1.9513587877700009354242638437426649034023284912109375}],["This theorem, `isGreatest_univ`, states that for any type `Î±` that has a preorder and is also an ordered set with a maximum element (denoted as `âŠ¤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `Î±`). In other words, no element in the universal set of `Î±` is greater than the maximum element `âŠ¤`.",{"type":"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±], IsGreatest Set.univ âŠ¤","name":"isGreatest_univ","isProp":true,"docString":"This theorem, `isGreatest_univ`, states that for any type `Î±` that has a preorder and is also an ordered set with a maximum element (denoted as `âŠ¤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `Î±`). In other words, no element in the universal set of `Î±` is greater than the maximum element `âŠ¤`.","distance":1.951522451925059353783353799371980130672454833984375}],["Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n",{"type":"â„• â†’ Linarith.PCompSet â†’ Linarith.LinarithM Unit","name":"Linarith.update","isProp":false,"docString":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n","distance":1.9370642402449045338386213188641704618930816650390625}],[" The theorem asserts that the function `Vector.head` on types `Î±` with `Primcodable` instance and natural numbers is primitive recursive.",{"type":"âˆ€ {Î± : Type u_1} [inst : Primcodable Î±] {n : â„•}, Primrec Vector.head","name":"Primrec.vector_head","isProp":true,"docString":" The theorem asserts that the function `Vector.head` on types `Î±` with `Primcodable` instance and natural numbers is primitive recursive.","distance":1.9538373122830707817598749898024834692478179931640625}],["This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `Î±` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.",{"type":"âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] [inst_1 : LinearOrder Î±]\n  [inst_2 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1] (a : Î±), max a 0 - max (-a) 0 = a","name":"max_zero_sub_max_neg_zero_eq_self","isProp":true,"docString":"This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `Î±` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.","distance":1.964753294726371724010505204205401241779327392578125}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment â†’ Lean.Name â†’ Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.9394811825647277903073018023860640823841094970703125}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConvexOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ f z â‰¤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9415061527481165537523111197515390813350677490234375}],["`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ",{"type":"{S : Type u_2} â†’\n  [inst : Ring S] â†’ {A : Type u_4} â†’ [inst_1 : CommRing A] â†’ [inst_2 : Algebra A S] â†’ PowerBasis A S â†’ Polynomial A","name":"PowerBasis.minpolyGen","isProp":false,"docString":"`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ","distance":1.9491174243446636182852671481668949127197265625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name â†’ Bool) â†’ Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.9499304510691277680933808369445614516735076904296875}],["The maximum operation: `max x y`. ",{"type":"{Î± : Type u} â†’ [self : Max Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Max.max","isProp":false,"docString":"The maximum operation: `max x y`. ","distance":1.9530044482851334208817206672392785549163818359375}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed âŠ£ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":1.9535701675217449491128718364052474498748779296875}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’ CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.9551979576524620707544954711920581758022308349609375}],["`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop","name":"Contravariant","isProp":false,"docString":"`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ","distance":1.956089988402560653213413388584740459918975830078125}],["The pointwise maximum of strictly convex functions is strictly convex. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {s : Set E} {f g : E â†’ Î²}, StrictConvexOn ğ•œ s f â†’ StrictConvexOn ğ•œ s g â†’ StrictConvexOn ğ•œ s (f âŠ” g)","name":"StrictConvexOn.sup","isProp":true,"docString":"The pointwise maximum of strictly convex functions is strictly convex. ","distance":1.9561985263410530677674614707939326763153076171875}],["The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.HasShift C â„¤] â†’\n      {J : Type u_1} â†’\n        (T : J â†’ CategoryTheory.Pretriangulated.Triangle C) â†’\n          [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚] â†’\n            [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚‚] â†’\n              [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚ƒ] â†’\n                [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).objâ‚] â†’\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Pretriangulated.productTriangle.fan T)","name":"CategoryTheory.Pretriangulated.productTriangle.isLimitFan","isProp":false,"docString":"The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ","distance":1.9570416928424718694401462926180101931095123291015625}],["The `ğŸ™_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n",{"type":"(V : Type v) â†’\n  [inst : CategoryTheory.Category.{w, v} V] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory V] â†’\n      {C : Type uâ‚} â†’\n        [inst_2 : CategoryTheory.EnrichedCategory V C] â†’ (X : C) â†’ ğŸ™_ V âŸ¶ CategoryTheory.EnrichedCategory.Hom X X","name":"CategoryTheory.eId","isProp":false,"docString":"The `ğŸ™_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n","distance":1.957222781304859271500617978745140135288238525390625}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConvexOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ f z â‰¤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9578569787502455579186744216713123023509979248046875}],["The tautological action by `CentroidHom Î±` on `Î±`.\n\nThis generalizes `Function.End.applyMulAction`. ",{"type":"{Î± : Type u_5} â†’ [inst : NonUnitalNonAssocSemiring Î±] â†’ Module (CentroidHom Î±) Î±","name":"CentroidHom.applyModule","isProp":false,"docString":"The tautological action by `CentroidHom Î±` on `Î±`.\n\nThis generalizes `Function.End.applyMulAction`. ","distance":1.958267172680240975068954867310822010040283203125}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name â†’ Array Simps.ParsedProjectionData â†’ Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9603856980290343958728271900326944887638092041015625}],["Convert a `BestFirstQueue` to a `MLList (Î± Ã— Î²)`, by popping off all elements.\n",{"type":"{Ï‰ Î± : Type} â†’\n  {prio : Î± â†’ Thunk Ï‰} â†’\n    {Îµ : Î± â†’ Type} â†’\n      [inst : LinearOrder Ï‰] â†’\n        [inst_1 : (a : Î±) â†’ Estimator (prio a) (Îµ a)] â†’\n          [I : âˆ€ (a : Î±), WellFoundedGT â†‘(Set.range (EstimatorData.bound (prio a)))] â†’\n            {m : Type â†’ Type} â†’\n              [inst_2 : Monad m] â†’\n                {Î² : Type} â†’\n                  [inst_3 : Ord Ï‰] â†’\n                    [inst_4 : Ord Î±] â†’ {maxSize : Option â„•} â†’ BestFirstQueue prio Îµ m Î² maxSize â†’ MLList m (Î± Ã— Î²)","name":"BestFirstQueue.toMLList","isProp":false,"docString":"Convert a `BestFirstQueue` to a `MLList (Î± Ã— Î²)`, by popping off all elements.\n","distance":1.96093214662069836862201555049978196620941162109375}],["Auxiliary definition for `free_monoidal_category.project`. ",{"type":"{C : Type u} â†’\n  {D : Type u'} â†’\n    [inst : CategoryTheory.Category.{v', u'} D] â†’\n      [inst : CategoryTheory.MonoidalCategory D] â†’ (C â†’ D) â†’ CategoryTheory.FreeMonoidalCategory C â†’ D","name":"CategoryTheory.FreeMonoidalCategory.projectObj","isProp":false,"docString":"Auxiliary definition for `free_monoidal_category.project`. ","distance":1.9609465651547519637887262433650903403759002685546875}],["`centroidWeights` equals a constant function. ",{"type":"âˆ€ (k : Type u_1) [inst : DivisionRing k] {Î¹ : Type u_4} (s : Finset Î¹),\n  Finset.centroidWeights k s = Function.const Î¹ (â†‘s.card)â»Â¹","name":"Finset.centroidWeights_eq_const","isProp":true,"docString":"`centroidWeights` equals a constant function. ","distance":1.9613059588031702684673973635653965175151824951171875}],["Function elaborating `initialize_simps_projections`. ",{"type":"Lean.Elab.Command.CommandElab","name":"Simps.elabInitializeSimpsProjections","isProp":false,"docString":"Function elaborating `initialize_simps_projections`. ","distance":1.96180286642506729322121827863156795501708984375}]]