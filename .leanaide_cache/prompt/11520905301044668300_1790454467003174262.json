[["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9585922244064857267176194000057876110076904296875}],[" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Zero Î²], â‡‘0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.","distance":2.016413075314805070092916139401495456695556640625}],["The theorem `IsBot.isMin` states that for any type `Î±` that has a less than or equal to ordering (`LE`), if an element `a` of `Î±` is a bottom element (meaning it is less than or equal to every other element of `Î±`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.",{"type":"âˆ€ {Î± : Type u_1} [inst : LE Î±] {a : Î±}, IsBot a â†’ IsMin a","name":"IsBot.isMin","isProp":true,"docString":"The theorem `IsBot.isMin` states that for any type `Î±` that has a less than or equal to ordering (`LE`), if an element `a` of `Î±` is a bottom element (meaning it is less than or equal to every other element of `Î±`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.","distance":2.0145112528148931829719003872014582157135009765625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.978290861127264488317223367630504071712493896484375}],[" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ğ•œ E H),\n  UniqueDiffOn ğ•œ (Set.range â†‘I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.","distance":2.02241641926436077625339748919941484928131103515625}],["The theorem `orthogonalProjection_minimal` states that for any real or complex number type `ğ•œ`, any normed add commutative group `E`, and any inner product space over `ğ•œ` and `E`, given a submodule `U` of `E` and any element `y` of `E`, the orthogonality of the projection of `y` onto `U` is such that it minimizes the norm (or distance) of `y - x` for any `x` in `U`. In mathematical terms, this can be written as `â€–y - â†‘((orthogonalProjection U) y)â€– = â¨… x, â€–y - â†‘xâ€–`, where `â¨… x` denotes the infimum over all `x` in `U`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] (y : E), â€–y - â†‘((orthogonalProjection U) y)â€– = â¨… x, â€–y - â†‘xâ€–","name":"orthogonalProjection_minimal","isProp":true,"docString":"The theorem `orthogonalProjection_minimal` states that for any real or complex number type `ğ•œ`, any normed add commutative group `E`, and any inner product space over `ğ•œ` and `E`, given a submodule `U` of `E` and any element `y` of `E`, the orthogonality of the projection of `y` onto `U` is such that it minimizes the norm (or distance) of `y - x` for any `x` in `U`. In mathematical terms, this can be written as `â€–y - â†‘((orthogonalProjection U) y)â€– = â¨… x, â€–y - â†‘xâ€–`, where `â¨… x` denotes the infimum over all `x` in `U`.","distance":2.017585239028156340879149865941144526004791259765625}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.987275548979270833882537772296927869319915771484375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.989701486664291696371265061316080391407012939453125}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.991113795287395848987443969235755503177642822265625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name â†’ Simps.ParsedProjectionData â†’ List Lean.Level â†’ Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.9920594426459847792187929371721111238002777099609375}],["Find the first minimal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n",{"type":"{Î± : Type u_1} â†’ [ord : Ord Î±] â†’ [inst : Inhabited Î±] â†’ (xs : Array Î±) â†’ optParam â„• 0 â†’ optParam â„• (Array.size xs) â†’ Î±","name":"Array.minI","isProp":false,"docString":"Find the first minimal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n","distance":1.9943950325129937706236660233116708695888519287109375}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData â†’ Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9954180479025078742694176980876363813877105712890625}],["Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax â†’ Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":1.996275413858851432991059482446871697902679443359375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9977690268628549574714270420372486114501953125}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.998768054911905789339243710855953395366668701171875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9998668383496092104678609757684171199798583984375}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":2.00114707405024461195353069342672824859619140625}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":2.001616713002018599354414618574082851409912109375}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":2.002074186246807219191623516962863504886627197265625}],["Checks whether `completionPos` points at a free space in the header. ",{"type":"Lean.Syntax â†’ String.Pos â†’ Bool","name":"ImportCompletion.isImportCmdCompletionRequest","isProp":false,"docString":"Checks whether `completionPos` points at a free space in the header. ","distance":2.0039288689691385769720000098459422588348388671875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.00393776511585297583906140062026679515838623046875}],["The orthogonal projection of `y` on `U` minimizes the distance `â€–y - xâ€–` for `x âˆˆ U`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] (y : E), â€–y - â†‘((orthogonalProjection U) y)â€– = â¨… x, â€–y - â†‘xâ€–","name":"orthogonalProjection_minimal","isProp":true,"docString":"The orthogonal projection of `y` on `U` minimizes the distance `â€–y - xâ€–` for `x âˆˆ U`. ","distance":2.003941375446899986201287902076728641986846923828125}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":2.00452941658175110006823160802014172077178955078125}],["Function elaborating `initialize_simps_projections`. ",{"type":"Lean.Elab.Command.CommandElab","name":"Simps.elabInitializeSimpsProjections","isProp":false,"docString":"Function elaborating `initialize_simps_projections`. ","distance":2.00457911293177648559549197671003639698028564453125}]]