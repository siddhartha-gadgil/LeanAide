[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9561346908006382872002859585336409509181976318359375}],[" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ğ•œ E H),\n  UniqueDiffOn ğ•œ (Set.range â†‘I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ğ•œ`, normed additive commutative group `E`, normed space `E` over `ğ•œ`, and topological space `H`, the function `I` from `ğ•œ` to `E` defined in a Model With Corners `I` of types `ğ•œ`, `E`, and `H` is uniquely differentiable on its entire range.","distance":1.982587711596365043220657753408886492252349853515625}],["This theorem states that for any type `Î±` equipped with a Bornology structure and assumed to be a Bounded Space, the filter of cobounded sets in this Bornology is the bottom filter. In other words, in a bounded space, there are no cobounded sets in the corresponding Bornology, or the concept of cobounded sets becomes trivial.",{"type":"âˆ€ (Î± : Type u_2) [inst : Bornology Î±] [inst_1 : BoundedSpace Î±], Bornology.cobounded Î± = âŠ¥","name":"Bornology.cobounded_eq_bot","isProp":true,"docString":"This theorem states that for any type `Î±` equipped with a Bornology structure and assumed to be a Bounded Space, the filter of cobounded sets in this Bornology is the bottom filter. In other words, in a bounded space, there are no cobounded sets in the corresponding Bornology, or the concept of cobounded sets becomes trivial.","distance":1.978365921811033434352111726184375584125518798828125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.97013282195732930546228089951910078525543212890625}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":1.983288670907286554978554704575799405574798583984375}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.9789445934237714919134987212601117789745330810546875}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.97015098241242636589731773710809648036956787109375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9703102591761003647974348496063612401485443115234375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9741959500003216643193582058302126824855804443359375}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.975343005408891183805053515243344008922576904296875}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9762352780857070921882723268936388194561004638671875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9765607192798311242398767717531882226467132568359375}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.976812371777602717060062786913476884365081787109375}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.978329284422546852084678903338499367237091064453125}],["The seminorm controls the Schwartz estimate for any fixed `x`.\n\nVariant for functions `ğ“¢(â„, F)`. ",{"type":"âˆ€ (ğ•œ : Type u_1) {F : Type u_5} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace â„ F] [inst_2 : NormedField ğ•œ]\n  [inst_3 : NormedSpace ğ•œ F] [inst_4 : SMulCommClass â„ ğ•œ F] (k n : â„•) (f : SchwartzMap â„ F) (x : â„),\n  |x| ^ k * â€–iteratedDeriv n (â‡‘f) xâ€– â‰¤ (SchwartzMap.seminorm ğ•œ k n) f","name":"SchwartzMap.le_seminorm'","isProp":true,"docString":"The seminorm controls the Schwartz estimate for any fixed `x`.\n\nVariant for functions `ğ“¢(â„, F)`. ","distance":1.9787728608778742955820462157134898006916046142578125}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.9799546340623719320461759707541204988956451416015625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.980511332608146712885854867636226117610931396484375}],["`toNNReal x` returns `x` if it is real, otherwise 0. ",{"type":"ENNReal â†’ NNReal","name":"ENNReal.toNNReal","isProp":false,"docString":"`toNNReal x` returns `x` if it is real, otherwise 0. ","distance":1.9805209134445214136377444447134621441364288330078125}],["**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {s : Set E} {f : E â†’ Î²}, ConcaveOn ğ•œ ((convexHull ğ•œ) s) f â†’ âˆ€ {x : E}, x âˆˆ (convexHull ğ•œ) s â†’ âˆƒ y âˆˆ s, f y â‰¤ f x","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ","distance":1.9811426167412957699553999191266484558582305908203125}],["Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ",{"type":"{K : semiOutParam (Type u_1)} â†’ [self : IsROrC K] â†’ K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ","distance":1.9811958441453227930395541989128105342388153076171875}],["`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ",{"type":"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  {f : MeasureTheory.SimpleFunc Î± E} {g : E â†’ ENNReal},\n  MeasureTheory.Integrable â†‘f â†’\n    g 0 = 0 â†’\n      (âˆ€ (b : E), g b â‰  âŠ¤) â†’\n        MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map (ENNReal.toReal âˆ˜ g) f) =\n          ENNReal.toReal (âˆ«â» (a : Î±), g (â†‘f a) âˆ‚Î¼)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","isProp":true,"docString":"`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ","distance":1.9824584316358706548300006033969111740589141845703125}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.982879753062047001321843708865344524383544921875}],["The seminorm controls the Schwartz estimate for any fixed `x`. ",{"type":"âˆ€ (ğ•œ : Type u_1) {E : Type u_4} {F : Type u_5} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace â„ F] [inst_4 : NormedField ğ•œ] [inst_5 : NormedSpace ğ•œ F]\n  [inst_6 : SMulCommClass â„ ğ•œ F] (k n : â„•) (f : SchwartzMap E F) (x : E),\n  â€–xâ€– ^ k * â€–iteratedFDeriv â„ n (â‡‘f) xâ€– â‰¤ (SchwartzMap.seminorm ğ•œ k n) f","name":"SchwartzMap.le_seminorm","isProp":true,"docString":"The seminorm controls the Schwartz estimate for any fixed `x`. ","distance":1.9830582335878788047267562433262355625629425048828125}],["`toReal x` returns `x` if it is real, `0` otherwise. ",{"type":"ENNReal â†’ â„","name":"ENNReal.toReal","isProp":false,"docString":"`toReal x` returns `x` if it is real, `0` otherwise. ","distance":1.98519359664865735481953379348851740360260009765625}]]