[["The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. ",{"type":"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P}, Set.Nonempty â†‘s â†’ â†‘(AffineSubspace.direction s) = â†‘s -áµ¥ â†‘s","name":"AffineSubspace.coe_direction_eq_vsub_set","isProp":true,"docString":"The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. ","distance":1.9517662822924746190977884907624684274196624755859375}],[" For any type `M` with a group structure, any type `Î±` with a `MulAction` of `M` on `Î±`, and a family of sets `s : Î¹ â†’ Sets`, the subgroup of `M` fixing the union of `s` equals the intersection of subgroups fixing each `s(i)`.",{"type":"âˆ€ (M : Type u_1) (Î± : Type u_2) [inst : Group M] [inst_1 : MulAction M Î±] {Î¹ : Sort u_3} {s : Î¹ â†’ Set Î±},\n  fixingSubgroup M (â‹ƒ i, s i) = â¨… i, fixingSubgroup M (s i)","name":"fixingSubgroup_iUnion","isProp":true,"docString":" For any type `M` with a group structure, any type `Î±` with a `MulAction` of `M` on `Î±`, and a family of sets `s : Î¹ â†’ Sets`, the subgroup of `M` fixing the union of `s` equals the intersection of subgroups fixing each `s(i)`.","distance":1.9481298721934319218007658491842448711395263671875}],["The theorem `Isometry.preimage_setOf_dist` states that for all types `Î±` and `Î²` that are instances of PseudoMetricSpace, for all functions `f` from `Î±` to `Î²` that are isometries, and for all `x` in `Î±` and predicate `p` on real numbers, the preimage of the set of elements in `Î²` that satisfy predicate `p` with the distance to `f(x)` under the function `f` is exactly the set of elements in `Î±` that satisfy predicate `p` with the distance to `x`. In simpler terms, this means that an isometry `f` preserves the property of distance: the set of points in `Î±` that have a certain property with respect to their distance to `x` is mapped by `f` onto the set of points in `Î²` that have the same property with respect to their distance to `f(x)`.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : PseudoMetricSpace Î±] [inst_1 : PseudoMetricSpace Î²] {f : Î± â†’ Î²},\n  Isometry f â†’ âˆ€ (x : Î±) (p : â„ â†’ Prop), f â»Â¹' {y | p (dist y (f x))} = {y | p (dist y x)}","name":"Isometry.preimage_setOf_dist","isProp":true,"docString":"The theorem `Isometry.preimage_setOf_dist` states that for all types `Î±` and `Î²` that are instances of PseudoMetricSpace, for all functions `f` from `Î±` to `Î²` that are isometries, and for all `x` in `Î±` and predicate `p` on real numbers, the preimage of the set of elements in `Î²` that satisfy predicate `p` with the distance to `f(x)` under the function `f` is exactly the set of elements in `Î±` that satisfy predicate `p` with the distance to `x`. In simpler terms, this means that an isometry `f` preserves the property of distance: the set of points in `Î±` that have a certain property with respect to their distance to `x` is mapped by `f` onto the set of points in `Î²` that have the same property with respect to their distance to `f(x)`.","distance":1.97252170518114144925903019611723721027374267578125}],["In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. ",{"type":"âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E],\n  1 < Module.rank â„ E â†’ âˆ€ (x : E) {r : â„}, 0 â‰¤ r â†’ IsPathConnected (Metric.sphere x r)","name":"isPathConnected_sphere","isProp":true,"docString":"In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. ","distance":1.9518826132327620204165441464283503592014312744140625}],[" Given a subtractive, negatable monoid `M` with set `S` of its additive subgroups that respects scalars multiplication by integers, then `S` is a set of `M` that respects scalar multiplication by integers.",{"type":"âˆ€ {S : Type u_1} {M : Type u_2} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [inst_2 : AddSubgroupClass S M],\n  SMulMemClass S â„¤ M","name":"AddSubgroupClass.zsmulMemClass","isProp":true,"docString":" Given a subtractive, negatable monoid `M` with set `S` of its additive subgroups that respects scalars multiplication by integers, then `S` is a set of `M` that respects scalar multiplication by integers.","distance":1.949820188578535340440112122450955212116241455078125}],["The theorem `MeasureTheory.SimpleFunc.measurableSet_preimage` states that for any types `Î±` and `Î²`, given a measurable space structure on `Î±`, a simple function `f` from `Î±` to `Î²`, and a set `s` of type `Î²`, the preimage of the set `s` under the function `f` is a measurable set. \n\nIn other words, if we apply the function `f` to some elements of `Î±` and consider the set of all such elements that map into `s`, that set of elements from `Î±` is measurable. This is a fundamental property in measure theory, which ensures that we can measure the \"size\" of the set of all elements that get mapped into a particular subset of the range of a simple function.",{"type":"âˆ€ {Î± : Type u_1} {Î² : Type u_2} [inst : MeasurableSpace Î±] (f : MeasureTheory.SimpleFunc Î± Î²) (s : Set Î²),\n  MeasurableSet (â†‘f â»Â¹' s)","name":"MeasureTheory.SimpleFunc.measurableSet_preimage","isProp":true,"docString":"The theorem `MeasureTheory.SimpleFunc.measurableSet_preimage` states that for any types `Î±` and `Î²`, given a measurable space structure on `Î±`, a simple function `f` from `Î±` to `Î²`, and a set `s` of type `Î²`, the preimage of the set `s` under the function `f` is a measurable set. \n\nIn other words, if we apply the function `f` to some elements of `Î±` and consider the set of all such elements that map into `s`, that set of elements from `Î±` is measurable. This is a fundamental property in measure theory, which ensures that we can measure the \"size\" of the set of all elements that get mapped into a particular subset of the range of a simple function.","distance":1.973504461800512199687318570795468986034393310546875}],["The base space of a vector bundle core, as a convenience function for dot notation",{"type":"{B : Type u_2} â†’ Type u_2","name":"VectorBundleCore.Base","isProp":false,"docString":"The base space of a vector bundle core, as a convenience function for dot notation","distance":1.9524565638778932363806006833328865468502044677734375}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.95360301899524468893787343404255807399749755859375}],["The setoid of the `SameRay` relation for the subtype of nonzero vectors. ",{"type":"(R : Type u_1) â†’\n  [inst : StrictOrderedCommSemiring R] â†’\n    (M : Type u_2) â†’ [inst_1 : AddCommMonoid M] â†’ [inst : Module R M] â†’ Setoid (RayVector R M)","name":"RayVector.Setoid","isProp":false,"docString":"The setoid of the `SameRay` relation for the subtype of nonzero vectors. ","distance":1.95444642146946190308653967804275453090667724609375}],["If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ",{"type":"âˆ€ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {s : Set G} {x y : G},\n  openSegment â„ x y âŠ† s â†’ y - x âˆˆ tangentConeAt â„ s x","name":"mem_tangentCone_of_openSegment_subset","isProp":true,"docString":"If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ","distance":1.9546832266400395727856675875955261290073394775390625}],["If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - kâ»Â¹`.\n",{"type":"âˆ€ {A : Set â„•} [inst : DecidablePred fun x => x âˆˆ A] {k : â„•}, k âˆ‰ A â†’ schnirelmannDensity A â‰¤ 1 - (â†‘k)â»Â¹","name":"schnirelmannDensity_le_of_not_mem","isProp":true,"docString":"If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - kâ»Â¹`.\n","distance":1.9578511151904063325446259113959968090057373046875}],["Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. ",{"type":"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P},\n  p âˆˆ s â†’ AffineSubspace.mk' p (AffineSubspace.direction s) = s","name":"AffineSubspace.mk'_eq","isProp":true,"docString":"Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. ","distance":1.9579569445727516008304291972308419644832611083984375}],["If vectors `vâ‚` and `vâ‚‚` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `vâ‚ + vâ‚‚`, see `SameRay.exists_eq_smul_add`. ",{"type":"âˆ€ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {vâ‚ vâ‚‚ : M}, SameRay R vâ‚ vâ‚‚ â†’ âˆƒ u a b, 0 â‰¤ a âˆ§ 0 â‰¤ b âˆ§ a + b = 1 âˆ§ vâ‚ = a â€¢ u âˆ§ vâ‚‚ = b â€¢ u","name":"SameRay.exists_eq_smul","isProp":true,"docString":"If vectors `vâ‚` and `vâ‚‚` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `vâ‚ + vâ‚‚`, see `SameRay.exists_eq_smul_add`. ","distance":1.9588920852824724949670098794740624725818634033203125}],["If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ",{"type":"âˆ€ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace â„ G] {s : Set G} {x y : G},\n  segment â„ x y âŠ† s â†’ y - x âˆˆ tangentConeAt â„ s x","name":"mem_tangentCone_of_segment_subset","isProp":true,"docString":"If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ","distance":1.9593823915441868077635945155634544789791107177734375}],["An alias of `ContinuousMultilinearMap.normedSpace` with non-dependent types to help typeclass\nsearch. ",{"type":"{ğ•œ : Type u} â†’\n  {Î¹ : Type v} â†’\n    {G : Type wG} â†’\n      {G' : Type wG'} â†’\n        [inst : Fintype Î¹] â†’\n          [inst_1 : NontriviallyNormedField ğ•œ] â†’\n            [inst_2 : SeminormedAddCommGroup G] â†’\n              [inst_3 : NormedSpace ğ•œ G] â†’\n                [inst_4 : SeminormedAddCommGroup G'] â†’\n                  [inst_5 : NormedSpace ğ•œ G'] â†’\n                    {ğ•œ' : Type u_1} â†’\n                      [inst_6 : NormedField ğ•œ'] â†’\n                        [inst_7 : NormedSpace ğ•œ' G] â†’\n                          [inst_8 : SMulCommClass ğ•œ ğ•œ' G] â†’ NormedSpace ğ•œ' (ContinuousMultilinearMap ğ•œ (fun x => G') G)","name":"ContinuousMultilinearMap.normedSpace'","isProp":false,"docString":"An alias of `ContinuousMultilinearMap.normedSpace` with non-dependent types to help typeclass\nsearch. ","distance":1.959585608766023057114580296911299228668212890625}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) â†’ AlgebraicGeometry.IsAffine X â†’ AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":1.9601256537920139777497752220369875431060791015625}],["The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ğ•œ : Type u_8} â†’\n  {ğ•œ' : Type u_9} â†’\n    {E : Type u_10} â†’\n      [inst : NormedField ğ•œ'] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’ [I : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ' (RestrictScalars ğ•œ ğ•œ' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9603170698581726671960723251686431467533111572265625}],["The tangent bundle to a smooth manifold, as a Sigma type. Defined in terms of\n`Bundle.TotalSpace` to be able to put a suitable topology on it. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {H : Type u_4} â†’\n            [inst_3 : TopologicalSpace H] â†’\n              (I : ModelWithCorners ğ•œ E H) â†’\n                (M : Type u_6) â†’\n                  [inst_4 : TopologicalSpace M] â†’\n                    [inst_5 : ChartedSpace H M] â†’ [inst : SmoothManifoldWithCorners I M] â†’ Type (max u_6 u_2)","name":"TangentBundle","isProp":false,"docString":"The tangent bundle to a smooth manifold, as a Sigma type. Defined in terms of\n`Bundle.TotalSpace` to be able to put a suitable topology on it. ","distance":1.9608252424833343408039354471839033067226409912109375}],["The projectivization of the `K`-vector space `V`.\nThe notation `â„™ K V` is preferred. ",{"type":"(K : Type u_1) â†’ (V : Type u_2) â†’ [inst : DivisionRing K] â†’ [inst_1 : AddCommGroup V] â†’ [inst : Module K V] â†’ Type u_2","name":"Projectivization","isProp":false,"docString":"The projectivization of the `K`-vector space `V`.\nThe notation `â„™ K V` is preferred. ","distance":1.9610940040499682535113379344693385064601898193359375}],["In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. ",{"type":"âˆ€ {Î± : Type u} [inst : EMetricSpace Î±] [inst_1 : CompleteSpace Î±], CompleteSpace (TopologicalSpace.Closeds Î±)","name":"EMetric.Closeds.completeSpace","isProp":true,"docString":"In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. ","distance":1.961268807984575257563619743450544774532318115234375}],["The trivial submonoid `{1}` of a monoid `M`. ",{"type":"{M : Type u_1} â†’ [inst : MulOneClass M] â†’ Bot (Submonoid M)","name":"Submonoid.instBotSubmonoid","isProp":false,"docString":"The trivial submonoid `{1}` of a monoid `M`. ","distance":1.9620628958889783088892500018118880689144134521484375}],["A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty Î²` instead of `0 â‰¤ r`. ",{"type":"âˆ€ {Î² : Type v} {Ï€ : Î² â†’ Type u_3} [inst : Fintype Î²] [inst_1 : (b : Î²) â†’ PseudoMetricSpace (Ï€ b)] (x : (b : Î²) â†’ Ï€ b)\n  {r : â„}, 0 â‰¤ r â†’ Metric.closedBall x r = Set.pi Set.univ fun b => Metric.closedBall (x b) r","name":"closedBall_pi","isProp":true,"docString":"A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty Î²` instead of `0 â‰¤ r`. ","distance":1.962408561493080849658099396037869155406951904296875}],["The vector given in euclidean space by being `1 : ğ•œ` at coordinate `i : Î¹` and `0 : ğ•œ` at\nall other coordinates. ",{"type":"{Î¹ : Type u_1} â†’\n  {ğ•œ : Type u_3} â†’ [inst : IsROrC ğ•œ] â†’ [inst_1 : Fintype Î¹] â†’ [inst_2 : DecidableEq Î¹] â†’ Î¹ â†’ ğ•œ â†’ EuclideanSpace ğ•œ Î¹","name":"EuclideanSpace.single","isProp":false,"docString":"The vector given in euclidean space by being `1 : ğ•œ` at coordinate `i : Î¹` and `0 : ğ•œ` at\nall other coordinates. ","distance":1.9624413585681586003062193412915803492069244384765625}],["A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. ",{"type":"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P},\n  Set.Nonempty â†‘s â†’ âˆ€ (v : V), v âˆˆ AffineSubspace.direction s â†” âˆƒ p1 âˆˆ s, âˆƒ p2 âˆˆ s, v = p1 -áµ¥ p2","name":"AffineSubspace.mem_direction_iff_eq_vsub","isProp":true,"docString":"A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. ","distance":1.9627688846046407178391746128909289836883544921875}]]