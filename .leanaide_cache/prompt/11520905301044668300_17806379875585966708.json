[["The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ğ•œ : Type u_8} â†’\n  {ğ•œ' : Type u_9} â†’\n    {E : Type u_10} â†’\n      [inst : NormedField ğ•œ'] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’ [I : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ' (RestrictScalars ğ•œ ğ•œ' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9892497890892471001933472507516853511333465576171875}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"âˆ€ (n : â„•), â†‘n = â†‘n","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":2.01731445551198884658106180722825229167938232421875}],["The theorem `Nat.prime_three` asserts that the natural number 3 is a prime number. In other words, 3 is a natural number which is at least 2 and its only divisors are 3 and 1.",{"type":"Nat.Prime 3","name":"Nat.prime_three","isProp":true,"docString":"The theorem `Nat.prime_three` asserts that the natural number 3 is a prime number. In other words, 3 is a natural number which is at least 2 and its only divisors are 3 and 1.","distance":2.010410790572125794284374933340586721897125244140625}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{Î± : Type u_2} â†’ [inst : Preorder Î±] â†’ (p : Î± â†’ Prop) â†’ Subtype p â†ªo Î±","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.9909985078647169931542748599895276129245758056640625}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":2.0199596928254361927201898652128875255584716796875}],["This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.",{"type":"âˆ€ {p : â„•}, p.Prime â†’ p.properDivisors = {1}","name":"Nat.Prime.properDivisors","isProp":true,"docString":"This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.","distance":2.013840074038205418816005476401187479496002197265625}],["Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ",{"type":"{P : Type u_1} â†’ [inst : Preorder P] â†’ {I : Order.Ideal P} â†’ Order.Ideal.IsPrime I â†’ Order.Ideal.PrimePair P","name":"Order.Ideal.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ","distance":1.9931483765647624029071494078380055725574493408203125}],["The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"commandSudoSet_option___","isProp":false,"docString":"The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n","distance":1.995075410882227284758982932544313371181488037109375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.99961079052181123216769265127368271350860595703125}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : âˆ€ (x : â†‘s), f â†‘x âˆˆ t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.9996313306024406930561099215992726385593414306640625}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9997208269462003471517164143733680248260498046875}],["Create an element of type `Order.Ideal.PrimePair` from a filter satisfying the predicate\n`Order.PFilter.IsPrime`. ",{"type":"{P : Type u_1} â†’ [inst : Preorder P] â†’ {F : Order.PFilter P} â†’ Order.PFilter.IsPrime F â†’ Order.Ideal.PrimePair P","name":"Order.PFilter.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from a filter satisfying the predicate\n`Order.PFilter.IsPrime`. ","distance":2.00108530038229925906989592476747930049896240234375}],["Restrict the codomain of a principal segment ",{"type":"{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {r : Î± â†’ Î± â†’ Prop} â†’\n      {s : Î² â†’ Î² â†’ Prop} â†’\n        (p : Set Î²) â†’ (f : r â‰ºi s) â†’ (âˆ€ (a : Î±), f.toRelEmbedding a âˆˆ p) â†’ f.top âˆˆ p â†’ r â‰ºi Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":2.002044260744652692807221683324314653873443603515625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Î± : Type v} â†’ Quotient.out (Cardinal.mk Î±) â‰ƒ Î±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":2.0022493835211179202815401367843151092529296875}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"â„¤ â†’ â„¤","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":2.003133087464672001942744827829301357269287109375}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"â„• â†’ Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":2.003754877161629366355555248446762561798095703125}],["TODO: prove this in greater generality. ",{"type":"âˆ€ {m : Type u_2} {n : Type u_3} {R : Type u_5} [inst : Fintype n] [inst_1 : Fintype m] [inst_2 : LinearOrderedField R]\n  (A : Matrix m n R), Matrix.rank (Matrix.transpose A) = Matrix.rank A","name":"Matrix.rank_transpose","isProp":true,"docString":"TODO: prove this in greater generality. ","distance":2.0039666547445360578194595291279256343841552734375}],["Restrict the codomain of an initial segment ",{"type":"{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ (p : Set Î²) â†’ (f : r â‰¼i s) â†’ (âˆ€ (a : Î±), f a âˆˆ p) â†’ r â‰¼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":2.0048342884338286040701859747059643268585205078125}],["The maximum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_maximal_degree_vertex`, `degree_le_maxDegree`\nand `maxDegree_le_of_forall_degree_le`. ",{"type":"{V : Type u} â†’ (G : SimpleGraph V) â†’ [inst : Fintype V] â†’ [inst : DecidableRel G.Adj] â†’ â„•","name":"SimpleGraph.maxDegree","isProp":false,"docString":"The maximum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_maximal_degree_vertex`, `degree_le_maxDegree`\nand `maxDegree_le_of_forall_degree_le`. ","distance":2.00506677327964322188336154795251786708831787109375}],["Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ğ•œ ğ•œ' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ğ•œ ğ•œ' E`. This would be a very bad instance; both because `ğ•œ'` cannot be\ninferred, and because it is likely to create instance diamonds.\n",{"type":"(ğ•œ : Type u_5) â†’\n  (ğ•œ' : Type u_6) â†’\n    [inst : NormedField ğ•œ] â†’\n      [inst_1 : NormedField ğ•œ'] â†’\n        [inst_2 : NormedAlgebra ğ•œ ğ•œ'] â†’\n          (E : Type u_7) â†’ [inst_3 : SeminormedAddCommGroup E] â†’ [inst_4 : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ E","name":"NormedSpace.restrictScalars","isProp":false,"docString":"Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ğ•œ ğ•œ' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ğ•œ ğ•œ' E`. This would be a very bad instance; both because `ğ•œ'` cannot be\ninferred, and because it is likely to create instance diamonds.\n","distance":2.005976315833240430919204300153069198131561279296875}],["This is a special case of a more general instance that we define in a later file. ",{"type":"âˆ€ {R : Type u} (A : Type v) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Subsingleton (R â†’â‚[R] A)","name":"Algebra.subsingleton_id","isProp":true,"docString":"This is a special case of a more general instance that we define in a later file. ","distance":2.0062619931406349138569567003287374973297119140625}],["The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"termSudoSet_option___In_","isProp":false,"docString":"The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n","distance":2.007791658990380145866083694272674620151519775390625}],["The minimum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_minimal_degree_vertex`, `minDegree_le_degree`\nand `le_minDegree_of_forall_le_degree`. ",{"type":"{V : Type u} â†’ (G : SimpleGraph V) â†’ [inst : Fintype V] â†’ [inst : DecidableRel G.Adj] â†’ â„•","name":"SimpleGraph.minDegree","isProp":false,"docString":"The minimum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_minimal_degree_vertex`, `minDegree_le_degree`\nand `le_minDegree_of_forall_le_degree`. ","distance":2.007931188494376240072369910194538533687591552734375}],["An `AddSubgroup` of an `AddGroup` inherits an integer scaling. ",{"type":"{G : Type u_5} â†’ [inst : AddGroup G] â†’ {H : AddSubgroup G} â†’ SMul â„¤ â†¥H","name":"AddSubgroup.zsmul","isProp":false,"docString":"An `AddSubgroup` of an `AddGroup` inherits an integer scaling. ","distance":2.008029151287747726684074223157949745655059814453125}]]