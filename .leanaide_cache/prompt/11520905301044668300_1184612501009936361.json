[["The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ùïú : Type u_8} ‚Üí\n  {ùïú' : Type u_9} ‚Üí\n    {E : Type u_10} ‚Üí\n      [inst : NormedField ùïú'] ‚Üí\n        [inst_1 : SeminormedAddCommGroup E] ‚Üí [I : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú' (RestrictScalars ùïú ùïú' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9434392819182708667113956835237331688404083251953125}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"‚àÄ (n : ‚Ñï), ‚Üën = ‚Üën","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":1.9682077975166130112683049446786753833293914794921875}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"‚àÄ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.96769843786131648499804214225150644779205322265625}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí Subtype p ‚Ü™o Œ±","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.950345839375009493465995547012425959110260009765625}],[" A prime number does not divide 1.",{"type":"‚àÄ {p : ‚Ñï}, p.Prime ‚Üí ¬¨p ‚à£ 1","name":"Nat.Prime.not_dvd_one","isProp":true,"docString":" A prime number does not divide 1.","distance":1.9743153338201684388053536167717538774013519287109375}],["This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.",{"type":"‚àÄ {p : ‚Ñï}, p.Prime ‚Üí p.properDivisors = {1}","name":"Nat.Prime.properDivisors","isProp":true,"docString":"This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.","distance":1.9710474347449478127458633025526069104671478271484375}],["Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ",{"type":"ZNum ‚Üí PosNum","name":"PosNum.ofZNum","isProp":false,"docString":"Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ","distance":1.9525308266800822654118974242010153830051422119140625}],["`IsSpecial'` is an alternative of `IsSpecial`. ",{"type":"PNat.XgcdType ‚Üí Prop","name":"PNat.XgcdType.IsSpecial'","isProp":false,"docString":"`IsSpecial'` is an alternative of `IsSpecial`. ","distance":1.9550404718709248896857388899661600589752197265625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Œ± : Type v} ‚Üí Quotient.out (Cardinal.mk Œ±) ‚âÉ Œ±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.95832683022356235369443311356008052825927734375}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.958382803407439975984516422613523900508880615234375}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.958560434433718189239925777656026184558868408203125}],["Restrict the codomain of a principal segment ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n      {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí\n        (p : Set Œ≤) ‚Üí (f : r ‚â∫i s) ‚Üí (‚àÄ (a : Œ±), f.toRelEmbedding a ‚àà p) ‚Üí f.top ‚àà p ‚Üí r ‚â∫i Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":1.9591377322847502995273316628299653530120849609375}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"‚Ñï ‚Üí Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.959388211722842054740567618864588439464569091796875}],["This is a special case of a more general instance that we define in a later file. ",{"type":"‚àÄ {R : Type u} (A : Type v) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Subsingleton (R ‚Üí‚Çê[R] A)","name":"Algebra.subsingleton_id","isProp":true,"docString":"This is a special case of a more general instance that we define in a later file. ","distance":1.9596445393659838174471587990410625934600830078125}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"‚Ñï ‚Üí ‚Ñï","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":1.9602123811284648535746555353398434817790985107421875}],["A variant of `IsUnifLocDoublingMeasure.doublingConstant` which allows for scaling the\nradius by values other than `2`. ",{"type":"{Œ± : Type u_1} ‚Üí\n  [inst : MetricSpace Œ±] ‚Üí\n    [inst_1 : MeasurableSpace Œ±] ‚Üí (Œº : MeasureTheory.Measure Œ±) ‚Üí [inst : IsUnifLocDoublingMeasure Œº] ‚Üí ‚Ñù ‚Üí NNReal","name":"IsUnifLocDoublingMeasure.scalingConstantOf","isProp":false,"docString":"A variant of `IsUnifLocDoublingMeasure.doublingConstant` which allows for scaling the\nradius by values other than `2`. ","distance":1.9604390736779804260692117168218828737735748291015625}],["A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"Type u_1 ‚Üí Type u_2 ‚Üí Type (max u_1 u_2)","name":"Symbol.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9605144872105808584450414855382405221462249755859375}],["`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = ‚àÖ`. ",{"type":"‚Ñï ‚Üí Finset ‚Ñï","name":"Nat.properDivisors","isProp":false,"docString":"`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = ‚àÖ`. ","distance":1.9606687594029938992434836109168827533721923828125}],["This is the `norm_num` plug-in that evaluates Legendre symbols. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalLegendreSym","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Legendre symbols. ","distance":1.960760785160122754433587033418007194995880126953125}],["Restrict the codomain of an initial segment ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí (p : Set Œ≤) ‚Üí (f : r ‚âºi s) ‚Üí (‚àÄ (a : Œ±), f a ‚àà p) ‚Üí r ‚âºi Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9613118974716552411763359486940316855907440185546875}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.9621607578122615134219586252584122121334075927734375}],["A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n",{"type":"(A : Type u_2) ‚Üí [inst : CommRing A] ‚Üí [inst : IsDomain A] ‚Üí Prop","name":"IsDedekindDomainInv","isProp":false,"docString":"A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n","distance":1.9627224230844380059579634689725935459136962890625}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.962917319296770823910947001422755420207977294921875}],["A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",{"type":"{Œ± : Type u_2} ‚Üí (Œ≤ : Œ± ‚Üí Type u_1) ‚Üí (i : Œ±) √ó' Œ≤ i ‚âÉ (i : Œ±) √ó Œ≤ i","name":"Equiv.psigmaEquivSigma","isProp":false,"docString":"A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ","distance":1.9635047726725749495102490982390008866786956787109375}]]