[["The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ğ•œ : Type u_8} â†’\n  {ğ•œ' : Type u_9} â†’\n    {E : Type u_10} â†’\n      [inst : NormedField ğ•œ'] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’ [I : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ' (RestrictScalars ğ•œ ğ•œ' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9408458930262513231213006292819045484066009521484375}],[" For any type `Î±` with a linear order and any `b` in `Î±`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-âˆ, b]` to themselves.",{"type":"âˆ€ {Î± : Type u_1} [inst : LinearOrder Î±] {b : Î±} (x : â†‘(Set.Iic b)), Set.projIic b â†‘x = x","name":"Set.projIic_coe","isProp":true,"docString":" For any type `Î±` with a linear order and any `b` in `Î±`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-âˆ, b]` to themselves.","distance":1.968926532643166638081311248242855072021484375}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.9445056939339055990245697103091515600681304931640625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name â†’ Simps.ParsedProjectionData â†’ List Lean.Level â†’ Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.949664243238036664962464783457107841968536376953125}],[" For any type vector `Î±` of length `n+1`, appending the last element of `Î±` to the subvector obtained by dropping the last element results in the original vector `Î±`.",{"type":"âˆ€ {n : â„•} (Î± : TypeVec.{u_1} (n + 1)), Î±.drop.append1 Î±.last = Î±","name":"TypeVec.append1_drop_last","isProp":true,"docString":" For any type vector `Î±` of length `n+1`, appending the last element of `Î±` to the subvector obtained by dropping the last element results in the original vector `Î±`.","distance":1.9710562240480651308160986445727758109569549560546875}],["This theorem states that for all natural numbers `p`, the `p`-adic norm of `1` is `1`. This means that regardless of the prime number `p` you choose, when you calculate the `p`-adic norm for the rational number `1`, the result will always be `1`.",{"type":"âˆ€ {p : â„•}, padicNorm p 1 = 1","name":"padicNorm.one","isProp":true,"docString":"This theorem states that for all natural numbers `p`, the `p`-adic norm of `1` is `1`. This means that regardless of the prime number `p` you choose, when you calculate the `p`-adic norm for the rational number `1`, the result will always be `1`.","distance":1.960107429523306077356892274110578000545501708984375}],["Given two ordinals `Î± < Î²`, then `principalSegOut Î± Î²` is the principal segment embedding\nof `Î±` to `Î²`, as map from a model type for `Î±` to a model type for `Î²`. ",{"type":"{Î± Î² : Ordinal.{u_3}} â†’ Î± < Î² â†’ (fun x x_1 => x < x_1) â‰ºi fun x x_1 => x < x_1","name":"Ordinal.principalSegOut","isProp":false,"docString":"Given two ordinals `Î± < Î²`, then `principalSegOut Î± Î²` is the principal segment embedding\nof `Î±` to `Î²`, as map from a model type for `Î±` to a model type for `Î²`. ","distance":1.950532738296401280564396074623800814151763916015625}],["Given two ordinals `Î± â‰¤ Î²`, then `initialSegOut Î± Î²` is the initial segment embedding\nof `Î±` to `Î²`, as map from a model type for `Î±` to a model type for `Î²`. ",{"type":"{Î± Î² : Ordinal.{u_3}} â†’ Î± â‰¤ Î² â†’ (fun x x_1 => x < x_1) â‰¼i fun x x_1 => x < x_1","name":"Ordinal.initialSegOut","isProp":false,"docString":"Given two ordinals `Î± â‰¤ Î²`, then `initialSegOut Î± Î²` is the initial segment embedding\nof `Î±` to `Î²`, as map from a model type for `Î±` to a model type for `Î²`. ","distance":1.9541532980161504529093008386553265154361724853515625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Î± : Type v} â†’ Quotient.out (Cardinal.mk Î±) â‰ƒ Î±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.9549543937273530236353735745069570839405059814453125}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9551702276332552088433658354915678501129150390625}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"â„• â†’ Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9556520945372657394045745604671537876129150390625}],["A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n",{"type":"(A : Type u_2) â†’ [inst : CommRing A] â†’ [inst : IsDomain A] â†’ Prop","name":"IsDedekindDomainInv","isProp":false,"docString":"A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n","distance":1.956253173014495860826400530640967190265655517578125}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{Î± : Type u_2} â†’ [inst : Preorder Î±] â†’ (p : Î± â†’ Prop) â†’ Subtype p â†ªo Î±","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.956567218382742279203512225649319589138031005859375}],["The `p`-adic norm of `p` is `pâ»Â¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ",{"type":"âˆ€ {p : â„•}, 1 < p â†’ padicNorm p â†‘p = (â†‘p)â»Â¹","name":"padicNorm.padicNorm_p","isProp":true,"docString":"The `p`-adic norm of `p` is `pâ»Â¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ","distance":1.9575214379394763053454653345397673547267913818359375}],["Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ",{"type":"{ğ•œ : Type u_1} â†’\n  {F : Type u_3} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : AddCommGroup F] â†’ [inst_2 : Module ğ•œ F] â†’ [c : InnerProductSpace.Core ğ•œ F] â†’ Norm F","name":"InnerProductSpace.Core.toNorm","isProp":false,"docString":"Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ","distance":1.95779866623440579331827393616549670696258544921875}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m Î±`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{Ï‰ : Type u_1} â†’\n  {Î± : Type} â†’\n    (prio : Î± â†’ Thunk Ï‰) â†’\n      (Îµ : Î± â†’ Type) â†’\n        [inst : LinearOrder Ï‰] â†’\n          [inst_1 : (a : Î±) â†’ Estimator (prio a) (Îµ a)] â†’\n            [I : âˆ€ (a : Î±), WellFoundedGT â†‘(Set.range (EstimatorData.bound (prio a)))] â†’\n              [inst : Ord Ï‰] â†’\n                [inst : Ord Î±] â†’\n                  {m : Type â†’ Type} â†’\n                    [inst : Monad m] â†’\n                      [inst : Alternative m] â†’\n                        [inst : (a : Î±) â†’ Bot (Îµ a)] â†’ Option â„• â†’ (Î± â†’ MLList m Î±) â†’ Î± â†’ MLList m Î±","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m Î±`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.9580545995571714268379537315922789275646209716796875}],["A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"Type u_1 â†’ Type u_2 â†’ Type (max u_1 u_2)","name":"Symbol.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9587537586859358196278435571002773940563201904296875}],["`LinearMap.bound_of_ball_bound` is a version of this over arbitrary nontrivially normed fields.\nIt produces a less precise bound so we keep both versions. ",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : IsROrC ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] {r : â„},\n  0 < r â†’ âˆ€ (c : â„) (f : E â†’â‚—[ğ•œ] ğ•œ), (âˆ€ z âˆˆ Metric.closedBall 0 r, â€–f zâ€– â‰¤ c) â†’ âˆ€ (z : E), â€–f zâ€– â‰¤ c / r * â€–zâ€–","name":"LinearMap.bound_of_ball_bound'","isProp":true,"docString":"`LinearMap.bound_of_ball_bound` is a version of this over arbitrary nontrivially normed fields.\nIt produces a less precise bound so we keep both versions. ","distance":1.9598545273331833271868163137696683406829833984375}],["Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite Î±`.\n",{"type":"(Î± : Type u_4) â†’ Fintype Î± âŠ•' Infinite Î±","name":"fintypeOrInfinite","isProp":false,"docString":"Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite Î±`.\n","distance":1.96040481544140465786085769650526344776153564453125}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"â„¤ â†’ â„¤","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.96088857611396694125005524256266653537750244140625}],["`RatFunc.denom` is the denominator of a rational function,\nnormalized such that it is monic. ",{"type":"{K : Type u} â†’ [inst : Field K] â†’ RatFunc K â†’ Polynomial K","name":"RatFunc.denom","isProp":false,"docString":"`RatFunc.denom` is the denominator of a rational function,\nnormalized such that it is monic. ","distance":1.9610480417950773013302523395395837724208831787109375}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"â„• â†’ â„•","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":1.9616411746826212247896137341740541160106658935546875}],["Restrict the codomain of an initial segment ",{"type":"{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ (p : Set Î²) â†’ (f : r â‰¼i s) â†’ (âˆ€ (a : Î±), f a âˆˆ p) â†’ r â‰¼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9617182237560595314818101542186923325061798095703125}],["The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ",{"type":"{Î¹ : Type u_1} â†’ [inst : Fintype Î¹] â†’ BoxIntegral.Box Î¹ â†’ NNReal","name":"BoxIntegral.Box.distortion","isProp":false,"docString":"The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ","distance":1.961780085027532205543820964521728456020355224609375}]]