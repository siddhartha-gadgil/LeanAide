[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.971446157272314536612611846067011356353759765625}],[" Given a real vector space `E` with a continuous scalar multiplication, if `s` is a neighborhood of the origin in `E`, then the Minkowski functional of `s` approaches 0 as the input approaches the origin.",{"type":"‚àÄ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] {s : Set E} [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul ‚Ñù E], s ‚àà nhds 0 ‚Üí Filter.Tendsto (gauge s) (nhds 0) (nhds 0)","name":"tendsto_gauge_nhds_zero","isProp":true,"docString":" Given a real vector space `E` with a continuous scalar multiplication, if `s` is a neighborhood of the origin in `E`, then the Minkowski functional of `s` approaches 0 as the input approaches the origin.","distance":2.014555264442692728010797509341500699520111083984375}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.007930798889052237399255318450741469860076904296875}],["The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9876610130316441082953815566725097596645355224609375}],[" The real hyperbolic sine function evaluates to zero at zero: $\\sinh(0) = 0$.",{"type":"Real.sinh 0 = 0","name":"Real.sinh_zero","isProp":true,"docString":" The real hyperbolic sine function evaluates to zero at zero: $\\sinh(0) = 0$.","distance":2.0160745399576729397495000739581882953643798828125}],["This theorem, `hammingDist_pos`, states that for any types `Œπ` and `Œ≤`, where `Œ≤` is a function from `Œπ` to another type and `Œπ` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Œπ` over `Œ≤ i`, then the Hamming distance between two functions `x` and `y` (from `Œπ` to `Œ≤`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"This theorem, `hammingDist_pos`, states that for any types `Œπ` and `Œ≤`, where `Œ≤` is a function from `Œπ` to another type and `Œπ` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Œπ` over `Œ≤ i`, then the Hamming distance between two functions `x` and `y` (from `Œπ` to `Œ≤`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.","distance":2.009430106017287442909946548752486705780029296875}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9977100295257363971046515871421433985233306884765625}],["**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {N : Set Œ±} {f : Œ± ‚Üí ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], AEMeasurable f ‚Üí ‚Üë‚ÜëŒº N = 0 ‚Üí ‚àÉ x ‚àâ N, f x ‚â§ ‚à´‚Åª (a : Œ±), f a ‚àÇŒº","name":"MeasureTheory.exists_not_mem_null_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ","distance":2.000117221305157233501859082025475800037384033203125}],["**First moment method**. The minimum of a measurable function is smaller than its integral. ",{"type":"‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº], AEMeasurable f ‚Üí ‚àÉ x, f x ‚â§ ‚à´‚Åª (a : Œ±), f a ‚àÇŒº","name":"MeasureTheory.exists_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral. ","distance":2.0035124970412407918729513767175376415252685546875}],["Default definition of `max`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":2.00384077222784373617514575016684830188751220703125}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : TypeVec.Arrow Fin2.elim0 Fin2.elim0 ‚Üí Sort u_1} ‚Üí\n  Œ≤ TypeVec.nilFun ‚Üí (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) ‚Üí Œ≤ f","name":"TypeVec.typevecCasesNil‚ÇÇ","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.004178502440421283381510875187814235687255859375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":2.00466459161492505103296934976242482662200927734375}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"‚àÄ {d : ‚Ñ§} {a : Pell.Solution‚ÇÅ d}, a = 1 ‚à® a = -1 ‚Üî Pell.Solution‚ÇÅ.y a = 0","name":"Pell.Solution‚ÇÅ.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.0050630374434117442206115811131894588470458984375}],["cases distinction for 0-length type vector ",{"type":"{Œ≤ : TypeVec.{u_2} 0 ‚Üí Sort u_1} ‚Üí Œ≤ Fin2.elim0 ‚Üí (v : TypeVec.{u_2} 0) ‚Üí Œ≤ v","name":"TypeVec.casesNil","isProp":false,"docString":"cases distinction for 0-length type vector ","distance":2.005165636940778650654237935668788850307464599609375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":2.005336513678232623902886189171113073825836181640625}],["**First moment method**. The minimum of an integrable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"‚àÄ {Œ± : Type u_1} {m0 : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {N : Set Œ±} {f : Œ± ‚Üí ‚Ñù}\n  [inst : MeasureTheory.IsProbabilityMeasure Œº],\n  MeasureTheory.Integrable f ‚Üí ‚Üë‚ÜëŒº N = 0 ‚Üí ‚àÉ x ‚àâ N, f x ‚â§ ‚à´ (a : Œ±), f a ‚àÇŒº","name":"MeasureTheory.exists_not_mem_null_le_integral","isProp":true,"docString":"**First moment method**. The minimum of an integrable function is smaller than its integral,\nwhile avoiding a null set. ","distance":2.005811530711431256435162140405736863613128662109375}],["Corresponds to `dist_pos`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":2.00683147135905937119559894199483096599578857421875}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":2.007997213993614860072511874022893607616424560546875}],["If a functor preserves a certain right homology data of a short complex `S`, then it\npreserves the right homology of `S`. ",{"type":"{C : Type u_1} ‚Üí\n  {D : Type u_2} ‚Üí\n    [inst : CategoryTheory.Category.{u_3, u_1} C] ‚Üí\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] ‚Üí\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] ‚Üí\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] ‚Üí\n            (F : CategoryTheory.Functor C D) ‚Üí\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] ‚Üí\n                {S : CategoryTheory.ShortComplex C} ‚Üí\n                  (h : CategoryTheory.ShortComplex.RightHomologyData S) ‚Üí\n                    [inst_5 : CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy h F] ‚Üí\n                      CategoryTheory.Functor.PreservesRightHomologyOf F S","name":"CategoryTheory.Functor.PreservesRightHomologyOf.mk'","isProp":false,"docString":"If a functor preserves a certain right homology data of a short complex `S`, then it\npreserves the right homology of `S`. ","distance":2.008324180017059035208148998208343982696533203125}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ",{"type":"{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ","distance":2.008492886480585326580694527365267276763916015625}],["Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ‚Ñï ‚Üí Type u_2} ‚Üí ((n : ‚Ñï) ‚Üí E n) ‚Üí Set ((n : ‚Ñï) ‚Üí E n) ‚Üí ‚Ñï","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":2.00876230371540653862894032499752938747406005859375}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : (v : TypeVec.{u_2} 0) ‚Üí (v' : TypeVec.{u_3} 0) ‚Üí TypeVec.Arrow v v' ‚Üí Sort u_1} ‚Üí\n  Œ≤ Fin2.elim0 Fin2.elim0 TypeVec.nilFun ‚Üí\n    (v : TypeVec.{u_2} 0) ‚Üí (v' : TypeVec.{u_3} 0) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ v v' fs","name":"TypeVec.typevecCasesNil‚ÇÉ","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":2.0088131618958779966988004161976277828216552734375}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) ‚Üí (M : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommGroup M] ‚Üí [inst : Module R M] ‚Üí ‚Ñï","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":2.009421000414875368988987247576005756855010986328125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.00982818264950591213846564642153680324554443359375}]]