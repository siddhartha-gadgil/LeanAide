[["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.909769126716095666296268973383121192455291748046875}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":1.9594785805486003571473929696367122232913970947265625}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9437110638573911192139576087356545031070709228515625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9240327679744495537050852362881414592266082763671875}],[" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Zero Î²], â‡‘0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.","distance":1.9611639994167411327197214632178656756877899169921875}],["The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `ğ•œ`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : LinearOrderedField ğ•œ] [inst_1 : OrderedAddCommMonoid Î²]\n  [inst_2 : AddCommMonoid E] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²] {f : E â†’ Î²}\n  {s : Set E} {x y : E}, StrictConvexOn ğ•œ s f â†’ IsMinOn f s x â†’ IsMinOn f s y â†’ x âˆˆ s â†’ y âˆˆ s â†’ x = y","name":"StrictConvexOn.eq_of_isMinOn","isProp":true,"docString":"The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `ğ•œ`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.","distance":1.9446142925759877240210471427417360246181488037109375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9279363427520086471389504367834888398647308349609375}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{Mâ‚ : Type u_1} â†’\n  {Mâ‚‚ : Type u_2} â†’\n    [inst : Zero Mâ‚] â†’\n      [inst_1 : Neg Mâ‚] â†’\n        [inst_2 : NegZeroClass Mâ‚‚] â†’\n          (f : Mâ‚ â†’ Mâ‚‚) â†’ Function.Injective f â†’ f 0 = 0 â†’ (âˆ€ (x : Mâ‚), f (-x) = -f x) â†’ NegZeroClass Mâ‚","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.93059987382818309953336211037822067737579345703125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9315535885394339299381272212485782802104949951171875}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9339708110336035762344408794888295233249664306640625}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasColimits C] â†’ (X : AlgebraicGeometry.PresheafedSpace C) â†’ â†‘â†‘X â†’ C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.9408381856709187029963459281134419143199920654296875}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name â†’ Simps.ParsedProjectionData â†’ List Lean.Level â†’ Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.9414730403314550688520512267132289707660675048828125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.942121259049347958836051475373096764087677001953125}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9439329940187495271430861976114101707935333251953125}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : (v : TypeVec.{u_2} 0) â†’ (v' : TypeVec.{u_3} 0) â†’ TypeVec.Arrow v v' â†’ Sort u_1} â†’\n  Î² Fin2.elim0 Fin2.elim0 TypeVec.nilFun â†’\n    (v : TypeVec.{u_2} 0) â†’ (v' : TypeVec.{u_3} 0) â†’ (fs : TypeVec.Arrow v v') â†’ Î² v v' fs","name":"TypeVec.typevecCasesNilâ‚ƒ","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":1.94436817788556748354267256218008697032928466796875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9444435627078926476229980835341848433017730712890625}],["With the optimal candidate, construct a premetric space structure on `X âŠ• Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ",{"type":"(X : Type u) â†’\n  (Y : Type v) â†’\n    [inst : MetricSpace X] â†’\n      [inst : CompactSpace X] â†’\n        [inst : Nonempty X] â†’\n          [inst : MetricSpace Y] â†’ [inst : CompactSpace Y] â†’ [inst : Nonempty Y] â†’ PseudoMetricSpace (X âŠ• Y)","name":"GromovHausdorff.premetricOptimalGHDist","isProp":false,"docString":"With the optimal candidate, construct a premetric space structure on `X âŠ• Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ","distance":1.94481992309607232272128385375253856182098388671875}],["Corresponds to `dist_pos`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9467469248158957295657955910428427159786224365234375}],["A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.",{"type":"{Mâ‚ : Type u_1} â†’\n  {Mâ‚‚ : Type u_2} â†’\n    [inst : Add Mâ‚] â†’\n      [inst_1 : Zero Mâ‚] â†’\n        [inst_2 : AddZeroClass Mâ‚‚] â†’\n          (f : Mâ‚ â†’ Mâ‚‚) â†’ Function.Injective f â†’ f 0 = 0 â†’ (âˆ€ (x y : Mâ‚), f (x + y) = f x + f y) â†’ AddZeroClass Mâ‚","name":"Function.Injective.addZeroClass","isProp":false,"docString":"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.","distance":1.9470592777505004722371495518018491566181182861328125}],["Corresponds to `dist_zero_right`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)]\n  [inst_2 : (i : Î¹) â†’ Zero (Î² i)] (x : (i : Î¹) â†’ Î² i), hammingDist x 0 = hammingNorm x","name":"hammingDist_zero_right","isProp":true,"docString":"Corresponds to `dist_zero_right`. ","distance":1.94707592308634414024481884553097188472747802734375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.94730922637157721766243412275798618793487548828125}],["A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.",{"type":"{Mâ‚ : Type u_1} â†’\n  {Mâ‚‚ : Type u_2} â†’\n    [inst : Add Mâ‚‚] â†’\n      [inst_1 : Zero Mâ‚‚] â†’\n        [inst_2 : AddZeroClass Mâ‚] â†’\n          (f : Mâ‚ â†’ Mâ‚‚) â†’ Function.Surjective f â†’ f 0 = 0 â†’ (âˆ€ (x y : Mâ‚), f (x + y) = f x + f y) â†’ AddZeroClass Mâ‚‚","name":"Function.Surjective.addZeroClass","isProp":false,"docString":"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.","distance":1.9476728033434209663710134918801486492156982421875}],["`sigmaPreimageEquiv f` for `f : Î± â†’ Î²` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `Î±`. ",{"type":"{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ (f : Î± â†’ Î²) â†’ (b : Î²) Ã— â†‘(f â»Â¹' {b}) â‰ƒ Î±","name":"Equiv.sigmaPreimageEquiv","isProp":false,"docString":"`sigmaPreimageEquiv f` for `f : Î± â†’ Î²` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `Î±`. ","distance":1.948200189318705088936667380039580166339874267578125}],["Find arguments for the `Zero` class. ",{"type":"Simps.findArgType","name":"Simps.findZeroArgs","isProp":false,"docString":"Find arguments for the `Zero` class. ","distance":1.94840821396857233338550940970890223979949951171875}]]