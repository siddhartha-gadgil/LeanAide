[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9653046756503289582695970239001326262950897216796875}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ð•œ`, a normed additive group `E` over `ð•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ð•œ E] {I : ModelWithCorners ð•œ E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInvâ‚€ I G]\n  â¦ƒx : Gâ¦„, x â‰  0 â†’ SmoothAt I I (fun y => yâ»Â¹) x","name":"SmoothInvâ‚€.smoothAt_invâ‚€","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ð•œ`, a normed additive group `E` over `ð•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":2.007741383995459205635825128410942852497100830078125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.0017572439607693723928605322726070880889892578125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9821935667688979076928035283344797790050506591796875}],[" For any nontrivially normed field `ð•œ`, normed additive commutative group `E`, normed space `E` over `ð•œ`, and topological space `H`, the function `I` from `ð•œ` to `E` defined in a Model With Corners `I` of types `ð•œ`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"âˆ€ {ð•œ : Type u_1} [inst : NontriviallyNormedField ð•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ð•œ E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ð•œ E H),\n  UniqueDiffOn ð•œ (Set.range â†‘I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ð•œ`, normed additive commutative group `E`, normed space `E` over `ð•œ`, and topological space `H`, the function `I` from `ð•œ` to `E` defined in a Model With Corners `I` of types `ð•œ`, `E`, and `H` is uniquely differentiable on its entire range.","distance":2.016293481486770122756979617406614124774932861328125}],["This theorem, named `sign_pos`, states that for any type `Î±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Î±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.",{"type":"âˆ€ {Î± : Type u_1} [inst : Zero Î±] [inst_1 : Preorder Î±] [inst_2 : DecidableRel fun x x_1 => x < x_1] {a : Î±},\n  0 < a â†’ SignType.sign a = 1","name":"sign_pos","isProp":true,"docString":"This theorem, named `sign_pos`, states that for any type `Î±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Î±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.","distance":2.007249493675260065828069855342619121074676513671875}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9915735806185477230201286147348582744598388671875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9935444960541535142084512699511833488941192626953125}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.993885183151103301923967592301778495311737060546875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ð•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ð•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ð•œ E] [inst_4 : Module ð•œ Î²] [inst_5 : OrderedSMul ð•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ð•œ (segment ð•œ x y) f â†’ z âˆˆ segment ð•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.996645273639538142873561810120008885860443115234375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9971072099880193828624896923429332673549652099609375}],["Corresponds to `dist_pos`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9995059878374001893774902782752178609371185302734375}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ð•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ð•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ð•œ Î²] [inst_3 : OrderedSMul ð•œ Î²] {f : ð•œ â†’ Î²} {x y z : ð•œ},\n  ConcaveOn ð•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.00037196839788311564234390971250832080841064453125}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":2.001983117220266006341944375890307128429412841796875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":2.00221506559886197607056601555086672306060791015625}],["Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ",{"type":"{K : semiOutParam (Type u_1)} â†’ [self : IsROrC K] â†’ K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ","distance":2.0030645485848168618758791126310825347900390625}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.003544619502807933031363063491880893707275390625}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":2.004073879714432404597346248920075595378875732421875}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.00460514551460011745120937121100723743438720703125}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData â†’ Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":2.005603591498657412017792012193240225315093994140625}],["The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ",{"type":"Lean.ParserDescr","name":"prioHigh","isProp":false,"docString":"The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ","distance":2.007462591920465388994898603414185345172882080078125}],["Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ",{"type":"{Î± : Type u_3} â†’ {Î² : Type u_4} â†’ [inst : Mul Î±] â†’ [inst_1 : Mul Î²] â†’ (Î± â†’â‚™* Î²) â†’ (I : Type u_5) â†’ (I â†’ Î±) â†’â‚™* I â†’ Î²","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ","distance":2.008218613614129566258270642720162868499755859375}],["The class number of a function field is `1` iff the ring of integers is a PID. ",{"type":"âˆ€ (Fq F : Type) [inst : Field Fq] [inst_1 : Fintype Fq] [inst_2 : Field F] [inst_3 : Algebra (Polynomial Fq) F]\n  [inst_4 : Algebra (RatFunc Fq) F] [inst_5 : IsScalarTower (Polynomial Fq) (RatFunc Fq) F]\n  [inst_6 : FunctionField Fq F] [inst_7 : IsSeparable (RatFunc Fq) F],\n  FunctionField.classNumber Fq F = 1 â†” IsPrincipalIdealRing â†¥(FunctionField.ringOfIntegers Fq F)","name":"FunctionField.classNumber_eq_one_iff","isProp":true,"docString":"The class number of a function field is `1` iff the ring of integers is a PID. ","distance":2.00829660730486647679526868159882724285125732421875}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":2.008405902961246880522594437934458255767822265625}]]