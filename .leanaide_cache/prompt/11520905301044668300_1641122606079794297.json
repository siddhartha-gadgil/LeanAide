[["The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ğ•œ : Type u_8} â†’\n  {ğ•œ' : Type u_9} â†’\n    {E : Type u_10} â†’\n      [inst : NormedField ğ•œ'] â†’\n        [inst_1 : SeminormedAddCommGroup E] â†’ [I : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ' (RestrictScalars ğ•œ ğ•œ' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ğ•œ ğ•œ' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.97471909994146965772188195842318236827850341796875}],[" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Î²(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.",{"type":"âˆ€ {u : â„‚}, 0 < u.re â†’ âˆ€ (n : â„•), u.betaIntegral (â†‘n + 1) = â†‘n.factorial / (Finset.range (n + 1)).prod fun j => u + â†‘j","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Î²(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.","distance":1.9999355368049298586896611595875583589076995849609375}],["This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.",{"type":"âˆ€ {u : â„‚}, 0 < u.re â†’ âˆ€ (n : â„•), u.betaIntegral (â†‘n + 1) = â†‘n.factorial / (Finset.range (n + 1)).prod fun j => u + â†‘j","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":"This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.","distance":1.99364988494223549508888027048669755458831787109375}],["The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ",{"type":"{Î¹ : Type u_1} â†’ [inst : Fintype Î¹] â†’ BoxIntegral.Box Î¹ â†’ NNReal","name":"BoxIntegral.Box.distortion","isProp":false,"docString":"The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ","distance":1.97780597840161487255272731999866664409637451171875}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"âˆ€ (n : â„•), â†‘n = â†‘n","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":2.00169644014767644790708800428546965122222900390625}],["The theorem `ProbabilityTheory.IsMeasurableRatCDF.measurable_stieltjesFunction` states that for any measurable space `Î±`, and any rational function `f : Î± â†’ â„š â†’ â„` that satisfies the `IsMeasurableRatCDF` property, for any real number `x`, the function that maps each `Î±` to the `x`-th value of the Stieltjes function associated with `f` (obtained through `ProbabilityTheory.IsMeasurableRatCDF.stieltjesFunction`) is measurable. This means the preimage of every measurable set under this function is a measurable set. The `IsMeasurableRatCDF` property ensures that `f` is a measurable function from the rational numbers to the real numbers.",{"type":"âˆ€ {Î± : Type u_1} [inst : MeasurableSpace Î±] {f : Î± â†’ â„š â†’ â„} (hf : ProbabilityTheory.IsMeasurableRatCDF f) (x : â„),\n  Measurable fun a => â†‘(hf.stieltjesFunction a) x","name":"ProbabilityTheory.IsMeasurableRatCDF.measurable_stieltjesFunction","isProp":true,"docString":"The theorem `ProbabilityTheory.IsMeasurableRatCDF.measurable_stieltjesFunction` states that for any measurable space `Î±`, and any rational function `f : Î± â†’ â„š â†’ â„` that satisfies the `IsMeasurableRatCDF` property, for any real number `x`, the function that maps each `Î±` to the `x`-th value of the Stieltjes function associated with `f` (obtained through `ProbabilityTheory.IsMeasurableRatCDF.stieltjesFunction`) is measurable. This means the preimage of every measurable set under this function is a measurable set. The `IsMeasurableRatCDF` property ensures that `f` is a measurable function from the rational numbers to the real numbers.","distance":1.99603985137137129868278861977159976959228515625}],["The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.",{"type":"(ğ•œ : Type u_1) â†’\n  (E : Type u_3) â†’\n    [inst : NormedField ğ•œ] â†’\n      [inst_1 : AddCommGroup E] â†’\n        [inst_2 : Module ğ•œ E] â†’ [inst_3 : TopologicalSpace E] â†’ [inst : ContinuousSMul ğ•œ E] â†’ Bornology E","name":"Bornology.vonNBornology","isProp":false,"docString":"The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.","distance":1.9780545948635099851031782236532308161258697509765625}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"â„¤ â†’ â„¤","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r â‰¤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.9790466858551523099407631889334879815578460693359375}],["Return the current `maxHeartbeats`. ",{"type":"Lean.CoreM â„•","name":"getMaxHeartbeats","isProp":false,"docString":"Return the current `maxHeartbeats`. ","distance":1.9850563305422179727344200728111900389194488525390625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.986236489803646865226482987054623663425445556640625}],["Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ğ•œ ğ•œ' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ğ•œ ğ•œ' E`. This would be a very bad instance; both because `ğ•œ'` cannot be\ninferred, and because it is likely to create instance diamonds.\n",{"type":"(ğ•œ : Type u_5) â†’\n  (ğ•œ' : Type u_6) â†’\n    [inst : NormedField ğ•œ] â†’\n      [inst_1 : NormedField ğ•œ'] â†’\n        [inst_2 : NormedAlgebra ğ•œ ğ•œ'] â†’\n          (E : Type u_7) â†’ [inst_3 : SeminormedAddCommGroup E] â†’ [inst_4 : NormedSpace ğ•œ' E] â†’ NormedSpace ğ•œ E","name":"NormedSpace.restrictScalars","isProp":false,"docString":"Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ğ•œ ğ•œ' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ğ•œ ğ•œ' E`. This would be a very bad instance; both because `ğ•œ'` cannot be\ninferred, and because it is likely to create instance diamonds.\n","distance":1.986895699033954354462139235693030059337615966796875}],["Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ",{"type":"{ğ•œ : Type u_1} â†’\n  {F : Type u_3} â†’\n    [inst : IsROrC ğ•œ] â†’ [inst_1 : AddCommGroup F] â†’ [inst_2 : Module ğ•œ F] â†’ [c : InnerProductSpace.Core ğ•œ F] â†’ Norm F","name":"InnerProductSpace.Core.toNorm","isProp":false,"docString":"Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ","distance":1.9881781885110771934677131866919808089733123779296875}],["Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ",{"type":"{P : Type u_1} â†’ [inst : Preorder P] â†’ {I : Order.Ideal P} â†’ Order.Ideal.IsPrime I â†’ Order.Ideal.PrimePair P","name":"Order.Ideal.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ","distance":1.9906481215570337450770921350340358912944793701171875}],["The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"commandSudoSet_option___","isProp":false,"docString":"The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n","distance":1.991602318437899032943505517323501408100128173828125}],["`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ",{"type":"(k : Type u_1) â†’ [inst : DivisionRing k] â†’ {Î¹ : Type u_4} â†’ Finset Î¹ â†’ Î¹ â†’ k","name":"Finset.centroidWeightsIndicator","isProp":false,"docString":"`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ","distance":1.9916734914887117557924511856981553137302398681640625}],["`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = âˆ…`. ",{"type":"â„• â†’ Finset â„•","name":"Nat.properDivisors","isProp":false,"docString":"`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = âˆ…`. ","distance":1.9919331066932297602534163161180913448333740234375}],["The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Î±` and `Î²` and a number `n` such that\n`card Î² * n < card Î±`, there exists an element `y : Î²` such that its preimage has more than `n`\nelements. ",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : DecidableEq Î²] [inst_1 : Fintype Î±] [inst_2 : Fintype Î²] (f : Î± â†’ Î²) {n : â„•},\n  Fintype.card Î² * n < Fintype.card Î± â†’ âˆƒ y, n < (Finset.filter (fun x => f x = y) Finset.univ).card","name":"Fintype.exists_lt_card_fiber_of_mul_lt_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Î±` and `Î²` and a number `n` such that\n`card Î² * n < card Î±`, there exists an element `y : Î²` such that its preimage has more than `n`\nelements. ","distance":1.9922033022784846334474195828079245984554290771484375}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"âˆ€ {Î± : Type u_1} {Î² : Type u_2} {s : Set Î±} {t : Set Î²} {f : Î± â†’ Î²} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : âˆ€ (x : â†‘s), f â†‘x âˆˆ t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.992299675103569978062978407251648604869842529296875}],["`IsSpecial'` is an alternative of `IsSpecial`. ",{"type":"PNat.XgcdType â†’ Prop","name":"PNat.XgcdType.IsSpecial'","isProp":false,"docString":"`IsSpecial'` is an alternative of `IsSpecial`. ","distance":1.9925854639670916856886151435901410877704620361328125}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.992796244971132058054763547261245548725128173828125}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.99297665874177543088308084406889975070953369140625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Î± : Type v} â†’ Quotient.out (Cardinal.mk Î±) â‰ƒ Î±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.993285478405625088527131083537824451923370361328125}],["Converts a natural into a `Fin2` if it is in range ",{"type":"{n : â„•} â†’ â„• â†’ Option (Fin2 n)","name":"Fin2.optOfNat","isProp":false,"docString":"Converts a natural into a `Fin2` if it is in range ","distance":1.993311248396584911546369767165742814540863037109375}],["Restrict the codomain of an initial segment ",{"type":"{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {r : Î± â†’ Î± â†’ Prop} â†’ {s : Î² â†’ Î² â†’ Prop} â†’ (p : Set Î²) â†’ (f : r â‰¼i s) â†’ (âˆ€ (a : Î±), f a âˆˆ p) â†’ r â‰¼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9934831774701340378896929905749857425689697265625}]]