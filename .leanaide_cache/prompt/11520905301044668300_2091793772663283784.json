[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9388155488032656759145311298198066651821136474609375}],[" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : TopologicalSpace Î±] [inst_1 : PseudoMetricSpace Î²] [inst_2 : Zero Î²], â‡‘0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Î±` and pseudo metric space `Î²` with defined zero, the constant function `0 : Î± â†’ Î²` equals the zero function.","distance":1.9760758337934281048120510604348964989185333251953125}],["This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":1.9685859625969539532519547719857655465602874755859375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9571137361331774062733757091336883604526519775390625}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":1.9761718444352129875341006481903605163097381591796875}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.972540206878746982255279363016597926616668701171875}],["`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n",{"type":"Lean.Elab.Tactic.TacticM Unit â†’ Lean.Expr â†’ Lean.MetaM Lean.Expr","name":"Linarith.proveEqZeroUsing","isProp":false,"docString":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n","distance":1.96626652557921222097547797602601349353790283203125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9681401617681348881205849465914070606231689453125}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.9721346088218325576235656626522541046142578125}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9730548072791991298657876541255973279476165771484375}],["Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ",{"type":"{Î± : Type u_3} â†’ {Î² : Type u_4} â†’ [inst : Mul Î±] â†’ [inst_1 : Mul Î²] â†’ (Î± â†’â‚™* Î²) â†’ (I : Type u_5) â†’ (I â†’ Î±) â†’â‚™* I â†’ Î²","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ","distance":1.973870943808241573691475423402152955532073974609375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9746781143750327114361198255210183560848236083984375}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{Mâ‚ : Type u_1} â†’\n  {Mâ‚‚ : Type u_2} â†’\n    [inst : Zero Mâ‚] â†’\n      [inst_1 : Neg Mâ‚] â†’\n        [inst_2 : NegZeroClass Mâ‚‚] â†’\n          (f : Mâ‚ â†’ Mâ‚‚) â†’ Function.Injective f â†’ f 0 = 0 â†’ (âˆ€ (x : Mâ‚), f (-x) = -f x) â†’ NegZeroClass Mâ‚","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.974724993437117603889419115148484706878662109375}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.97487703947845449903297776472754776477813720703125}],["Corresponds to `norm_zero`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)]\n  [inst_2 : (i : Î¹) â†’ Zero (Î² i)], hammingNorm 0 = 0","name":"hammingNorm_zero","isProp":true,"docString":"Corresponds to `norm_zero`. ","distance":1.9758159146160869656938530170009471476078033447265625}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.976154808950063124228790911729447543621063232421875}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.9764150548173284871467103585018776357173919677734375}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9764720906570925063050481185200624167919158935546875}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9770138629223115156463563835131935775279998779296875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.977096454181630047486351031693629920482635498046875}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9776507586440421615492368800914846360683441162109375}],["cases distinction for 0-length type vector ",{"type":"{Î² : TypeVec.{u_2} 0 â†’ Sort u_1} â†’ Î² Fin2.elim0 â†’ (v : TypeVec.{u_2} 0) â†’ Î² v","name":"TypeVec.casesNil","isProp":false,"docString":"cases distinction for 0-length type vector ","distance":1.9778192067507376350476988591253757476806640625}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.978634080078997659057904456858523190021514892578125}],["A tactic that solves `0 â‰¤ â†‘x`, `0 â‰¤ 1 - â†‘x`, `â†‘x â‰¤ 1`, and `1 - â†‘x â‰¤ 1` for `x : I`. ",{"type":"Lean.ParserDescr","name":"Tactic.Interactive.tacticUnit_interval","isProp":false,"docString":"A tactic that solves `0 â‰¤ â†‘x`, `0 â‰¤ 1 - â†‘x`, `â†‘x â‰¤ 1`, and `1 - â†‘x â‰¤ 1` for `x : I`. ","distance":1.9788439693154680210085416547372005879878997802734375}]]