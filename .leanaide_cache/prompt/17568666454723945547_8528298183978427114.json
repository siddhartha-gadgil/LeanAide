[["The second hexagon identity. ",{"type":"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  [self : CategoryTheory.BraidedCategory C] (X Y Z : C),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Z).inv\n      (CategoryTheory.CategoryStruct.comp (Î²_ (CategoryTheory.MonoidalCategory.tensorObj X Y) Z).hom\n        (CategoryTheory.MonoidalCategory.associator Z X Y).inv) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (Î²_ Y Z).hom)\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Z Y).inv\n        (CategoryTheory.MonoidalCategory.tensorHom (Î²_ X Z).hom (CategoryTheory.CategoryStruct.id Y)))","name":"CategoryTheory.BraidedCategory.hexagon_reverse","isProp":true,"docString":"The second hexagon identity. ","distance":0.4002150170489595648604108646395616233348846435546875}],[" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.",{"type":"âˆ€ (x y : SetTheory.PGame), (x + y).birthday = x.birthday.nadd y.birthday","name":"SetTheory.PGame.birthday_add","isProp":true,"docString":" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.","distance":0.495702879260213669088130927775637246668338775634765625}],["This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.",{"type":"âˆ€ (n m : â„•), (SetTheory.PGame.nim â†‘n + SetTheory.PGame.nim â†‘m).grundyValue = â†‘(n ^^^ m)","name":"SetTheory.PGame.grundyValue_nim_add_nim","isProp":true,"docString":"This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.","distance":0.47728903029402769409017537327599711716175079345703125}],["Negation of games. ",{"type":"SetTheory.Game â†’ SetTheory.Game","name":"SetTheory.Game.neg","isProp":false,"docString":"Negation of games. ","distance":0.40365920784409581312246473316918127238750457763671875}],[" For an impartial pre-game G in set theory, G is fuzzy relative to the zero game if and only if the Left player can win the less or fuzzy version of G.",{"type":"âˆ€ (G : SetTheory.PGame) [inst : G.Impartial], G.Fuzzy 0 â†” G.LF 0","name":"SetTheory.PGame.Impartial.fuzzy_zero_iff_lf","isProp":true,"docString":" For an impartial pre-game G in set theory, G is fuzzy relative to the zero game if and only if the Left player can win the less or fuzzy version of G.","distance":0.50907263416079528983715363210649229586124420166015625}],["The **Chicken McNugget Theorem** states that for any two coprime natural numbers `m` and `n`, both greater than one, the Frobenius number (the largest number that cannot be expressed as a sum of any combination of `m` and `n`) is calculated by the formula `m * n - m - n`.",{"type":"âˆ€ {m n : â„•}, m.Coprime n â†’ 1 < m â†’ 1 < n â†’ FrobeniusNumber (m * n - m - n) {m, n}","name":"frobeniusNumber_pair","isProp":true,"docString":"The **Chicken McNugget Theorem** states that for any two coprime natural numbers `m` and `n`, both greater than one, the Frobenius number (the largest number that cannot be expressed as a sum of any combination of `m` and `n`) is calculated by the formula `m * n - m - n`.","distance":0.488817102447343554416647748439572751522064208984375}],["The first hexagon identity. ",{"type":"âˆ€ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  [self : CategoryTheory.BraidedCategory C] (X Y Z : C),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Z).hom\n      (CategoryTheory.CategoryStruct.comp (Î²_ X (CategoryTheory.MonoidalCategory.tensorObj Y Z)).hom\n        (CategoryTheory.MonoidalCategory.associator Y Z X).hom) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (Î²_ X Y).hom (CategoryTheory.CategoryStruct.id Z))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y X Z).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (Î²_ X Z).hom))","name":"CategoryTheory.BraidedCategory.hexagon_forward","isProp":true,"docString":"The first hexagon identity. ","distance":0.403913905967967890031644628834328614175319671630859375}],["The empty reduced word. ",{"type":"(G : Type u_1) â†’ [inst : Group G] â†’ (A B : Subgroup G) â†’ HNNExtension.NormalWord.ReducedWord G A B","name":"HNNExtension.NormalWord.ReducedWord.empty","isProp":false,"docString":"The empty reduced word. ","distance":0.414697889574994149608500038084457628428936004638671875}],["Young diagram from a sorted list ",{"type":"(w : List â„•) â†’ List.Sorted (fun x x_1 => x â‰¥ x_1) w â†’ YoungDiagram","name":"YoungDiagram.ofRowLens","isProp":false,"docString":"Young diagram from a sorted list ","distance":0.415411057607208589192993031247169710695743560791015625}],["an arrow ",{"type":"{V : Type u} â†’ [inst : Quiver V] â†’ (self : Quiver.Total V) â†’ self.left âŸ¶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.415963270776702531694724029875942505896091461181640625}],["Open balls are bounded ",{"type":"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] {x : Î±} {r : â„}, Bornology.IsBounded (Metric.ball x r)","name":"Metric.isBounded_ball","isProp":true,"docString":"Open balls are bounded ","distance":0.4172323858349920033816715658758766949176788330078125}],["The empty weak sequence ",{"type":"{Î± : Type u} â†’ Stream'.WSeq Î±","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.41866924644929504051305002576555125415325164794921875}],["A heavily unfolded version of the definition of multiplication ",{"type":"âˆ€ {Î¹ : Type u_1} [inst : DecidableEq Î¹] (A : Î¹ â†’ Type u_2) [inst_1 : (i : Î¹) â†’ AddCommMonoid (A i)]\n  [inst_2 : AddMonoid Î¹] [inst_3 : DirectSum.GSemiring A] [inst_4 : (i : Î¹) â†’ (x : A i) â†’ Decidable (x â‰  0)]\n  (a a' : DirectSum Î¹ fun i => A i),\n  a * a' =\n    Finset.sum (DFinsupp.support a Ã—Ë¢ DFinsupp.support a') fun ij =>\n      (DirectSum.of (fun i => A i) (ij.1 + ij.2)) (GradedMonoid.GMul.mul (a ij.1) (a' ij.2))","name":"DirectSum.mul_eq_sum_support_ghas_mul","isProp":true,"docString":"A heavily unfolded version of the definition of multiplication ","distance":0.419014479539048689815672332770191133022308349609375}],["The ball package made of unit balls. ",{"type":"(Î± : Type u_1) â†’ Besicovitch.BallPackage Î± Î±","name":"Besicovitch.unitBallPackage","isProp":false,"docString":"The ball package made of unit balls. ","distance":0.41927197366608470741056180486339144408702850341796875}],["an endomorphism of the object ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’ (self : CategoryTheory.Idempotents.Karoubi C) â†’ self.X âŸ¶ self.X","name":"CategoryTheory.Idempotents.Karoubi.p","isProp":false,"docString":"an endomorphism of the object ","distance":0.419506019826710152553772559258504770696163177490234375}],["The empty finset ",{"type":"{Î± : Type u_1} â†’ Finset Î±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.421592208863718564959555124005419202148914337158203125}],["The map on images induced by a commutative square. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {f g : CategoryTheory.Arrow C} â†’\n      [inst_1 : CategoryTheory.Limits.HasImage f.hom] â†’\n        [inst_2 : CategoryTheory.Limits.HasImage g.hom] â†’\n          (sq : f âŸ¶ g) â†’\n            [inst_3 : CategoryTheory.Limits.HasImageMap sq] â†’\n              CategoryTheory.Limits.image f.hom âŸ¶ CategoryTheory.Limits.image g.hom","name":"CategoryTheory.Limits.image.map","isProp":false,"docString":"The map on images induced by a commutative square. ","distance":0.422260486762431386242866437896736897528171539306640625}],["The empty set is meagre. ",{"type":"âˆ€ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre âˆ…","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.422726494567552180114944349043071269989013671875}],["The empty word ",{"type":"{G : Type u_1} â†’\n  [inst : Group G] â†’\n    {A B : Subgroup G} â†’ {d : HNNExtension.NormalWord.TransversalPair G A B} â†’ HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.42403000969313353607503813691437244415283203125}],["Seminorm-balls at the origin are balanced. ",{"type":"âˆ€ {ð•œ : Type u_3} {E : Type u_7} [inst : SeminormedRing ð•œ] [inst_1 : AddCommGroup E] [inst_2 : Module ð•œ E]\n  (p : Seminorm ð•œ E) (r : â„), Balanced ð•œ (Seminorm.ball p 0 r)","name":"Seminorm.balanced_ball_zero","isProp":true,"docString":"Seminorm-balls at the origin are balanced. ","distance":0.426011364467848985260189920154516585171222686767578125}],["A forgetful map, forgetting the time bound on the number of steps. ",{"type":"{Î± Î² : Type} â†’\n  {ea : Computability.FinEncoding Î±} â†’\n    {eb : Computability.FinEncoding Î²} â†’ {f : Î± â†’ Î²} â†’ Turing.TM2ComputableInTime ea eb f â†’ Turing.TM2Computable ea eb f","name":"Turing.TM2ComputableInTime.toTM2Computable","isProp":false,"docString":"A forgetful map, forgetting the time bound on the number of steps. ","distance":0.426432824758942674581163601033040322363376617431640625}],["**Portmanteau theorem** ",{"type":"âˆ€ {Î© : Type u_1} [inst : MeasurableSpace Î©] {Î¹ : Type u_2} {L : Filter Î¹} {Î¼ : MeasureTheory.Measure Î©}\n  {Î¼s : Î¹ â†’ MeasureTheory.Measure Î©} [inst_1 : MeasureTheory.IsProbabilityMeasure Î¼]\n  [inst_2 : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)] {E : Set Î©},\n  MeasurableSet E â†’ Filter.limsup (fun i => â†‘â†‘(Î¼s i) E) L â‰¤ â†‘â†‘Î¼ E â†’ â†‘â†‘Î¼ Eá¶œ â‰¤ Filter.liminf (fun i => â†‘â†‘(Î¼s i) Eá¶œ) L","name":"MeasureTheory.le_measure_compl_liminf_of_limsup_measure_le","isProp":true,"docString":"**Portmanteau theorem** ","distance":0.42653161563273622736147672185325063765048980712890625}],["Flip a relabelling. ",{"type":"{x y : SetTheory.PGame} â†’ SetTheory.PGame.Relabelling x y â†’ SetTheory.PGame.Relabelling y x","name":"SetTheory.PGame.Relabelling.symm","isProp":false,"docString":"Flip a relabelling. ","distance":0.42675472411793158311610341115738265216350555419921875}],["The unique empty cycle. ",{"type":"{Î± : Type u_1} â†’ Cycle Î±","name":"Cycle.nil","isProp":false,"docString":"The unique empty cycle. ","distance":0.426849683547163294417003953640232793986797332763671875}]]