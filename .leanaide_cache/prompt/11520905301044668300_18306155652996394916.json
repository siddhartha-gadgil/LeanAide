[["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) ‚Üí [inst : CategoryTheory.Category.{v, u} C] ‚Üí [inst : CategoryTheory.Limits.HasZeroObject C] ‚Üí Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.96527980292518122951150871813297271728515625}],[" The center of the group of units of a `GroupWithZero` type `M` equals the preimage of the center of `M` under the underlying value function.",{"type":"‚àÄ {M : Type u_1} [inst : GroupWithZero M], Set.center MÀ£ = Units.val ‚Åª¬π' Set.center M","name":"Set.center_units_eq","isProp":true,"docString":" The center of the group of units of a `GroupWithZero` type `M` equals the preimage of the center of `M` under the underlying value function.","distance":1.9798827042230568995506700957776047289371490478515625}],["This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.",{"type":"‚àÄ {G : Type u_1} [inst : NegZeroClass G], -0 = 0","name":"neg_zero","isProp":true,"docString":"This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.","distance":1.9901867061662705804536699361051432788372039794921875}],["Computes `‚åämax 0 (log‚ÇÇ n)‚åã`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n",{"type":"‚Ñï ‚Üí ‚Ñï","name":"Nat.log2","isProp":false,"docString":"Computes `‚åämax 0 (log‚ÇÇ n)‚åã`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n","distance":1.966927224410021768363776573096401989459991455078125}],[" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.",{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} {œÄ : BoxIntegral.TaggedPrepartition I} [inst : Fintype Œπ],\n  œÄ.IsHenstock ‚Üí ‚àÄ (x : Œπ ‚Üí ‚Ñù), (Finset.filter (fun J => œÄ.tag J = x) œÄ.boxes).card ‚â§ 2 ^ Fintype.card Œπ","name":"BoxIntegral.TaggedPrepartition.IsHenstock.card_filter_tag_eq_le","isProp":true,"docString":" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.","distance":1.987450021132659561118316560168750584125518798828125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9920307995983586035748658105148933827877044677734375}],["An estimator for the priority of the key.\n(We will assume we have `[‚àÄ a : Œ±, Estimator (prio a) (Œµ a)]`.) ",{"type":"{Œ± : Sort u_1} ‚Üí {œâ : Type u_2} ‚Üí {prio : Œ± ‚Üí Thunk œâ} ‚Üí {Œµ : Œ± ‚Üí Type} ‚Üí (self : BestFirstNode prio Œµ) ‚Üí Œµ self.key","name":"BestFirstNode.estimator","isProp":false,"docString":"An estimator for the priority of the key.\n(We will assume we have `[‚àÄ a : Œ±, Estimator (prio a) (Œµ a)]`.) ","distance":1.9705800431769879832444303247029893100261688232421875}],["If `task : Task Œ±` then `task.get : Œ±` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{Œ± : Type u} ‚Üí Task Œ± ‚Üí Œ±","name":"Task.get","isProp":false,"docString":"If `task : Task Œ±` then `task.get : Œ±` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9717203890633026031053987026098184287548065185546875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9720199521461083680407000429113395512104034423828125}],["Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ‚Ñï ‚Üí Type u_2} ‚Üí ((n : ‚Ñï) ‚Üí E n) ‚Üí Set ((n : ‚Ñï) ‚Üí E n) ‚Üí ‚Ñï","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.9727901996282837249196973061771132051944732666015625}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} ‚Üí\n  {P : Type u_2} ‚Üí\n    [inst : NormedAddCommGroup V] ‚Üí [inst_1 : MetricSpace P] ‚Üí [inst_2 : NormedAddTorsor V P] ‚Üí AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.976854706804306527345715949195437133312225341796875}],["Gadget for optional parameter support.\n\nA binder like `(x : Œ± := default)` in a declaration is syntax sugar for\n`x : optParam Œ± default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",{"type":"(Œ± : Sort u) ‚Üí Œ± ‚Üí Sort u","name":"optParam","isProp":false,"docString":"Gadget for optional parameter support.\n\nA binder like `(x : Œ± := default)` in a declaration is syntax sugar for\n`x : optParam Œ± default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n","distance":1.9782978694047728129845609146286733448505401611328125}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConvexOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí f z ‚â§ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9785874334472028923670450240024365484714508056640625}],["Retrieves the value of `a : Part Œ±` if it exists, and return the provided default value\notherwise. ",{"type":"{Œ± : Type u_1} ‚Üí (a : Part Œ±) ‚Üí [inst : Decidable a.Dom] ‚Üí Œ± ‚Üí Œ±","name":"Part.getOrElse","isProp":false,"docString":"Retrieves the value of `a : Part Œ±` if it exists, and return the provided default value\notherwise. ","distance":1.9788101480072450844005516046308912336826324462890625}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{Œ± : Prop} ‚Üí {p : Œ± ‚Üí Prop} ‚Üí {C : Sort u_1} ‚Üí C ‚Üí ((a : Œ±) ‚Üí p a ‚Üí C) ‚Üí C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":1.9794636130770688620117425671196542680263519287109375}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData ‚Üí Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9809652594270434899925703575718216598033905029296875}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9810461448749736579344471465446986258029937744140625}],["Returns the current max variable. ",{"type":"Linarith.LinarithM ‚Ñï","name":"Linarith.getMaxVar","isProp":false,"docString":"Returns the current max variable. ","distance":1.98173639908535204057216105866245925426483154296875}],["Name to use for the declaration for a type that is `Equiv` to the given type. ",{"type":"Mathlib.ProxyType.ProxyEquivConfig ‚Üí Lean.Name","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","isProp":false,"docString":"Name to use for the declaration for a type that is `Equiv` to the given type. ","distance":1.98249596657847870773139220545999705791473388671875}],["Converts an `Int` to a `ZNum`. ",{"type":"‚Ñ§ ‚Üí ZNum","name":"ZNum.ofInt'","isProp":false,"docString":"Converts an `Int` to a `ZNum`. ","distance":1.9830715964883911528460203044232912361621856689453125}],["`f : Œ± ‚Üí+* Œ≤` has a trivial codomain iff its range is `{0}`. ",{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤),\n  0 = 1 ‚Üî Set.range ‚áëf = {0}","name":"RingHom.codomain_trivial_iff_range_eq_singleton_zero","isProp":true,"docString":"`f : Œ± ‚Üí+* Œ≤` has a trivial codomain iff its range is `{0}`. ","distance":1.9833918255821647580461331017431803047657012939453125}],["`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : Œ±]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`Œ±` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat √ó Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",{"type":"{Œ± : Sort u} ‚Üí [i : Œ±] ‚Üí Œ±","name":"inferInstance","isProp":false,"docString":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : Œ±]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`Œ±` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat √ó Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n","distance":1.983543773460036963030006518238224089145660400390625}],["An arbitrary `RayVector` giving a ray. ",{"type":"{R : Type u_1} ‚Üí\n  [inst : StrictOrderedCommSemiring R] ‚Üí\n    {M : Type u_2} ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Module.Ray R M ‚Üí RayVector R M","name":"Module.Ray.someRayVector","isProp":false,"docString":"An arbitrary `RayVector` giving a ray. ","distance":1.9837130169563457204873202499584294855594635009765625}],["Given two integers, return their GCD and an equality proof.\nPanics if `ex` or `ey` aren't integer literals. ",{"type":"(ex ey : Q(‚Ñ§)) ‚Üí (ed : Q(‚Ñï)) √ó Q(Int.gcd ¬´$ex¬ª ¬´$ey¬ª = ¬´$ed¬ª)","name":"Tactic.NormNum.proveIntGCD","isProp":false,"docString":"Given two integers, return their GCD and an equality proof.\nPanics if `ex` or `ey` aren't integer literals. ","distance":1.984219614341645954169734977767802774906158447265625}]]