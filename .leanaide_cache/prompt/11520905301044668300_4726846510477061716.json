[["Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n",{"type":"â„• â†’ Linarith.PCompSet â†’ Linarith.LinarithM Unit","name":"Linarith.update","isProp":false,"docString":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n","distance":1.9428817844892289912195337819866836071014404296875}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":1.962017092406954876793179209926165640354156494140625}],["This theorem, `isGreatest_univ`, states that for any type `Î±` that has a preorder and is also an ordered set with a maximum element (denoted as `âŠ¤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `Î±`). In other words, no element in the universal set of `Î±` is greater than the maximum element `âŠ¤`.",{"type":"âˆ€ {Î± : Type u} [inst : Preorder Î±] [inst_1 : OrderTop Î±], IsGreatest Set.univ âŠ¤","name":"isGreatest_univ","isProp":true,"docString":"This theorem, `isGreatest_univ`, states that for any type `Î±` that has a preorder and is also an ordered set with a maximum element (denoted as `âŠ¤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `Î±`). In other words, no element in the universal set of `Î±` is greater than the maximum element `âŠ¤`.","distance":1.96160689283124867188234929926693439483642578125}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.94611160392518200978884124197065830230712890625}],[" In the category of TypeVec, two functions with the same point-wise behavior at all indices are equal.",{"type":"âˆ€ {n : â„•} {Î± : TypeVec.{u_1} n} {Î² : TypeVec.{u_2} n} (f g : Î±.Arrow Î²), (âˆ€ (i : Fin2 n), f i = g i) â†’ f = g","name":"TypeVec.Arrow.ext","isProp":true,"docString":" In the category of TypeVec, two functions with the same point-wise behavior at all indices are equal.","distance":1.9696424185808731888158717993064783513545989990234375}],["This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `Î±` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.",{"type":"âˆ€ {Î± : Type u_1} [inst : AddGroup Î±] [inst_1 : LinearOrder Î±]\n  [inst_2 : CovariantClass Î± Î± (fun x x_1 => x + x_1) fun x x_1 => x â‰¤ x_1] (a : Î±), max a 0 - max (-a) 0 = a","name":"max_zero_sub_max_neg_zero_eq_self","isProp":true,"docString":"This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `Î±` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.","distance":1.9731810893392573991178551295888610184192657470703125}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment â†’ Lean.Name â†’ Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.94944471733256019518876200891099870204925537109375}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConvexOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ f z â‰¤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.950142245646555583249437404447235167026519775390625}],["The `ğŸ™_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n",{"type":"(V : Type v) â†’\n  [inst : CategoryTheory.Category.{w, v} V] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory V] â†’\n      {C : Type uâ‚} â†’\n        [inst_2 : CategoryTheory.EnrichedCategory V C] â†’ (X : C) â†’ ğŸ™_ V âŸ¶ CategoryTheory.EnrichedCategory.Hom X X","name":"CategoryTheory.eId","isProp":false,"docString":"The `ğŸ™_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n","distance":1.958864393464196052008219339768402278423309326171875}],["The maximum operation: `max x y`. ",{"type":"{Î± : Type u} â†’ [self : Max Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Max.max","isProp":false,"docString":"The maximum operation: `max x y`. ","distance":1.9589843108338076405061656259931623935699462890625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name â†’ Bool) â†’ Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.96222815515203397040977506549097597599029541015625}],["`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ",{"type":"{S : Type u_2} â†’\n  [inst : Ring S] â†’ {A : Type u_4} â†’ [inst_1 : CommRing A] â†’ [inst_2 : Algebra A S] â†’ PowerBasis A S â†’ Polynomial A","name":"PowerBasis.minpolyGen","isProp":false,"docString":"`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ","distance":1.9633075838153590808587978244759142398834228515625}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConvexOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ f z â‰¤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9640095650342159760981530780554749071598052978515625}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’ CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.965129200907359763306203603860922157764434814453125}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed âŠ£ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":1.9662924891172182118026512398500926792621612548828125}],["`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) â†’ (N : Type u_2) â†’ (M â†’ N â†’ N) â†’ (N â†’ N â†’ Prop) â†’ Prop","name":"Contravariant","isProp":false,"docString":"`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ","distance":1.968369809304330697585783127578906714916229248046875}],["Default definition of `max`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.9699258434017592467313306769938208162784576416015625}],["The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.HasShift C â„¤] â†’\n      {J : Type u_1} â†’\n        (T : J â†’ CategoryTheory.Pretriangulated.Triangle C) â†’\n          [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚] â†’\n            [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚‚] â†’\n              [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).objâ‚ƒ] â†’\n                [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).objâ‚] â†’\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Pretriangulated.productTriangle.fan T)","name":"CategoryTheory.Pretriangulated.productTriangle.isLimitFan","isProp":false,"docString":"The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ","distance":1.9705680028087766419986337496084161102771759033203125}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name â†’ Array Simps.ParsedProjectionData â†’ Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.970693008373750831907500469242222607135772705078125}],["The tautological action by `CentroidHom Î±` on `Î±`.\n\nThis generalizes `Function.End.applyMulAction`. ",{"type":"{Î± : Type u_5} â†’ [inst : NonUnitalNonAssocSemiring Î±] â†’ Module (CentroidHom Î±) Î±","name":"CentroidHom.applyModule","isProp":false,"docString":"The tautological action by `CentroidHom Î±` on `Î±`.\n\nThis generalizes `Function.End.applyMulAction`. ","distance":1.9709225819459661455113064221222884953022003173828125}],["The pointwise maximum of strictly convex functions is strictly convex. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Î²] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {s : Set E} {f g : E â†’ Î²}, StrictConvexOn ğ•œ s f â†’ StrictConvexOn ğ•œ s g â†’ StrictConvexOn ğ•œ s (f âŠ” g)","name":"StrictConvexOn.sup","isProp":true,"docString":"The pointwise maximum of strictly convex functions is strictly convex. ","distance":1.971382700550609712308869347907602787017822265625}],["Bicoloring of a path graph ",{"type":"(n : â„•) â†’ SimpleGraph.Coloring (SimpleGraph.pathGraph n) Bool","name":"SimpleGraph.pathGraph.bicoloring","isProp":false,"docString":"Bicoloring of a path graph ","distance":1.97144193763418495990435985731892287731170654296875}],["`centroidWeights` equals a constant function. ",{"type":"âˆ€ (k : Type u_1) [inst : DivisionRing k] {Î¹ : Type u_4} (s : Finset Î¹),\n  Finset.centroidWeights k s = Function.const Î¹ (â†‘s.card)â»Â¹","name":"Finset.centroidWeights_eq_const","isProp":true,"docString":"`centroidWeights` equals a constant function. ","distance":1.971460122592343822134353104047477245330810546875}],["Auxiliary for `popMax`. ",{"type":"{Î± : Type u_1} â†’\n  {lt : Î± â†’ Î± â†’ Bool} â†’ (self : BinaryHeap Î± lt) â†’ { a' // BinaryHeap.size a' = BinaryHeap.size self - 1 }","name":"BinaryHeap.popMaxAux","isProp":false,"docString":"Auxiliary for `popMax`. ","distance":1.9722219458607976871888922687503509223461151123046875}]]