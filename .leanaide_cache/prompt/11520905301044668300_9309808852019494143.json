[["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’ CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.97060288096701530236032340326346457004547119140625}],[" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : OrderedSemiring ğ•œ] [inst_1 : AddCommMonoid E] [inst_2 : SMul ğ•œ E] {x : E}\n  {s : Set E}, StarConvex ğ•œ x s â†” âˆ€ â¦ƒy : Eâ¦„, y âˆˆ s â†’ segment ğ•œ x y âŠ† s","name":"starConvex_iff_segment_subset","isProp":true,"docString":" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.","distance":2.001784437796827464950411012978293001651763916015625}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.00740512874147913890965355676598846912384033203125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.99125865010552249856345952139236032962799072265625}],[" The sign of real number 0 is 0.",{"type":"Real.sign 0 = 0","name":"Real.sign_zero","isProp":true,"docString":" The sign of real number 0 is 0.","distance":2.009093734896067129369612302980385720729827880859375}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"âˆ€ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":2.018953095362063354656356750638224184513092041015625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.992455247539516971500006548012606799602508544921875}],["The identity as a `StarAlgHom`. ",{"type":"(R : Type u_2) â†’\n  (A : Type u_3) â†’\n    [inst : CommSemiring R] â†’ [inst_1 : Semiring A] â†’ [inst_2 : Algebra R A] â†’ [inst_3 : Star A] â†’ A â†’â‹†â‚[R] A","name":"StarAlgHom.id","isProp":false,"docString":"The identity as a `StarAlgHom`. ","distance":1.9938895245708285752783694988465867936611175537109375}],["If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ",{"type":"Linarith.GlobalBranchingPreprocessor","name":"Linarith.natToInt","isProp":false,"docString":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ","distance":1.9940937538582856891622441253275610506534576416015625}],["The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",{"type":"âˆ€ (p : ENNReal) {Î± : Type u_2} {Î² : Type u_3} [inst : PseudoEMetricSpace Î±] [inst_1 : PseudoEMetricSpace Î²]\n  (f : WithLp p (Î± Ã— Î²)), edist f f = 0","name":"WithLp.prod_edist_self","isProp":true,"docString":"The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ","distance":1.994881052820334677022628966369666159152984619140625}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’ CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.99737112387442738992149315890856087207794189453125}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.99848759806992237741951612406410276889801025390625}],["This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ",{"type":"{F : Type u_1} â†’\n  {A : Type u_2} â†’\n    [inst : NormedRing A] â†’\n      [inst_1 : NormedAlgebra â„‚ A] â†’\n        [inst_2 : CompleteSpace A] â†’\n          [inst_3 : StarRing A] â†’\n            [inst_4 : CstarRing A] â†’ [inst_5 : StarModule â„‚ A] â†’ [hF : AlgHomClass F â„‚ A â„‚] â†’ StarHomClass F A â„‚","name":"WeakDual.Complex.instStarHomClass","isProp":false,"docString":"This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ","distance":1.9998012356255163712859257429954595863819122314453125}],["Extend the scalars of an `AlgHom`. ",{"type":"{A : Type w} â†’\n  (B : Type uâ‚) â†’\n    {C : Type u_1} â†’\n      {D : Type u_2} â†’\n        [inst : CommSemiring A] â†’\n          [inst_1 : CommSemiring C] â†’\n            [inst_2 : CommSemiring D] â†’\n              [inst_3 : Algebra A C] â†’\n                [inst_4 : Algebra A D] â†’\n                  (f : C â†’â‚[A] D) â†’\n                    [inst_5 : CommSemiring B] â†’\n                      [inst_6 : Algebra A B] â†’ [inst_7 : Algebra B C] â†’ [inst_8 : IsScalarTower A B C] â†’ C â†’â‚[B] D","name":"AlgHom.extendScalars","isProp":false,"docString":"Extend the scalars of an `AlgHom`. ","distance":2.0007098159085270339119233540259301662445068359375}],["The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_4} [inst : SeminormedAddCommGroup E] [inst_1 : NontriviallyNormedField ğ•œ]\n  [inst_2 : NormedSpace ğ•œ E], â€–ContinuousLinearMap.id ğ•œ Eâ€– â‰¤ 1","name":"ContinuousLinearMap.norm_id_le","isProp":true,"docString":"The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. ","distance":2.0022962298888291599041622248478233814239501953125}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name â†’ Bool) â†’ Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":2.002512977128358517830974960816092789173126220703125}],["Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `â€–u - vâ€–` over points in `K` if and only if\nfor all `w âˆˆ K`, `âŸªu - v, wâŸ« = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (K : Submodule ğ•œ E) {u v : E}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, wâŸ«_ğ•œ = 0)","name":"norm_eq_iInf_iff_inner_eq_zero","isProp":true,"docString":"Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `â€–u - vâ€–` over points in `K` if and only if\nfor all `w âˆˆ K`, `âŸªu - v, wâŸ« = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n","distance":2.003135586992858652166660249349661171436309814453125}],["An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {v : Set E} [inst_3 : FiniteDimensional ğ•œ E],\n  Orthonormal ğ•œ Subtype.val â†’ ((âˆ€ u âŠ‡ v, Orthonormal ğ•œ Subtype.val â†’ u = v) â†” âˆƒ b, â‡‘b = Subtype.val)","name":"maximal_orthonormal_iff_basis_of_finiteDimensional","isProp":true,"docString":"An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ","distance":2.0032818728674808284040409489534795284271240234375}],["Endowing the space `WithLp p (Î± Ã— Î²)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 â‰¤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (Î± Ã— Î²)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) â†’ (Î± : Type u_2) â†’ (Î² : Type u_3) â†’ [inst : Dist Î±] â†’ [inst : Dist Î²] â†’ Dist (WithLp p (Î± Ã— Î²))","name":"WithLp.instProdDist","isProp":false,"docString":"Endowing the space `WithLp p (Î± Ã— Î²)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 â‰¤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (Î± Ã— Î²)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":2.003893806570620217399891771492548286914825439453125}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed âŠ£ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":2.00465941597894659054190924507565796375274658203125}],["Endowing the space `WithLp p (Î± Ã— Î²)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 â‰¤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (Î± Ã— Î²)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) â†’ (Î± : Type u_2) â†’ (Î² : Type u_3) â†’ [inst : EDist Î±] â†’ [inst : EDist Î²] â†’ EDist (WithLp p (Î± Ã— Î²))","name":"WithLp.instProdEDist","isProp":false,"docString":"Endowing the space `WithLp p (Î± Ã— Î²)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 â‰¤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (Î± Ã— Î²)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":2.00702361230474934927769936621189117431640625}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        {J : Type w} â†’\n          [inst_2 : CategoryTheory.Category.{w', w} J] â†’\n            {K : CategoryTheory.Functor J C} â†’\n              (F : CategoryTheory.Functor C D) â†’\n                {c : CategoryTheory.Limits.Cocone K} â†’\n                  CategoryTheory.Limits.IsColimit c â†’\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] â†’\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.007109209056727738840208985493518412113189697265625}],["a class of triangle which are called `distinguished` ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] â†’\n      [inst_2 : CategoryTheory.HasShift C â„¤] â†’\n        [inst_3 : CategoryTheory.Preadditive C] â†’\n          [inst_4 : âˆ€ (n : â„¤), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)] â†’\n            [self : CategoryTheory.Pretriangulated C] â†’ Set (CategoryTheory.Pretriangulated.Triangle C)","name":"CategoryTheory.Pretriangulated.distinguishedTriangles","isProp":false,"docString":"a class of triangle which are called `distinguished` ","distance":2.007420833315863628598663126467727124691009521484375}],["In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ",{"type":"âˆ€ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace â„ E] [inst_2 : StrictConvexSpace â„ E] {x y : E},\n  Â¬SameRay â„ x y â†” â€–x + yâ€– < â€–xâ€– + â€–yâ€–","name":"not_sameRay_iff_norm_add_lt","isProp":true,"docString":"In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ","distance":2.008844981661164208475156556232832372188568115234375}]]