[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.926472703694547927710800649947486817836761474609375}],[" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, âŸ¨Â·, Â·âŸ©)` over commutative scalar type `ğ•œ`, âŸ¨0, xâŸ© = 0 for all `x âˆˆ E`.","distance":1.9612171493112253717328030688804574310779571533203125}],["This theorem, `inner_zero_left`, states that for any scalar type `ğ•œ` and any normed add commutative group `E` with an inner product space over `ğ•œ`, the inner product of the zero vector and any vector `x` in `E` is always zero. This is a fundamental property of inner product spaces, essentially stating that the zero vector is orthogonal to all other vectors.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  (x : E), âŸª0, xâŸ«_ğ•œ = 0","name":"inner_zero_left","isProp":true,"docString":"This theorem, `inner_zero_left`, states that for any scalar type `ğ•œ` and any normed add commutative group `E` with an inner product space over `ğ•œ`, the inner product of the zero vector and any vector `x` in `E` is always zero. This is a fundamental property of inner product spaces, essentially stating that the zero vector is orthogonal to all other vectors.","distance":1.9553060846007668249768585155834443867206573486328125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.94185809483454985269190729013644158840179443359375}],[" Given a `PseudoMetricSpace` and `ProperSpace` TYPE `Î±` with point `x`, real number `r`, and closed set `s`, if `s âŠ† ball x r`, then there exists `r' < r` such that `s âŠ† ball x r'`.",{"type":"âˆ€ {Î± : Type u} [inst : PseudoMetricSpace Î±] [inst_1 : ProperSpace Î±] {x : Î±} {r : â„} {s : Set Î±},\n  IsClosed s â†’ s âŠ† Metric.ball x r â†’ âˆƒ r' < r, s âŠ† Metric.ball x r'","name":"exists_lt_subset_ball","isProp":true,"docString":" Given a `PseudoMetricSpace` and `ProperSpace` TYPE `Î±` with point `x`, real number `r`, and closed set `s`, if `s âŠ† ball x r`, then there exists `r' < r` such that `s âŠ† ball x r'`.","distance":1.966978269256905331729967656428925693035125732421875}],["The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `ğ•œ`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_5} [inst : LinearOrderedField ğ•œ] [inst_1 : OrderedAddCommMonoid Î²]\n  [inst_2 : AddCommMonoid E] [inst_3 : SMul ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²] {f : E â†’ Î²}\n  {s : Set E} {x y : E}, StrictConvexOn ğ•œ s f â†’ IsMinOn f s x â†’ IsMinOn f s y â†’ x âˆˆ s â†’ y âˆˆ s â†’ x = y","name":"StrictConvexOn.eq_of_isMinOn","isProp":true,"docString":"The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `ğ•œ`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.","distance":1.955625219211764242999151974800042808055877685546875}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.948341229364367155341142279212363064289093017578125}],["Corresponds to `dist_pos`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9519343064531835540975635012728162109851837158203125}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9533944332047517011829995681182481348514556884765625}],["**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {s : Set E} {f : E â†’ Î²}, ConcaveOn ğ•œ ((convexHull ğ•œ) s) f â†’ âˆ€ {x : E}, x âˆˆ (convexHull ğ•œ) s â†’ âˆƒ y âˆˆ s, f y â‰¤ f x","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ","distance":1.953771757948383314129614518606103956699371337890625}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9537979534551708216127963169128634035587310791015625}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.954844725090451706961403033346869051456451416015625}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.9550436718851103012895009669591672718524932861328125}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9560250886145638116175859977374784648418426513671875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9577017604733775169023601847584359347820281982421875}],["Corresponds to `zero_eq_dist`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 = hammingDist x y â†” x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.9581707865450683758723471328266896307468414306640625}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9589431035945004122567070226068608462810516357421875}],["`toReal x` returns `x` if it is real, `0` otherwise. ",{"type":"ENNReal â†’ â„","name":"ENNReal.toReal","isProp":false,"docString":"`toReal x` returns `x` if it is real, `0` otherwise. ","distance":1.95925905157653890142910313443280756473541259765625}],["The minimum function is equivalent to the one you get from `minOfLe`. ",{"type":"âˆ€ {Î± : Type u} [self : LinearOrderedCommGroup Î±] (a b : Î±), min a b = if a â‰¤ b then a else b","name":"LinearOrderedCommGroup.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. ","distance":1.9594525229936667898300584056414663791656494140625}],["`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ",{"type":"âˆ€ {Î± : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace Î±} {Î¼ : MeasureTheory.Measure Î±}\n  {f : MeasureTheory.SimpleFunc Î± E} {g : E â†’ ENNReal},\n  MeasureTheory.Integrable â†‘f â†’\n    g 0 = 0 â†’\n      (âˆ€ (b : E), g b â‰  âŠ¤) â†’\n        MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map (ENNReal.toReal âˆ˜ g) f) =\n          ENNReal.toReal (âˆ«â» (a : Î±), g (â†‘f a) âˆ‚Î¼)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","isProp":true,"docString":"`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ","distance":1.959467936587653280611220907303504645824432373046875}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.9598508577259108331958259441307745873928070068359375}],["The space of functions `Fin 2 â†’ Î±` is equivalent to `Î± Ã— Î±`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. ",{"type":"(Î± : Type u_1) â†’ (Fin 2 â†’ Î±) â‰ƒ Î± Ã— Î±","name":"finTwoArrowEquiv","isProp":false,"docString":"The space of functions `Fin 2 â†’ Î±` is equivalent to `Î± Ã— Î±`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. ","distance":1.9603769720052479641481113503687083721160888671875}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{Mâ‚ : Type u_1} â†’\n  {Mâ‚‚ : Type u_2} â†’\n    [inst : Zero Mâ‚] â†’\n      [inst_1 : Neg Mâ‚] â†’\n        [inst_2 : NegZeroClass Mâ‚‚] â†’\n          (f : Mâ‚ â†’ Mâ‚‚) â†’ Function.Injective f â†’ f 0 = 0 â†’ (âˆ€ (x : Mâ‚), f (-x) = -f x) â†’ NegZeroClass Mâ‚","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.9608514466837572154389590650680474936962127685546875}],["Corresponds to `dist_zero_right`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)]\n  [inst_2 : (i : Î¹) â†’ Zero (Î² i)] (x : (i : Î¹) â†’ Î² i), hammingDist x 0 = hammingNorm x","name":"hammingDist_zero_right","isProp":true,"docString":"Corresponds to `dist_zero_right`. ","distance":1.961437115623013927034890002687461674213409423828125}]]