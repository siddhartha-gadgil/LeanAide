[["Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n",{"type":"{V : Type u} â†’\n  {G : SimpleGraph V} â†’\n    (G' : SimpleGraph.Subgraph G) â†’\n      (V'' : Set V) â†’ V'' = G'.verts â†’ (adj' : V â†’ V â†’ Prop) â†’ adj' = G'.Adj â†’ SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.copy","isProp":false,"docString":"Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n","distance":1.869988850907501554132750243297778069972991943359375}],[" For a given type `k`, set `P` of points in the `AddTorsor` `V P`, and point `p` in `P`, the submodule `Submodule.span {x : P | x â‰  p} (x - p)` is equal to the vector space span of `{p} âˆª {x : P | x â‰  p}`.",{"type":"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : DecidableEq P] [inst_5 : DecidableEq V] {s : Finset P} {p : P},\n  p âˆˆ s â†’ vectorSpan k â†‘s = Submodule.span k â†‘(Finset.image (fun x => x -áµ¥ p) (s.erase p))","name":"vectorSpan_eq_span_vsub_finset_right_ne","isProp":true,"docString":" For a given type `k`, set `P` of points in the `AddTorsor` `V P`, and point `p` in `P`, the submodule `Submodule.span {x : P | x â‰  p} (x - p)` is equal to the vector space span of `{p} âˆª {x : P | x â‰  p}`.","distance":1.875882293151539759179513566778041422367095947265625}],["The theorem `vectorSpan_eq_span_vsub_set_left` expresses that, given a set of points `s` in an additive torsor space `P` over a module `V`, and a point `p` within `s`, the vector span of `s` is equivalent to the span of the set of vectors formed by subtracting each point in `s` from `p`. Here, the vector subtraction `-áµ¥` returns a vector in `V`. In other words, in such a setting, we can create the vector span of `s` by looking at all vectors resulting from subtracting other points in `s` from a chosen point `p` in `s`, and then spanning over these vectors.",{"type":"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P}, p âˆˆ s â†’ vectorSpan k s = Submodule.span k ((fun x => p -áµ¥ x) '' s)","name":"vectorSpan_eq_span_vsub_set_left","isProp":true,"docString":"The theorem `vectorSpan_eq_span_vsub_set_left` expresses that, given a set of points `s` in an additive torsor space `P` over a module `V`, and a point `p` within `s`, the vector span of `s` is equivalent to the span of the set of vectors formed by subtracting each point in `s` from `p`. Here, the vector subtraction `-áµ¥` returns a vector in `V`. In other words, in such a setting, we can create the vector span of `s` by looking at all vectors resulting from subtracting other points in `s` from a chosen point `p` in `s`, and then spanning over these vectors.","distance":1.8885301284913034169932188888196833431720733642578125}],["Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning\nsubgraph, then `G'.spanningCoe` yields an isomorphic graph.\nIn general, this adds in all vertices from `V` as isolated vertices. ",{"type":"{V : Type u} â†’ {G : SimpleGraph V} â†’ SimpleGraph.Subgraph G â†’ SimpleGraph V","name":"SimpleGraph.Subgraph.spanningCoe","isProp":false,"docString":"Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning\nsubgraph, then `G'.spanningCoe` yields an isomorphic graph.\nIn general, this adds in all vertices from `V` as isolated vertices. ","distance":1.872558091018984072206876589916646480560302734375}],[" If a subset `sâ‚` of a coplanar set `sâ‚‚` of points in an affine space over a division ring `k` and its module `V`, then `sâ‚` is also coplanar.",{"type":"âˆ€ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {sâ‚ sâ‚‚ : Set P}, sâ‚ âŠ† sâ‚‚ â†’ Coplanar k sâ‚‚ â†’ Coplanar k sâ‚","name":"Coplanar.subset","isProp":true,"docString":" If a subset `sâ‚` of a coplanar set `sâ‚‚` of points in an affine space over a division ring `k` and its module `V`, then `sâ‚` is also coplanar.","distance":1.886941459066933557409129207371734082698822021484375}],["The theorem `vectorSpan_eq_span_vsub_set_left_ne` states that, for a given ring `k`, the vector space `V` of some type, a point `P`, and a set `s` of points of type `P` which includes the point `p`, the `vectorSpan` of `s` (which represents the submodule generated by the differences of all pairs of points in the set) is equal to the `Submodule.span` of the set of differences between `p` and all other points in `s` (excluding the difference of `p` with itself). In other words, the set of all pairwise differences in `s` generates the same subspace as the set of differences between a fixed point `p` in `s` and all the other points in `s`.",{"type":"âˆ€ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P},\n  p âˆˆ s â†’ vectorSpan k s = Submodule.span k ((fun x => p -áµ¥ x) '' (s \\ {p}))","name":"vectorSpan_eq_span_vsub_set_left_ne","isProp":true,"docString":"The theorem `vectorSpan_eq_span_vsub_set_left_ne` states that, for a given ring `k`, the vector space `V` of some type, a point `P`, and a set `s` of points of type `P` which includes the point `p`, the `vectorSpan` of `s` (which represents the submodule generated by the differences of all pairs of points in the set) is equal to the `Submodule.span` of the set of differences between `p` and all other points in `s` (excluding the difference of `p` with itself). In other words, the set of all pairwise differences in `s` generates the same subspace as the set of differences between a fixed point `p` in `s` and all the other points in `s`.","distance":1.89051812694729193253806442953646183013916015625}],["Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {EM : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup EM] â†’\n        [inst_2 : NormedSpace ğ•œ EM] â†’\n          {HM : Type u_3} â†’\n            [inst_3 : TopologicalSpace HM] â†’\n              (IM : ModelWithCorners ğ•œ EM HM) â†’\n                {E : Type u_4} â†’\n                  [inst_4 : NormedAddCommGroup E] â†’\n                    [inst_5 : NormedSpace ğ•œ E] â†’\n                      {H : Type u_5} â†’\n                        [inst_6 : TopologicalSpace H] â†’\n                          (I : ModelWithCorners ğ•œ E H) â†’\n                            {M : Type u} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace HM M] â†’\n                                  (N : Type u) â†’\n                                    [inst_9 : TopologicalSpace N] â†’\n                                      [inst_10 : ChartedSpace H N] â†’\n                                        (x : M) â†’\n                                          TopCat.Presheaf.stalk (TopCat.Sheaf.presheaf (smoothSheaf IM I M N)) x â†’ N","name":"smoothSheaf.eval","isProp":false,"docString":"Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`. ","distance":1.8821450045853740373758000714587979018688201904296875}],["If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nSee also `LinearMap.eqOn_span'` for a version using `Set.EqOn`. ",{"type":"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring Râ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : Module Râ‚‚ Mâ‚‚] {F : Type u_8}\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] {s : Set M} {f g : F},\n  Set.EqOn (â‡‘f) (â‡‘g) s â†’ âˆ€ â¦ƒx : Mâ¦„, x âˆˆ Submodule.span R s â†’ f x = g x","name":"LinearMap.eqOn_span","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nSee also `LinearMap.eqOn_span'` for a version using `Set.EqOn`. ","distance":1.883547252519485848409885875298641622066497802734375}],["If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nThis version uses `Set.EqOn`, and the hidden argument will expand to `h : x âˆˆ (span R s : Set M)`.\nSee `LinearMap.eqOn_span` for a version that takes `h : x âˆˆ span R s` as an argument. ",{"type":"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring Râ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : Module Râ‚‚ Mâ‚‚] {F : Type u_8}\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] {s : Set M} {f g : F},\n  Set.EqOn (â‡‘f) (â‡‘g) s â†’ Set.EqOn â‡‘f â‡‘g â†‘(Submodule.span R s)","name":"LinearMap.eqOn_span'","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nThis version uses `Set.EqOn`, and the hidden argument will expand to `h : x âˆˆ (span R s : Set M)`.\nSee `LinearMap.eqOn_span` for a version that takes `h : x âˆˆ span R s` as an argument. ","distance":1.8852174025774512955422324012033641338348388671875}],["The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ",{"type":"{R : Type u} â†’\n  {A : Type v} â†’\n    [inst : CommSemiring R] â†’\n      [inst_1 : StarRing R] â†’\n        [inst_2 : NonUnitalSemiring A] â†’\n          [inst_3 : StarRing A] â†’\n            [inst_4 : Module R A] â†’\n              [inst_5 : IsScalarTower R A A] â†’\n                [inst_6 : SMulCommClass R A A] â†’\n                  [inst_7 : StarModule R A] â†’ NonUnitalSubalgebra R A â†’ NonUnitalStarSubalgebra R A","name":"NonUnitalSubalgebra.starClosure","isProp":false,"docString":"The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ","distance":1.8855509135672054998877911202725954353809356689453125}],["Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Set`. See\nnote [pointwise nat action].",{"type":"{Î± : Type u_2} â†’ [inst : Zero Î±] â†’ [inst : Add Î±] â†’ SMul â„• (Set Î±)","name":"Set.NSMul","isProp":false,"docString":"Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Set`. See\nnote [pointwise nat action].","distance":1.8863604861514813304523840997717343270778656005859375}],["Repeated pointwise addition/subtraction (not the same as pointwise repeated\naddition/subtraction!) of a `Set`. See note [pointwise nat action]. ",{"type":"{Î± : Type u_2} â†’ [inst : Zero Î±] â†’ [inst : Add Î±] â†’ [inst : Neg Î±] â†’ SMul â„¤ (Set Î±)","name":"Set.ZSMul","isProp":false,"docString":"Repeated pointwise addition/subtraction (not the same as pointwise repeated\naddition/subtraction!) of a `Set`. See note [pointwise nat action]. ","distance":1.886957251440203098269421388977207243442535400390625}],["An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {B : C} â†’\n      (X Y : CategoryTheory.Subobject B) â†’\n        X = Y â†’ (CategoryTheory.Subobject.underlying.obj X â‰… CategoryTheory.Subobject.underlying.obj Y)","name":"CategoryTheory.Subobject.isoOfEq","isProp":false,"docString":"An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) ","distance":1.88741707466358743516821050434373319149017333984375}],["The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `â…x,Gâ† âŠ† H n`",{"type":"âˆ€ (G : Type u_1) [inst : Group G] (n : â„•) (x : G),\n  x âˆˆ upperCentralSeries G (n + 1) â†” âˆ€ (y : G), x * y * xâ»Â¹ * yâ»Â¹ âˆˆ upperCentralSeries G n","name":"mem_upperCentralSeries_succ_iff","isProp":true,"docString":"The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `â…x,Gâ† âŠ† H n`","distance":1.8877830935275687895824603401706553995609283447265625}],["Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`, considered as a morphism in the category of types. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {EM : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup EM] â†’\n        [inst_2 : NormedSpace ğ•œ EM] â†’\n          {HM : Type u_3} â†’\n            [inst_3 : TopologicalSpace HM] â†’\n              (IM : ModelWithCorners ğ•œ EM HM) â†’\n                {E : Type u_4} â†’\n                  [inst_4 : NormedAddCommGroup E] â†’\n                    [inst_5 : NormedSpace ğ•œ E] â†’\n                      {H : Type u_5} â†’\n                        [inst_6 : TopologicalSpace H] â†’\n                          (I : ModelWithCorners ğ•œ E H) â†’\n                            {M : Type u} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace HM M] â†’\n                                  (N : Type u) â†’\n                                    [inst_9 : TopologicalSpace N] â†’\n                                      [inst_10 : ChartedSpace H N] â†’\n                                        (x : â†‘(TopCat.of M)) â†’\n                                          TopCat.Presheaf.stalk (TopCat.Sheaf.presheaf (smoothSheaf IM I M N)) x âŸ¶ N","name":"smoothSheaf.evalHom","isProp":false,"docString":"Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`, considered as a morphism in the category of types. ","distance":1.8878677838431248137140983089921064674854278564453125}],["The `dualAnnihilator` of a submodule `W` is the set of linear maps `Ï†` such\nthat `Ï† w = 0` for all `w âˆˆ W`. ",{"type":"{R : Type u} â†’\n  {M : Type v} â†’\n    [inst : CommSemiring R] â†’\n      [inst_1 : AddCommMonoid M] â†’ [inst_2 : Module R M] â†’ Submodule R M â†’ Submodule R (Module.Dual R M)","name":"Submodule.dualAnnihilator","isProp":false,"docString":"The `dualAnnihilator` of a submodule `W` is the set of linear maps `Ï†` such\nthat `Ï† w = 0` for all `w âˆˆ W`. ","distance":1.887930998614084199260787499952130019664764404296875}],["Compile the definition `dv` by adding a second definition `dvâœ` with the same body,\nand registering a `csimp`-lemma `dv = dvâœ`.\n",{"type":"Lean.DefinitionVal â†’ Lean.MetaM Unit","name":"Mathlib.Util.compileDefn","isProp":false,"docString":"Compile the definition `dv` by adding a second definition `dvâœ` with the same body,\nand registering a `csimp`-lemma `dv = dvâœ`.\n","distance":1.889129135437805029340552209760062396526336669921875}],["Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",{"type":"âˆ€ {a b : Prop}, a âˆ§ b â†’ b","name":"And.right","isProp":true,"docString":"Extract the right conjunct from a conjunction. `h : a âˆ§ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ","distance":1.8905180610547980268876244736020453274250030517578125}],["A tactic (for use in default params) that applies `Set.toFinite` to synthesize a `Set.Finite`\nterm. ",{"type":"Lean.ParserDescr","name":"Set.tacticToFinite_tac","isProp":false,"docString":"A tactic (for use in default params) that applies `Set.toFinite` to synthesize a `Set.Finite`\nterm. ","distance":1.890828174403646588785932181053794920444488525390625}],["Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {M N : CategoryTheory.Monad C} â†’\n      (f : M.toFunctor â‰… N.toFunctor) â†’\n        autoParam\n            (âˆ€ (X : C),\n              CategoryTheory.CategoryStruct.comp ((CategoryTheory.Monad.Î· M).app X) (f.hom.app X) =\n                (CategoryTheory.Monad.Î· N).app X)\n            _autoâœ â†’\n          autoParam\n              (âˆ€ (X : C),\n                CategoryTheory.CategoryStruct.comp ((CategoryTheory.Monad.Î¼ M).app X) (f.hom.app X) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X)))\n                    ((CategoryTheory.Monad.Î¼ N).app X))\n              _autoâœÂ¹ â†’\n            (M â‰… N)","name":"CategoryTheory.MonadIso.mk","isProp":false,"docString":"Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. ","distance":1.890906589496527345772847183980047702789306640625}],["Let `E` be a TVS, `ğ”– : Set (Set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (Î± â†’áµ¤[ğ”–] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `Î± â†’áµ¤[ğ”–] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. ",{"type":"âˆ€ (ğ•œ : Type u_1) (Î± : Type u_2) (E : Type u_3) (H : Type u_4) {hom : Type u_5} [inst : NormedField ğ•œ]\n  [inst_1 : AddCommGroup H] [inst_2 : Module ğ•œ H] [inst_3 : AddCommGroup E] [inst_4 : Module ğ•œ E]\n  [inst_5 : TopologicalSpace H] [inst_6 : UniformSpace E] [inst_7 : UniformAddGroup E] [inst_8 : ContinuousSMul ğ•œ E]\n  {ğ”– : Set (Set Î±)} [inst_9 : LinearMapClass hom ğ•œ H (UniformOnFun Î± E ğ”–)],\n  Set.Nonempty ğ”– â†’\n    DirectedOn (fun x x_1 => x âŠ† x_1) ğ”– â†’\n      âˆ€ (Ï† : hom), Inducing â‡‘Ï† â†’ (âˆ€ (u : H), âˆ€ s âˆˆ ğ”–, Bornology.IsVonNBounded ğ•œ (Ï† u '' s)) â†’ ContinuousSMul ğ•œ H","name":"UniformOnFun.continuousSMul_induced_of_image_bounded","isProp":true,"docString":"Let `E` be a TVS, `ğ”– : Set (Set Î±)` and `H` a submodule of `Î± â†’áµ¤[ğ”–] E`. If the image of any\n`S âˆˆ ğ”–` by any `u âˆˆ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ğ”–`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (Î± â†’áµ¤[ğ”–] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `Î± â†’áµ¤[ğ”–] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. ","distance":1.8916807450586834438155392490443773567676544189453125}],["See also `Subspace.dualAnnihilator_inf_eq` for vector subspaces. ",{"type":"âˆ€ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (U V : Submodule R M), Submodule.dualAnnihilator U âŠ” Submodule.dualAnnihilator V â‰¤ Submodule.dualAnnihilator (U âŠ“ V)","name":"Submodule.sup_dualAnnihilator_le_inf","isProp":true,"docString":"See also `Subspace.dualAnnihilator_inf_eq` for vector subspaces. ","distance":1.89336339085021077011106171994470059871673583984375}],["The `NonUnitalSubsemiring` generated by a set. ",{"type":"{R : Type u} â†’ [inst : NonUnitalNonAssocSemiring R] â†’ Set R â†’ NonUnitalSubsemiring R","name":"NonUnitalSubsemiring.closure","isProp":false,"docString":"The `NonUnitalSubsemiring` generated by a set. ","distance":1.8936434813181344249954918268485926091670989990234375}],["Two linear maps are equal on `Submodule.span s` iff they are equal on `s`. ",{"type":"âˆ€ {R : Type u_1} {Râ‚‚ : Type u_2} {M : Type u_4} {Mâ‚‚ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring Râ‚‚] [inst_4 : AddCommMonoid Mâ‚‚] [inst_5 : Module Râ‚‚ Mâ‚‚] {F : Type u_8}\n  {Ïƒâ‚â‚‚ : R â†’+* Râ‚‚} [inst_6 : SemilinearMapClass F Ïƒâ‚â‚‚ M Mâ‚‚] {s : Set M} {f g : F},\n  Set.EqOn â‡‘f â‡‘g â†‘(Submodule.span R s) â†” Set.EqOn (â‡‘f) (â‡‘g) s","name":"LinearMap.eqOn_span_iff","isProp":true,"docString":"Two linear maps are equal on `Submodule.span s` iff they are equal on `s`. ","distance":1.8940827914918241248187769087962806224822998046875}]]