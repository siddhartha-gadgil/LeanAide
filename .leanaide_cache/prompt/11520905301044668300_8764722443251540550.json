[["**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ",{"type":"{Œ± : Type u_1} ‚Üí Ordnode Œ± ‚Üí Œ± ‚Üí Ordnode Œ± ‚Üí Ordnode Œ±","name":"Ordnode.node'","isProp":false,"docString":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","distance":1.9834250401142263786624653221224434673786163330078125}],[" For any rational number r, normalizing r using its numerator and denominator yields the same rational number (i.e., Rat.normalize (numerator r) (denominator r) = r).",{"type":"‚àÄ (r : ‚Ñö), Rat.normalize r.num r.den ‚ãØ = r","name":"Rat.normalize_self","isProp":true,"docString":" For any rational number r, normalizing r using its numerator and denominator yields the same rational number (i.e., Rat.normalize (numerator r) (denominator r) = r).","distance":2.005892273966873862178772469633258879184722900390625}],["This theorem, named `PadicSeq.lift_index_right`, is about manipulating indices of a `p`-adic sequence, where `p` is a prime number. Specifically, for a given `p`-adic sequence `f` that is not equivalent to the zero sequence, and any two natural numbers `v1` and `v2`, the `p`-adic norm of the `f`th term at the stationary point of `f` is equal to the `p`-adic norm of the `f`th term at the maximum of `v1`, `v2`, and the stationary point of `f`. The stationary point of a `p`-adic sequence is such that beyond this point, the `p`-adic norm of all further terms in the sequence is constant. This theorem allows for flexibility in selecting the index of the `p`-adic sequence while still preserving the `p`-adic norm value.",{"type":"‚àÄ {p : ‚Ñï} [inst : Fact p.Prime] {f : PadicSeq p} (hf : ¬¨f ‚âà 0) (v1 v2 : ‚Ñï),\n  padicNorm p (‚Üëf (PadicSeq.stationaryPoint hf)) = padicNorm p (‚Üëf (max v1 (max v2 (PadicSeq.stationaryPoint hf))))","name":"PadicSeq.lift_index_right","isProp":true,"docString":"This theorem, named `PadicSeq.lift_index_right`, is about manipulating indices of a `p`-adic sequence, where `p` is a prime number. Specifically, for a given `p`-adic sequence `f` that is not equivalent to the zero sequence, and any two natural numbers `v1` and `v2`, the `p`-adic norm of the `f`th term at the stationary point of `f` is equal to the `p`-adic norm of the `f`th term at the maximum of `v1`, `v2`, and the stationary point of `f`. The stationary point of a `p`-adic sequence is such that beyond this point, the `p`-adic norm of all further terms in the sequence is constant. This theorem allows for flexibility in selecting the index of the `p`-adic sequence while still preserving the `p`-adic norm value.","distance":2.025836844683952531198656288324855268001556396484375}],["An uncurried version of `Finset.prod_prod_type_right`. ",{"type":"‚àÄ {Œ≥ : Type u_3} {Œ±‚ÇÅ : Type u_4} {Œ±‚ÇÇ : Type u_5} [inst : Fintype Œ±‚ÇÅ] [inst_1 : Fintype Œ±‚ÇÇ] [inst_2 : CommMonoid Œ≥]\n  {f : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ ‚Üí Œ≥},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun y => Finset.prod Finset.univ fun x => f x y","name":"Fintype.prod_prod_type_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type_right`. ","distance":1.991690773065367903171818397822789847850799560546875}],[" The `Finset.range` function maps larger natural numbers to larger and unbounded finite sets.",{"type":"Filter.Tendsto Finset.range Filter.atTop Filter.atTop","name":"Filter.tendsto_finset_range","isProp":true,"docString":" The `Finset.range` function maps larger natural numbers to larger and unbounded finite sets.","distance":2.01905466177151371454101536073721945285797119140625}],["The theorem `PadicSeq.stationaryPoint_spec` states that for any prime number `p` and any `p`-adic Cauchy sequence `f` that is not equivalent to zero, if natural numbers `m` and `n` are greater than or equal to the stationary point of `f`, then the `p`-adic norm of `f` at the indices `m` and `n` is the same. In other words, beyond the stationary point of a `p`-adic Cauchy sequence, the `p`-adic norm remains constant.",{"type":"‚àÄ {p : ‚Ñï} [inst : Fact p.Prime] {f : PadicSeq p} (hf : ¬¨f ‚âà 0) {m n : ‚Ñï},\n  PadicSeq.stationaryPoint hf ‚â§ m ‚Üí PadicSeq.stationaryPoint hf ‚â§ n ‚Üí padicNorm p (‚Üëf n) = padicNorm p (‚Üëf m)","name":"PadicSeq.stationaryPoint_spec","isProp":true,"docString":"The theorem `PadicSeq.stationaryPoint_spec` states that for any prime number `p` and any `p`-adic Cauchy sequence `f` that is not equivalent to zero, if natural numbers `m` and `n` are greater than or equal to the stationary point of `f`, then the `p`-adic norm of `f` at the indices `m` and `n` is the same. In other words, beyond the stationary point of a `p`-adic Cauchy sequence, the `p`-adic norm remains constant.","distance":2.02943955611817017370412941090762615203857421875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.993725671099874308112021026317961513996124267578125}],["A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ",{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : Fintype Œπ] (S : Œπ ‚Üí Set Œ±),\n  (fun f => Finset.sum Finset.univ fun i => f i) '' Set.pi Set.univ S = Finset.sum Finset.univ fun i => S i","name":"Set.image_fintype_sum_pi","isProp":true,"docString":"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ","distance":1.994452775785424680776714012608863413333892822265625}],["Restrict the codomain of an `NonUnitalAlgHom` `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ",{"type":"{F : Type v'} ‚Üí\n  {R : Type u} ‚Üí\n    {A : Type v} ‚Üí\n      {B : Type w} ‚Üí\n        [inst : CommSemiring R] ‚Üí\n          [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n            [inst_2 : Module R A] ‚Üí\n              [inst_3 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_4 : Module R B] ‚Üí\n                  [inst_5 : NonUnitalAlgHomClass F R A B] ‚Üí (f : F) ‚Üí A ‚Üí‚Çô‚Çê[R] ‚Ü•(NonUnitalAlgHom.range f)","name":"NonUnitalAlgHom.rangeRestrict","isProp":false,"docString":"Restrict the codomain of an `NonUnitalAlgHom` `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ","distance":1.9947291398015647434505126511794514954090118408203125}],["An uncurried version of `Finset.prod_product_right`. ",{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤},\n  (Finset.prod (s √óÀ¢ t) fun x => f x.1 x.2) = Finset.prod t fun y => Finset.prod s fun x => f x y","name":"Finset.prod_product_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_product_right`. ","distance":1.99707857136306632384048498352058231830596923828125}],["An uncurried version of `Finset.prod_prod_type`. ",{"type":"‚àÄ {Œ≥ : Type u_3} {Œ±‚ÇÅ : Type u_4} {Œ±‚ÇÇ : Type u_5} [inst : Fintype Œ±‚ÇÅ] [inst_1 : Fintype Œ±‚ÇÇ] [inst_2 : CommMonoid Œ≥]\n  {f : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ ‚Üí Œ≥},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun x => Finset.prod Finset.univ fun y => f x y","name":"Fintype.prod_prod_type'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type`. ","distance":1.9986454574002927575548937966232188045978546142578125}],["A version of `convexHull_prod` for `Set.reProdIm`. ",{"type":"‚àÄ (s t : Set ‚Ñù), (convexHull ‚Ñù) (s √ó‚ÑÇ t) = (convexHull ‚Ñù) s √ó‚ÑÇ (convexHull ‚Ñù) t","name":"Complex.convexHull_reProdIm","isProp":true,"docString":"A version of `convexHull_prod` for `Set.reProdIm`. ","distance":2.000378822776374132530463612056337296962738037109375}],["A special case of `Set.image_finset_prod_pi` for `Finset.univ`. ",{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] [inst_1 : Fintype Œπ] (S : Œπ ‚Üí Set Œ±),\n  (fun f => Finset.prod Finset.univ fun i => f i) '' Set.pi Set.univ S = Finset.prod Finset.univ fun i => S i","name":"Set.image_fintype_prod_pi","isProp":true,"docString":"A special case of `Set.image_finset_prod_pi` for `Finset.univ`. ","distance":2.0004298765903332224525001947768032550811767578125}],["Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the product is over `Finset.univ`. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"BigOperators.delabFinsetProd","isProp":false,"docString":"Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the product is over `Finset.univ`. ","distance":2.001926362094997191576339901075698435306549072265625}],["Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"BigOperators.delabFinsetSum","isProp":false,"docString":"Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ","distance":2.002634170556992554423914043582044541835784912109375}],["A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. ",{"type":"‚àÄ {R : Type u_1} {E : Type u_3} {Œπ : Type u_5} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] {s : Set E} {w : Œπ ‚Üí R} {z : Œπ ‚Üí E} (t : Finset Œπ),\n  (‚àÄ i ‚àà t, w i ‚â§ 0) ‚Üí (Finset.sum t fun i => w i) < 0 ‚Üí (‚àÄ i ‚àà t, z i ‚àà s) ‚Üí Finset.centerMass t w z ‚àà (convexHull R) s","name":"Finset.centerMass_mem_convexHull_of_nonpos","isProp":true,"docString":"A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. ","distance":2.004487581280184560483803579700179398059844970703125}],["The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ùïú : Type u_8} ‚Üí\n  {ùïú' : Type u_9} ‚Üí\n    {E : Type u_10} ‚Üí\n      [inst : NormedField ùïú'] ‚Üí\n        [inst_1 : SeminormedAddCommGroup E] ‚Üí [I : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú' (RestrictScalars ùïú ùïú' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":2.005833795907529637503330377512611448764801025390625}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name ‚Üí Array Simps.ParsedProjectionData ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":2.005954129617441683564038612530566751956939697265625}],["An uncurried version of `Finset.prod_product`. ",{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±} {f : Œ≥ ‚Üí Œ± ‚Üí Œ≤},\n  (Finset.prod (s √óÀ¢ t) fun x => f x.1 x.2) = Finset.prod s fun x => Finset.prod t fun y => f x y","name":"Finset.prod_product'","isProp":true,"docString":"An uncurried version of `Finset.prod_product`. ","distance":2.007130798931559212405772996135056018829345703125}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":2.00845268233283658076970823458395898342132568359375}],["A variant of `List.prod` that has `[x].prod = x` true definitionally.\nThe purpose is to make `FreeMonoid.lift_eval_of` true by `rfl`. ",{"type":"{M : Type u_6} ‚Üí [inst : Monoid M] ‚Üí List M ‚Üí M","name":"FreeMonoid.prodAux","isProp":false,"docString":"A variant of `List.prod` that has `[x].prod = x` true definitionally.\nThe purpose is to make `FreeMonoid.lift_eval_of` true by `rfl`. ","distance":2.0086650093207527589811434154398739337921142578125}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) ‚Üí AlgebraicGeometry.IsAffine X ‚Üí AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":2.009008062336051114726842570235021412372589111328125}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        {J : Type w} ‚Üí\n          [inst_2 : CategoryTheory.Category.{w', w} J] ‚Üí\n            {K : CategoryTheory.Functor J C} ‚Üí\n              (F : CategoryTheory.Functor C D) ‚Üí\n                {c : CategoryTheory.Limits.Cocone K} ‚Üí\n                  CategoryTheory.Limits.IsColimit c ‚Üí\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] ‚Üí\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.009708900049838486978615037514828145503997802734375}],["Restrict the codomain of a non-unital star algebra homomorphism `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ",{"type":"{F : Type v'} ‚Üí\n  {R : Type u} ‚Üí\n    {A : Type v} ‚Üí\n      {B : Type w} ‚Üí\n        [inst : CommSemiring R] ‚Üí\n          [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n            [inst_2 : Module R A] ‚Üí\n              [inst_3 : Star A] ‚Üí\n                [inst_4 : NonUnitalNonAssocSemiring B] ‚Üí\n                  [inst_5 : Module R B] ‚Üí\n                    [inst_6 : Star B] ‚Üí\n                      [inst_7 : NonUnitalStarAlgHomClass F R A B] ‚Üí (f : F) ‚Üí A ‚Üí‚ãÜ‚Çô‚Çê[R] ‚Ü•(NonUnitalStarAlgHom.range f)","name":"NonUnitalStarAlgHom.rangeRestrict","isProp":false,"docString":"Restrict the codomain of a non-unital star algebra homomorphism `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ","distance":2.01060566887902236743457251577638089656829833984375}]]