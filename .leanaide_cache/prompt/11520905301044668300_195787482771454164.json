[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9511783990572089120263399308896623551845550537109375}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ğ•œ`, a normed additive group `E` over `ğ•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] {I : ModelWithCorners ğ•œ E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInvâ‚€ I G]\n  â¦ƒx : Gâ¦„, x â‰  0 â†’ SmoothAt I I (fun y => yâ»Â¹) x","name":"SmoothInvâ‚€.smoothAt_invâ‚€","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ğ•œ`, a normed additive group `E` over `ğ•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":1.9984553218940532826053413373301737010478973388671875}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.981694603418421962715001427568495273590087890625}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.96192919081391092817057142383418977260589599609375}],[" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.",{"type":"âˆ€ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G}, â†‘H = Set.univ â†” H = âŠ¤","name":"AddSubgroup.coe_eq_univ","isProp":true,"docString":" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.","distance":1.9996796105933010156974205528968013823032379150390625}],["This theorem, `hammingDist_pos`, states that for any types `Î¹` and `Î²`, where `Î²` is a function from `Î¹` to another type and `Î¹` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Î¹` over `Î² i`, then the Hamming distance between two functions `x` and `y` (from `Î¹` to `Î²`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"This theorem, `hammingDist_pos`, states that for any types `Î¹` and `Î²`, where `Î²` is a function from `Î¹` to another type and `Î¹` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Î¹` over `Î² i`, then the Hamming distance between two functions `x` and `y` (from `Î¹` to `Î²`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.","distance":1.995089320051373515951809167745523154735565185546875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.962701804584172204926062477170489728450775146484375}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.965808381363055357127223032875917851924896240234375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9662237450739767918861389262019656598567962646484375}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9728874761977588381256509819650091230869293212890625}],["Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ",{"type":"(Î± : Type u_1) â†’ {Î² : Type u_2} â†’ [inst : Primcodable Î±] â†’ Î² â‰ƒ Î± â†’ Primcodable Î²","name":"Primcodable.ofEquiv","isProp":false,"docString":"Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ","distance":1.97313780771375579803361688391305506229400634765625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9740526704963181625629431437118910253047943115234375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.976706309047494780628539956524036824703216552734375}],["Attribute for identifying `positivity` extensions. ",{"type":"Lean.ParserDescr","name":"positivity","isProp":false,"docString":"Attribute for identifying `positivity` extensions. ","distance":1.9770490363300172731442216900177299976348876953125}],["Corresponds to `zero_eq_dist`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 = hammingDist x y â†” x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.977203229143826401781325330375693738460540771484375}],["Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ",{"type":"{K : semiOutParam (Type u_1)} â†’ [self : IsROrC K] â†’ K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = â„`. ","distance":1.977664627819137432851448465953581035137176513671875}],["Default definition of `max`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.9782135765479333944227846586727537214756011962890625}],["Corresponds to `dist_pos`. ",{"type":"âˆ€ {Î¹ : Type u_2} {Î² : Î¹ â†’ Type u_3} [inst : Fintype Î¹] [inst_1 : (i : Î¹) â†’ DecidableEq (Î² i)] {x y : (i : Î¹) â†’ Î² i},\n  0 < hammingDist x y â†” x â‰  y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9787960379693270152046125076594762504100799560546875}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.97880197079761188660995685495436191558837890625}],["The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = âŠ¥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.978955203760659475875627322238869965076446533203125}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9798952856866467442387147457338869571685791015625}],["Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax â†’ Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>â†’<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":1.9800460502497525538956324453465640544891357421875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9807075891783696430792360843042843043804168701171875}],["Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : â„• â†’ Type u_2} â†’ ((n : â„•) â†’ E n) â†’ Set ((n : â„•) â†’ E n) â†’ â„•","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Î  (n : â„•), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.9811641994563402580098454563994891941547393798828125}]]