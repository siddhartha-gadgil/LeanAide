[["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.989467314063507075161396642215549945831298828125}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ğ•œ`, a normed additive group `E` over `ğ•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E] {I : ModelWithCorners ğ•œ E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInvâ‚€ I G]\n  â¦ƒx : Gâ¦„, x â‰  0 â†’ SmoothAt I I (fun y => yâ»Â¹) x","name":"SmoothInvâ‚€.smoothAt_invâ‚€","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ğ•œ`, a normed additive group `E` over `ğ•œ` as a normed space, another topological space `H`, and a model `I` with corners, the function `y â†¦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":2.015736056716247670550501425168476998805999755859375}],["This theorem, named `IntermediateField.rank_bot`, states that for all fields `F` and `E`, where `E` is an algebra over `F`, the rank of the module `F` over the bottom intermediate field (`âŠ¥`) is always equal to 1. The bottom intermediate field is the smallest possible subfield of `E` that contains `F`. The rank of a module, in this context, is a measure of the \"size\" or \"dimensionality\" of that module.",{"type":"âˆ€ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E], Module.rank F â†¥âŠ¥ = 1","name":"IntermediateField.rank_bot","isProp":true,"docString":"This theorem, named `IntermediateField.rank_bot`, states that for all fields `F` and `E`, where `E` is an algebra over `F`, the rank of the module `F` over the bottom intermediate field (`âŠ¥`) is always equal to 1. The bottom intermediate field is the smallest possible subfield of `E` that contains `F`. The rank of a module, in this context, is a measure of the \"size\" or \"dimensionality\" of that module.","distance":2.0077756826214692154053409467451274394989013671875}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"â„¤ â†’ â„¤","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.989686460136101064932745430269278585910797119140625}],[" If `f` is a function from preordered types `Î±` to `Î²` that preserves the preorder, and `x` is the greatest lower bound of `s â†¦ f(s)` in `Î²`, then `x` is the greatest lower bound of `s` in `Î±`.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v} [inst : Preorder Î±] [inst_1 : Preorder Î²] {f : Î± â†’ Î²},\n  (âˆ€ {x y : Î±}, f x â‰¤ f y â†” x â‰¤ y) â†’ âˆ€ {s : Set Î±} {x : Î±}, IsGLB (f '' s) (f x) â†’ IsGLB s x","name":"IsGLB.of_image","isProp":true,"docString":" If `f` is a function from preordered types `Î±` to `Î²` that preserves the preorder, and `x` is the greatest lower bound of `s â†¦ f(s)` in `Î²`, then `x` is the greatest lower bound of `s` in `Î±`.","distance":2.01880194835781967555021765292622148990631103515625}],["This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"âˆ€ {Î± : Type u} [inst : TopologicalSpace Î±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Î± â†’ âˆ€ {f : Î± â†’ Y}, Continuous f â†’ âˆ€ {x y : Î±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `Î±` and any discrete topological space `Y`, if `Î±` is preconnected and `f` is a continuous function from `Î±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Î±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":2.008098402845631458291109083802439272403717041015625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {f : E â†’ Î²} {x y z : E}, ConcaveOn ğ•œ (segment ğ•œ x y) f â†’ z âˆˆ segment ğ•œ x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9925049483047192477869202775764279067516326904296875}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"âˆ€ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace â„ F] {K : Set F},\n  Convex â„ K â†’ âˆ€ {u v : F}, v âˆˆ K â†’ (â€–u - vâ€– = â¨… w, â€–u - â†‘wâ€– â†” âˆ€ w âˆˆ K, âŸªu - v, w - vâŸ«_â„ â‰¤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9967652040488139686402746519888751208782196044921875}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData â†’ Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9973213667806903881540847578435204923152923583984375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type â†’ Type} â†’ [inst : Monad m] â†’ [inst : Lean.MonadEnv m] â†’ [inst : Lean.MonadError m] â†’ Lean.Name â†’ m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.998036499991018732913516942062415182590484619140625}],["Default definition of `min`. ",{"type":"{Î± : Type u} â†’ [inst : LE Î±] â†’ [inst : DecidableRel fun x x_1 => x â‰¤ x_1] â†’ Î± â†’ Î± â†’ Î±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.99825587901190449002797322464175522327423095703125}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : LinearOrderedAddCommGroup Î²]\n  [inst_2 : Module ğ•œ Î²] [inst_3 : OrderedSMul ğ•œ Î²] {f : ğ•œ â†’ Î²} {x y z : ğ•œ},\n  ConcaveOn ğ•œ (Set.Icc x y) f â†’ z âˆˆ Set.Icc x y â†’ min (f x) (f y) â‰¤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.0009759402386766424797315266914665699005126953125}],["The minimum operation: `min x y`. ",{"type":"{Î± : Type u} â†’ [self : Min Î±] â†’ Î± â†’ Î± â†’ Î±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":2.001549100011022375156244379468262195587158203125}],["**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} {Î² : Type u_4} [inst : LinearOrderedField ğ•œ] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Î²] [inst_3 : Module ğ•œ E] [inst_4 : Module ğ•œ Î²] [inst_5 : OrderedSMul ğ•œ Î²]\n  {s : Set E} {f : E â†’ Î²}, ConcaveOn ğ•œ ((convexHull ğ•œ) s) f â†’ âˆ€ {x : E}, x âˆˆ (convexHull ğ•œ) s â†’ âˆƒ y âˆˆ s, f y â‰¤ f x","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. ","distance":2.003016309587994925323073402978479862213134765625}],["Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ",{"type":"{Î± : Type u_3} â†’ {Î² : Type u_4} â†’ [inst : Mul Î±] â†’ [inst_1 : Mul Î²] â†’ (Î± â†’â‚™* Î²) â†’ (I : Type u_5) â†’ (I â†’ Î±) â†’â‚™* I â†’ Î²","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I â†’ Î±` and `I â†’ Î²`, induced by a semigroup\nhomomorphism `f` between `Î±` and `Î²`. ","distance":2.004340615995030550067212971043772995471954345703125}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) â†’ (M : Type u_2) â†’ [inst : Semiring R] â†’ [inst_1 : AddCommGroup M] â†’ [inst : Module R M] â†’ â„•","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":2.0045404876687626938291941769421100616455078125}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name â†’ Simps.ParsedProjectionData â†’ List Lean.Level â†’ Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":2.00612950200292861069328864687122404575347900390625}],["`kernImage f s` is the set of `y` such that `f â»Â¹ y âŠ† s`. ",{"type":"{Î± : Type u} â†’ {Î² : Type v} â†’ (Î± â†’ Î²) â†’ Set Î± â†’ Set Î²","name":"Set.kernImage","isProp":false,"docString":"`kernImage f s` is the set of `y` such that `f â»Â¹ y âŠ† s`. ","distance":2.006181958369729567692729688133113086223602294921875}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":2.006567041123049843776016132324002683162689208984375}],["The orthogonal projection of `y` on `U` minimizes the distance `â€–y - xâ€–` for `x âˆˆ U`. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {U : Submodule ğ•œ E} [inst_3 : HasOrthogonalProjection U] (y : E), â€–y - â†‘((orthogonalProjection U) y)â€– = â¨… x, â€–y - â†‘xâ€–","name":"orthogonalProjection_minimal","isProp":true,"docString":"The orthogonal projection of `y` on `U` minimizes the distance `â€–y - xâ€–` for `x âˆˆ U`. ","distance":2.009553937494278574860118169453926384449005126953125}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"âˆ€ {d : â„¤} {a : Pell.Solutionâ‚ d}, a = 1 âˆ¨ a = -1 â†” Pell.Solutionâ‚.y a = 0","name":"Pell.Solutionâ‚.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.00988336576311699133157162577845156192779541015625}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasColimits C] â†’ (X : AlgebraicGeometry.PresheafedSpace C) â†’ â†‘â†‘X â†’ C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":2.0103388384429603519265583599917590618133544921875}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Î² : TypeVec.Arrow Fin2.elim0 Fin2.elim0 â†’ Sort u_1} â†’\n  Î² TypeVec.nilFun â†’ (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) â†’ Î² f","name":"TypeVec.typevecCasesNilâ‚‚","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.0108220477657621216849292977713048458099365234375}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData â†’ String â†’ Lean.Name â†’ Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":2.011617340086803817911231817561201751232147216796875}]]