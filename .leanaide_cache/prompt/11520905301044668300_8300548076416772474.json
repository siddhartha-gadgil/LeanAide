[["Convert a pre-set to a `set` of pre-sets. ",{"type":"PSet ‚Üí Set PSet","name":"PSet.toSet","isProp":false,"docString":"Convert a pre-set to a `set` of pre-sets. ","distance":1.9759126651216434300550872649182565510272979736328125}],[" The normalization of a natural number expression constraint does not change its denotation within a given context.",{"type":"‚àÄ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":" The normalization of a natural number expression constraint does not change its denotation within a given context.","distance":2.001266542757190070034312157076783478260040283203125}],["This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.",{"type":"‚àÄ (n : PosNum), ‚Üë‚Üën = ‚Üën","name":"PosNum.to_nat_to_int","isProp":true,"docString":"This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.","distance":2.004404314287445032505274866707623004913330078125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9813177672951862717809490277431905269622802734375}],[" A set in a sigma-finite measurable space has positive measure if and only if there exists a finite measure spanning set index such that the intersection of the set with that spanning set has positive measure.",{"type":"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} [inst_1 : MeasureTheory.SigmaFinite Œº]\n  (s : Set Œ±), (‚àÉ n, 0 < ‚Üë‚ÜëŒº (s ‚à© MeasureTheory.spanningSets Œº n)) ‚Üî 0 < ‚Üë‚ÜëŒº s","name":"MeasureTheory.Measure.exists_measure_inter_spanningSets_pos","isProp":true,"docString":" A set in a sigma-finite measurable space has positive measure if and only if there exists a finite measure spanning set index such that the intersection of the set with that spanning set has positive measure.","distance":2.0073567460882255630849613226018846035003662109375}],["This theorem states that for every positive number `n`, the double-coercion of `n` (which converts it first into a natural number and then into a number) gives the positive version of `n`. In other words, converting a positive number to a natural number and then to a generic number preserves its positivity. This can be symbolically represented in LaTeX as, for all positive numbers $n$, we have $n = \\text{Num.pos} \\ n$.",{"type":"‚àÄ (n : PosNum), ‚Üë‚Üën = Num.pos n","name":"PosNum.of_to_nat","isProp":true,"docString":"This theorem states that for every positive number `n`, the double-coercion of `n` (which converts it first into a natural number and then into a number) gives the positive version of `n`. In other words, converting a positive number to a natural number and then to a generic number preserves its positivity. This can be symbolically represented in LaTeX as, for all positive numbers $n$, we have $n = \\text{Num.pos} \\ n$.","distance":2.0094999730632014944831098546274006366729736328125}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ interior (‚áë(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.981989186641133660060631882515735924243927001953125}],["`whatsnew in $command` executes the command and then prints the\ndeclarations that were added to the environment. ",{"type":"Lean.ParserDescr","name":"Mathlib.WhatsNew.commandWhatsnewIn__","isProp":false,"docString":"`whatsnew in $command` executes the command and then prints the\ndeclarations that were added to the environment. ","distance":1.9835947246217913164656465596635825932025909423828125}],["The edit to perform on the file. ",{"type":"ProofWidgets.MakeEditLinkProps ‚Üí Lean.Lsp.TextDocumentEdit","name":"ProofWidgets.MakeEditLinkProps.edit","isProp":false,"docString":"The edit to perform on the file. ","distance":1.984303644917567499561528165941126644611358642578125}],["Restrict a prepartition to a box. ",{"type":"{Œπ : Type u_1} ‚Üí\n  {I : BoxIntegral.Box Œπ} ‚Üí BoxIntegral.Prepartition I ‚Üí (J : BoxIntegral.Box Œπ) ‚Üí BoxIntegral.Prepartition J","name":"BoxIntegral.Prepartition.restrict","isProp":false,"docString":"Restrict a prepartition to a box. ","distance":1.985420175772002693292961339466273784637451171875}],["The universal set `Set.univ` in a preconnected space is a preconnected set. ",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : PreconnectedSpace Œ±], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. ","distance":1.9868046266668517585429754035430960357189178466796875}],["Elaborate a `#noalign` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabNoAlign","isProp":false,"docString":"Elaborate a `#noalign` command. ","distance":1.9884853231156214281583061165292747318744659423828125}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ ‚áë(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.990407481972321424024130465113557875156402587890625}],["the condition that `premap` is in the presieve ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]\n  {F : CategoryTheory.Functor C D} {X : C} {S : CategoryTheory.Presieve X} {Y : D} {f : Y ‚ü∂ F.obj X}\n  (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f), S self.premap","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","isProp":true,"docString":"the condition that `premap` is in the presieve ","distance":1.9909010334703893807528629622538574039936065673828125}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.9909656043963313010181082063354551792144775390625}],["Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ",{"type":"ProofWidgets.MakeEditLinkProps ‚Üí Option Lean.Lsp.Range","name":"ProofWidgets.MakeEditLinkProps.newSelection?","isProp":false,"docString":"Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ","distance":1.9910564029386372819629968944354914128780364990234375}],["index set of an open cover of a scheme `X` ",{"type":"{X : AlgebraicGeometry.Scheme} ‚Üí AlgebraicGeometry.Scheme.OpenCover X ‚Üí Type v","name":"AlgebraicGeometry.Scheme.OpenCover.J","isProp":false,"docString":"index set of an open cover of a scheme `X` ","distance":1.9919082568310824132851166723412461578845977783203125}],["A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ",{"type":"ProofWidgets.Component ProofWidgets.MakeEditLinkProps","name":"ProofWidgets.MakeEditLink","isProp":false,"docString":"A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ","distance":1.9920038969437958709107761023915372788906097412109375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.992878825332840886375151967513374984264373779296875}],["The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ",{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_4} (w : Œπ ‚Üí k) (p : Œπ ‚Üí P) {s‚ÇÅ s‚ÇÇ : Finset Œπ},\n  s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí (Finset.weightedVSub s‚ÇÅ p) w = (Finset.weightedVSub s‚ÇÇ p) (Set.indicator (‚Üës‚ÇÅ) w)","name":"Finset.weightedVSub_indicator_subset","isProp":true,"docString":"The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ","distance":1.9933318035675282597907198578468523919582366943359375}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name ‚Üí Array Simps.ParsedProjectionData ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9933931243461582294429490502807311713695526123046875}],["Reinterpret a clopen as an open. ",{"type":"{Œ± : Type u_2} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí TopologicalSpace.Clopens Œ± ‚Üí TopologicalSpace.Opens Œ±","name":"TopologicalSpace.Clopens.toOpens","isProp":false,"docString":"Reinterpret a clopen as an open. ","distance":1.9940550757500361545027089960058219730854034423828125}],["Right-shift the binary representation of a `PosNum`. ",{"type":"PosNum ‚Üí ‚Ñï ‚Üí Num","name":"PosNum.shiftr","isProp":false,"docString":"Right-shift the binary representation of a `PosNum`. ","distance":1.99475715881088877523552582715637981891632080078125}],["We construct an open cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original open cover. ",{"type":"{X : AlgebraicGeometry.Scheme} ‚Üí\n  (ùí∞ : AlgebraicGeometry.Scheme.OpenCover X) ‚Üí\n    (J : Type u_1) ‚Üí\n      (obj : J ‚Üí AlgebraicGeometry.Scheme) ‚Üí\n        (map : (i : J) ‚Üí obj i ‚ü∂ X) ‚Üí\n          (e‚ÇÅ : J ‚âÉ ùí∞.J) ‚Üí\n            (e‚ÇÇ : (i : J) ‚Üí obj i ‚âÖ AlgebraicGeometry.Scheme.OpenCover.obj ùí∞ (e‚ÇÅ i)) ‚Üí\n              (‚àÄ (i : J),\n                  map i =\n                    CategoryTheory.CategoryStruct.comp (e‚ÇÇ i).hom (AlgebraicGeometry.Scheme.OpenCover.map ùí∞ (e‚ÇÅ i))) ‚Üí\n                AlgebraicGeometry.Scheme.OpenCover X","name":"AlgebraicGeometry.Scheme.OpenCover.copy","isProp":false,"docString":"We construct an open cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original open cover. ","distance":1.99557838367231621390374129987321794033050537109375}]]